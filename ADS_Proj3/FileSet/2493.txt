as [[exception handling]] and [[input/output]], because the order of operations becomes indeterminate. Also, debugging is difficult.<ref>[http://caml.inria.fr/pub/ml-archives/caml-list/1999/10/7b5cd5d7e12a9876637ada0ee3ed3e06.en.html OCaml and lazy evaluation]</ref> Languages that use lazy actions can be further subdivided into those that use a call-by-name [[evaluation strategy]] and those that use call-by-need. Most realistic lazy languages, such as [[Haskell (programming language)|Haskell]], use call-by-need for performance reasons, but theoretical presentations of lazy evaluation often use call-by-name for simplicity. The opposite of lazy actions is [[eager evaluation]], sometimes known as ''[[Evaluation strategy#Strict evaluation|strict evaluation]]''. Eager evaluation is the evaluation behavior used in most [[programming languages]]. Lazy evaluation refers to how expressions are evaluated when they are passed as arguments to functions and entails the following three points:<ref>"Conception, Evolution, and Application of Functional Programming Languages", Paul Hudak, ACM Computing Surveys, Vol. 21, No.3, September 1989, pg. 383-385</ref>{{verification failed|date=January 2011}} # The expression is only evaluated if the result is required by the calling function, called '''delayed evaluation'''.<ref>David A. Schmidt, "Denotational Semantics", p.181</ref>{{dubious|date=January 2011}} # The expression is only evaluated to the extent that is required by the calling function, called '''[[short-circuit evaluation]]'''.{{dubious|date=January 2011}} # The expression is never evaluated more than once, called '''applicative-order evaluation'''.<ref>David A. Watt, "Programming Language concepts and Paradigms", p. 100</ref>{{dubious|date=January 2011}} ==Delayed evaluation==<!-- This section is linked from [[Clean (programming language)]] --> Delayed evaluation is used particularly in [[functional programming|functional languages]]. When using delayed evaluation, an expression is not evaluated as soon as it gets bound to a variable, but when the evaluator is forced to produce the expression's value. That is, a statement such as <code>x:=expression;</code> (i.e. the assignment of the result of an expression to a variable) clearly calls for the expression to be evaluated and the result placed in <code>x</code>, but what actually is in <code>x</code> is irrelevant until there is a need for its value via a reference to <code>x</code> in some later expression whose evaluation could itself be deferred, though eventually the rapidly-growing tree of dependencies would be pruned in order to produce some symbol rather than another for the outside world to see.<ref name="Wadler2006">{{cite book|author=Philip Wadler|title=Functional and logic programming: 8th international symposium, FLOPS 2006, Fuji-Susono, Japan, April 24-26, 2006 : proceedings|url=http://books.google.com/books?id=gZzLFFZfc1sC&pg=PA149|accessdate=14 January 2011|year=2006|publisher=Springer|isbn=9783540334385|page=149}}</ref> Some programming languages delay evaluation of expressions by default, and some others provide [[subroutine|functions]] or special [[syntax of programming languages|syntax]] to delay evaluation. In [[Miranda (programming language)|Miranda]] and [[Haskell (programming language)|Haskell]], evaluation of function arguments is delayed by default. In many other languages, evaluation can be delayed by explicitly suspending the computation using special syntax (as with [[Scheme (programming language)|Scheme's]] "<code>delay</code>" and "<code>force</code>" and [[OCaml]]'s "<code>lazy</code>" and "<code>Lazy.force</code>") or, more generally, by wrapping the expression in a [[thunk]]. The object representing such an explicitly delayed evaluation is called a [[Futures and promises|future or promise]]. [[Perl 6]] uses lazy evaluation of lists, so one can assign infinite lists to variables and use them as arguments to functions, but unlike Haskell and Miranda, Perl 6 doesn't use lazy evaluation of arithmetic operators and functions by default.<ref name="Wadler2006"/> Delayed evaluation has the advantage of being able to create calculable infinite lists without infinite loops or size matters interfering in computation. For example, one could create a function that creates an infinite list (often called a ''[[stream (computing)|stream]]'') of [[Fibonacci number]]s. The calculation of the ''n''-th Fibonacci number would be merely the extraction of that element from the infinite list, forcing the evaluation of only the first n members of the list.<ref name="Métayer2002">{{cite book|author=Daniel Le Métayer|title=Programming languages and systems: 11th European Symposium on Programming, ESOP 2002, held as part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2002, Grenoble, France, April 8-12, 2002 : proceedings|url=http://books.google.com/books?id=dYZyzp-I9hQC&pg=PA129|accessdate=14 January 2011|year=2002|publisher=Springer|isbn=9783540433637|pages=129–132}}</ref><ref name="MachineryLanguages2002">{{cite book|author1=Association for Computing Machinery|author2=ACM Special Interest Group on Programming Languages|title=Proceedings of the 2002 ACM SIGPLAN Haskell Workshop (Haskell '02) : Pittsburgh, Pennsylvania, USA ; October 3, 2002|url=http://books.google.com/books?id=hsBQAAAAMAAJ|accessdate=14 January 2011|date=1 January 2002|publisher=Association for Computing Machinery|isbn=9781581136050|page=40}}</ref> For example, in Haskell, the list of all Fibonacci numbers can be written as<ref name="MachineryLanguages2002"/> <source lang="haskell"> fibs = 0 : 1 : zipWith (+) fibs (tail fibs) </source> In Haskell syntax, "<code>:</code>" prepends an element to a list, <code>tail</code> returns a list without its first element, and <code>zipWith</code> uses a specified function (in this case addition) to combine corresponding elements of two lists to produce a third.<ref name="Métayer2002"/> Provided the programmer is careful, only the values that are required to produce a particular result are evaluated. However, certain calculations may result in the program attempting to evaluate an infinite number of elements; for example, requesting the length of the list or trying to sum the elements of the list with a [[fold (higher-order function)|fold operation]] would result in the program either failing to terminate or running out of memory. ===Control structures=== Even in most eager languages ''if'' statements evaluate in a lazy fashion. if a then b else c evaluates (a), then if and only if (a) evaluates to true does it evaluate (b), otherwise it evaluates (c). That is, either (b) or (c) will not be evaluated. Conversely, in an eager language the expected behavior is that define f(x,y) = 2*x set k = f(e,5) will still evaluate (e) and (f) when computing (k). However, user-defined control structures depend on exact syntax, so for example define g(a,b,c) = if a then b else c l = g(h,i,j) (i) and (j) would both be evaluated in an eager language. While in l' = if h then i else j (i) or (j) would be evaluated, but never both. Lazy evaluation allows control structures to be defined normally, and not as primitives or compile-time techniques. If (i) or (j) have side effects or introduce run time errors, the subtle differences between (l) and (l') can be complex. As most programming languages are [[Turing_completeness|Turing-complete]], it is of course possible to introduce lazy control structures in eager languages, either as built-ins like [[C (programming language)|C's]] [[ternary operator]] [[?:]] or by other techniques such as clever use of [[anonymous function|lambdas]], or [[macro (computer science)|macros]]. [[Short-circuit evaluation]] of Boolean control structures is 