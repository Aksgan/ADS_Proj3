current assignment to its variables. The constraint expressing the inconsistency of this assignment is stored. ==Constraint maintenance== Constraint learning algorithms differ not only on the choice of constraint corresponding to a given inconsistent partial evaluation, but also on the choice of which constraint they maintain and which ones they discard. In general, learning all inconsistencies in form of constraints and keeping them indefinitedly may exhaust the available memory and increase the cost of checking consistency of partial evaluations. These problems can be solved either by storing only some learned constraints or by occasionally discarding constraints. ''Bounded learning'' only stores constraints if the inconsistent partial evaluation they represent is smaller than a given constrant number. ''Relevance-bounded learning'' discards constraints (or does not store them at all) that are considered not relevant given the current point of the search space; in particular, it discards or does not store all constraints that represent inconsistent partial evaluations that differ from the current partial evaluation on no more than a given fixed number of variables. ==See also== *[[Look-ahead (backtracking)]] *[[Backjumping]] ==References== *{{cite book | first=Rina | last=Dechter | title=Constraint Processing | publisher=Morgan Kaufmann | year=2003 | url=http://www.ics.uci.edu/~dechter/books/index.html }} ISBN 1-55860-890-7 [[Category:Constraint satisfaction]]</text> </page> <page> <id>7863</id> <title>Constraint satisfaction</title> <text>In [[artificial intelligence]] and [[operations research]], '''constraint satisfaction''' is the process of finding a solution to a set of [[Constraint (mathematics)|constraint]]s that impose conditions that the [[Variable (mathematics)|variables]] must satisfy. A solution is therefore a vector of variables that satisfies all constraints. The techniques used in constraint satisfaction depend on the kind of constraints being considered. Often used are constraints on a finite domain, to the point that [[constraint satisfaction problem]]s are typically identified with problems based on constraints on a finite domain. Such problems are usually solved via [[Search algorithm|search]], in particular a form of [[backtracking]] or [[local search (constraint satisfaction)|local search]]. [[Constraint propagation]] are other methods used on such problems; most of them are incomplete in general, that is, they may solve the problem or prove it unsatisfiable, but not always. Constraint propagation methods are also used in conjunction with search to make a given problem simpler to solve. Other considered kinds of constraints are on real or rational numbers; solving problems on these constraints is done via [[variable elimination]] or the [[simplex algorithm]]. Constraint satisfaction originated in the field of [[artificial intelligence]] in the 1970s (see for example {{Harv|Lauri√®re|1978}}). During the 1980s and 1990s, embedding of constraints into a [[programming language]] were developed. Languages often used for [[constraint programming]] are [[Prolog]] and [[C++]]. ==Constraint satisfaction problem== {{main|Constraint satisfaction problem}} As originally defined in artificial intelligence, constraints enumerate the possible values a set of variables may take. Informally, a finite domain is a finite set of arbitrary elements. A constraint satisfaction problem on such domain contains a set of variables whose values can only be taken from the domain, and a set of constraints, each constraint specifying the allowed values for a group of variables. A solution to this problem is an evaluation of the variables that satisfies all constraints. In other words, a solution is a way for assigning a value to each variable in such a way that all constraints are satisfied by these values. In practice, constraints are often expressed in compact form, rather than enumerating all values of the variables that would satisfy the constraint. One of the most used constraints is the one establishing that the values of the affected variables must be all different. Problems that can be expressed as constraint satisfaction problems are the [[Eight queens puzzle]], the [[Sudoku]] solving problem, the [[Boolean satisfiability problem]], [[scheduling]] problems and various problems on graphs such as the [[graph coloring]] problem. While usually not included in the above definition of a constraint satisfaction problem, arithmetic equations and inequalities bound the values of the variables they contain and can therefore be considered a form of constraints. Their domain is the set of numbers (either integer, rational, or real), which is infinite: therefore, the relations of these constraints may be infinite as well; for example, <math>X=Y+1</math> has an infinite number of pairs of satisfying values. Arithmetic equations and inequalities are often not considered within the definition of a "constraint satisfaction problem", which is limited to finite domains. They are however used often in [[constraint programming]]. ===Solving=== Constraint satisfaction problems on finite domains are typically solved using a form of [[Search algorithm|search]]. The most used techniques are variants of [[backtracking]], [[constraint propagation]], and [[Local search (optimization)|local search]]. These techniques are used on problems with [[nonlinear]] constraints. [[Variable elimination]] and the [[simplex algorithm]] are used for solving [[linear]] and [[polynomial]] equations and inequalities, and problems containing variables with infinite domain. These are typically solved as [[Optimization (mathematics)|optimization]] problems in which the optimized function is the number of violated constraints. ===Complexity=== {{main|Complexity of constraint satisfaction}} Solving a constraint satisfaction problem on a finite domain is an [[NP complete]] problem. Research has shown a number of [[Tractable problem|tractable]] subcases, some limiting the allowed constraint relations, some requiring the scopes of constraints to form a tree, possibly in a reformulated version of the problem. Research has also established relationship of the constraint satisfaction problem with problems in other areas such as [[finite model theory]]. ==Constraint programming== {{main|Constraint programming}} Constraint programming is the use of constraints as a programming language to encode and solve problems. This is often done by embedding constraints into a [[programming language]], which is called the host language. Constraint programming originated from a formalization of equalities of terms in [[Prolog II]], leading to a general framework for embedding constraints into a [[logic programming]] language. The most common host languages are [[Prolog]], [[C++]], and [[Java (programming language)|Java]], but other languages have been used as well. ===Constraint logic programming=== {{main|Constraint logic programming}} A constraint logic program is a [[Logic programming|logic program]] that contains constraints in the bodies of clauses. As an example, the clause <code>A(X):-X>0,B(X)</code> is a clause containing the constraint <code>X>0</code> in the body. Constraints can also be present in the goal. The constraints in the goal 