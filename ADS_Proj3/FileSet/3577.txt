the [[active object]] design pattern with [[futures and promises|futures]] objects. ==Programming model== The model was created by Denis Caromel, professor at [[University of Nice Sophia Antipolis]].<ref>{{cite journal | title = Towards a Method of Object-Oriented Concurrent Programming | last = Caromel | first = Denis | doi = 10.1.1.34.1074 | pages = 90–102 | journal = Communications of the ACM | volume = 36 | number = 9 | date = September 1993 | accessdate = November 6, 2010 }}</ref> Several extensions of the model were made later on by members of the OASIS team at [[Inria|INRIA]].<ref>{{cite journal | url = http://www-sop.inria.fr/oasis/personnel/mmorel/publis/programmingcomposingdeploying.pdf | type = PDF | title = Programming, Composing, Deploying for the Grid | last = Baduel | first = Laurent | last2 = Baude | first2 = Françoise | last3 = Caromel | first3 = Denis | last4 = Contes | first4 = Arnaud | last5 = Huet | first5 = Fabrice | last6 = Morel | first6 = Matthieu | last7 = Quilici | first7 = Romain | journal = Grid Computing: Software Environments and Tools | publisher = Sprinter-Verlag | date = January 2006 | doi = 10.1.1.58.7806 | editor-last = Cunha | editor-first = José C. | editor2-last = Rana | editor2-first = Omer F. }}</ref> The book ''A Theory of Distributed Objects'' presents the ASP calculus that formalizes ProActive features, and provides [[Formal semantics of programming languages|formal semantics]] to the calculus, together with properties of ProActive program execution.<ref>{{Cite book | isbn=978-3-540-20866-2 | title = A Theory of Distributed Objects: asynchrony, mobility, groups, components | last = Caromel | first = Denis | last2 = Henrio | first2 = Ludovic | publisher = Springer | location = Berlin | year = 2005 | id = {{LCCN|2005||923024}} }}</ref> ==Active objects== Active objects are the basic units of activity and distribution used for building [[concurrency (computer science)|concurrent]] applications using ProActive. An active object runs with its own [[thread (computer science)|thread]]. This thread only executes the methods invoked on this active object by other active objects, and those of the passive objects of the subsystem that belongs to this active object. With ProActive, the programmer does not have to explicitly manipulate Thread objects, unlike in standard Java. Active objects can be created on any of the hosts involved in the computation. Once an active object is created, its activity (the fact that it runs with its own thread) and its location (local or remote) are perfectly transparent. Any active object can be manipulated as if it were a passive instance of the same class. An ''active object'' is composed of two objects: a ''body'', and a standard Java object. The body is not visible from the outside of the active object. The body is responsible for receiving calls (or ''requests'') on the active object and storing them in a queue of pending calls. It executes these calls in an order specified by a synchronization policy. If a synchronization policy is not specified, calls are managed in a "[[First in, first out]]" (FIFO) manner. The thread of an active object then chooses a method in the queue of pending requests and executes it. No parallelism is provided inside an active object; this is an important decision in ProActive's design, enabling the use of "pre-post" conditions and [[class invariant]]s. On the side of the subsystem that sends a call to an active object, the active object is represented by a ''proxy''. The proxy generates future objects for representing future values, transforms calls into Request objects (in terms of metaobject, this is a [[Reification (computer science)|reification]]) and performs [[Deep copy|deep copies]] of passive objects passed as parameters. ===Active object basis=== ProActive is a library designed for developing applications in the model introduced by Eiffel//, a parallel extension of the [[Eiffel (programming language)|Eiffel programming language]]. In this model, the application is structured in ''subsystems''. There is one active object (and therefore one thread) for each subsystem, and one subsystem for each active object (or thread). Each subsystem is thus composed of one active object and any number of passive objects—possibly no passive objects. The thread of one subsystem only executes methods in the objects of this subsystem. There are no "shared passive objects" between subsystems. [[Image:activeObjectMethodCall.png|thumb|A call onto an active object, as opposed to a call onto passive one]] These features impact the application's topology. Of all the objects that make up a subsystem—the active object and the passive objects—only the active object is known to objects outside of the subsystem. All objects, both active and passive, may have references onto active objects. If an object ''o1'' has a reference onto a passive object ''o2'', then ''o1'' and ''o2'' are part of the same subsystem. [[Image:Sequential 2 Distributed.png|thumb|left|The model: Sequential, multithreaded, distributed]] This has also consequences on the semantics of message-passing between subsystems. When an object in a subsystem calls a method on an active object, the parameters of the call may be references on passive objects of the subsystem, which would lead to shared passive objects. This is why passive objects passed as parameters of calls on active objects are always passed by [[Deep copy|deep-copy]]. Active objects, on the other hand, are always passed by [[Reference (computer science)|reference]]. Symmetrically, this also applies to objects returned from methods called on active objects. Thanks to the concepts of [[Parallel computing|asynchronous calls]], futures, and no data sharing, an application written with ProActive doesn't need any structural change—actually, hardly any change at all—whether it runs in a sequential, [[Multithreaded|multi-threaded]], or [[Distributed computing|distributed]] environment. ==Asynchronous calls and futures== Whenever possible, a method call on an active object is [[Reification (computer science)|reified]] as an asynchronous request. If not possible, the call is synchronous, and [[Blocking (computing)|blocks]] until the reply is received. If the request is asynchronous, it immediately returns a ''future object''. [[Image:futureObject.png|thumb|A future object]] The future object acts as a placeholder for the result of the not-yet-performed method invocation. As a consequence, the calling thread can go on with executing its code, as long as 