a set '''M''' itself might be, is the content of the [[axiom of union]] in [[axiomatic set theory]]. This idea subsumes the above paragraphs, in that for example, ''A'' ∪ ''B'' ∪ ''C'' is the union of the collection {''A'',''B'',''C''}. Also, if '''M''' is the empty collection, then the union of '''M''' is the empty set. The analogy between finite unions and logical disjunction extends to one between arbitrary unions and [[existential quantification]]. The notation for the general concept can vary considerably, such as the following: : <math>\bigcup \mathbf{M},</math> : <math>\bigcup_{A\in\mathbf{M}} A.</math> : <math>\bigcup_{i\in I} A_{i},</math> which refers to the union of the collection {''A''<sub>''i''</sub> : ''i'' is in ''I''}. Here ''I'' is an [[index set]], and ''A''<sub>''i''</sub> is a set for every ''i'' in ''I''. In the case that the index set ''I'' is the set of [[natural number]]s, the notation is analogous to that of [[series (mathematics)|infinite series]]: : <math>\bigcup_{i=1}^{\infty} A_{i}.</math> When formatting is difficult, this can also be written "''A''<sub>1</sub> ∪ ''A''<sub>2</sub> ∪ ''A''<sub>3</sub> ∪ ···". (This last example, a union of countably many sets, is very common in [[analysis (math)|analysis]]; for an example see the article on [[sigma algebra|σ-algebras]].) Whenever the symbol "∪" is placed before other symbols instead of between them, it is of a larger size. Intersection distributes over infinitary union, in the sense that : <math>A \cap \bigcup_{i\in I} B_{i} = \bigcup_{i\in I} (A \cap B_{i}).</math> Infinitary union can be combined with infinitary intersection to get the law : <math>\bigcup_{i\in I} \bigg(\bigcap_{j\in J} A_{i,j}\bigg) \subseteq \bigcap_{j\in J} \bigg(\bigcup_{i\in I} A_{i,j}\bigg)</math>. == See also == * [[Naive set theory]] * [[Symmetric difference]] * [[Disjoint union]] * [[Intersection (set theory)]] * [[Complement (set theory)]] * [[Cardinality]] * [[Iterated binary operation]] ==Notes == <references/> == External links == {{commonscat}} *[http://www.apronus.com/provenmath/sum.htm Infinite Union and Intersection at ProvenMath] De Morgan's laws formally proven from the axioms of set theory. [[Category:Abstract algebra]] [[Category:Algebra]] [[Category:Basic concepts in set theory]] [[Category:Binary operations]] [[ar:اجتماع (نظرية المجموعات)]] [[be:Аб'яднанне мностваў]] [[be-x-old:Аб'яднаньне мностваў]] [[bg:Обединение (теория на множествата)]] [[ca:Unió]] [[cs:Sjednocení]] [[de:Mengenlehre#Vereinigungsmenge]] [[et:Ühend (matemaatika)]] [[el:Ένωση συνόλων]] [[es:Unión de conjuntos]] [[eo:Kunaĵo]] [[fa:اجتماع (مجموعه)]] [[fr:Union (mathématiques)]] [[xal:Ниилвр]] [[ko:합집합]] [[id:Gabungan (teori himpunan)]] [[is:Sammengi]] [[it:Unione (insiemistica)]] [[he:איחוד (מתמטיקה)]] [[hu:Unió (halmazelmélet)]] [[nah:Cētiliztli (tlapōhualmatiliztli)]] [[nl:Vereniging (verzamelingenleer)]] [[ja:和集合]] [[no:Union (mengdelære)]] [[nn:Union i matematikk]] [[pms:Union]] [[pl:Suma zbiorów]] [[pt:União (matemática)]] [[ru:Объединение множеств]] [[sk:Zjednotenie (matematika)]] [[sl:Unija množic]] [[fi:Yhdiste (matematiikka)]] [[sv:Union (matematik)]] [[ta:சேர்ப்பு (கணக் கோட்பாடு)]] [[th:ยูเนียน]] [[uk:Об'єднання множин]] [[vi:Phép hợp]] [[fiu-vro:Hulkõ kogo]] [[zh-classical:並集]] [[zh:并集]]</text> </page> <page> <id>38827</id> <title>Union of two regular languages</title> <text>{{Orphan|date=February 2009}} In [[formal language]] theory, and in particular the theory of [[nondeterministic finite state machine]]s, it is known that the '''union of two regular languages''' is a [[regular language]]. This article provides a proof of that statement. ==Theorem== For any regular languages <math>L_{1}</math> and <math>L_{2}</math>, language <math>L_{1}\cup L_{2}</math> is regular.'' ''Proof'' Since <math>L_{1}</math> and <math>L_{2}</math> are regular, there exist NFA's <math>N_{1},\ N_{2}</math> that recognize <math>L_{1}</math> and <math>L_{2}</math>. Let ::<math> N_{1} = (Q_{1},\ \Sigma ,\ T_{1},\ q_{1},\ A_{1})</math> ::<math> N_{2} = (Q_{2},\ \Sigma ,\ T_{2},\ q_{2},\ A_{2})</math> Construct :: <math>N = (Q,\ \Sigma ,\ T,\ q_{0},\ A_{1}\cup A_{2})</math> where ::<math>Q = Q_{1}\cup Q_{2}\cup\{q_{0}\}</math> ::<math>T(q,x) = \left\{\begin{array}{lll} T_{1}(q,x) & \mbox{if} & q\in Q_{1} \\ T_{2}(q,x) & \mbox{if} & q\in Q_{2} \\ \{q_{1}, q_{2}\} & \mbox{if} & q = q_{0}\ and\ x =\epsilon\\ \phi & \mbox{if} & q = q_{0}\ and\ x\neq\epsilon \end{array}\right. </math> In the following, we shall use <math>p\stackrel{x,T}{\rightarrow}q</math> to denote <math>q\in E(T(p,x))</math> Let <math>w</math> be a string from <math>L_{1}\cup L_{2}</math> <math>w\in L_{1}\ or\ w\in L_{2}</math> Assume <math>w\in L_{1}</math> (Proof would be similar if <math>w\in L_{2}</math>) Let <math>w = x_{1}x_{2}\cdots x_{m}</math> where <math>m\geq 0, x_{i}\in\Sigma</math> Since <math>N_{1}</math> accepts <math>x_{1}x_{2}\cdots x_{m}</math>, there exist <math>r_{0}, r_{1},\cdots r_{m}\in Q_{1}</math> such that ::<math> q_{1}\stackrel{\epsilon , T_{1}}{\rightarrow}r_{0}\stackrel{x_{1} , T_{1}}{\rightarrow}r_{1}\stackrel{x_{2} , T_{1}}{\rightarrow}r_{2}\cdots r_{m-1}\stackrel{x_{m} , T_{1}}{\rightarrow}r_{m}, r_{m}\in A_{1} </math> Since <math>T_{1}(q,x) = T(q,x)\ \forall q\in Q_{1}\forall x\in\Sigma</math> :: <math>r_{0}\in E(T_{1}(q_{1},\epsilon ))\Rightarrow r_{0}\in E(T(q_{1},\epsilon ))</math> :: <math>r_{1}\in E(T_{1}(r_{0},x_{1} ))\Rightarrow r_{1}\in E(T(r_{0},x_{1} ))</math> :::: <math>\vdots</math> :: <math>r_{m}\in E(T_{1}(r_{m-1},x_{m} ))\Rightarrow r_{m}\in E(T(r_{m-1},x_{m} ))</math> We can therefore substitute <math>T</math> for <math>T_{1}</math> and rewrite the above path as <math>q_{1}\stackrel{\epsilon , T}{\rightarrow}r_{0}\stackrel{x_{1} , T}{\rightarrow}r_{1}\stackrel{x_{2} , T}{\rightarrow}r_{2}\cdots r_{m-1}\stackrel{x_{m} , T}{\rightarrow}r_{m}, r_{m}\in A_{1}\cup A_{2}, r_{0}, r_{1},\cdots r_{m}\in Q</math> Furthermore, :: <math> \begin{array}{lcl} T(q_{0}, \epsilon) = \{q_{1}, q_{2}\} & \Rightarrow & q_{1}\in T(q_{0}, \epsilon)\\ \\ & \Rightarrow & q_{1}\in E(T(q_{0}, \epsilon))\\ \\ & \Rightarrow & q_{0}\stackrel{\epsilon , T}{\rightarrow}q_{1} \end{array} </math> and :: <math>q_{0}\stackrel{\epsilon , T}{\rightarrow}q_{1}\stackrel{\epsilon , T}{\rightarrow}r_{0}\Rightarrow q_{0}\stackrel{\epsilon , T}{\rightarrow}r_{0} </math> The above path can be rewritten as :<math>q_{0}\stackrel{\epsilon , T}{\rightarrow}r_{0}\stackrel{x_{1} , T}{\rightarrow}r_{1}\stackrel{x_{2} , T}{\rightarrow}r_{2}\cdots r_{m-1}\stackrel{x_{m} , T}{\rightarrow}r_{m}, r_{m}\in A_{1}\cup A_{2}, r_{0}, r_{1},\cdots r_{m}\in Q </math> Therefore, <math>N</math> accepts <math>x_{1}x_{2}\cdots x_{m}</math> and the proof is complete. '''Note:''' The idea drawn from this mathematical proof for constructing a machine to recognize <math>L_{1}\cup L_{2}</math> is to create an initial state and connect it to the initial states of <math>L_{1}</math> and <math>L_{2}</math> using <math>\epsilon</math> arrows. == References == * Michael Sipser, ''Introduction to the Theory of Computation'' ISBN 0-534-94728-X. ''(See . Theorem 1.22, section 1.2, pg. 59.)'' [[Category:Article proofs]] [[Category:Formal languages]]</text> </page> <page> <id>38842</id> <title>Unison (file synchronizer)</title> <text>{{Infobox software |name = [[Unison]] |screenshot = [[Image:Unison.png]] |caption = Unison logo |developer = [[Benjamin C. Pierce]] |latest_release_version = 2.32.52 |latest_release_date = {{release date|2009|06|29}} |latest_preview_version = 2.39 |latest_preview_date = {{release date|2010|01|10}} |programming language = [[Objective Caml]] |operating_system = [[Cross-platform]] |genre = [[File synchronization]] |license = [[GPL]] |status = Not active, minor updates only<ref name="status">[http://www.cis.upenn.edu/~bcpierce/unison/status.html Non-development status]</ref> |website = http://www.cis.upenn.edu/~bcpierce/unison/ }} '''Unison''' is a [[file synchronization]] program. It is used for synchronizing files between two directories, either on one computer, or between a computer and another storage device (e.g. another computer, or a removable disc). It runs on [[Unix-like]] operating systems (including [[Linux]], [[Mac OS X]], and [[Solaris (operating system)|Solaris]]), as well as on [[Microsoft Windows|Windows]]. ==Details== Unison allows the same version of files to be maintained on multiple computing devices. In other words, when two devices are synchronized, the user can be sure that the most current version of a file is available on both devices, regardless of where it was last modified. * It runs on many operating systems, and can synchronize files across platforms, so that 