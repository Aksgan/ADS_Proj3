random (it is hard on average over uniformly distributed inputs).<ref name="Gurevich91">{{cite journal|author = Y. Gurevich|journal = J. Comp. Sys. Sci.|year = 1991|pages = 346–398|volume=42|title= Average case completeness|publisher=Elsevier Science|doi = 10.1016/0022-0000(91)90007-R|issue=3}}</ref> * Another variant of PCP is called the '''''marked'' Post Correspondence Problem''', in which each ''u''<sub>''i''</sub> must begin with a different symbol, and each ''v''<sub>''i''</sub> must also begin with a different symbol. Halava, Hirvensalo, and de Wolf showed that this variation is decidable in [[EXPTIME|exponential time]]. Moreover, they showed that if this requirement is slightly loosened so that only the two-character prefixes need to differ (the so-called 2-marked Post Correspondence Problem), the problem becomes undecidable again.<ref name="HHW01">{{cite journal|author = V. Halava|coauthors= M. Hirvensalo and R. de Wolf|year=2001|title=Marked PCP is decidable|journal=Theor. Comp. Sci.|publisher=Elsevier Science|volume=255|pages=193–204|doi=10.1016/S0304-3975(99)00163-2}}</ref> * The '''Post Embedding Problem''' is another variant where one looks for indexes <math>i_1, i_2, ...</math> such that <math>\alpha_{i_1} \cdots \alpha_{i_k}</math> is a [[substring|(scattered) subword]] of <math>\beta_{i_1} \cdots \beta_{i_k}</math>. This variant is easily decidable since, when some solutions exist, in particular a length-one solution exists. More interesting is the '''Regular''' Post Embedding Problem, a further variant where one looks for solutions that belong to a given regular language (submitted, e.g., under the form of a regular expression on the set <math>\{1,...,N\}</math>). The Regular Post Embedding Problem is still decidable but, because of the added regular constraint, it has a very high complexity that dominates every multiply-recursive function.<ref name="CS07">{{cite journal|author = P. Chambart|coauthors = Ph. Schnoebelen|title = Post embedding problem is not primitive recursive, with applications to channel systems|year = 2007|journal = Lecture Notes in Computer Science|volume =4855|pages=265–276|publisher=Springer|doi=10.1007/978-3-540-77050-3_22}}</ref> == References == <references/> == External links == * Eitan M. Gurari. ''An Introduction to the Theory of Computation'', Chapter 4, [http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-fourse7.html Post's Correspondence Problem]. A proof of the undecidability of PCP based on a generalization of [[context-free grammar]]s. * [http://jamesvanboxtel.com/projects/pcp-solver/ Online PHP Based PCP Solver] * [http://www.theory.informatik.uni-kassel.de/~stamer/pcp/pcpcontest_en.html PCP AT HOME] {{DEFAULTSORT:Post Correspondence Problem}} [[Category:Theory of computation]] [[Category:Recursion theory]] [[cs:Postův korespondenční problém]] [[de:Postsches Korrespondenzproblem]] [[es:Problema de correspondencia de Post]] [[he:בעיית ההתאמה של פוסט]] [[pl:Problem odpowiedniości Posta]] [[tr:Post Correspondence Problemi]]</text> </page> <page> <id>29691</id> <title>Postcondition</title> <text>In [[computer programming]], a '''postcondition''' is a condition or [[Predicate (mathematics)|predicate]] that must always be true just after the execution of some section of code or after an operation in a [[formal specification]]. Postconditions are sometimes tested using [[assertion (computing)|assertions]] within the code itself. Often, postconditions are simply included in the documentation of the affected section of code. For example: The result of a [[factorial]] is always an integer and greater than or equal to 1. So a program that calculates the factorial of an input number would have postconditions that the result after the calculation be an integer and that it be greater than or equal to 1. ==Postconditions in object-oriented programming== In object-oriented programming, postconditions, along with [[Precondition|preconditions]] and class [[Invariant (computer science)|invariants]] are components of the software construction method [[design by contract]]. The postcondition for any routine is a declaration of the properties which are guaranteed upon completion of the routine's execution.<ref>[[Bertrand Meyer|Meyer, Bertrand]], ''[[Object-Oriented Software Construction]], second edition,'' Prentice Hall, 1997, p. 342.</ref> As it relates to the routine's contract, the postcondition offers assurance to potential callers that in cases in which the routine is called in a state in which its [[precondition]] holds, the properties declared by the postcondition are assured. ===[[Eiffel (programming language)|Eiffel]] example=== The following example written in Eiffel sets the value of a class attribute <code>hour</code> based on a caller-provided argument <code>a_hour<code>. The postcondition follows the keyword <code>ensure</code>. In this example the postcondition guarantees, in cases in which the precondition holds (i.e., when <code>a_hour</code> represents a valid hour of the day), that after the execution of <code>set_hour</code>, the class attribute <code>hour</code> will have the same value as <code>a_hour</code>. The tag "<code>hour_set:</code>" describes this postcondition clause and serves to identify it in case of a runtime postcondition violation. <source lang="eiffel"> set_hour (a_hour: INTEGER) -- Set `hour' to `a_hour' require valid_argument: 0 <= a_hour and a_hour <= 23 do hour := a_hour ensure hour_set: hour = a_hour end </source> ===Postconditions and inheritance=== In the presence of inheritance, the routines inherited by descendant classes (subclasses) do so with their contracts, that is their preconditions and postconditions, in force. This means that any implementations or redefinitions of inherited routines also have to be written to comply with their inherited contract. Postconditions can be modified in redefined routines, but they may only be strengthened.<ref>Meyer, 1997, pp. 570–573.</ref> That is, the redefined routine may increase the benefits it provides to the client, but may not decrease those benefits. ==See also== *[[Precondition]] *[[Design by contract]] *[[Hoare logic]] *[[Invariant (computer science)|Invariant]]s maintained by conditions *[[Database trigger]] ==References== {{reflist}} {{Formalmethods-stub}} [[Category:Programming constructs]] [[Category:Formal methods terminology]] [[Category:Logic in computer science]] [[Category:Mathematics of computing]] [[de:Nachbedingung (Informatik)]] [[es:Postcondición]] [[uk:Післяумова (формальні методи)]]</text> </page> <page> <id>29711</id> <title>Potentially visible set</title> <text>'''Potentially Visible Sets''' are used to accelerate the rendering of 3D environments. This is a form of [[occlusion culling]], whereby a candidate set of ''potentially visible'' polygons are pre-computed, then indexed at run-time in order to quickly obtain an estimate of the visible geometry. The term ''PVS'' is sometimes used to refer to any occlusion culling algorithm (since in effect, this is what all occlusion algorithms compute), although in almost all the literature, it is used to refer specifically to occlusion culling algorithms that pre-compute visible sets and associate these sets with regions in space. In order to make this association, the camera view-space (the set of points from which the camera can render an image) is typically subdivided into (usually convex) regions and a PVS is computed for each region. == Benefits vs. Cost == The benefit of offloading visibility as a pre-process are: * The application just has to look up the pre-computed set given its view position. This set may be further reduced via frustum culling. Computationally, this is far cheaper than computing occlusion based visibility every frame. * Within a frame, time is limited. Only 1/60th of a second (assuming a 60 Hz frame-rate) is available for visibility determination, rendering 