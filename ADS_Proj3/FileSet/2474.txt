Ming Dong, Robert Reynolds, Anthony Aristar, Martha Ratliff, Geoff Nathan, Joseph Tan, and Ronald Powell, “Language Engineering for the Semantic Web: a Digital Library for Endangered Languages”, Information Research, 9(3), April, 2004.</ref> ==See also== * [[Engineered language]] * [[Language ideology]] ==References== {{Reflist}} {{linguistics-stub}} [[Category:Natural language processing]] [[Category:Linguistic rights]] [[Category:Language varieties and styles]] [[Category:Linguistics]] [[Category:Language regulators| e]] [[Category:Sociolinguistics]]</text> </page> <page> <id>21147</id> <title>Language primitive</title> <text>In computing, '''language primitives''' are the simplest elements available in a [[programming language]]. A primitive can be defined as the smallest 'unit of processing' available to a programmer of a particular machine, or can be an [[Atomic operation|atomic]] element of an [[Expression (programming)|expression]] in a language. ==Machine level primitives== A [[machine instruction]], usually generated by an [[Assembler program]], is often considered the smallest unit of processing although this is not always the case. It typically performs what is perceived to be one single operation such as copying a [[byte]] or [[String (computer science)|string]] of bytes from one [[computer memory|memory]] location to another or adding one [[processor register]] to another. ==Micro code primitives== Many of today's [[computer]]s, however, actually embody an even lower unit of processing known as [[microcode]] which interprets the "machine code" and it is then that the microcode instructions would be the ''genuine'' primitives. These instructions would typically be available for modification only by the [[computer hardware|hardware]] vendors programmers. ==High level language primitives== A [[high-level programming language]] (''HLL'') program is composed of discrete [[statements]] and [[primitive data type]]s that may also be ''perceived'' to perform a single operation or represent a single data item, but at a more abstract level than those provided by the machine. Copying a data item from one location to another may actually involve many [[machine instruction]]s that, for instance, * calculate the address of both [[operand]]s in [[computer memory|memory]], based on their positions within a [[data structure]], * convert from one [[data type]] to another before finally * performing the final store operation to the target destination. Some [[HLL]] statements, particularly those involving [[Control flow#Loops|loops]], can generate thousands or even millions of primitives in a [[Low-level programming language|low level language]] - which comprise the genuine [[instruction path length]] the processor has to execute at the lowest level. This perception has been referred to as the "Abstraction penalty" <ref>{{cite paper | author = Surana P | title = Meta-Compilation of Language Abstractions. | year = 2006 | url = ftp://lispnyc.org/meeting-assets/2007-02-13_pinku/SuranaThesis.pdf | format = [[PDF]] | accessdate = 2008-03-17 }}</ref><ref>{{cite web | last = Kuketayev | title = The Data Abstraction Penalty (DAP) Benchmark for Small Objects in Java. | url= http://www.adtmag.com/joop/article.aspx?id=4597 | accessdate = 2008-03-17 }}</ref><ref>{{Cite book | last = Chatzigeorgiou | last2 = Stephanides | editor-last = Blieberger | editor2-last = Strohmeier | contribution = Evaluating Performance and Power Of Object-Oriented Vs. Procedural Programming Languages | title = Proceedings - 7th International Conference on Reliable Software Technologies - Ada-Europe'2002 | year = 2002 | pages = 367 | publisher = Springer | url = http://books.google.com/?id=QMalP1P2kAMC&dq=%22abstraction+penalty%22 | isbn = 9783540437840 }}</ref> ==Interpreted language primitives== An interpreted language statement has similarities to the [[HLL]] primitives but with a further added 'layer'. Before the statement can be executed in a manner very similar to a [[HLL]] statement, first, it has to be processed by an [[interpreter]], a process that may involve many primitives in the target machine language. ==Fourth and Fifth-generation programming language primitives== [[Fourth-generation programming language|4gl]]s and [[Fifth-generation programming language|5gl]]s do not have a simple one-to-many correspondence from high-to-low level primitives. There are some elements of interpreted language primitives embodied in [[4GL|4gl]] and [[Fifth-generation programming language|5gl]] specifications but the approach to the original problem is less a [[procedural language]] construct and are more oriented toward [[problem solving]] and [[systems engineering]]. ==See also== * [[Primitive type]] * [[Hardware-software codesign]] ==References== <references /> [[Category:Programming language topics]] [[Category:Computer languages]] {{prog-lang-stub}}</text> </page> <page> <id>21153</id> <title>LapLink cable</title> <text>{{Refimprove|date=August 2007}} A '''LapLink cable''' (also known as ''lablink'' or ''null-printer'' cable) is a cable that allows one to connect two computers together to establish a [[direct cable connection]]. The connection is achieved via the [[parallel port]]s on the two computers. No networking hardware such as a [[network interface card]] or a [[modem]] are required. The cable is named after the [[Laplink]] software package, which was designed to make such a connection possible (many years before it became a Windows term and feature). It can be used by the [[List of DOS commands#InterSvr / InterLnk|InterSvr]] program in [[MS-DOS]] 6, and by Linux.<ref>http://www.linux-usb.org/usbnet/#t-host</ref> The term "Laplink" is a registered trademark used by Laplink Software Inc. ==Comparison to null modem cables== A LapLink cable can be seen as a parallel equivalent to a serial [[null modem]] cable. Because of the higher bandwidth of the parallel port versus the serial port, a LapLink cable is able to shift data more quickly at the same [[clock speed]], which was important at the time it was developed, since clock speeds then were relatively slow. This is still the reason it is used (rather than a [[RS-232]] port) as a means to install [[Linux]] to machines without a [[CD-ROM]]/[[DVD]] station or [[Ethernet]] port built-in. It can also be used as an (additional) [[failover]] link between [[High-availability cluster|ha-cluster]] [[Node (networking)|nodes]]. However, the clock speed of any parallel interface is limited due to the need to synchronize all of the signals representing data bits (and, to a lesser extent, all of the other signals as well). The problem is that slight differences in the thickness, insulation, or spacing of the wires in a parallel cable can cause different signals—on different wires—to arrive at slightly different times (microseconds apart) at the far end of the cable, even when they were sent at exactly the same time from the near end. This is called [[skew]]. At very high clock speeds, these very small time differences become significant, causing an upper limit on the usable clock speed of the parallel interface. By precisely controlling cable quality, it is possible to reduce skew enough to allow higher parallel clock rates, but this becomes 