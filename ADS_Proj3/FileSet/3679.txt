a terser variation of the previous [[Haskell (programming language)|Haskell]]: main=ap((putStr.).(++))show"main=ap((putStr.).(++))show" This is actually, if you squint, a particular instance of (one particular) general pattern to produce a quine: (\o -> APPLY (UNQUOTE o) (QUOTE o)) (QUOTE (\o -> APPLY (UNQUOTE o) (QUOTE o))) where CAPITALIZED identifiers are schematic. In passing, note the implicit "APPLY"s that are happening at the level of the programming language. Armed with this template, we can unravel the second of the two previous Haskell quines. First, we extract the essential part of the quine ap(++)show"ap(++)show" then note that ap f g = (\o -> f o (g o)) expanding this in the original gives (\o -> (++) o (show o)) "(\\o -> (++) o (show o))" and matching this against our quine template produces APPLY := (++) UNQUOTE := id QUOTE := show So, APPLY is string concatenation, QUOTE is string-escaping, and UNQUOTE is the identity. We can also perform a similarly mechanical matching of the previous (slightly modified, but in a non-essential way) English quine: quoted and preceeded by itself is a quine. "quoted and preceeded by itself is a quine." Also, notice that by using "is a quine", it references itself in another way as well, and this additional self reference is not essential for it to be a quine. In other words, quoted and preceeded by itself. "quoted and preceeded by itself." is a quine. ===C=== The idea behind this quine is to store a copy of the program code in a string, and use that to print out both the program code and the string. <source lang="c"> /* A simple quine (self-printing program), in standard C. */ /* Note: in designing this quine, we have tried to make the code clear * and readable, not concise and obscure as many quines are, so that * the general principle can be made clear at the expense of length. * In a nutshell: use the same data structure (called "progdata" * below) to output the program code (which it represents) and its own * textual representation. */ #include <stdio.h> void quote(const char *s) /* This function takes a character string s and prints the * textual representation of s as it might appear formatted * in C code. */ { int i; printf(" \""); for (i=0; s[i]; ++i) { /* Certain characters are quoted. */ if (s[i] == '\\') printf("\\\\"); else if (s[i] == '"') printf("\\\""); else if (s[i] == '\n') printf("\\n"); /* Others are just printed as such. */ else printf("%c", s[i]); /* Also insert occasional line breaks. */ if (i % 48 == 47) printf("\"\n \""); } printf("\""); } /* What follows is a string representation of the program code, * from beginning to end (formatted as per the quote() function * above), except that the string _itself_ is coded as two * consecutive '@' characters. */ const char progdata[] = "/* A simple quine (self-printing program), in st" "andard C. */\n\n/* Note: in designing this quine, " "we have tried to make the code clear\n * and read" "able, not concise and obscure as many quines are" ", so that\n * the general principle can be made c" "lear at the expense of length.\n * In a nutshell:" " use the same data structure (called \"progdata\"\n" " * below) to output the program code (which it r" "epresents) and its own\n * textual representation" ". */\n\n#include <stdio.h>\n\nvoid quote(const char " "*s)\n /* This function takes a character stri" "ng s and prints the\n * textual representati" "on of s as it might appear formatted\n * in " "C code. */\n{\n int i;\n\n printf(\" \\\"\");\n " " for (i=0; s[i]; ++i) {\n /* Certain cha" "racters are quoted. */\n if (s[i] == '\\\\')" "\n printf(\"\\\\\\\\\");\n else if (s[" "i] == '\"')\n printf(\"\\\\\\\"\");\n e" "lse if (s[i] == '\\n')\n printf(\"\\\\n\");" "\n /* Others are just printed as such. */\n" " else\n printf(\"%c\", s[i]);\n " " /* Also insert occasional line breaks. */\n " " if (i % 48 == 47)\n printf(\"\\\"\\" "n \\\"\");\n }\n printf(\"\\\"\");\n}\n\n/* What fo" "llows is a string representation of the program " "code,\n * from beginning to end (formatted as per" " the quote() function\n * above), except that the" " string _itself_ is coded as two\n * consecutive " "'@' characters. */\nconst char progdata[] =\n@@;\n\n" "int main(void)\n /* The program itself... */\n" "{\n int i;\n\n /* Print the program code, cha" "racter by character. */\n for (i=0; progdata[i" "]; ++i) {\n if (progdata[i] == '@' && prog" "data[i+1] == '@')\n /* We encounter tw" "o '@' signs, so we must print the quoted\n " " * form of the program code. */\n {\n " " quote(progdata); /* Quote all. */\n" " i++; /* Skip second '" "@'. */\n } else\n printf(\"%c\", p" "rogdata[i]); /* Print character. */\n }\n r" "eturn 0;\n}\n"; int main(void) /* The program itself... */ { int i; /* Print the program code, character by character. */ for (i=0; progdata[i]; ++i) { if (progdata[i] == '@' && progdata[i+1] == '@') /* We encounter two '@' signs, so we must print the quoted * form of the program code. */ { quote(progdata); /* Quote all. */ i++; /* Skip second '@'. */ } else printf("%c", progdata[i]); /* Print character. */ } return 0; } </source> An alternative approach in C would be to make use of the C pre-processor. For example: <source lang="c"> #include <stdio.h> int main(int argc, char** argv) { /* This macro B will expand to its argument, followed by a printf command that prints the macro invocation as a literal string */ #define B(x) x; printf(" B(" #x ")\n"); /* This macro A will expand to a printf command that prints the macro invocation, followed by the macro argument itself. */ #define A(x) printf(" A(" #x ")\n"); x; /* Now we call B on a command to print the text of the program up to this point. It will execute the command, and then cause itself to be printed. */ B(printf("#include <stdio.h>\n\nint main(int 