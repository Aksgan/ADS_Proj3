Lego.com (Adobe Shockwave also required) [[Category:Fictional robots]] [[Category:Fictional janitors]] [[Category:Freeware games]] [[Category:Lego games]] [[Category:Puzzle video games]] [[pt:Junkbot]]</text> </page> <page> <id>20297</id> <title>Justesen code</title> <text>In [[coding theory]], '''Justesen codes''' form a class of [[Error detection and correction|error-correcting codes]] which are derived from [[Reed-Solomon code]]s and have good error-control properties. ==Definition== Let ''R'' be a Reed-Solomon code of length ''N'' = 2<sup>''m''</sup> &minus; 1, [[dimension (vector space)|rank]] ''K'' and minimum weight ''N'' &minus; ''K'' + 1. The symbols of ''R'' are elements of ''F'' = GF(2<sup>''m''</sup>) and the codewords are obtained by taking every polynomial &fnof; over ''F'' of degree less than ''K'' and listing the values of &fnof; on the non-zero elements of ''F'' in some predetermined order. Let α be a [[primitive element (finite field)|primitive element]] of ''F''. For a codeword '''a''' = (''a''<sub>1</sub>, ..., ''a''<sub>''N''</sub>) from ''R'', let '''b''' be the vector of length 2''N'' over ''F'' given by :<math> \mathbf{b} = \left( a_1, a_1, a_2, \alpha^1 a_2, \ldots, a_N, \alpha^{N-1} a_N \right) </math> and let '''c''' be the vector of length 2''N'' ''m'' obtained from ''b'' by expressing each element of ''F'' as a binary vector of length ''m''. The ''Justesen code'' is the linear code containing all such '''c'''. ==Properties== The parameters of this code are length 2''m'' ''N'', dimension ''m'' ''K'' and [[minimum distance]] at least :<math> \sum_{i=1}^\ell i \binom{2m}{i} . </math> The Justesen codes are examples of [[concatenated code]]s. == References == * {{cite journal | author=J. Justesen | title=A class of constructive asymptotically good algebraic codes | journal=IEEE Trans. Info. Theory | volume=18 | year=1972 | pages=652–656 | doi=10.1109/TIT.1972.1054893 }} * {{cite book | author=F.J. MacWilliams | authorlink=Jessie MacWilliams | coauthors=N.J.A. Sloane | title=The Theory of Error-Correcting Codes | publisher=North-Holland | date=1977 | isbn=0-444-85193-3 | pages=306–316 }} [[Category:Error detection and correction]] [[Category:Finite fields]] [[Category:Coding theory]] {{algebra-stub}}</text> </page> <page> <id>20327</id> <title>KAOS (software development)</title> <text>'''KAOS''', is a goal-oriented [[requirement|software requirements]] capturing approach in [[requirements engineering]]. It is a specific [[Goal modeling]] method; another is [[i*]]. It allows for requirements to be calculated from goal diagrams.<ref>[http://www.cs.utoronto.ca/~alexei/pub/Lapouchnian-Depth.pdf Goal-Oriented Requirements Engineering: An Overview of the Current Research].</ref> KAOS stands for ''Knowledge Acquisition in automated specification''<ref>A. Dardenne, A. van Lamsweerde and S. Fickas. Goal-Directed Requirements Acquisition. Science of Computer Programming, 20(1-2), April 1993.</ref> or ''Keep All Objects Satisfied''.<ref>A. van Lamsweerde, E. Letier. From Object Orientation to Goal Orientation: A Paradigm Shift for Requirements Engineering. Proc. Radical Innovations of Software and Systems Engineering, LNCS, 2003.</ref> The University of Oregon and the University of Louvain (Belgium) designed the KAOS methodology in 1990.<ref name="objectiver.com">[http://www.objectiver.com/fileadmin/download/documents/KaosTutorial.pdf A KAOS Tutorial].</ref> It is now widely taught worldwide at the university level {{Citation needed|date=July 2009}} for capturing software requirements. ==External links== *[http://www.objectiver.com/fileadmin/download/documents/KaosTutorial.pdf A KAOS Tutorial] *[http://www.cs.utoronto.ca/~alexei/pub/Lapouchnian-Depth.pdf Goal-Oriented Requirements Engineering: An Overview of the Current Research] ==References== <references/> {{DEFAULTSORT:Kaos (Software Development)}} [[Category:Software requirements]] [[Category:Diagrams]] [[Category:Systems analysis]]</text> </page> <page> <id>20329</id> <title>KCDSA</title> <text>'''KCDSA''' ('''Korean Certificate-based Digital Signature Algorithm''') is a [[digital signature]] algorithm created by a team led by the [[KISA|Korean Information Security Agency]] (KISA). It is an [[ElGamal signature scheme|ElGamal]] variant, similar to the [[Digital Signature Algorithm]] and [[GOST R 34.10-94]]. The standard algorithm is implemented over <math>GF(p)</math>, but an [[elliptic curve]] variant ('''EC-KCDSA''') is also specified. KCDSA requires a collision-resistant [[cryptographic hash function]] that can produce a variable-sized output (from 128 to 256 bits, in 32-bit increments). [[HAS-160]], another Korean standard, is the suggested choice. ==External links== * [http://grouper.ieee.org/groups/1363/P1363a/contributions/kcdsa1363.pdf KCDSA specification and analysis] {{crypto-stub}} [[Category:Public-key cryptography]] [[Category:Asymmetric-key cryptosystems]]</text> </page> <page> <id>20336</id> <title>KDL</title> <text>{{Unreferenced stub|auto=yes|date=December 2009}} {{Orphan|date=December 2009}} A '''KDL''' is a term used on [[BeOS]]/[[Haiku (operating system)|Haiku]] and possibly other [[operating system]]s for a serious [[Kernel (computer science)|kernel]] error which causes the computer to drop into the [[kernel debugger]]. '''KDL''' stands for Kernel Debug(ger) Land. While a KDL brought about by a buggy driver which is not crucial, such as a [[filesystem]] driver, can be escaped from (with the command 'es'), it usually leaves the user needing to reboot. {{DEFAULTSORT:Kdl}} [[Category:BeOS]] [[Category:Computer errors]] [[Category:Operating system technology]] {{Comp-sci-stub}}</text> </page> <page> <id>20337</id> <title>KDrive</title> <text>'''KDrive''' (or '''freedesktop.org Xserver''' or just '''Xserver''') is a small [[X Window System]] server implementation created by [[Keith Packard]]. Unlike the [[X.Org Server]], KDrive was not based on [[XFree86]] code. It was used by X.Org developers as a testing ground for new ideas, such as [[EXA]]. It practically superseded [[SmallX]] (also known as TinyX) and is commonly used in [[embedded system]]s with the need for a very thin X server. A specific feature of KDrive was that it was configured at compile-time, not at run-time. It was often compiled to use the native [[Linux framebuffer]] device as output. As of X.Org Server version 7.1, the KDrive framework was integrated into the reference implementation and is now part of the generic source code release of the server. == External links == *[http://www.freedesktop.org/Software/Xserver Xserver at freedesktop.org] {{XWinSys}} {{linux-stub}} [[Category:X servers]] [[Category:Freedesktop.org]] [[Category:Embedded Linux]] [[pt:KDrive]]</text> </page> <page> <id>20341</id> <title>KERNAL</title> <text>{{unreferenced|date=February 2009}} :''This article is about Commodore's 8-bit OS software. ''Kernal'' is also a common misspelling of [[kernel]]''. The '''KERNAL''' is [[Commodore International|Commodore]]'s name for the [[read-only memory|ROM]]-resident [[operating system]] core in its [[8-bit]] [[home computer]]s; from the original [[Commodore PET|PET]] of 1977, followed by the extended but strongly related versions used in its successors; the [[Commodore VIC-20|VIC-20]], [[Commodore 64]], [[Plus/4]], [[Commodore 16|C16]], and [[Commodore 128|C128]]. The Commodore 8-bit machines' KERNAL consisted of the low-level, close-to-the-hardware OS routines roughly equivalent to the [[BIOS]] in [[IBM PC compatibles]] (in contrast to the [[Commodore BASIC|BASIC interpreter]] routines, also located in ROM), and was user callable via a [[jump table]] whose central (oldest) part, for reasons of backwards compatibility, remained largely identical throughout the whole 8-bit series. The KERNAL ROM occupies the last 8 [[Kilobyte|KB]] of the 8-bit CPU's 64 KB address space ($E000-$FFFF). The KERNAL was initially written for the Commodore PET by [[John Feagans]], who introduced the idea of separating the BASIC routines from the operating system. It was further developed by several people, notably [[Robert Russell (engineer)|Robert Russell]] added many of the features for the VIC-20 and the C64. ==Example of use== A 