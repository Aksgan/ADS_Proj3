&times; b[7:0] = {8{a[7]}} & b[7:0]</nowiki> where <nowiki>{8{a[0]}}</nowiki> means repeating a[0] (the 0th bit of a) 8 times (Verilog notation). To produce our product, we then need to add up all eight of our partial products, as shown here: p0[7] p0[6] p0[5] p0[4] p0[3] p0[2] p0[1] p0[0] + p1[7] p1[6] p1[5] p1[4] p1[3] p1[2] p1[1] p1[0] 0 + p2[7] p2[6] p2[5] p2[4] p2[3] p2[2] p2[1] p2[0] 0 0 + p3[7] p3[6] p3[5] p3[4] p3[3] p3[2] p3[1] p3[0] 0 0 0 + p4[7] p4[6] p4[5] p4[4] p4[3] p4[2] p4[1] p4[0] 0 0 0 0 + p5[7] p5[6] p5[5] p5[4] p5[3] p5[2] p5[1] p5[0] 0 0 0 0 0 + p6[7] p6[6] p6[5] p6[4] p6[3] p6[2] p6[1] p6[0] 0 0 0 0 0 0 + p7[7] p7[6] p7[5] p7[4] p7[3] p7[2] p7[1] p7[0] 0 0 0 0 0 0 0 ------------------------------------------------------------------------------------------- P[15] P[14] P[13] P[12] P[11] P[10] P[9] P[8] P[7] P[6] P[5] P[4] P[3] P[2] P[1] P[0] In other words, ''P''[15:0] is produced by summing ''p''0, ''p''1 << 1, ''p''2 << 2, and so forth, to produce our final unsigned 16-bit product. ==Engineering approach: signed integers== If ''b'' had been a [[signedness|signed]] integer instead of an [[signedness|unsigned]] integer, then the partial products would need to have been sign-extended up to the width of the product before summing. If ''a'' had been a signed integer, then partial product ''p7'' would need to be subtracted from the final sum, rather than added to it. The above array multiplier can be modified to support [[two's complement notation]] signed numbers by inverting several of the product terms and inserting a one to the left of the first partial product term: 1 -p0[7] p0[6] p0[5] p0[4] p0[3] p0[2] p0[1] p0[0] -p1[7] +p1[6] +p1[5] +p1[4] +p1[3] +p1[2] +p1[1] +p1[0] 0 -p2[7] +p2[6] +p2[5] +p2[4] +p2[3] +p2[2] +p2[1] +p2[0] 0 0 -p3[7] +p3[6] +p3[5] +p3[4] +p3[3] +p3[2] +p3[1] +p3[0] 0 0 0 -p4[7] +p4[6] +p4[5] +p4[4] +p4[3] +p4[2] +p4[1] +p4[0] 0 0 0 0 -p5[7] +p5[6] +p5[5] +p5[4] +p5[3] +p5[2] +p5[1] +p5[0] 0 0 0 0 0 -p6[7] +p6[6] +p6[5] +p6[4] +p6[3] +p6[2] +p6[1] +p6[0] 0 0 0 0 0 0 1 +p7[7] -p7[6] -p7[5] -p7[4] -p7[3] -p7[2] -p7[1] -p7[0] 0 0 0 0 0 0 0 ------------------------------------------------------------------------------------------------------------ P[15] P[14] P[13] P[12] P[11] P[10] P[9] P[8] P[7] P[6] P[5] P[4] P[3] P[2] P[1] P[0] Do not be misled by the minus sign (-) notation above. It does not mean arithmetic negation ( -(7) = -7), but instead binary complementation, more commonly denoted <math>x\prime</math> (read x prime), <math>\bar x</math> (x bar) or ~<math>x</math> (tilde x), achieved by flipping all the bits. In two's complement to get the negation of a number, you complement the number then add 1, so they are NOT equivalent. There are a lot of simplifications in the bit array above that are not shown and are not obvious. The sequences of one complemented bit followed by noncomplemented bits are implementing a two's complement trick to avoid sign extension. The sequence of p7 (noncomplemented bit followed by all complemented bits) is because we're subtracting this term so they were all negated to start out with (and a 1 was added in the least significant position). For both types of sequences, the last bit is flipped and an implicit -1 should be added directly below the MSB. When the +1 from the two's complement negation for p7 in bit position 0 (LSB) and all the -1's in bit columns 7 through 14 (where each of the MSBs are located) are added together, they can be simplified to the single 1 that "magically" is floating out to the left. For an explanation and proof of why flipping the MSB saves us the sign extension, see a computer arithmetic book {{Citation needed|reason=Do not patronize: cite an authoritative source|date=September 2010}}. ==Implementations== Older multiplier architectures employed a shifter and accumulator to sum each partial product, often one partial product per cycle, trading off speed for die area. Modern multiplier architectures use the [[Baugh&ndash;Wooley algorithm]], [[Wallace tree]]s, or [[Dadda multiplier]]s to add the partial products together in a single cycle. The performance of the [[Wallace tree]] implementation is sometimes improved by ''modified'' [[Booth encoding]] one of the two multiplicands, which reduces the number of partial products that must be summed. ==Example== [[Image:binary multi1.jpg|center|thumb|500px|2 Bit by 2 Bit Binary Multiplier<br> '''Using a 4 Bit + 4 Bit Adder''']] <!-- Deleted image removed: [[Image:eightbitmult.jpg|center|thumb|500px|4 Bit by 4 Bit Binary Multiplier<br> '''Using 4 Bit + 4 Bit Adders''']] --> (The following are to clarify each level of abstraction) [[Image:adder.jpg|center|thumb|500px|A simple adder<br> '''1-bit adder''']] [[Image:ander.jpg|center|thumb|500px|"Ander"<br> '''A 1x4 bit ander''']] [[Image:fourbitadder.jpg|center|thumb|500px|4-bit Adder<br> '''Using 4 1-bit adders''']] ==See also== * [[Booth's multiplication algorithm]] * [[Multiply-accumulate]] (fused multiply-add) * [[Wallace tree]] * [[BKM algorithm]] for complex logarithms and exponentials * [[Kochanski multiplication]] for [[modular arithmetic|modular]] multiplication ==References== {{Reflist}} *Computer Architecture: A quantitative Approach, Hennessy and Patterson, 1990, Morgan Kafmann Publishers, Inc. Section A.2 (pages A-3 through A-6) and section A.9 (pages A-39 through A-49). ==External links== * [http://www.andraka.com/multipli.htm Multiplier Designs] targeted at [[FPGA]]s * Self-clocking [http://ixeelectronics.com/openttl/Multiplier.html Multiplier] using TTL {{DEFAULTSORT:Binary Multiplier}} [[Category:Digital circuits]] [[Category:Computer arithmetic]] [[Category:Multiplication]] [[ar:ضارب]] [[de:Multiplizierer (Digitaltechnik)]] [[fa:ضرب‌کننده دودویی]] [[ko:곱셈기]] [[id:Pengganda biner]] [[ja:乗算器]]</text> </page> <page> <id>3835</id> <title>Binary search tree</title> <text>[[Image:Binary search tree.svg|right|200px|thumb|A binary search tree of size 9 and depth 3, with root 8 and leaves 1, 4, 7 and 13]] In [[computer science]], a '''binary search tree''' ('''BST'''), which may sometimes also be called '''ordered''' or '''sorted''' binary tree, is a [[Node_(computer_science)|node-based]] [[binary tree]] [[data structure]] which has the following properties:<ref>{{citation |last1=Gilberg |first1=R. |last2=Forouzan |first2=B. |title=Data Structures: A Pseudocode Approach With C++ |publisher=Brooks/Cole |location=Pacific Grove, CA |year=2001 |isbn=0-534-95216-X |page=339 |chapter=8 }}</ref> * The left [[Tree (data structure)#subtrees|subtree]] of a node contains only nodes with keys less than the node's key. * The right subtree of a node contains only nodes with keys greater than the node's key. * Both the left and right subtrees must also be binary search trees. Generally, the information represented by each node is a '''record''' rather than a single data element. However, 