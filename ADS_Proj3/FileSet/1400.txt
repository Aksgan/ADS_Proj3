digitized as 16 kHz 16-bit audio, although he did freely confess that "maybe the authors [of the exabyte estimate] were thinking about text."<ref>{{Cite web| url=http://itre.cis.upenn.edu/~myl/languagelog/archives/000087.html | title=Zettascale Linguistics | author=Mark Liberman | authorlink=Mark Liberman | date=November 3, 2003 | publisher=upenn.edu | accessdate=2007-02-17}}</ref> Earlier Berkeley studies estimated that by the end of 1999, the sum of human-produced information (including all audio, video recordings and text/books) was about 12 exabytes of data.<ref>{{Cite web| url=http://www.cio.com/archive/092203/enriquez.html | title=The Data That Defines Us | year=2003 | month= Fall/Winter | author=Juan Enriquez | publisher=CIO Magazine | accessdate=2006-07-19}}</ref> The 2003 Berkeley report stated that in 2002 alone, "telephone calls worldwide on both landlines and mobile phones contained 17.3 exabytes of new information if stored in digital form" and that "it would take 9.25 exabytes of storage to hold all U.S. [telephone] calls each year."<ref name="UCB"/> International Data Corporation estimates that approximately 160 exabytes of digital information were created, captured, and replicated worldwide in 2006.<ref>{{Cite web| url=http://www.businessweek.com/ap/financialnews/D8NMAG802.htm | publisher=[[BusinessWeek]] | title=So much data, relatively little space | author=[[Brian Bergstein]] | date=March 5, 2007 | accessdate=2007-03-05}}</ref> ===The Human Brain=== If the human brain was converted to a digital hard drive, the size of it can be estimated at up to 10 Exabytes. This is calculated by estimating the number of synapses in the brain, and assuming that each one can hold a few bits of memory. The number of synapses is estimated by Von Neumann to be 10 to the power of 20, giving 100,000,000,000,000,000,000 bits. As there are 8 bits in a byte, you divide the number by 8, then by 1024 to get kilobytes, then megabytes, etc. to get 10.82 Exabytes. ==See also== * [[Binary prefix]] * [[Orders of magnitude (data)]] ==References== {{Reflist|colwidth=30em}} ==External links== * [http://searchstorage.techtarget.com/sDefinition/0,,sid5_gci212085,00.html exabyte (whatis.com definition)] {{Computer Storage Volumes}} [[Category:Units of information]] [[ar:إكسابايت]] [[az:Ekzabayt]] [[be-x-old:Эксабайт]] [[ca:Exabyte]] [[da:Exabyte]] [[es:Exabyte]] [[eu:Exabyte]] [[fa:اگزابایت]] [[ko:엑사바이트]] [[hy:Էկսա]] [[it:Exabyte]] [[mk:Ексабајт]] [[mr:एक्साबाईट]] [[ms:Eksabait]] [[ja:エクサバイト]] [[no:Exabyte]] [[pl:Eksabajt]] [[pt:Exabyte]] [[ru:Эксабайт]] [[simple:Exabyte]] [[sk:Exabajt]] [[sr:Ексабајт]] [[th:เอกซะไบต์]] [[tg:Эксабайт]] [[zh:艾字节]]</text> </page> <page> <id>12744</id> <title>Example Pictor Encoder</title> <text>{{move to Wikibooks}} == Pictor PCPaint PIC image format == '''[[PICtor PIC image format|PICtor]]''' is an [[graphics file formats|image file format]] developed by [[John Bridges]], the principal author of [[PCPaint]], the first Paintbrush program for the PC. It was also the native file format for [[Pictor Paint]] and [[GRASP (multimedia authoring software)]] (also by Bridges) and became the first widely accepted [[MS-DOS|DOS]] imaging standard. The PICtor format is quite well documented, but lacks a programming example like the one below. ==Typical Pictor Encoder == <pre> // This source code is herewith released by me into the Public Domain. // Bill Buckels, May 21, 2007 // You have a royalty-free right to use, modify, reproduce and distribute this // source code and the binaries that it produces in any way you find useful // this is a highly simplified run length encoder for encoding a raw image block // of up to 8 bit pixel depth into an encoded block for a Pictor File. // if the buffer contains all 256 ascii values the LEAST used byte is used for a marker. // Note also, if you are encoding a planar image such as an ega 4 plane // image, each bit plane must be split into 4 separate contiguous blocks // of monochrome data (sometimes referred to a "SEGMENTS") of the height and width // of the image that you are encoding before encoding takes place (below). // This is done outside of here. // The code below works for monochrome, 2 bit CGA, 4 bit EGA, and 8 bit MCGA // I am assuming a 32 bit Windows platform with a BOOL and a TRUE and a FALSE // no hardship to compile this in 'nix tho' #define PICTOR_Int unsigned short // for 32 bit Windows #define SUCCESS 0 #define FAILURE -1 int WritePictorBlock(unsigned char *buf, unsigned buflen, FILE *fp) { unsigned idx, jdx, writecnt = 0, offset = 1, runcnt = 1, markerbuf[256]; unsigned char markertest, RunMarker, lastbyte, nextbyte, leastused; PICTOR_Int RunLength, BlockSize, RunCount; BOOL bfound = FALSE, endofrun = FALSE; FILE *fpTmp; int c; // I am limiting myself to maximum 64000 byte blocks here // since this seems probably enough memory for pictor to allocate // for an unpacking buffer. // my particular algorithm also will not encode less than 2 bytes // which in the grand scheme of things is not a hardship. if (buflen < 2 || buflen > 64000)return FAILURE; // record all ascii values used in this block // and use one that isn't used for a marker. for (idx = 0; idx < 256; idx++) { markerbuf[idx] = 0; // initial count } for (idx = 0; idx < buflen; idx++) { markertest = buf[idx]; markerbuf[markertest] += 1; } // count backwards, I prefer the highest value possible for a marker. markertest = 255; for(;;) { if (markerbuf[markertest] == 0) { bfound = TRUE; RunMarker = markertest; break; } if (markertest == 0) break; markertest -= 1; } // if we found no available markers in this block // all 256 byte values are in use // ROT - to avoid complicated algorithms that consider patterning etc. // take John Bridges' early advice... // no unique bytes in scanline, so use the LEAST used byte as a marker // again counting backwards if (bfound == FALSE) { leastused = 255; jdx = markerbuf[255]; markertest = 254; for(;;) { idx = (unsigned) markerbuf[markertest]; if (idx < jdx) { // only switch for less jdx = idx; leastused = markertest; } if (markertest == 0) break; markertest -= 1; } RunMarker = leastused; } // now we know what the marker will be so we encode the runs // for this block into a temporary file which tells us the // sum of the compressed block which we require for our header. // I could also have done a dry-run, allocated memory and encoded into // a buffer but I am being lazy and these days computers are fast and disk space abundant 