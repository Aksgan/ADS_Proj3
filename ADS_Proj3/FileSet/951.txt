# Assembly of modules might require more effort and/or time due to the increased inter-module dependency. # A particular module might be harder to reuse and/or test because dependent modules must be included. == Performance issues == Whether loosely or tightly coupled, a system's performance is often reduced by message and parameter creation, transmission, translation and interpretation overhead. See [[event-driven programming]]. ;Message Creation Overhead and Performance: Since all messages and parameters must possess particular meanings to be consumed (i.e., result in intended logical flow within the receiver), they must be created with a particular meaning. Creating any sort of message requires overhead in either CPU or memory usage. Creating a single integer value message (which might be a reference to a string, array or data structure) requires less overhead than creating a complicated message such as a SOAP message. Longer messages require more CPU and memory to produce. To optimize runtime performance, message length must be minimized and message meaning must be maximized. ;Message Transmission Overhead and Performance: Since a message must be transmitted in full to retain its complete meaning, message transmission must be optimized. Longer messages require more CPU and memory to transmit and receive. Also, when necessary, receivers must reassemble a message into its original state to completely receive it. Hence, to optimize runtime performance, message length must be minimized and message meaning must be maximized. ;Message Translation Overhead and Performance: Message protocols and messages themselves often contain extra information (i.e., packet, structure, definition and language information). Hence, the receiver often needs to translate a message into a more refined form by removing extra characters and structure information and/or by converting values from one type to another. Any sort of translation increases CPU and/or memory overhead. To optimize runtime performance, message form and content must be reduced and refined to maximize its meaning and reduce translation. ;Message Interpretation Overhead and Performance: All messages must be interpreted by the receiver. Simple messages such as integers might not require additional processing to be interpreted. However, complex messages such as SOAP messages require a parser and a string transformer for them to exhibit intended meanings. To optimize runtime performance, messages must be refined and reduced to minimize interpretation overhead. == Solutions == One approach to decreasing coupling is [[functional design]], which seeks to limit the responsibilities of modules along functionality, coupling increases between two classes '''''A''''' and '''''B''''' if: *'''''A''''' has an attribute that refers to (is of type) '''''B'''''. *'''''A''''' calls on services of an object '''''B'''''. *'''''A''''' has a method that references '''''B''''' (via return type or parameter). *'''''A''''' is a subclass of (or implements) class '''''B'''''. Low coupling refers to a relationship in which one module interacts with another module through a simple and stable interface and does not need to be concerned with the other module's internal implementation (see [[Information Hiding]]). Systems such as [[CORBA]] or [[Component Object Model|COM]] allow objects to communicate with each other without having to know anything about the other object's implementation. Both of these systems even allow for objects to communicate with objects written in other languages. == Module coupling == Coupling in Software Engineering<ref name=Pressman>Pressman, Roger S. Ph.D (1982). Software Engineering - A Practitioner's Approach - Fourth Edition. ISBN 0-07-052182-4</ref> describes a version of metrics associated with this concept. For data and control flow coupling: * '''d<sub>i</sub>''': number of input data parameters * '''c<sub>i</sub>''': number of input control parameters * '''d<sub>o</sub>''': number of output data parameters * '''c<sub>o</sub>''': number of output control parameters For global coupling: * '''g<sub>d</sub>''': number of global variables used as data * '''g<sub>c</sub>''': number of global variables used as control For environmental coupling: * '''w''': number of modules called (fan-out) * '''r''': number of modules calling the module under consideration (fan-in) <math>\mathrm{Coupling}(C) = 1 - \frac{1}{d_{i} + 2\times c_{i} + d_{o} + 2\times c_{o} + g_{d} + 2\times g_{c} + w + r}</math> <code>Coupling(C)</code> makes the value larger the more coupled the module is. This number ranges from approximately 0.67 (low coupling) to 1.0 (highly coupled) For example, if a module has only a single input and output data parameter <math>C = 1 - \frac{1}{1+0+1+0+0+0+1+0} = 1 - \frac{1}{3} = 0.67</math> If a module has 5 input and output data parameters, an equal number of control parameters, and accesses 10 items of global data, with a fan-in of 3 and a fan-out of 4, <math>C = 1 - \frac{1}{5 + 2\times 5 + 5 + 2\times 5 + 10 + 0 + 3 + 4} = 0.98</math> ==See also== * [[Cohesion (computer science)]] * [[Dependency hell]] * [[Efferent coupling]] * [[Inversion of control]] * [[List of object-oriented programming terms]] * [[Loose coupling]] * [[Make (software)]] * [[Static code analysis]] == References == <references/> {{DEFAULTSORT:Coupling (Computer Science)}} [[Category:Object-oriented programming]] [[Category:Software architecture]] [[Category:Software metrics]] [[de:Kopplung (Softwareentwicklung)]] [[fr:Couplage (informatique)]] [[it:Dipendenza (informatica)]] [[mt:Coupling]] [[ja:結合度]] [[pl:Zależność oprogramowania]] [[ru:Связанность (программирование)]]</text> </page> <page> <id>8304</id> <title>Covariance matrix</title> <text>[[Image:Gaussian-2d.png|thumb|right|A [[multivariate Gaussian distribution|bivariate Gaussian probability density function]] centered at (0,0), with covariance matrix [ 1.00, .50 ; .50, 1.00 ]. ]] In [[probability theory]] and [[statistics]], a '''covariance matrix''' is a [[Matrix (mathematics)|matrix]] whose element in the ''i'', ''j'' position is the [[covariance]] between the ''i'' <sup>th</sup> and ''j'' <sup>th</sup> elements of a [[random vector]] (that is, of a [[Euclidean vector |vector]] of [[random variable]]s). == Definition == If the entries in the [[column vector]] :<math> \mathbf{X} = \begin{bmatrix}X_1 \\ \vdots \\ X_n \end{bmatrix}</math> are [[random variable]]s, each with finite variance, then the covariance matrix Σ is the matrix whose (''i'', ''j'') entry is the [[covariance]] :<math> \Sigma_{ij} = \mathrm{cov}(X_i, X_j) = \mathrm{E}\begin{bmatrix} (X_i - \mu_i)(X_j - \mu_j) \end{bmatrix} </math> where : <math> \mu_i = \mathrm{E}(X_i)\, </math> is the [[expected value]] of the ''i''th entry in the vector ''X''. In other words, we have : <math> \Sigma = \begin{bmatrix} \mathrm{E}[(X_1 - \mu_1)(X_1 - \mu_1)] & \mathrm{E}[(X_1 - \mu_1)(X_2 - \mu_2)] & \cdots & \mathrm{E}[(X_1 - \mu_1)(X_n - \mu_n)] \\ \\ \mathrm{E}[(X_2 - \mu_2)(X_1 - \mu_1)] & \mathrm{E}[(X_2 - \mu_2)(X_2 - \mu_2)] & \cdots & \mathrm{E}[(X_2 - 