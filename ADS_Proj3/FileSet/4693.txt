clause is false, the last value at latch_out will remain and is independent of the value of din. <source lang="verilog"> // Transparent latch example reg out; always @(gate or din) if(gate) out = din; // Pass through state // Note that the else isn't required here. The variable // out will follow the value of din while gate is high. // When gate goes low, out will remain constant. </source> The flip-flop is the next significant template; in Verilog, the D-flop is the simplest, and it can be modeled as: <source lang="verilog"> reg q; always @(posedge clk) q <= d; </source> The significant thing to notice in the example is the use of the non-blocking assignment. A basic [[rule of thumb]] is to use '''<=''' when there is a '''posedge''' or '''negedge''' statement within the always clause. A variant of the D-flop is one with an asynchronous reset; there is a convention that the reset state will be the first if clause within the statement. <source lang="verilog"> reg q; always @(posedge clk or posedge reset) if(reset) q <= 0; else q <= d; </source> The next variant is including both an asynchronous reset and asynchronous set condition; again the convention comes into play, i.e. the reset term is followed by the set term. <source lang="verilog"> reg q; always @(posedge clk or posedge reset or posedge set) if(reset) q <= 0; else if(set) q <= 1; else q <= d; </source> Note: If this model is used to model a Set/Reset flip flop then simulation errors can result. Consider the following test sequence of events. 1) reset goes high 2) clk goes high 3) set goes high 4) clk goes high again 5) reset goes low followed by 6) set going low. Assume no setup and hold violations. In this example the always @ statement would first execute when the rising edge of reset occurs which would place q to a value of 0. The next time the always block executes would be the rising edge of clk which again would keep q at a value of 0. The always block then executes when set goes high which because reset is high forces q to remain at 0. This condition may or may not be correct depending on the actual flip flop. However, this is not the main problem with this model. Notice that when reset goes low, that set is still high. In a real flip flop this will cause the output to go to a 1. However, in this model it will not occur because the always block is triggered by rising edges of set and reset - not levels. A different approach may be necessary for set/reset flip flops. The final basic variant is one that implements a D-flop with a mux feeding its input. The mux has a d-input and feedback from the flop itself. This allows a gated load function. <source lang="verilog"> // Basic structure with an EXPLICIT feedback path always @(posedge clk) if(gate) q <= d; else q <= q; // explicit feedback path // The more common structure ASSUMES the feedback is present // This is a safe assumption since this is how the // hardware compiler will interpret it. This structure // looks much like a Latch. The differences are the // '''@(posedge clk)''' and the non-blocking '''<=''' // always @(posedge clk) if(gate) q <= d; // the "else" mux is "implied" </source> == Initial and Always == There are two separate ways of declaring a verilog process. These are the '''always''' and the '''initial''' keywords. The '''always''' keyword indicates a free-running process. The '''initial''' keyword indicates a process executes exactly once. Both constructs begin execution at simulator time 0, and both execute until the end of the block. Once an always block has reached its end, it is rescheduled (again). It is a common misconception to believe that an initial block will execute before an always block. In fact, it is better to think of the '''initial'''-block as a special-case of the '''always'''-block, one which terminates after it completes for the first time. <source lang="verilog"> //Examples: initial begin a = 1; // Assign a value to reg a at time 0 #1; // Wait 1 time unit b = a; // Assign the value of reg a to reg b end always @(a or b) // Any time a or b CHANGE, run the process begin if (a) c = b; else d = ~b; end // Done with this block, now return to the top (i.e. the @ event-control) always @(posedge a)// Run whenever reg a has a low to high change a <= b; </source> These are the classic uses for these two keywords, but there are two significant additional uses. The most common of these is an '''always''' keyword without the '''@(...)''' sensitivity list. It is possible to use always as shown below: <source lang="verilog"> always begin // Always begins executing at time 0 and NEVER stops clk = 0; // Set clk to 0 #1; // Wait for 1 time unit clk = 1; // Set clk to 1 #1; // Wait 1 time unit end // Keeps executing - so continue back at the top of the begin </source> The '''always''' keyword acts similar to the "C" construct '''while(1) {..}''' in the sense that it will execute forever. The other interesting exception is the use of the '''initial''' keyword with the addition of the '''forever''' keyword. The example below is functionally identical to the '''always''' example above. <source lang="verilog"> initial forever // Start at time 0 and repeat the begin/end forever begin clk = 0; // Set clk to 0 #1; // Wait for 1 time unit clk = 1; // Set clk to 1 #1; // Wait 1 time unit end </source> == Fork/Join == The '''fork/join''' pair are used by Verilog to create parallel processes. All statements (or blocks) between a fork/join pair begin execution simultaneously upon execution flow hitting the '''fork'''. Execution continues after 