has these components and sub-components: # Root. ## Routing object ''O''. ## Radius O<sub>''r''</sub>. ## A set of Nodes or (exclusive) Leafs. # Node. ## Routing object ''O''<sub>r</sub>. ## Radius O<sub>''r''</sub>. ## Distance from this node to its parent ''O''<sub>p</sub>. ## A set of Nodes or (exclusive) Leafs. # Leaf. ## Routing object ''O''. ## Radius O<sub>''r''</sub>. ## Distance from this leaf to its parent ''O''<sub>p</sub>. ## Objects. # Objects. ## Feature value (usually a ''d''-dimensional vector). === Insert === The main idea is first to find a leaf node <math>N</math> where the new object <math>O</math> belongs. If <math>N</math> is not full then just attach it to <math>N</math>. If <math>N</math> is full then invoke a method to split <math>N</math>. The algorithm is as follow: {{algorithm-begin|name=Insert}} Input: Node <math>N</math> of M-Tree <math>MT</math>, Entry <math>O_{n}</math> Output: A new instance of <math>MT</math> containing all entries in original <math>MT</math> plus <math>O_{n}</math> <math>N_{e}</math> ← Entries of node <math>N</math> '''if''' <math>N</math> is not a leaf '''then''' { /*Look for entries such that the new objects is into*/ let be <math>N_{in}</math> entries such that <math>d(O_{r}, O_{n}) <= r(O_{r})</math> '''if''' <math>N_{in}</math> is not empty '''then''' { /*If there are one or more entry, then look for an entry such that is closer to the new object*/ let be <math>O_{r}^{*} \in N_{in}</math> such that <math>d(O_{r}^{*}, O_{n})</math> is minimum } '''else''' { /*If there are no such entry, then look for an entry with minimal distance from its edge to the new object*/ let be <math>O_{r}^{*} \in N_{in}</math> such that <math>d(O_{r}^{*}, O_{n}) - r(O_{r})</math> is minimum /*Upgrade the new radii of the entry*/ <math>r(O_{r}^{*})</math> = <math>d(O_{r}^{*}, O_{n})</math> } /*Continue inserting in the next level*/ return insert(<math>T(O_{r}^{*})</math>, <math>O_{n}</math>); '''else''' { /*If the node has capacity then just insert the new object*/ '''if''' <math>N</math> is not full '''then''' { store(<math>N</math>, <math>O_{n}</math>) } /*The node is at full capacity, then it is needed to do a new split in this level*/ '''else''' { split(<math>N</math>, <math>O_{n}</math>) } } {{algorithm-end}} === Split === If the split method arrives to the root of the tree, then it choose two routing objects from <math>N</math>, and creates two new nodes containing all the objectos in original <math>N</math>, and store them into the new root. If split methods arrives to a node <math>N</math> that is not the root of the tree, the method choose two new routing objects from <math>N</math>, re-arrange every routing object in <math>N</math> in two new nodes <math>N_{1}</math> and <math>N_{2}</math>, and store this new nodes in the parent node <math>N_{p}</math> of original <math>N</math>. The split must be repeated if <math>N_{p}</math> has not enough capacity to store <math>N_{2}</math>. The algorithm is as follow: {{algorithm-begin|name=Split}} Input: Node <math>N</math> of M-Tree <math>MT</math>, Entry <math>O_{n}</math> Output: A new instance of <math>MT</math> containing a new partition. /*The new routing objects are now all those in the node plus the new routing object*/ let be <math>NN</math> entries of <math>N \cup O</math> '''if''' <math>N</math> is not the root '''then''' { /*Get the parent node and the parent routing object*/ let <math>O_{p}</math> be the parent routing object of <math>N</math> let <math>N_{p}</math> be the parent node of <math>N</math> } /*This node will contain part of the objects of the node to be splitted*/ Create a new node <math>N'</math> /*Promote two routing objects from the node to be splitted, to be new routing objects*/ Promote(<math>N</math>, <math>O_{p1}</math>, <math>O_{p2}</math>) /*Choose which objects from the node being splited will act as new routing objects*/ Partition(<math>N</math>, <math>O_{p1}</math>, <math>O_{p2}</math>, <math>N_{1}</math>, <math>N_{2}</math>) /*Store entries in each new routing object*/ Store <math>N_{1}</math>'s entries in <math>N</math> and <math>N_{2}</math>'s entries in <math>N'</math> '''if''' <math>N</math> is the current root '''then''' { /*Create a new node and set it as new root and store the new routing objects*/ Create a new root node <math>N_{p}</math> Store <math>O_{p1}</math> and <math>O_{p2}</math> in <math>N_{p}</math> } '''else''' { /*Now use the parent rouing object to store one of the new objects*/ Replace entry <math>O_{p}</math> with entry <math>O_{p1}</math> in <math>N_{p}</math> '''if''' <math>N_{p}</math> is no full '''then''' { /*The second routinb object is stored in the parent only if it has free capacity*/ Store <math>O_{p2}</math> in <math>N_{p}</math> } '''else''' { /*If there is no free capacity then split the level up*/ split(<math>N_{p}</math>, <math>O_{p2}</math>) } } {{algorithm-end}} == M-Tree Queries == === Range queries === Range queries === k-NN queries === {{Empty section|date=January 2011}} ==See also== * [[Segment tree]] * [[Interval tree]] - A degenerate R-Tree for 1 dimension (usually time). * [[Bounding volume hierarchy]] * [[Spatial index]] * [[GiST]] ==References== {{reflist}} ==External links== {{CS-Trees}} {{DEFAULTSORT:M-Tree}} [[Category:R-tree]] [[Category:Database index techniques]]</text> </page> <page> <id>22820</id> <title>M32R</title> <text>{{Infobox CPU architecture | name = M32R | designer = [[Renesas Technology]] | bits = 32 | introduced = 1997 | version = | design = RISC | type = | encoding = Fixed, 16- or 32-bit | branching = | endianness = Bi | extensions = | open = | registers = 16× 32-bit integer registers }} The '''M32R''' is a 32-bit [[Reduced instruction set computer|RISC]] [[instruction set architecture]] (ISA) developed by [[Mitsubishi]] for embedded [[microprocessor]]s and [[microcontroller]]s. The ISA is now owned by [[Renesas Electronics Corporation]], and the company designs and fabricates M32R implementations. M32R processors are used in [[embedded system]]s such as Engine Control Units, [[digital camera]]s and PDAs. The ISA is supported by [[Linux]] and the [[GNU Compiler Collection]]. ==External links== * [http://eu.renesas.com/fmwk.jsp?cnt=m32r_family_landing.jsp&fp=/products/mpumcu/m32r_family/ M32R homepage] * [http://www.linux-m32r.org Linux/M32R homepage] * [http://www.cqpub.co.jp/eda/blanca/ Interface (CQ Publishing Co.,Ltd.)] {{compu-hardware-stub}} {{RISC-based processor architectures}} [[Category:1997 introductions]] [[Category:Instruction set architectures]] [[ja:M32R]]</text> </page> <page> <id>22822</id> <title>M50734SP</title> <text>{{Context|date=October 2009}} The m50734 is a high-performance 8-bit single-chip CMOS microcontroller that is fully compatible with Mitsubishi's Series 740 family. This ROM/RAM-less device includes an array of on-chip functions such as UART, Serial I/O, A/D, Watchdog timer, VCU, 32parallel I/O ports. A choice of 8 and 16-bit timers to manage real time tasks. The instruction set of M50734 is upward compatible with the 6502 microprocessor. Incorporated into this particular IC are the following; * Enhanced [[MOS Technology 6502|6502]] processor * 24 input/output (I/O) lines * Four Analogue to Digital (A/D) converters * Universal Asynchronous Receiver/Transmitter ([[UART]]) * High-speed 