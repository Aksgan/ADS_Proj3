name="HP_Labs"/> The basis for the research was [[Very long instruction word|VLIW]], in which multiple operations are encoded in every instruction, and then processed by multiple execution units. One goal of EPIC was to move the complexity of instruction scheduling from the CPU hardware to the software compiler, which can do the instruction scheduling statically (with help of trace feedback information). This eliminates the need for complex scheduling circuitry in the CPU, which frees up space and power for other functions, including additional execution resources. An equally important goal was to further exploit [[instruction level parallelism]] (''ILP''), by using the compiler to find and exploit additional opportunities for [[parallel computing|parallel execution]]. ''VLIW'' (at least the original forms) has several short-comings that precluded it from becoming mainstream: * VLIW [[instruction set]]s are not [[backward compatibility|backward compatible]] between implementations. When wider implementations (more [[execution unit]]s) are built, the instruction set for the wider machines is not backward compatible with older, narrower implementations. * Load responses from a memory hierarchy which includes [[CPU cache]]s and [[DRAM]] do not have a deterministic delay. This makes static scheduling of load instructions by the compiler very difficult. ==Moving beyond VLIW== ''EPIC'' architectures add several features to get around the deficiencies of VLIW: * Each group of multiple software instructions is called a ''bundle''. Each of the bundles has a [[stop bit]] indicating if this set of operations is depended upon by the subsequent bundle. With this capability, future implementations can be built to issue multiple bundles in parallel. The dependency information is calculated by the compiler, so the hardware does not have to perform operand dependency checking. * A software prefetch instruction is used as a type of data prefetch. This prefetch increases the chances for a cache hit for loads, and can indicate the degree of temporal locality needed in various levels of the cache. * A speculative load instruction is used to speculatively load data before it is known whether it will be used (bypassing control dependencies), or whether it will be modified before it is used (bypassing data dependencies). * A check load instruction aids speculative loads by checking whether a speculative load was dependent on a later store, and thus must be reloaded. The ''EPIC'' architecture also includes a ''grab-bag'' of architectural concepts to increase ''ILP'': * [[Branch predication|Predicated execution]] is used to decrease the occurrence of branches and to increase the [[speculative execution]] of instructions. In this feature, branch conditions are converted to predicate registers which are used to kill results of executed instructions from the side of the branch which is not taken. * Delayed exceptions, using a [[Not a thing (computing)|not a thing]] bit within the general purpose registers, allow speculative execution past possible exceptions. * Very large architectural [[register file]]s avoid the need for [[register renaming]]. * Multi-way branch instructions improve branch prediction by combining many alternative branches into one bundle. The [[Itanium]] architecture also added register renaming<ref name="anand"/> and [[rotating register file]]s, a tool useful for [[software pipelining]] since it avoids having to manually [[Loop unrolling|unroll]] and rename registers. ==Other research and development== There have been other investigations into EPIC architectures that are not directly tied to the development of the Itanium architecture. *The [[Impact (research group)|IMPACT]] project at [[University of Illinois at Urbana-Champaign]], led by [[Wen-mei Hwu]], was the source of much influential research on this topic. *The [[PlayDoh]] architecture from HP-labs was another major research project. *[[Gelato Federation|Gelato]] is an open source development community in which academic and commercial researchers are working to develop more effective compilers for Linux applications running on Itanium servers. ==See also== *[[Complex instruction set computer]] (CISC) *[[Reduced instruction set computer]] (RISC) *[[Very long instruction word]] (VLIW) *[[Elbrus (computer)|Russian processors "Elbrus"]] ==References== {{reflist}} ==External links== * [http://www.cs.clemson.edu/~mark/epic.html Historical background for EPIC] * Mark Smotherman (2002) "[http://www.cs.clemson.edu/~mark/464/acmse_epic.pdf Understanding EPIC Architectures and Implementations]" {{CPU technologies}} {{DEFAULTSORT:Explicitly Parallel Instruction Computing}} [[Category:Instruction processing]] [[de:Explicitly Parallel Instruction Computing]] [[es:EPIC (informática)]] [[fr:Explicitly Parallel Instruction Computing]] [[it:Explicitly Parallel Instruction Computing]] [[ja:EPICアーキテクチャ]] [[ru:EPIC (архитектура микропроцессора)]] [[tr:EPIC]] [[zh:EPIC]]</text> </page> <page> <id>12860</id> <title>Exploratory search</title> <text>'''Exploratory search''' is a specialization of information exploration which represents the activities carried out by searchers who are either:<nowiki>[1]</nowiki> * a) unfamiliar with the domain of their goal (ie need to learn about the topic in order to understand how to achieve their goal) * b) unsure about the ways to achieve their goals (either the technology or the process) * c) or even unsure about their goals in the first place. Consequently, exploratory search covers a broader class of activities than typical [[information retrieval]], such as investigating, evaluating, comparing, and synthesizing, where new information is sought in a defined conceptual area; [[exploratory data analysis]] is another example of an information exploration activity. Typically, therefore, such users generally combine querying and browsing strategies to foster learning and investigation. ==History== Exploratory search is a topic that has grown from the fields of [[information retrieval]] and [[information seeking]] but has become more concerned with alternatives to the kind of search that has received the majority of focus (returning the most relevant documents to a [[Google]]-like keyword search). The research is motivated by questions like "what if the user doesn't know which keywords to use?" or "what if the user isn't looking for a single answer?" Consequently, research has begin to focus on defining the broader set of ''information behaviors'' in order to learn about the situations when a user is, or feels, limited by only having the ability to perform a keyword search. In the last few years, a series of workshops have been held at various related and key events. In 2005, the [http://research.microsoft.com/~ryenw/xsi/index.html Exploratory Search Interfaces workshop] focused on beginning to define some of the key challenges in the field. Since then a series of other workshops have been held at related conferences: [http://research.microsoft.com/~ryenw/eess/index.html Evaluating Exploratory Search] at [http://www.sigir2006.org SIGIR06] and [http://research.microsoft.com/~ryenw/esi/index.html Exploratory Search and HCI] at [http://www.chi2007.org CHI07] (in order to meet with the experts in [[human–computer interaction]]). In March 2008, an [http://www.sciencedirect.com/science/journal/03064573 ''Information Processing and Management'' 