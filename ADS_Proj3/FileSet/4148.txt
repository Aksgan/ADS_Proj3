for optimizing the use of other algorithms (such as [[search algorithm|search]] and [[merge algorithm|merge]] algorithms) that require sorted lists to work correctly; it is also often useful for [[Canonicalization|canonicalizing]] data and for producing human-readable output. More formally, the output must satisfy two conditions: # The output is in nondecreasing order (each element is no smaller than the previous element according to the desired [[total order]]); # The output is a [[permutation]], or reordering, of the input. Since the dawn of computing, the sorting problem has attracted a great deal of research, perhaps due to the complexity of solving it efficiently despite its simple, familiar statement. For example, [[bubble sort]] was analyzed as early as 1956.<ref>Demuth, H. Electronic Data Sorting. PhD thesis, Stanford University, 1956.</ref> Although many consider it a solved problem, useful new sorting algorithms are still being invented (for example, [[library sort]] was first published in 2004). Sorting algorithms are prevalent in introductory computer science classes, where the abundance of algorithms for the problem provides a gentle introduction to a variety of core algorithm concepts, such as [[big O notation]], [[divide and conquer algorithm]]s, [[data structure]]s, [[randomized algorithm]]s, [[best, worst and average case]] analysis, [[time-space tradeoff]]s, and lower bounds. == Classification ==<!-- This section is linked from [[Merge sort]] --> Sorting algorithms used in [[computer science]] are often classified by: * [[Computational complexity theory|Computational complexity]] ([[Worst-case performance|worst]], [[Average performance|average]] and [[Best-case performance|best]] behaviour) of element comparisons in terms of the size of the list <math>\left( n \right)</math>. For typical sorting algorithms good behavior is [[Big O notation|<math>\mathcal{O}</math>]]<math>\left( n \log n\right)</math> and bad behavior is <math>\mathcal{O}\left( n^2 \right)</math>. (See [[Big O notation]].) Ideal behavior for a sort is <math>\mathcal{O}\left( n \right)</math>, but this is not possible in the average case. [[Comparison sort|Comparison-based sorting algorithms]], which evaluate the elements of the list via an abstract key comparison operation, need at least <math>\mathcal{O}\left( n \log n\right)</math> comparisons for most inputs. * [[Computational complexity theory|Computational complexity]] of swaps (for "in place" algorithms). * Memory usage (and use of other computer resources). In particular, some sorting algorithms are "[[In-place algorithm|in place]]". This means that they need only <math>\mathcal{O}(1)</math> or <math>\mathcal{O}(\log n)</math> memory beyond the items being sorted and they don't need to create auxiliary locations for data to be temporarily stored, as in other sorting algorithms. * Recursion. Some algorithms are either recursive or non-recursive, while others may be both (e.g., merge sort). * Stability: '''stable sorting algorithms''' maintain the relative order of records with equal keys (i.e., values). See below for more information. * Whether or not they are a [[comparison sort]]. A comparison sort examines the data only by comparing two elements with a comparison operator. * General method: insertion, exchange, selection, merging, ''etc.''. Exchange sorts include bubble sort and quicksort. Selection sorts include shaker sort and heapsort. * Adaptability: Whether or not the presortedness of the input affects the running time. Algorithms that take this into account are known to be [[Adaptive sort|adaptive]]. ==== Stability ==== Stable sorting algorithms maintain the relative order of records with equal keys. If all keys are different then this distinction is not necessary. But if there are equal keys, then a sorting algorithm is stable if whenever there are two records (let's say R and S) with the same key, and R appears before S in the original list, then R will always appear before S in the sorted list. When equal elements are indistinguishable, such as with integers, or more generally, any data where the entire element is the key, stability is not an issue. However, assume that the following pairs of numbers are to be sorted by their first component: (4, 2) (3, 7) (3, 1) (5, 6) In this case, two different results are possible, one which maintains the relative order of records with equal keys, and one which does not: (3, 7) (3, 1) (4, 2) (5, 6) (order maintained) (3, 1) (3, 7) (4, 2) (5, 6) (order changed) Unstable sorting algorithms may change the relative order of records with equal keys, but stable sorting algorithms never do so. Unstable sorting algorithms can be specially implemented to be stable. One way of doing this is to artificially extend the key comparison, so that comparisons between two objects with otherwise equal keys are decided using the order of the entries in the original data order as a tie-breaker. Remembering this order, however, often involves an additional [[computational complexity theory|computational cost]]. Sorting based on a primary, secondary, tertiary, etc. sort key can be done by any sorting method, taking all sort keys into account in comparisons (in other words, using a single composite sort key). If a sorting method is stable, it is also possible to sort multiple times, each time with one sort key. In that case the keys need to be applied in order of increasing priority. Example: sorting pairs of numbers as above by second, then first component: (4, 2) (3, 7) (3, 1) (5, 6) (original) (3, 1) (4, 2) (5, 6) (3, 7) (after sorting by second component) (3, 1) (3, 7) (4, 2) (5, 6) (after sorting by first component) On the other hand: (3, 7) (3, 1) (4, 2) (5, 6) (after sorting by first component) (3, 1) (4, 2) (5, 6) (3, 7) (after sorting by second component, order by first component is disrupted). == Comparison of algorithms == [[File:SortingAlgoComp.png|right|thumb|The complexity of different algorithms in a specific situation.]] In this table, ''n'' is the number of records to be sorted. The columns "Average" and "Worst" give the time complexity in each case, under the assumption that the length of each key is constant, and that therefore all comparisons, swaps, and other needed operations can proceed in constant time. "Memory" denotes the amount of auxiliary storage needed beyond that used by the list itself, under the same assumption. These are all [[comparison sort]]s. The run-time and the memory of algorithms could be measured using various notations like theta, sigma, Big-O, small-o, etc. The memory and 