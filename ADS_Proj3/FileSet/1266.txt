Principles | publisher = [[Taylor & Francis]] | year = 2010 | isbn = 9780824740993 }}</ref> In fact, Dijkstra's explanation of the logic behind the algorithm,<ref>{{harvnb|Dijkstra|1959|p=270}}</ref> namely {{quote| '''Problem 2.''' Find the path of minimum total length between two given nodes <math>P</math> and <math>Q</math>. We use the fact that, if <math>R</math> is a node on the minimal path from <math>P</math> to <math>Q</math>, knowledge of the latter implies the knowledge of the minimal path from <math>P</math> to <math>R</math>. }} is a paraphrasing of [[Richard Bellman|Bellman's]] famous [[Principle of Optimality]] in the context of the [[shortest path problem]]. === Fibonacci sequence === Here is a na&iuml;ve implementation of a function finding the ''n''th member of the [[Fibonacci sequence]], based directly on the mathematical definition: '''function''' fib(n) '''if''' n = 0 '''return''' 0 '''if''' n = 1 '''return''' 1 '''return''' fib(n − 1) + fib(n − 2) Notice that if we call, say, <code>fib(5)</code>, we produce a call tree that calls the function on the same value many different times: # <code>fib(5)</code> # <code>fib(4) + fib(3)</code> # <code>(fib(3) + fib(2)) + (fib(2) + fib(1))</code> # <code>((fib(2) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))</code> # <code>(((fib(1) + fib(0)) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))</code> In particular, <code>fib(2)</code> was calculated three times from scratch. In larger examples, many more values of <code>fib</code>, or ''subproblems'', are recalculated, leading to an exponential time algorithm. Now, suppose we have a simple [[Associative array|map]] object, ''m'', which maps each value of <code>fib</code> that has already been calculated to its result, and we modify our function to use it and update it. The resulting function requires only [[Big-O notation|O]](''n'') time instead of exponential time: '''var''' m := '''map'''(0 → 0, 1 → 1) '''function''' fib(n) '''if''' '''map''' m '''does not contain key''' n m[n] := fib(n − 1) + fib(n − 2) '''return''' m[n] This technique of saving values that have already been calculated is called ''[[memoization]]''; <!-- Yes, memoization, not memorization. Not a typo. --> this is the top-down approach, since we first break the problem into subproblems and then calculate and store values. In the '''bottom-up''' approach we calculate the smaller values of <code>fib</code> first, then build larger values from them. This method also uses O(''n'') time since it contains a loop that repeats n − 1 times, however it only takes constant (O(1)) space, in contrast to the top-down approach which requires O(''n'') space to store the map. '''function''' fib(n) '''var''' previousFib := 0, currentFib := 1 '''if''' n = 0 '''return''' 0 '''else if''' n = 1 '''return''' 1 '''repeat''' n − 1 '''times''' '''var''' newFib := previousFib + currentFib previousFib := currentFib currentFib := newFib '''return''' currentFib In both these examples, we only calculate <code>fib(2)</code> one time, and then use it to calculate both <code>fib(4)</code> and <code>fib(3)</code>, instead of computing it every time either of them is evaluated. (Note the calculation of the Fibonacci sequence is used to demonstrate dynamic programming. An O(''1'') formula exists from which an arbitrary term can be calculated, which is more efficient than any dynamic programming technique.) === A type of balanced 0-1 matrix === Consider the problem of assigning values, either zero or one, to the positions of an {{math|<var>n</var> &times; <var>n</var>}} matrix, {{math|<var>n</var>}} even, so that each row and each column contains exactly {{math|<var>n</var> / 2}} zeros and {{math|<var>n</var> / 2}} ones. For example, when {{math|<var>n</var> {{=}} 4}}, four possible solutions are :<math>\begin{bmatrix} 0 & 1 & 0 & 1 \\ 1 & 0 & 1 & 0 \\ 0 & 1 & 0 & 1 \\ 1 & 0 & 1 & 0 \end{bmatrix} \text{ and } \begin{bmatrix} 0 & 0 & 1 & 1 \\ 0 & 0 & 1 & 1 \\ 1 & 1 & 0 & 0 \\ 1 & 1 & 0 & 0 \end{bmatrix} \text{ and } \begin{bmatrix} 1 & 1 & 0 & 0 \\ 0 & 0 & 1 & 1 \\ 1 & 1 & 0 & 0 \\ 0 & 0 & 1 & 1 \end{bmatrix} \text{ and } \begin{bmatrix} 1 & 0 & 0 & 1 \\ 0 & 1 & 1 & 0 \\ 0 & 1 & 1 & 0 \\ 1 & 0 & 0 & 1 \end{bmatrix}.</math> We ask how many different assignments there are for a given <math>n</math>. There are at least three possible approaches: [[Brute-force search|brute force]], [[backtracking]], and dynamic programming. Brute force consists of checking all assignments of zeros and ones and counting those that have balanced rows and columns (<math>n/2</math> zeros and <math>n/2</math> ones). As there are <math>\tbinom{n}{n/2}^n</math> possible assignments, this strategy is not practical except maybe up to <math>n=6</math>. Backtracking for this problem consists of choosing some order of the matrix elements and recursively placing ones or zeros, while checking that in every row and column the number of elements that have not been assigned plus the number of ones or zeros are both at least ''n / 2''. While more sophisticated than brute force, this approach will visit every solution once, making it impractical for ''n'' larger than six, since the number of solutions is already 116963796250 for ''n = 8'', as we shall see. Dynamic programming makes it possible to count the number of solutions without visiting them all. We consider {{math|<var>k</var> &times; <var>n</var>}} boards, where {{math|1 &le; <var>k</var> &le; <var>n</var>}}, whose <math>k</math> rows contain <math>n/2</math> zeros and <math>n/2</math> ones. The function ''f'' to which [[memoization]] is applied maps vectors of ''n'' pairs of integers to the number of admissible boards (solutions). There is one pair for each column and its two components indicate respectively the number of ones and zeros that have yet to be placed in that column. We seek the value of <math> f((n/2, n/2), (n/2, n/2), \ldots (n/2, n/2)) </math> (<math>n</math> arguments or one vector of <math>n</math> elements). The process of subproblem creation involves iterating over every one of <math>\tbinom{n}{n/2}</math> possible assignments for the top row of the board, and 