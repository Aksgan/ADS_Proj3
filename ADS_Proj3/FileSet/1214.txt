the values (reflecting location), it has an error of <math>1/2</math> for the other values. This illustrates the kinds of trade-offs between these transforms, and how in some respects the DWT provides preferable behavior, particularly for the modeling of transients, which is of interest in applications. == Definition == === One level of the transform === The DWT of a signal <math>x</math> is calculated by passing it through a series of filters. First the samples are passed through a [[low pass filter]] with [[impulse response]] <math>g</math> resulting in a [[convolution]] of the two: :<math>y[n] = (x * g)[n] = \sum\limits_{k = - \infty }^\infty {x[k] g[n - k]}. </math> The signal is also decomposed simultaneously using a [[high-pass filter]] <math>h</math>. The outputs giving the detail coefficients (from the high-pass filter) and approximation coefficients (from the low-pass). It is important that the two filters are related to each other and they are known as a [[quadrature mirror filter]]. However, since half the frequencies of the signal have now been removed, half the samples can be discarded according to Nyquist’s rule. The filter outputs are then [[subsampling|subsampled]] by 2 (Mallat's and the common notation is the opposite, g- high pass and h- low pass): :<math>y_{\mathrm{low}} [n] = \sum\limits_{k = - \infty }^\infty {x[k] g[2 n - k]} </math> :<math>y_{\mathrm{high}} [n] = \sum\limits_{k = - \infty }^\infty {x[k] h[2 n - k]} </math> This decomposition has halved the time resolution since only half of each filter output characterises the signal. However, each output has half the frequency band of the input so the frequency resolution has been doubled. [[Image:Wavelets - DWT.png|frame|none|Block diagram of filter analysis]] With the [[subsampling]] operator <math>\downarrow</math> :<math>(y \downarrow k)[n] = y[k n] </math> the above summation can be written more concisely. :<math>y_{\mathrm{low}} = (x*g)\downarrow 2 </math> :<math>y_{\mathrm{high}} = (x*h)\downarrow 2 </math> However computing a complete convolution <math>x*g</math> with subsequent downsampling would waste computation time. The [[Lifting scheme]] is an optimization where these two computations are interleaved. === Cascading and Filter banks === This decomposition is repeated to further increase the frequency resolution and the approximation coefficients decomposed with high and low pass filters and then down-sampled. This is represented as a binary tree with nodes representing a sub-space with a different time-frequency localisation. The tree is known as a [[filter bank]]. [[Image:Wavelets - Filter Bank.png|frame|none|A 3 level filter bank]] At each level in the above diagram the signal is decomposed into low and high frequencies. Due to the decomposition process the input signal must be a multiple of <math>2^n</math> where <math>n</math> is the number of levels. For example a signal with 32 samples, frequency range 0 to <math>f_n</math> and 3 levels of decomposition, 4 output scales are produced: {| class="wikitable" ! Level ! Frequencies ! Samples |- | rowspan="2" | 3 | <math>0</math> to <math>{{f_n}}/8</math> | 4 |- | <math>{{f_n}}/8</math> to <math>{{f_n}}/4</math> | 4 |- | 2 | <math>{{f_n}}/4</math> to <math>{{f_n}}/2</math> | 8 |- | 1 | <math>{{f_n}}/2</math> to <math>f_n</math> | 16 |} [[Image:Wavelets - DWT Freq.png|frame|none|Frequency domain representation of the DWT]] == Other transforms == {{see also|Adam7 algorithm}} The [[Adam7 algorithm]], used for [[Interlacing (bitmaps)|interlacing]] in the [[Portable Network Graphics]] (PNG) format, is a multiscale model of the data which is similar to a DWT with [[Haar wavelet]]s. Unlike the DWT, it has a specific scale – it starts from an 8×8 block, and it [[downsample]]s the image, rather than [[decimation (signal processing)|decimating]] ([[low-pass filter]]ing, then downsampling). It thus offers worse frequency behavior, showing artifacts ([[pixelation]]) at the early stages, in return for simpler implementation. == Code examples == In its simplest form, the DWT is remarkably easy to compute. The [[Haar wavelet]] in [[Java (programming language)|Java]]: <source lang=java> public static int[] invoke(int[] input) { //This function assumes input.length=2^n, n>1 int[] output = new int[input.length]; for (int length = input.length >> 1; ; length >>= 1) { //length=input.length/2^n, WITH n INCREASING to log(input.length)/log(2) for (int i = 0; i < length; i++) { int sum = input[i*2]+input[i*2+1]; int difference = input[i*2]-input[i*2+1]; output[i] = sum; output[length+i] = difference; } if (length == 1) return output; //Swap arrays to do next iteration System.arraycopy(output, 0, input, 0, length<<1); } } </source> A complete Java code for a 1-D and 2-D DWT using [[Haar wavelet|Haar]], [[Daubechies wavelet|Daubechies]], [[Coiflet]], and [[Legendre wavelet|Legendre]] wavelets is available from the open source project: [http://code.google.com/p/jwave/ JWave]. Furthermore, a fast lifting implementation of the discrete biorthogonal [[Cohen-Daubechies-Feauveau wavelet|CDF]] 9/7 wavelet transform in [[C (programming language)|C]], used in the [[JPEG 2000]] image compression standard can be found [http://www.embl.de/~gpau/misc/dwt97.c here]. ==See also== * [[Wavelet series]] * [[Wavelet compression]] * [[List of wavelet-related transforms]] ==Notes== {{reflist|group=note}} ==References== *Stéphane Mallat, [http://books.google.com/books?vid=ISBN012466606X&id=yW2kut44AsMC&dq=Wavelet+tour+of+signal+processing A Wavelet Tour of Signal Processing] {{DEFAULTSORT:Discrete Wavelet Transform}} [[Category:Numerical analysis]] [[Category:Signal processing]] [[Category:Wavelets]] [[Category:Articles with example Java code]] [[Category:Transforms]] [[ca:Transformada discreta d'ondeta]] [[cs:Diskrétní vlnková transformace]] [[de:Wavelet-Transformation#Diskrete Wavelet-Transformation]] [[fa:تبدیل موجک گسسته]] [[fr:Transformée en ondelettes discrète]] [[ja:離散ウェーブレット変換]] [[pt:Transformada discreta de wavelet]] [[ru:Дискретное вейвлет-преобразование]] [[zh:離散小波變換]]</text> </page> <page> <id>10672</id> <title>Discretionary access control</title> <text>{{Cleanup|date=January 2008}} In [[computer security]], '''discretionary access control''' ('''DAC''') is a kind of [[access control]] defined by the [[Trusted Computer System Evaluation Criteria]]<ref> {{ cite book | title = Trusted Computer System Evaluation Criteria | publisher = United States Department of Defense | date = December 1985 | url = http://www.radium.ncsc.mil/tpep/library/rainbow/5200.28-STD.html | id = DoD Standard 5200.28-STD }}</ref> "as a means of restricting access to objects based on the identity of subjects and/or groups to which they belong. The controls are [[wikt:discretionary|discretionary]] in the sense that a subject with a certain access permission is capable of passing that permission (perhaps indirectly) on to any other subject (unless restrained by [[mandatory access control]])". Discretionary access control is commonly defined in opposition to [[mandatory access control]] (sometimes termed ''non-discretionary access control''). Occasionally a system as a whole is said to have "discretionary" or "purely discretionary" access control as a way of saying that the system lacks mandatory access control. On the other hand, systems can be said to implement both MAC and DAC simultaneously, where DAC refers to one category of access controls that subjects 