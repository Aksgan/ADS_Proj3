if the successor component meets the requirements of the initial component (expressed via the interfaces). Consequently, components can be replaced with either an updated version or an alternative without breaking the system in which the component operates. As a general rule of thumb for engineers substituting components, component B can immediately replace component A if component B provides at least what component A provided, and uses no more than what component A used. Software components often take the form of [[object (computing)|objects]] (not [[Class (computer science)|classes]]) or collections of objects (from [[object-oriented programming]]), in some binary or textual form, adhering to some [[interface description language]] (IDL) so that the component may exist autonomously from other components in a [[computer]]. When a component is to be accessed or shared across execution contexts or network links, techniques such as [[serialization]] or [[marshalling (computer science)|marshalling]] are often employed to deliver the component to its destination. [[Reusability]] is an important characteristic of a high-quality software component. Programmers should design and implement software components in such a way that many different programs can reuse them. Furthermore, [[Component-Based Usability Testing|component-based usability testing]] should be considered when software components directly interact with users. It takes significant effort and awareness to write a software component that is effectively reusable. The component needs to be: * fully documented * thoroughly tested ** robust - with comprehensive input-validity checking ** able to pass back appropriate [[error message]]s or return codes * designed with an awareness that it ''will'' be put to unforeseen uses In the 1960s, programmers built scientific [[subroutine]] libraries that were reusable in a broad array of engineering and scientific applications. Though these subroutine libraries reused well-defined [[algorithms]] in an effective manner, they had a limited domain of application. Commercial sites routinely created application programs from reusable modules written in [[Assembly language|Assembler]], [[COBOL]], [[PL/1]] and other [[second generation language|second-]] and [[third generation language|third-generation languages]] using both [[operating system|System]] and user application libraries. {{As of | 2010}}, modern reusable components encapsulate both data structures and the algorithms that are applied to the data structures. It{{Clarify|date=February 2010}} builds on prior theories of [[object (object-oriented programming)|software objects]], [[software architecture]]s, [[software framework]]s and [[software design pattern]]s, and the extensive theory of [[object-oriented programming]] and the [[object oriented design]] of all these. It claims that software components, like the idea of hardware [[electronic component|components]], used for example in telecommunications, can ultimately be made interchangeable and reliable. On the other hand, it is argued that it is a mistake to focus on independent components rather than the framework (without which they would not exist).<ref> [http://existentialprogramming.blogspot.com/search/label/components "There is no such thing as a Component", Bruce Wallace, Existential Programming, June, 2000]</ref> ==History== <!-- Commented out because image was deleted: [[Image:Software components lecture large.jpg|thumb|left|250px|Douglas McIlroy's historic lecture on software components at the NATO conference in Garmisch, Germany (1968). {{deletable image-caption}}]] --> The idea that [[software]] should be componentized - built from prefabricated ''components'' - first became prominent with [[Douglas McIlroy]]'s address at the [[NATO]] conference on [[software engineering]] in [[Garmisch-Partenkirchen|Garmisch]], [[Germany]], 1968,<!-- The practice of modular programming existed before 1968 I am certain --> titled ''Mass Produced Software Components''. The conference set out to counter the so-called [[software crisis]]. McIlroy's subsequent inclusion of [[pipes and filters]] into the [[Unix]] [[operating system]] was the first implementation of an infrastructure for this idea. [[Brad Cox]] of [[Stepstone]] largely defined the modern concept of a software component{{Citation needed|date=February 2010}}. He called them ''Software ICs'' and set out to create an infrastructure and market for these components by inventing the [[Objective-C]] programming language. (He summarizes this view in his book ''Object-Oriented Programming - An Evolutionary Approach'' 1986.) [[IBM]] led the path{{Citation needed|date=February 2010}} with their [[System Object Model|System Object Model (SOM)]] in the early 1990s.<!-- IBM built System/360 operating systems and language compilers from many component modules, both binary and source both statically linked and dynamically loaded--> Some{{Who|date=February 2010}} claim that [[Microsoft]] paved the way for actual deployment of component software with [[Object linking and embedding|OLE]] and [[Component Object Model|COM]]. {{As of | 2010}} many successful software component models exist. ==Differences from object-oriented programming== Proponents of [[object-oriented programming]] (OOP) maintain that software should be written according to a mental model of the actual or imagined objects it represents. OOP and the related disciplines of [[object-oriented design]] and [[object-oriented analysis]] focus on modeling real-world{{Citation needed|date=January 2009}} interactions and attempting to create "verbs" and "nouns" which can be used in more human-readable ways, ideally by end users as well as by programmers coding for those end users. Component-based software engineering, by contrast, makes no such assumptions, and instead states that developers should construct software by gluing together prefabricated components - much like in the fields of [[electronics]] or [[mechanics]]. Some peers{{Who|date=January 2009}} will even talk of modularizing systems as software components as a new [[programming paradigm]]. Some{{Who|date=October 2009}} argue that earlier [[computer scientist]]s made this distinction, with [[Donald Knuth]]'s theory of "[[literate programming]]" optimistically assuming there was convergence between intuitive and formal models, and [[Edsger Dijkstra]]'s theory in the article ''[[The Cruelty of Really Teaching Computer Science]]'', which stated that programming was simply, and only, a branch of [[mathematics]].{{Citation needed|date=October 2009}} In both forms, this notion has led to many academic debates{{Weasel-inline|date=October 2009}} about the pros and cons of the two approaches and possible strategies for uniting the two. Some{{Who|date=October 2009}} consider the different strategies not as competitors, but as descriptions of the same problem from different points of view.{{Citation needed|date=October 2009}} ==Architecture== <!-- What about simple programs composed of modules for starters? etc etc. Why jump to servers as examples of module use?--> A computer running several software components is often called an [[application server]]. Using this combination of application servers and software components is usually called [[distributed computing]]. The usual real-world application of this is in e.g. financial applications or business software. ==Technologies== * [[Pipeline (software)|Pipes and Filters]] ** [[Unix]] [[operating system]] * Component-oriented programming ** [[SOFA component system]] [http://sofa.ow2.org] from [http://www.objectweb.org ObjectWeb] ** [[Fractal component model]] [http://fractal.ow2.org/] from [http://www.objectweb.org ObjectWeb] 