An output function (Input x State -> Output) * A distinguished State called Start. A State Machine begins at the State labeled Start. Each Input received is passed through the transition and output function to produce a new State and an Output. The State is held stable until a new Input is received, while the Output is communicated to the appropriate receiver. It should be clear that any algorithm can be implemented using this model if driven by an appropriate Input stream. In particular, this discussion requires a State Machine to have the following property: :'''Deterministic:''' :Multiple copies of the same State Machine begun in the Start state, and receiving the same Inputs in the same order will arrive at the same State having generated the same Outputs. ===Fault Tolerance Explained=== Determinism is an ideal characteristic for providing fault-tolerance. Intuitively, if multiple copies of a system exist, a fault in one would be noticeable as a difference in the State or Output from the others. A little deduction shows the minimum number of copies needed for fault-tolerance is three; one which has a fault, and two others to whom we compare State and Output. Two copies is not enough; there is no way to tell which copy is the faulty one. Further deduction shows a three-copy system can support at most one failure (after which it must repair or replace the faulty copy). If more than one of the copies were to fail, all three States and Outputs might differ, and there would be no way to choose which is the correct one. Research has shown <ref name=lowerbounds>{{cite web|curly=yes|last=Lamport|first=Leslie|year=2004|title=Lower Bounds for Asynchronous Consensus|url=http://research.microsoft.com/users/lamport/pubs/pubs.html#lower-bound}}</ref> that in general a system which supports F failures must have 2F+1 copies (also called replicas). The extra copies are used as evidence to decide which of the copies are correct and which are faulty. Special cases can improve these bounds <ref name=cheap>{{cite journal|curly=yes|last=Lamport|first=Leslie|coauthors=Mike Massa|year=2004|title=Cheap Paxos|journal=Proceedings of the International Conference on Dependable Systems and Networks (DSN 2004)|url=http://research.microsoft.com/users/lamport/pubs/pubs.html#web-dsn-submission}}</ref>. All of this deduction pre-supposes that replicas are experiencing only random independent faults such as memory errors or hard-drive crash. Failures caused by replicas which attempt to lie, deceive, or collude can also be handled by the State Machine Approach, with isolated changes. It should be noted that failed replicas are not required to stop; they may continue operating, including generating spurious or incorrect Outputs. ====Special Case: Fail-Stop==== Theoretically, if a failed replica is guaranteed to stop without generating outputs, only F+1 replicas are required, and clients may accept the first output generated by the system. No existing systems achieve this limit, but it is often used when analyzing systems built on top of a fault-tolerant layer (Since the fault-tolerant layer provides fail-stop semantics to all layers above it). ====Special Case: Byzantine Failure==== Faults where a replica sends different values in different directions (for instance, the correct Output to some of its fellow replicas and incorrect Outputs to others) are called Byzantine Failures <ref name=byzantine>{{cite journal|curly=yes|last=Lamport|first=Leslie|coauthors=Robert Shostak, Marshall Pease|year=1982|month=July|title=The Byzantine Generals Problem|journal=ACM Transactions on Programming Languages and Systems|volume=4|issue=3|pages=382–401|url=http://research.microsoft.com/users/lamport/pubs/pubs.html#byz|accessdate=2007-02-02|doi=10.1145/357172.357176}}</ref>. Byzantine failures may be random, spurious faults, or malicious, intelligent attacks. 2F+1 replicas, with non-cryptographic hashes suffices to survive all non-malicious Byzantine failures (with high probability). Malicious attacks require cryptographic primitives to achieve 2F+1 (using message signatures), or non-cryptographic techniques can be applied but the number of replicas must be increased to 3F+1. ==The State Machine Approach== The preceding intuitive discussion implies a simple technique for implementing a fault-tolerant service in terms of a State Machine: # Place copies of the State Machine on multiple, independent servers. # Receive client requests, interpreted as Inputs to the State Machine. # Choose an ordering for the Inputs. # Execute Inputs in the chosen order on each server. # Respond to clients with the Output from the State Machine. # Monitor replicas for differences in State or Output. The remainder of this article develops the details of this technique. * Step 1 and 2 are outside the scope of this article. * Step 3 is the critical operation, see [[#Ordering Inputs|Ordering Inputs]]. * Step 4 is covered by the [[#State Machine Definition|State Machine Definition]]. * Step 5, see [[#Sending Outputs|Ordering Outputs]]. * Step 6, see [[#Auditing and Failure Detection|Auditing and Failure Detection]]. The appendix contains discussion on typical extensions used in real-world systems such as [[#Logging|Logging]], [[#Checkpoints|Checkpoints]], [[#Reconfiguration|Reconfiguration]], and [[#State Transfer|State Transfer]]. ===Ordering Inputs=== The critical step in building a distributed system of State Machines is choosing an order for the Inputs to be processed. Since all non-faulty replicas will arrive at the same State and Output if given the same Inputs, it is imperative that the Inputs are submitted in an equivalent order at each replica. Many solutions have been proposed in the literature <ref name=reliable/><ref name=time>{{cite journal|curly=yes|last=Lamport|first=Leslie|year=1984|title=Using Time Instead of Timeout for Fault-Tolerant Distributed Systems|journal=ACM Transactions on Programming Languages and Systems|volume=6|issue=2|pages=254–280|url= http://research.microsoft.com/users/lamport/pubs/pubs.html#using-time|accessdate=2008-03-13|doi=10.1145/2993.2994}}</ref><ref name=paxos/><ref name=virtualsync>{{cite journal|curly=yes|last=Birman|first=Kenneth|coauthors=Thomas Joseph|year=1987|title=Exploiting virtual synchrony in distributed systems|journal= Proceedings of the 11th ACM Symposium on Operating systems principles (SOSP)|url=http://portal.acm.org/citation.cfm?id=37515&dl=ACM&coll=GUIDE|accessdate=2008-03-13|doi=10.1145/37499.37515|volume=21|pages=123}}</ref><ref name=lampson>{{cite web|curly=yes|last=Lampson|first=Butler|year=1996|title=How to Build a Highly Available System Using Consensus|url=http://research.microsoft.com/lampson/58-Consensus/Abstract.html|accessdate=2008-03-13}}</ref>. A '''Visible Channel''' is a communication path between two entities actively participating in the system (such as clients and servers). Example: client to server, server to server A '''Hidden Channel''' is a communication path which is not revealed to the system. Example: client to client channels are usually hidden; such as users communicating over a telephone, or a process writing files to disk which are read by another process. When all communication paths are visible channels and no hidden channels exist, a partial global order ('''Causal Order''') may be inferred from the pattern of communications <ref name=virtualsync/><ref name=clocks>{{cite journal|curly=yes|last=Lamport|first=Leslie|year=1978|month=July|title=Time, Clocks and the Ordering of Events in a Distributed System|journal=Communications of the ACM|volume=21|issue=7|pages=558–565|url=http://research.microsoft.com/users/lamport/pubs/pubs.html#time-clocks|accessdate=2007-02-02|doi=10.1145/359545.359563}}</ref>. Causal Order may be derived independently by each server. Inputs to the State Machine may be executed in Causal Order, guaranteeing consistent State and Output for all non-faulty replicas. In open systems, hidden channels are common and a weaker form of ordering must be used. An order of Inputs 