would write for run time evaluation (this example code is in the [[D programming language]]<ref>[http://www.digitalmars.com/d/1.0/function.html#interpretation D 1.0 language specification: Functions]</ref>): <source lang="D"> int factorial(int n) { if (n == 0) return 1; return n * factorial(n - 1); } // computed at compile time const int y = factorial(0); // == 1 const int x = factorial(4); // == 24 </source> The use of <code>const</code> tells the compiler that the initializer for the variables must be computed at compile time<ref>[http://www.digitalmars.com/d/1.0/attribute.html#const D 1.0 language specification: Attributes]</ref>. CTFE can be used to populate simple data structures at compile-time in a simple way (D version 2) (this is a function template): <source lang="D">int[N] genFactorials(int N)() { int[N] result; result[0] = 1; foreach (i; 1 .. N) result[i] = result[i - 1] * i; return result; } enum auto factorials = genFactorials!(13)(); // Now 'factorials' contains at compile-time: // [1, 1, 2, 6, 24, 120, 720, 5_040, 40_320, 362_880, 3_628_800, // 39_916_800, 479_001_600] </source> == References == <references/> [[Category:Compiler theory]]</text> </page> <page> <id>7275</id> <title>Complete (complexity)</title> <text>{{Citations missing|date=October 2008}} In [[computational complexity theory]], a [[computational problem]] is '''complete''' for a [[complexity class]] if it is, in a formal sense, one of the "hardest" or "most expressive" problems in the complexity class. If a problem has the property that it allows you to quickly solve any problem in a complexity class, it is called '''hard''' for that class. More formally, a problem ''p'' is called hard for a complexity class ''C'' under a given type of [[reduction (complexity)|reduction]], if there is a reduction of this type from any problem in ''C'' to ''p''. If a problem is both hard for a class, and a member of the class, it is complete for that class (under the given type of reduction). A problem that is complete for a class ''C'' is said to be '''C-complete''', and the class of all problems complete for ''C'' is denoted '''C-complete'''. The first complete class to be defined and the most well-known is [[NP-complete]], a class that contains many difficult-to-solve problems that arise in practice. Similarly, a problem hard for a class ''C'' is called '''C-hard''', e.g. [[NP-hard]]. Normally it is assumed that the reduction in question does not have higher computational complexity than the class itself. Therefore it may be said that if a ''C-complete'' problem has a "computationally easy" solution, then all problems in "C" have an "easy" solution. Generally, complexity classes that have a recursive enumeration have known complete problems, whereas those that do not, don't have any known complete problems. For example, [[NP (complexity)|NP]], [[co-NP]], [[PLS (complexity)|PLS]], [[PPA (complexity)|PPA]] all have known natural complete problems, while [[RP (complexity)|RP]], [[ZPP (complexity)|ZPP]], [[BPP]] and [[TFNP]] do not have any known complete problems (although such a problem may be discovered in the future).{{Fact|date=July 2008}} There are classes without complete problems. For example, Sipser showed that there is a language '''M''' such that '''BPP'''<sup>'''M'''</sup> ('''BPP''' with [[oracle machine|oracle]] '''M''') has no complete problems.<ref>M. Sipser. On relativization and the existence of complete sets, Proceedings of ICALP'82, Springer-Verlag Lecture Notes in Computer Science volume 140, pp. 523-531, 1982.</ref> == References == {{reflist}} [[Category:Computational complexity theory]] [[de:Vollständigkeit (Komplexitätstheorie)]] [[zh:完備 (複雜度)]]</text> </page> <page> <id>7276</id> <title>Complete active space</title> <text>{{Unreferenced stub|auto=yes|date=December 2009}} In [[quantum chemistry]], a '''complete active space''' is a type of classification of [[molecular orbitals]]. [[Spatial orbitals]] are classified as belonging to three classes: * ''core'', always hold two electrons * ''active'', partially occupied orbitals * ''virtual'', always hold zero electrons This classification allows to develop a set of [[Slater determinant]]s for the description of the [[wavefunction]] as a linear combination of these determinants. Based on the freedom left for the occupation in the active orbitals, a certain number of [[electrons]] are allowed to populate all the active orbitals in appropriate combinations, developing a finite-size space of determinants. The resulting wavefunction is of [[Multireference configuration interaction|multireference]] nature, and is blessed by additional properties if compared to other selection schemes. The active classification can theoretically be extended to all the molecular orbitals, to obtain a [[full CI]] treatment. In practice, this choice is limited, due to the high computational cost needed to optimize a large CAS wavefunction on medium and large molecular systems. A Complete Active Space wavefunction is used to obtain a first approximation of the so-called [[static correlation]], which represents the contribution needed to describe bond dissociation processes correctly. This requires a wavefunction that includes a set of electronic configurations with high and very similar importance. [[Dynamic correlation]], representing the contribution to the energy brought by the instantaneous interaction between electrons, is normally small and can be recovered with good accuracy by means of perturbative evaluations, such as [[CASPT2]] and [[NEVPT]]. ==See also== * [[Multi-configurational self-consistent field#Complete_Active_Space_SCF|CASSCF]] * [[Multi-configurational self-consistent field]] (MCSCF) * [[Multi-configurational self-consistent field#Restricted_Active_Space_SCF|RASSCF]] {{DEFAULTSORT:Complete Active Space}} [[Category:Quantum chemistry]] {{Chem-stub}} [[it:Complete active space]]</text> </page> <page> <id>7280</id> <title>Complete numbering</title> <text>In [[computability theory]] '''complete numberings''' are generalizations of [[Gödel numbering]] first introduced by [[A.I. Mal'tsev]] in 1963. They are studied because several important results like the [[Kleene's recursion theorem]] and [[Rice's theorem]], which were originally proven for the Gödel-numbered set of [[computable function]]s, still hold for arbitrary sets with complete numberings. == Definition == A [[numbering (computability theory)|numbering]] <math>\nu</math> of a set <math>A</math> is called '''complete''' (with respect to an element <math>a \in A</math>) if for every [[partial computable function]] <math>f</math> there exists a [[total computable function]] <math>h</math> so that :<math> \nu \circ h(i) = \left\{ \begin{matrix} \nu \circ f(i) &\mbox{if}\ i \in \mathrm{dom}(f), \\ a &\mbox{otherwise}. \end{matrix} \right. </math> The numbering <math>\nu</math> is called '''precomplete''' if :<math> \nu \circ f(i) = \nu \circ h(i) \qquad i \in \mathrm{dom}(f).\,</math> == Examples == * any numbering of a [[singleton set]] is complete * the [[identity function]] on the natural numbers is ''not'' complete * a [[gödel numbering]] is precomplete == References == * A.I. Mal'tsev, ''Sets with complete numberings''. [[Algebra i Logika]], 1963, vol. 2, no. 2, 4-29 (Russian) [[Category:Recursion theory]]</text> </page> <page> <id>7293</id> <title>Complex instruction set computing</title> <text>A '''complex instruction set computer''' ('''CISC''') ({{pron-en|ˈsɪsk}}), 