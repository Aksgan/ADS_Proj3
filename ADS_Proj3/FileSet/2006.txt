global warming] * [http://blog.hunch.com/?p=11554 And now for something lighter: Cookie Monster blows away #2 Oscar as a Hunch favorite] * [http://hunch.com/media/reports/nyt-bestsellers/ New York Times Bestsellers: A Hunch Topic Snapshot] * [http://hunch.com/media/reports/macpc/ Mac vs PC People: Personality Traits & Aesthetic/Media Choices] * [http://hunch.com/media/reports/food/ How Food Preferences Vary by Political Ideology] * [http://blog.hunch.com/?p=8414 Profile of a Hunch iPhone owner] * [http://blog.hunch.com/?p=7654 Does TV Make us Dumber-er?] == References == {{Reflist}} == External links == * {{official|http://hunch.com}} [[Category:Collaboration]] [[Category:Community websites]] [[Category:Knowledge markets]] [[Category:Social information processing]] [[Category:Internet properties established in 2009]] [[hu:Hunch.com]] [[pms:Hunch]]</text> </page> <page> <id>17100</id> <title>Hungarian Unix Portal</title> <text>{{Orphan|date=February 2009}} Since 2000 the '''Hungarian Unix Portal''' ('''HUP'''), founded by Gabor Micsko aka. ''[http://hup.hu/user/1 trey]'', is the largest [[Hungary|Hungarian]] [[Unix|UNIX]]/[[Linux]]/[[BSD]] system administrators' webpage. On this page you can read news, get help in the forum, discuss the news, etc. HUP's aim is to join with the Hungarian [[free software]] community. Members of HUP can discuss and resolve problems about *NIX systems. The main language of HUP is Hungarian, but we can also respond in English to your problems. HUP hosts the [http://wiki.hup.hu HupWiki], which is the most important [[wiki]] about free software and [[*NIX]] systems in Hungary. HupWiki consists of over 1000 articles and documentations. HUP (also known as: [http://portal.fsn.hu portal.fsn.hu]) has been associated with the [http://www.fsn.hu/?setlang=en Free Software Network] (aka FSN.hu) foundation. FSN's goal is to distribute free software, to help people and organizations using them and to provide infrastructural background and other services. The best known service of our project is the file server called [ftp://ftp.fsn.hu ftp.fsn.hu], which is Hungary's largest (by traffic), independent free software distribution point. Its biggest daily traffic was 875 GB so far. The services of the machine can be used by anyone 24 hours a day. == See also == *[[SIGHUP]]: terminal line hangup == External links == *[http://www.hup.hu/ HUP] *[http://wiki.hup.hu HupWiki] - Hup's WikiWiki page *[http://href.hu/x/alco More info about the owner] *[http://hup.hu/regisztracio Registration Page] [[Category:Unix]] [[Category:Linux websites]] [[hu:Hungarian UNIX Portal]]</text> </page> <page> <id>17101</id> <title>Hungarian algorithm</title> <text>The '''Hungarian method''' is a [[Optimization (mathematics)|combinatorial optimization]] [[algorithm]] which solves the [[assignment problem]] in polynomial time and which anticipated later [[primal-dual method]]s. It was developed and published by [[Harold Kuhn]] in 1955, who gave the name "Hungarian method" because the algorithm was largely based on the earlier works of two [[Hungary|Hungarian]] mathematicians: [[Dénes Kőnig]] and [[Jenő Egerváry]]. [[James Munkres]] reviewed the algorithm in 1957 and observed that it is [[Time complexity#Strongly_and_weakly_polynomial_time|(strongly) polynomial]]. Since then the algorithm has been known also as '''Kuhn-Munkres algorithm''' or '''Munkres assignment algorithm'''. The [[Computational_complexity_theory#Time_and_space_complexity|time complexity]] of the original algorithm was <math>O(n^4)</math>, however [[Jack Edmonds|Edmonds]] and [[Richard Karp|Karp]], and independently Tomizawa noticed that it can be modified to achieve an <math>O(n^3)</math> running time. [[L. R. Ford, Jr.|Ford]] and [[D. R. Fulkerson|Fulkerson]] extended the method to general transportation problems. In 2006, it was discovered that [[Carl Gustav Jacobi]] had solved the assignment problem in the 19th century, and published posthumously in 1890 in Latin.<ref>http://www.lix.polytechnique.fr/~ollivier/JACOBI/jacobiEngl.htm</ref> ==Layman’s Explanation== Say you have three workers: '''Jim''', '''Steve''' and '''Alan'''. You need to have one of them clean the bathroom, another sweep the floors & the third wash the windows. What’s the best (minimum-cost) way to assign the jobs? First we need a [[Matrix (mathematics)|matrix]] of the costs of the workers doing the jobs. {| class="wikitable" border="1" |- ! ! Clean bathroom ! Sweep floors ! Wash windows |- | Jim | $1 | $2 | $3 |- | Steve | $3 | $3 | $3 |- | Alan | $3 | $3 | $2 |} Then the Hungarian algorithm, when applied to the above table would give us the minimum cost it can be done with: Jim cleans the bathroom, Steve sweeps the floors and Alan washes the windows. ==Setting== We are given a nonnegative ''n''×''n'' [[Matrix (mathematics)|matrix]], where the element in the ''i''-th row and ''j''-th column represents the cost of assigning the ''j''-th job to the ''i''-th worker. We have to find an assignment of the jobs to the workers that has minimum cost. If the goal is to find the assignment that yields the maximum cost, the problem can be altered to fit the setting by replacing each cost with the maximum cost subtracted by the cost.<ref>[http://www.ams.jhu.edu/~castello/362/Handouts/hungarian.pdf Beryl Castello, The Hungarian Algorithm]</ref> The algorithm is easier to describe if we formulate the problem using a bipartite graph. We have a [[complete bipartite graph]] ''G=(S, T; E)'' with ''n'' worker vertices (''S'') and ''n'' job vertices (''T''), and each edge has a nonnegative cost ''c(i,j)''. We want to find a [[perfect matching]] with minimum cost. Let us call a function <math>y: (S \cup T) \mapsto \mathbb{Q}</math> a '''potential''' if <math>y(i)+y(j) \leq c(i, j)</math> for each <math>i \in S, j \in T</math>. The value of potential ''y'' is <math>\sum_{v\in S\cup T} y(v)</math>. It can be seen that the cost of each perfect matching is at least the value of each potential. The Hungarian method finds a perfect matching and a potential with equal cost/value which proves the optimality of both. In fact it finds a perfect matching of '''tight edges''': an edge ''ij'' is called tight for a potential ''y'' if <math>y(i)+y(j) = c(i, j)</math>. Let us denote the [[subgraph]] of tight edges by <math>G_y</math>. The cost of a perfect matching in <math>G_y</math> (if there is one) equals the value of ''y''. ==The algorithm in terms of bipartite graphs== During the algorithm we maintain a potential ''y'' and an [[Glossary_of_graph_theory#Direction|orientation]] of <math>G_y</math> (denoted by <math>\overrightarrow{G_y}</math>) which has the property that the edges oriented from ''T'' to ''S'' form a matching ''M''. Initially, ''y'' is 0 everywhere, and all edges are oriented from ''S'' to ''T'' (so ''M'' is empty). In each step, either we modify ''y'' so that its value increases, or modify the orientation to obtain a matching with more edges. We maintain the invariant that all the edges of ''M'' are tight. We are done if ''M'' is a perfect matching. In a general step, let <math>R_S \subseteq S</math> and <math>R_T \subseteq T</math> be the vertices not covered 