performance, thus being degree-optimal. == Example == In a simple [[functional programming]] form, the algorithm (in [[Haskell (programming language)|Haskell]]) would look something like this: <source lang="text"> data Tree a = Leaf | Node (Tree a) a (Tree a) insert :: Ord a => a -> Tree a -> Tree a insert x Leaf = Node Leaf x Leaf insert x (Node t y t') | x <= y = Node (insert x t) y t' insert x (Node t y t') | x > y = Node t y (insert x t') flatten :: Tree a -> [a] flatten Leaf = [] flatten (Node t x t') = flatten t ++ [x] ++ flatten t' treesort :: Ord a => [a] -> [a] treesort = flatten . foldr insert Leaf </source> Mind that in the above example, both the insertion algorithm and the retrieval algorithm have O(n<sup>2</sup>) worst case scenarios. An example using a self-balancing binary search tree in C++, with O(n log n) worst-case: <source lang="cpp"> #include <set> // for multiset #include <algorithm> // for copy #include <iterator> // for iterator_traits template <typename Iterator> void binary_tree_sort(Iterator begin, Iterator end) { // C++'s multiset class is a self-balancing binary search tree that allows duplicates // Add each element in input range to the tree std::multiset<typename std::iterator_traits<Iterator>::value_type> tree(begin, end); // Read elements in ascending order by simply traversing the tree. std::copy(tree.begin(), tree.end(), begin); } </source> == External links== {{wikibooks|Algorithm implementation|Sorting/Binary Tree Sort|Binary Tree Sort}} * [http://www.qmatica.com/DataStructures/Trees/BST.html Binary Tree Java Applet and Explanation] * [http://www.martinbroadhurst.com/articles/sorting-a-linked-list-by-turning-it-into-a-binary-tree.html Tree Sort of a Linked List] * [http://www.martinbroadhurst.com/cpp-sorting.html#tree-sort Tree Sort in C++] {{sorting}} [[Category:Sorting algorithms]] [[es:Ordenamiento con árbol binario]] [[fa:مرتب‌سازی درختی]] [[fr:Tri arborescent]] [[ru:Сортировка с помощью двоичного дерева]] [[tr:Ağaç sıralaması]]</text> </page> <page> <id>38211</id> <title>Treefinder</title> <text>'''Treefinder''' is a free computer program for the [[maximum likelihood|likelihood-based]] reconstruction of [[phylogenetic tree]]s from molecular sequences. A platform-independent graphical environment integrates a standard suite of analyses that can be done by just pressing a few buttons: [[computational phylogenetics|phylogeny reconstruction]], bootstrap analysis, [[model selection]], [[hypothesis testing]], tree calibration, manipulation of trees and sequence data. Treefinder is also programmable in its own [[scripting language]] TL. Treefinder has an efficient tree search [[algorithm]] that can infer even large trees with thousands of [[species]] within a short time. Result trees are displayed on the screen and can then be saved in a special data format, the "reconstruction report", which may serve as an input for further analysis, for example hypothesis testing. The report contains all information about the tree and the models used. Export of results to popular tree formats such as [[newick format|NEWICK]] or [[nexus format|NEXUS]] is also possible. Noteworthy is the broad collection of [[substitution model|models of sequence evolution]]. The version of June 2008 implements 7 models of nucleotide substitution (HKY, TN, J1, J2, J3 (= TIM), TVM, GTR), 14 empirical models of amino acid substitution (BLOSUM, cpREV, Dayhoff, JTT, LG, mtArt, mtMam, mtREV, PMB, rtREV, betHIV, witHIV, VT, WAG), 4 substitution models of structured rRNA (bactRNA, eukRNA, euk23RNA, mitoRNA), the 6-state "Dayhoff Groups" protein model (DG), 2-state and 3-state models of DNA (GTR3, GTR2), a parametric mixed model (MIX) mixing the empirical models of proteins or rRNA, and also a user-definable GTR-type model (MAP) mapping characters to states as needed. Three models of among-site rate heterogeneity are available (Gamma,Gamma+I,I), which can be combined with any of the substitution models. Last but not least, one can assume different models for different partitions of a [[sequence alignment]], and partitions may be assumed to evolve at different speeds. All parameters of the models can be estimated from the data by maximization of likelihood. Special TL expressions, the "model expressions", allow the concise notation of even complex models, together with all their parameters and optimization modes. Treefinder <ref>Jobb G, von Haeseler A, Strimmer K. 2004. TREEFINDER: a powerful graphical analysis environment for molecular phylogenetics. BMC Evol. Biol. 4:18.</ref> has been produced by Gangolf Jobb, formerly a researcher at the University of Munich, Germany. ==References== <references/> ==See also== * [[Computational phylogenetics]] * [[Molecular phylogeny]] * [[Molecular biology]] ==External links== * [http://www.treefinder.de/ Treefinder homepage] [[Category:Computational phylogenetics]] [[Category:Bioinformatics software]] [[Category:Science software]] [[Category:Molecular biology]] [[Category:Genetics]]</text> </page> <page> <id>38217</id> <title>Trench code</title> <text>{{Unreferenced|date=December 2009}} {{Inappropriate tone|date=December 2007}} In [[cryptography]], '''trench codes''' were [[code (cryptography)|code]]s used for secrecy by field armies in [[World War I]]. A reasonably-designed code is generally more difficult to crack than a [[classical cipher]], but of course suffers from the difficulty of preparing, distributing, and protecting [[codebook]]s. However, by the middle of [[World War I]] the conflict had settled down into a static battle of attrition, with the two sides sitting in huge lines of fixed earthworks fortifications. Vast numbers of men were sacrificed in futile offensives to break these lines, with the usual result being little more than a dent of a few kilometers at best. With armies generally immobile, distributing codebooks and protecting them was easier than it would have been for armies on the move. To be sure, trench-raiding parties could sneak into enemy lines and try to snatch codebooks, but then an alarm could be raised and a code quickly changed. They were changed on a regular basis anyway. ==French Army== The [[France|French]] began to develop trench codes in early 1916. They started out as [[telephone]] codes, implemented at the request of a [[general]] whose forces had suffered devastating [[artillery]] bombardments due to indiscretions in telephone conversations between his men. The original telephone code featured a small set of two-letter codewords that were spelled out in voice communications. This grew into a three-letter code scheme, which was then adopted for wireless, with early one-part code implementations evolving into more secure two-part code implementations. The British began to adopt trench codes as well. ==German Army== The [[Germany|Germans]] started using trench codes in the spring of 1917, evolving into a book of 4,000 codewords that were changed twice a month, with different codebooks used on different sectors of the front. The French codebreakers were extremely competent at cracking [[Encryption|ciphers]] but were somewhat inexperienced at cracking codes, which require 