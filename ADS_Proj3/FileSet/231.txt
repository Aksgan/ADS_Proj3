is based on the [[stable model semantics|stable model]] (answer set) semantics of [[logic programming]]. In ASP, search problems are reduced to computing stable models, and ''answer set solvers'' -- programs for generating stable models—are used to perform search. The computational process employed in the design of many answer set solvers is an enhancement of the [[DPLL algorithm]] and, in principle, it always terminates (unlike [[Prolog]] query evaluation, which may lead to an [[infinite loop]]). In a more general sense, ASP includes all applications of answer sets to [[knowledge representation]]<ref>C. Baral [2003] ''Knowledge Representation, Reasoning and Declarative Problem Solving.'' Cambridge University Press.</ref><ref>M. Gelfond [2008] ''[http://www.krlab.cs.ttu.edu/Papers/download/gel07b.pdf Answer sets.]'' In: Handbook of Knowledge Representation, Elsevier, pages 285-316.</ref> and the use of Prolog-style query evaluation for solving problems arising in these applications. ==History== The [[Automated planning and scheduling|planning]] method proposed by Dimopoulos, Nebel and Köhler<ref>Y. Dimopoulos, [[Bernhard Nebel|B. Nebel]] and J. Köhler [1997] ''[ftp://ftp.informatik.uni-freiburg.de/documents/papers/ki/dimopoulos-etal-ecp97.ps.gz Encoding planning problems in non-monotonic logic programs.]'' In: Proceedings of ECP-97, Springer Verlag, pages 273-285.</ref> is an early example of answer set programming. Their approach is based on the relationship between plans and stable models<ref>V.S.Subrahmanian and C. Zaniolo [1995] ''[http://www.cs.ucla.edu/%7Ezaniolo/papers/iclp95.ps Relating stable models and AI planning domains.]'' In: Proceedings of ICLP-95, pages 233-247.</ref>. Soininen and Niemelä<ref>T. Soininen and I. Niemelä [1998] ''[http://www.tcs.hut.fi/~ini/papers/sn-faanmr98.ps.gz Formalizing configuration knowledge using rules with choices.]'' Technical Report TKO-B142, Laboratory of Information Processing Science, Helsinki University of Technology.</ref> applied what is now known as answer set programming to the problem of product configuration. The use of answer set solvers for search was identified as a new programming paradigm in Marek and Truszczyński<ref>V. Marek and M. Truszczyński [1999] ''[http://xxx.lanl.gov/pdf/cs/9809032 Stable models and an alternative logic programming paradigm.]'' In: The Logic Programming Paradigm: a 25-Year Perspective, Springer Verlag, pages 169-181.</ref> (the term "answer set programming" was used for the first time as the title of a part of the collection where that paper appeared) and in [Niemelä 1999].<ref>I. Niemelä [1999] ''[http://www.tcs.hut.fi/~ini/papers/lp-csp-long.ps Logic programs with stable model semantics as a constraint programming paradigm.]'' Annals of Mathematics and Artificial Intelligence, Vol. 25, pages 241-273.</ref> ==Answer set programming language Lparse== [http://www.tcs.hut.fi/Software/smodels/lparse.ps Lparse] is the name of the program that was originally created as a front-end for the answer set solver [http://www.tcs.hut.fi/Software/smodels/ smodels], and is now used in the same way in many other answer set solvers, including [http://assat.cs.ust.hk/ assat], [http://www.cs.uni-potsdam.de/clasp/ clasp], [http://www.cs.utexas.edu/users/tag/cmodels/ cmodels], [http://www.tcs.hut.fi/Software/gnt/ gNt], [http://www.cs.uni-potsdam.de/nomore/ nomore++] and [http://www.cs.uky.edu/ai/pbmodels/ pbmodels]. ([http://www.dbai.tuwien.ac.at/proj/dlv/ dlv] is an exception; the syntax of ASP programs written for dlv is somewhat different.) An Lparse program consists of rules of the form <pre> <head> :- <body> . </pre> The symbol <code>:-</code> ("if") is dropped if <code><body></code> is empty. The simplest kind of Lparse rules are [[Stable model semantics#Programs with constraints|rules with constraints]]. One other useful construct included in this language is ''choice''. For instance, the choice rule <pre> {p,q,r}. </pre> says: choose arbitrarily which of the atoms <math>p,q,r</math> to include in the stable model. The lparse program that contains this choice rule and no other rules has 8 stable models—arbitrary subsets of <math>\{p,q,r\}</math>. The definition of a stable model was generalized to programs with choice rules.<ref>I. Niemelä, P. Simons and T. Soinenen [1999] ''[http://www.tcs.hut.fi/~ini/papers/nss-lpnmr99-www.ps.gz Stable model semantics of weight constraint rules.]'' In: Proceedings of LPNMR-99, pages 317-331.</ref> Choice rules can be treated also as abbreviations for [[Stable_model_semantics#Stable_models_of_a_set_of_propositional_formulas|propositional formulas under the stable model semantics]].<ref>P. Ferraris and V. Lifschitz [2005] ''[http://www.cs.utexas.edu/users/vl/papers/weight.ps Weight constraints as nested expressions.]'' Theory and Practice of Logic Programming, Vol. 5, pages 45-74.</ref> For instance, the choice rule above can be viewed as shorthand for the conjunction of three "[[excluded middle]]" formulas: :<math>(p\lor\neg p)\land(q\lor\neg q)\land(r\lor\neg r).</math> The language of lparse allows us also to write "constrained" choice rules, such as <pre> 1{p,q,r}2. </pre> This rule says: choose at least 1 of the atoms <math>p,q,r</math>, but not more than 2. The meaning of this rule under the stable model semantics is represented by the [[propositional formula]] :<math>(p\lor\neg p)\land(q\lor\neg q)\land(r\lor\neg r)</math> ::<math>\land\,(p\lor q\lor r)\land\neg(p\land q\land r).</math> Cardinality bounds can be used in the body of a rule as well, for instance: <pre> :- 2{p,q,r}. </pre> Adding this constraint to an Lparse program eliminates the stable models that contain at least 2 of the atoms <math>p,q,r</math>. The meaning of this rule can be represented by the propositional formula ::<math>\neg((p\land q)\lor(p\land r)\lor(q\land r)).</math> Variables (capitalized, as in [[Prolog#Data types|Prolog]]) are used in Lparse to abbreviate collections of rules that follow the same pattern, and also to abbreviate collections of atoms within the same rule. For instance, the Lparse program <pre> p(a). p(b). p(c). q(X) :- p(X), X!=a. </pre> has the same meaning as <pre> p(a). p(b). p(c). q(b). q(c). </pre> The program <pre> p(a). p(b). p(c). {q(X):p(X)}2. </pre> is shorthand for <pre> p(a). p(b). p(c). {q(a),q(b),q(c)}2. </pre> ==Generating stable models== To find a stable model of the Lparse program stored in file <code><filename></code> we use the command <pre> % lparse <filename> | smodels </pre> Option 0 instructs smodels to find ''all'' stable models of the program. For instance, if file <code>test</code> contains the rules <pre> 1{p,q,r}2. s :- not p. </pre> then the command <pre> % lparse test | smodels 0 </pre> produces the output <pre> Answer: 1 Stable Model: q p Answer: 2 Stable Model: p Answer: 3 Stable Model: r p Answer: 4 Stable Model: q s Answer: 5 Stable Model: r s Answer: 6 Stable Model: r q s </pre> ==Examples of ASP programs== ===Graph coloring=== An <math>n</math>-[[Graph coloring|coloring]] of a [[Graph (mathematics)|graph]] <math>G</math> is a function <math>color\ </math> from its set of vertices to <math>\{1,\dots,n\}</math> such that <math>color(x)\neq color(y)</math> for every pair of adjacent vertices <math>x,y</math>. We would like to use ASP to find an <math>n</math>-coloring of a given graph (or determine that it does not exist). This can be accomplished using the following Lparse program: <pre> c(1..n). 1 {color(X,I) : c(I)} 1 :- v(X). :- color(X,I), color(Y,I), e(X,Y), c(I). </pre> Line 1 defines the numbers <math>1,\dots,n</math> to be colors. According to the choice rule in Line 2, a unique color <math>i</math> should be assigned to each vertex 