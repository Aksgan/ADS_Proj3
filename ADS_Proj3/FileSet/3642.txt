<page> <id>30716</id> <title>Quadratic residue code</title> <text>A '''quadratic residue code''' is a type of [[cyclic code]]. There is a quadratic residue code of length <math>p</math> over the finite field <math>GF(l)</math> whenever <math>p</math> and <math>l</math> are primes, <math>p</math> is odd and <math>l</math> is a [[quadratic residue]] modulo <math>p</math>. Its generator polynomial as a cyclic code is given by :<math>f(x)=\prod_{j\in Q}(x-\zeta^j)</math> where <math>Q</math> is the set of quadratic residues of <math>p</math> in the set <math>\{1,2,\ldots,p-1\}</math> and <math>\zeta</math> is a primitive <math>p</math>th root of unity in some finite extension field of <math>GF(l)</math>. The condition that <math>l</math> is a quadratic residue of <math>p</math> ensures that the coefficients of <math>f</math> lie in <math>GF(l)</math>. The dimension of the code is <math>(p+1)/2</math> Replacing <math>\zeta</math> by another primitive <math>p</math>-th root of unity <math>\zeta^r</math> either results in the same code or an equivalent code, according to whether or not <math>r</math> is a quadratic residue of <math>p</math>. An alternative construction avoids roots of unity. Define :<math>g(x)=c+\sum_{j\in Q}x^j</math> for a suitable <math>c\in GF(l)</math>. When <math>l=2</math> choose <math>c</math> to ensure that <math>g(1)=1</math> while if <math>l</math> is odd <math>c=(1+\sqrt{p^*})/2</math> where <math>p^*=p</math> or <math>-p</math> according to whether <math>p</math> is congruent to <math>1</math> or <math>3</math> modulo <math>4</math>. Then <math>g(x)</math> also generates a quadratic residue code; more precisely the ideal of <math>F_l[X]/\langle X^p-1\rangle</math> generated by <math>g(x)</math> corresponds to the quadratic residue code. The minimum weight of a quadratic residue code of length <math>p</math> is greater than <math>\sqrt{p}</math>; this is the '''square root bound'''. Adding an overall parity-check digit to a quadratic residue code gives an '''extended quadratic residue code'''. When <math>p\equiv 3</math> (mod <math>4</math>) an extended quadratic residue code is self-dual; otherwise it is equivalent but not equal to its dual. By a theorem of Gleason and Prange, the automorphism group of an extended quadratic residue code has a subgroup which is isomorphic to either <math>PSL_2(p)</math> or <math>SL_2(p)</math>. Examples of quadratic residue codes include the <math>(7,4)</math> [[Hamming code]] over <math>GF(2)</math>, the <math>(23,12)</math> [[binary Golay code]] over <math>GF(2)</math> and the <math>(11,6)</math> [[ternary Golay code]] over <math>GF(3)</math>. == References == F. J. MacWilliams and N. J. A. Sloane, ''The Theory of Error-Correcting Codes'', North-Holland Publishing Co., Amsterdam-New York-Oxford, 1977. [[Category:Quadratic residue]] [[Category:Coding theory]] {{math-stub}}</text> </page> <page> <id>30720</id> <title>Quadratically constrained quadratic program</title> <text>In mathematics, a '''quadratically constrained quadratic program''' ('''QCQP''') is an [[optimization (mathematics)|optimization]] problem in which both the objective function and the constraints are quadratic functions. It has the form :<math> \begin{align} & \text{minimize} && \tfrac12 x^\top P_0 x + q_0^\top x \\ & \text{subject to} && \tfrac12 x^\top P_i x + q_i^\top x + r_i \leq 0 \quad \text{for } i = 1,\dots,m , \\ &&& Ax = b, \end{align} </math> where ''P''<sub>0</sub>, &hellip; ''P''<sub>''m''</sub> are ''n''-by-''n'' matrices and ''x'' &isin; '''R'''<sup>''n''</sup> is the optimization variable. If ''P''<sub>0</sub>, &hellip; ''P''<sub>''m''</sub> are all [[Positive-definite_matrix | positive semidefinite]] then the problem is [[Convex_set | convex]]. If these matrices are neither positive or negative semidefinite, the problem is non-convex. If these are all zero, then the constraints are in fact [[Linear_map | linear]] and the problem is a [[quadratic program]]. == Hardness == Solving the general case is an [[NP-hard]] problem. To see this, note that the two constraints ''x''<sub>1</sub>(''x''<sub>1</sub> − 1) &le; 0 and ''x''<sub>1</sub>(''x''<sub>1</sub> − 1) &ge; 0 are equivalent to the constraint ''x''<sub>1</sub>(''x''<sub>1</sub> − 1) = 0, which is in turn equivalent to the constraint ''x''<sub>1</sub> &isin; {0, 1}. Hence, any [[0–1 integer program]] (in which all variables have to be either 0 or 1) can be formulated as a quadratically constrained quadratic program. But 0–1 integer programming is NP-hard, so QCQP is also NP-hard. == Example == [[Cut_(graph_theory)| Max Cut]] is a problem in graph theory, which is NP-hard. Given a graph, the problem is to divide the vertices in two sets, so that as many edges as possible go from one set to the other. Max Cut can be easily formulated as a QCQP, which allows obtaining good lower bounds using SDP realization of the dual. == Special cases == There are two main relaxations of QCQP: using [[semidefinite programming]] (SDP), and using the reformulation- linearization technique (RLT). === Semidefinite programming === When ''P''<sub>0</sub>, &hellip; ''P''<sub>''n''</sub> are all [[Positive-definite matrix|positive-definite matrices]], the problem is [[Convex optimization|convex]] and can be readily solved using [[interior point method]]s, as done with [[semidefinite programming]]. == References == * Stephen Boyd and Lieven Vandenberghe, [http://www.stanford.edu/~boyd/cvxbook/ Convex Optimization] (book in pdf) {{mathapplied-stub}} [[Category:Mathematical optimization]]</text> </page> <page> <id>30725</id> <title>Quadruple precision floating-point format</title> <text>In [[computing]], '''quadruple precision''' (also commonly shortened to '''quad precision''') is a binary [[floating-point]] [[computer numbering format]] that occupies 16 bytes (128 bits in modern computers) in computer memory. In [[IEEE 754-2008]] the 128-bit base 2 format is officially referred to as '''binary128'''. {{Floating-point}} == IEEE 754 quadruple precision binary floating-point format: binary128 == The IEEE 754 standard specifies a '''binary128''' as having: * [[Sign bit]]: 1 * [[Exponent]] width: 15 * [[Significand]] [[precision (arithmetic)|precision]]: 113 (112 explicitly stored) <!-- "significand", with a d at the end, is a technical term, please do not confuse with "significant" --> The format is written with an implicit lead bit with value 1 unless the exponent is stored with all zeros. Thus only 112 bits of the [[significand]] appear in the memory format, but the total precision is 113 bits (approximately 34 decimal digits, <math>\log_{10}(2^{113}) \approx 34.016</math>). The bits are laid out as follows: [[Image:IEEE_754_Quadruple_Floating_Point_Format.svg]] === Exponent encoding === The quadruple precision binary floating-point exponent is encoded using an [[offset binary]] representation, with the zero offset being 16383; also known as exponent bias in the IEEE 754 standard. * E<sub>min</sub> = 0x0001−0x3fff = −16382 * E<sub>max</sub> = 0x7ffe−0x3fff = 16383 * [[Exponent bias]] = 0x3fff = 16383 Thus, as defined by the offset binary representation, in order to get the true exponent the offset of 16383 has to be subtracted from the stored exponent. The stored exponents 0x0000 and 0x7fff are interpreted specially. {|class="wikitable" style="text-align:center" ! Exponent !! Significand zero !! Significand non-zero !! Equation |- | 0x0000 || [[0 (number)|0]], [[−0]] || [[subnormal numbers]] || <math>(-1)^{\text{signbit}} \times 2^{-16382} \times 0.\text{significandbits}_2</math> |- | 0x0001, 