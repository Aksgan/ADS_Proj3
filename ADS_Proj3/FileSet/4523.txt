Anniversary]]'', ''[[Tomb Raider: Underworld]]'') * '''Archibald Cutter''' (''[[Gunga Din (film)|Gunga Din]]'') * '''[[Nathan Drake (character)|Nathan Drake]]''' (''[[Uncharted: Drake's Fortune]]'', ''[[Uncharted 2: Among Thieves]]'', ''[[Uncharted 3: Drake's Deception]]'') * '''[[Fool's Gold (film)|Benjamin "Finn" Finnegan]]''' (''[[Fool's Gold (film)|Fool's Gold]]'') * '''[[Sydney Fox]]''' (''[[Relic Hunter]]'') * '''[[Benjamin Franklin Gates]]''' (''[[National Treasure (film)|National Treasure]]'', ''[[National Treasure: Book of Secrets]]'') * '''[[Indiana Jones|Dr. Henry "Indiana" Jones, Jr.]]''' (''[[Raiders of the Lost Ark]]'', ''[[Indiana Jones and the Temple of Doom]]'', ''[[Indiana Jones and the Last Crusade]]'', ''[[Indiana Jones and the Kingdom of the Crystal Skull]]'', ''[[The Young Indiana Jones Chronicles]]'') * '''[[Rick O'Connell]]''' (''[[The Mummy (1999 film)|The Mummy]]'', ''[[The Mummy Returns]]'', ''[[The Mummy: Tomb of the Dragon Emperor]]'') * '''[[Dirk Pitt]]''' (''[[Raise the Titanic (film)|Raise the Titanic]]'', ''[[Sahara (2005 film)|Sahara]]'') * '''[[Allan Quatermain]]''' (''[[King Solomon's Mines]]'') ==See also== * [[Armchair treasure hunt]] * [[Buried treasure]] * [[La chouette d'or]] * [[Geocaching]] * [[Letterboxing]] * [[Lost mines]] * [[Marine salvage]] and [[treasure hunting (marine)]] * [[Metal detector]] * [[Shipwreck]] ==Further reading== * Robert E. Burgess, ''Sunken Treasure'' (Dodd, Mead; New York; 1988) * [[Cork Graham]], The Bamboo Chest; 2004 * [[Dr. E. Lee Spence]], ''Treasures of the Confederate Coast: the "Real Rhett Butler" & Other Revelations'' (Narwhal Press, Charleston/Miami, 1995) [[Category:Treasure]] [[Category:Treasure troves]] [[Category:Archaeology]] [[bg:Иманяр]] [[de:Schatzsuche]] [[ja:トレジャーハンター]] [[pt:Caça ao tesouro]]</text> </page> <page> <id>38193</id> <title>Tree (Unix)</title> <text>{{Orphan|date=February 2009}} {{lowercase}} '''Tree''' is a [[Computer program|program]] available for [[Unix]] and [[Unix-like]] systems. <tt>tree</tt> is a recursive [[directory (file systems)|directory]] listing program that produces a depth-indented listing of files. With no arguments, <tt>tree</tt> lists the files in the current directory. When directory arguments are given, <tt>tree</tt> lists all the files and/or directories found in the given directories each in turn. Upon completion of listing all files/directories found, <tt>tree</tt> returns the total number of files and/or directories listed. ==Poor Man's Version== <pre> ls -R | grep ":$" | sed -e 's/:$//' -e 's/[^-][^\/]*\//--/g' -e 's/^/ /' -e 's/-/|/' </pre> ==See also== *[[List of Unix programs]] ==External links== *http://mama.indstate.edu/users/ice/tree/ - The program's web page. {{unix commands}} [[Category:Unix file system-related software]] [[fr:Tree]] [[pl:Tree (Unix)]] [[pt:Tree]]</text> </page> <page> <id>38203</id> <title>Tree rearrangement</title> <text>'''Tree rearrangements''' are used in [[heuristic]] [[algorithm]]s devoted to searching for an [[Optimization (mathematics)|optimal]] [[tree structure]]. They can be applied to any set of data that are naturally arranged into a tree, but have most applications in [[computational phylogenetics]], especially in [[maximum parsimony]] and [[maximum likelihood]] searches of [[phylogenetic tree]]s, which seek to identify one among many possible trees that best explains the [[evolution]]ary history of a particular [[gene]] or [[species]]. ==Basic tree rearrangements== <gallery> Image:NNI.svg|Nearest Neighbor Interchange (NNI) Image:SPR.svg|Sub-tree Pruning and Regrafting (SPR) Image:TBR.svg|Tree bisection and reconnection (TBR) </gallery> The simplest tree-rearrangement, known as ''nearest-neighbor interchange'', exchanges the connectivity of four subtrees within the main tree. Because there are three possible ways of connecting four subtrees,<ref name="felsenstein">Felsenstein J. (2004). ''Inferring Phylogenies'' Sinauer Associates: Sunderland, MA.</ref> and one is the original connectivity, each interchange creates two new trees. Exhaustively searching the possible nearest-neighbors for each possible set of subtrees is the slowest but most optimizing way of performing this search. An alternative, more wide-ranging search, ''subtree pruning and regrafting'' (SPR), selects and removes a subtree from the main tree and reinserts it elsewhere on the main tree to create a new node. Finally, ''tree bisection and reconnection'' (TBR) detaches a subtree from the main tree at an interior node and then attempts all possible connections between branches of the two trees thus created. The increasing complexity of the tree rearrangement technique correlates with increasing computational time required for the search, although not necessarily with their performance.<ref name="takahashi">Takahashi K, Nei M. (2000). Efficiencies of fast algorithms of phylogenetic inference under the criteria of maximum parsimony, minimum evolution, and maximum likelihood when a large number of sequences are used. ''Mol Biol Evol'' 17(8):1251-8.</ref> ==Tree fusion== The simplest type of tree fusion begins with two trees already identified as near-optimal; thus, they most likely have the majority of their nodes correct but may fail to resolve individual tree "leaves" properly; for example, the separation ((A,B),(C,D)) at a branch tip versus ((A,C),(B,D)) may be unresolved.<ref name="felsenstein" /> Tree fusion swaps these two solutions between two otherwise near-optimal trees. Variants of the method use standard [[genetic algorithm]]s with a defined [[objective function]] to swap high-scoring subtrees into main trees that are high-scoring overall.<ref name="matsuda">Matsuda H. (1996). Protein phylogenetic inference using maximum likelihood with a genetic algorithm. ''Pacific Symposium on Biocomputing 1996'', pp512-23.</ref> ==References== <references /> [[Category:Phylogenetics]] [[Category:Optimization algorithms]] [[Category:Trees (structure)]]</text> </page> <page> <id>38205</id> <title>Tree sort</title> <text>{{Infobox Algorithm |class=[[Sorting algorithm]] |image= |data=[[Array data structure|Array]] |time=O(n<sup>2</sup>) (unbalanced) O(<math>n \log n</math>) (balanced) |space= |optimal=Yes, if balanced }} A '''tree sort''' is a [[sort algorithm]] that builds a [[binary search tree]] from the keys to be sorted, and then traverses the tree ([[Tree traversal|in-order]]) so that the keys come out in sorted order. Its typical use is when sorting the elements of a stream from a file. Several other sorts would have to load the elements to a temporary data structure, whereas in a tree sort the act of loading the input into a data structure is sorting it. == Efficiency == Adding one item to a binary search tree is on average an O(log(n)) process, so adding n items is an O(n log(n)) process, making Tree Sort a so-called, 'fast sort'. But adding an item to an unbalanced binary tree needs [[Big O notation|O]](''n'') time in the worst-case, when the tree resembles a [[linked list]] ([[Binary Tree#Types of binary trees|degenerate tree]]), causing a worst case of O(n<sup>2</sup>) for this sorting algorithm. The worst case scenario then is triggered by handing a Tree Sort algorithm an already sorted set. This would make the time needed to insert all elements into the binary tree O(n<sup>2</sup>). The dominant process in the Tree Sort algorithm is the "insertion" into the binary tree, assuming that the time needed for retrieval is O(n). The worst-case behaviour can be improved upon by using a [[self-balancing binary search tree]]. Using such a tree, the algorithm has an O(n log(n)) worst-case 