and two that remove quantifiers from the consequent. These rules can be derived by rewriting the implication <math>\phi \rightarrow \psi</math> as <math>\lnot \phi \lor \psi</math> and applying the rules for disjunction above. As with the rules for disjunction, these rules require that the variable quantified in one subformula does not appear free in the other subformula. The rules for removing quantifiers from the antecedent are: :<math>(\forall x \phi ) \rightarrow \psi</math> is equivalent to <math>\exists x (\phi \rightarrow \psi)</math>, :<math>(\exists x \phi ) \rightarrow \psi</math> is equivalent to <math>\forall x (\phi \rightarrow \psi)</math>. The rules for removing quantifiers from the consequent are: :<math>\phi \rightarrow (\exists x \psi)</math> is equivalent to <math>\exists x (\phi \rightarrow \psi)</math>, :<math>\phi \rightarrow (\forall x \psi)</math> is equivalent to <math>\forall x (\phi \rightarrow \psi)</math>. === Example === Suppose that <math>\phi</math>, <math>\psi</math>, and <math>\rho</math> are quantifier-free formulas and no two of these formulas share any free variable. Consider the formula :<math> (\phi \lor \exists x \psi) \rightarrow \forall z \rho</math>. By recursively applying the rules starting at the innermost subformulas, the following sequence of logically equivalent formulas can be obtained: :<math> ( \exists x (\phi \lor \psi) ) \rightarrow \forall z \rho</math>, :<math> \forall x ( ( \phi \lor \psi) \rightarrow \forall z \rho )</math>, :<math> \forall x ( \forall z ( \phi \lor \psi) \rightarrow \rho )</math>, :<math> \forall x \forall z ( ( \phi \lor \psi) \rightarrow \rho )</math>. This is not the only prenex form equivalent to the original formula. For example, by dealing with the consequent before the antecedent in the example above, the prenex form :<math>\forall z \forall x ( ( \phi \lor \psi) \rightarrow \rho)</math> can be obtained: :<math> \forall z ( (\phi \lor \exists x \psi) \rightarrow \rho )</math> :<math> \forall z ( (\exists x (\phi \lor \psi) ) \rightarrow \rho )</math>, :<math> \forall z ( \forall x ( (\phi \lor \psi) \rightarrow \rho ) )</math>, :<math> \forall z \forall x ( (\phi \lor \psi) \rightarrow \rho )</math>. === Intuitionistic logic === The rules for converting a formula to prenex form make heavy use of classical logic. In [[intuitionistic logic]], it is not true that every formula is logically equivalent to a prenex formula. The negation connective is one obstacle, but not the only one. The implication operator is also treated differently in intuitionistic logic than classical logic; in intuitionistic logic, it is not definable using disjunction and negation. The [[BHK interpretation]] illustrates why some formulas have no intuitionistically-equivalent prenex form. In this interpretation, a proof of :<math>(\exists x \phi) \rightarrow \exists y \psi \qquad (1)</math> is a function which, given a concrete ''x'' and a proof of φ(''x''), produces a concrete ''y'' and a proof of ψ(''y''). In this case it is allowable for the value of ''y'' to be computed from the given value of ''x''. A proof of :<math>\exists y ( \exists x \phi \rightarrow \psi), \qquad (2)</math> on the other hand, produces a single concrete value of ''y'' and a function that converts any proof of <math>\exists x \phi</math> into a proof of ψ(''y''). If each ''x'' satisfying φ can be used to construct a ''y'' satisfying ψ but no such ''y'' can be constructed without knowledge of such an ''x'' then formula (1) will not be equivalent to formula (2). The rules for converting a formula to prenex form that do ''fail'' in intuitionistic logic are: :(1) <math>\forall x (\phi \lor \psi)</math> implies <math>(\forall x \phi) \lor \psi</math>, :(2) <math>\forall x (\phi \lor \psi)</math> implies <math>\phi \lor (\forall x \psi)</math>, :(3) <math>(\forall x \phi) \rightarrow \psi</math> implies <math>\exists x (\phi \rightarrow \psi)</math>, :(4) <math>\phi \rightarrow (\exists x \psi)</math> implies <math>\exists x (\phi \rightarrow \psi)</math>, :(5) <math>\lnot \forall x \phi</math> implies <math>\exists x \lnot \phi</math>, (''x'' does not appear as a free variable of <math>\,\psi</math> in (1) and (3); ''x'' does not appear as a free variable of <math>\,\phi</math> in (2) and (4)). == Use of prenex form == Some [[proof calculus|proof calculi]] will only deal with a theory whose formulae are written in prenex normal form. The concept is essential for developing the [[arithmetical hierarchy]] and the [[analytical hierarchy]]. [[Gödel]]'s proof of his [[Gödel's completeness theorem|completeness theorem]] for [[first-order logic]] presupposes that all formulae have been recast in prenex normal form. ==See also== *[[Herbrandization]] *[[Skolemization]] *[[Arithmetical hierarchy]] ==Notes== {{reflist}} ==References== * {{Citation | last1=Hinman | first1=P. | title=Fundamentals of Mathematical Logic | publisher=[[A K Peters]] | isbn=978-1-56881-262-5 | year=2005}} [[Category:Normal forms (logic)]] [[de:Pränexform]] [[fr:Forme prénexe]] [[it:Forma prenessa]] [[hu:Prenex-formula]] [[nl:Prenex-normaalvorm]] [[ja:冠頭標準形]] [[pl:Forma preneksowa]] [[pt:Forma normal prenex]] [[zh:前束范式]]</text> </page> <page> <id>29874</id> <title>Preprocessor</title> <text>In [[computer science]], a '''preprocessor''' is a [[Computer program|program]] that processes its input data to produce output that is used as input to another program. The output is said to be a '''preprocessed''' form of the input data, which is often used by some subsequent programs like [[compiler]]s. The amount and kind of processing done depends on the nature of the preprocessor; some preprocessors are only capable of performing relatively simple textual substitutions and [[Macro (computer science)|macro]] expansions, while others have the power of fully-fledged [[programming language]]s. A common example from [[computer programming]] is the processing performed on [[source code]] before the next step of compilation. In some [[computer language]]s (e.g., [[C (programming language)|C]] and [[PL/I (programming language)|PL/I]] ) there is a phase of [[compiler|translation]] known as ''preprocessing''. ==Lexical preprocessors== Lexical preprocessors are the lowest-level of preprocessors, insofar as they only require [[lexical analysis]], that is, they operate on the source text, prior to any [[parser|parsing]], by performing simple substitution of [[lexer|tokenized]] character sequences for other tokenized character sequences, according to user-defined rules. They typically perform [[macro substitution]], [[header file|textual inclusion]] of other files, and conditional [[compilation]] or inclusion. ===C preprocessor=== The most common example of this is the [[C preprocessor]], which takes lines beginning with '#' as directives. Because it knows nothing about the underlying language, its use has been criticized and many of its features built directly into other languages. For example, macros replaced with aggressive inlining and templates, includes with compile-time imports 