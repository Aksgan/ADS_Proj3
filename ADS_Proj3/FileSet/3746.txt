challenges Chomsky's idea that recursion is the only trait which differentiates human and animal communication, is currently under debate. Nevins, Andrew and David Pesetsky and Cilene Rodrigues provide a debate against this proposal in Evidence and Argumentation: A Reply to Everett (2009). Language 85.3: 671--681 (2009). Indirect proof that Everett's idea are wrong come from works in neurolinguistics where it appears that all human being are endowed with the very same neurobiological structures to manage with all and only recursive langauages. For a review, see Kaan et al. (2002) Recursion in linguistics enables '[[discrete infinity]]' by embedding phrases within phrases of the same type in a hierarchical structure. Without recursion, language does not have 'discrete infinity' and cannot embed sentences into infinity (with a '[[Matryoshka doll|Russian nesting doll]]' effect). Everett contests that language must have discrete infinity, and that the Pirahã language - which he claims lacks recursion - is in fact finite. He likens it to the finite game of [[chess]], which has a finite number of moves but is nevertheless very productive, with novel moves being discovered throughout history. ===Recursion in plain English=== Recursion is the process a procedure goes through when one of the steps of the procedure involves rerunning the procedure. A procedure that goes through recursion is said to be 'recursive'. conversely, a product that is the result of a recursive procedure is said to be recursive. To understand recursion, one must recognize the distinction between a procedure and the running of a procedure. A procedure is a set of steps that are to be taken based on a set of rules. The running of a procedure involves actually following the rules and performing the steps. An analogy might be that a procedure is like a cookbook in that it is the possible steps, while running a procedure is actually preparing the meal. A procedure is recursive if one of the steps that makes up the procedure calls for a new instance of that procedure; a recursive four-course meal would be a meal in which one of the choices of appetizer, salad, entrée, or dessert was an entire meal unto itself. So a recursive meal might be potato skins, baby greens salad, chicken Parmesan, and for dessert, a four-course meal, consisting of crab cakes, Caesar salad, for an entrée, a four-course meal, and chocolate cake for dessert, so on until each of the meals within the meals is completed. <!-- A recursive procedure must complete every one of its steps. Even if a new running is called in one of its steps, each running must run through the remaining steps. What this means in reference to the analogy of the menu is that even if the salad is an entire four-course meal unto itself, you still have to eat your entrée and dessert. Comment: Routines can be written in programs such that they are recursive until a certain condition is satisfied, and then they continue with other code. Jehan60188, Jan, 2011 --> ===Recursive humor=== A common joke is the following "definition" of recursion.<ref>{{cite web|url=http://catb.org/~esr/jargon/html/R/recursion.html |title=recursion |publisher=Catb.org |date= |accessdate=2010-04-07}}</ref> :'''Recursion''' ::See "Recursion". A variation on this joke is: : '''Recursion''' :: If you still don't get it, see: "Recursion". which actually ''does'' terminate, as soon as the reader "gets it". Another example occurs in an index entry on page 269 of Kernighan and Ritchie's book "[[The C Programming Language (book)|The C Programming Language]]": ::''recursion 86, 139, 141, 182, 202, 269'' Other examples are [[recursive acronym]]s, such as [[GNU]], [[PHP]], [[YAML]], [[HURD]] or [[Wine_(software)|WINE]]. ==Recursion in mathematics== [[Image:Sierpinski Triangle.svg|right|thumb|250px|A [[Sierpinski triangle]]—a confined recursion of triangles to form a geometric [[lattice (group)|lattice]].]] ===Recursively defined sets=== {{Main|Recursive definition}} ====Example: the natural numbers==== The canonical example of a recursively defined set is given by the [[natural numbers]]: :1 is in <math>\mathbb{N}</math> :if ''n'' is in <math>\mathbb{N}</math>, then ''n'' + 1 is in <math>\mathbb{N}</math> :The set of natural numbers is the smallest set of real numbers satisfying the previous two properties. ====Example: The set of true reachable propositions==== Another interesting example is the set of all true "reachable" propositions in an [[axiomatic system]]. *if a proposition is an axiom, it is a true reachable proposition. *if a proposition can be obtained from true reachable propositions by means of inference rules, it is a true reachable proposition. *The set of true reachable propositions is the smallest set of reachable propositions satisfying these conditions. This set is called 'true reachable propositions' because: in non-constructive approaches to the foundations of mathematics, the set of true propositions is larger than the set recursively constructed from the axioms and rules of inference. See also [[Gödel's incompleteness theorems]]. (Note that determining whether a certain object is in a recursively defined set is not an algorithmic task.) ===Functional recursion=== A [[function (mathematics)|function]] may be partly defined in terms of itself. A familiar example is the [[Fibonacci number]] sequence: ''F''(''n'') = ''F''(''n'' &minus; 1) + ''F''(''n'' &minus; 2). For such a definition to be useful, it must lead to values which are non-recursively defined, in this case ''F''(0) = 0 and ''F''(1) = 1. A famous recursive function is the [[Ackermann function]] which, unlike the Fibonacci sequence, cannot be expressed without recursion. ===Recursive proofs=== Applying the standard technique of [[proof by cases]] to recursively-defined sets or functions as in the preceding sections yields [[structural induction]], a powerful generalization of [[mathematical induction]] which is widely used to derive proofs in [[mathematical logic]] and [[computer science]]. For instance, the standard way to define new systems of mathematics or logic is to define objects (such as "true" and "false", or "all natural numbers"), then define operations on these. These are the base cases. After this, all valid computations in the system are defined with rules for assembling these. In this way, if the base cases and rules are all proven to be calculable, then any formula in the mathematical system will also be calculable. While the above example may seem unexciting, this type of proof is the normal way to prove that 