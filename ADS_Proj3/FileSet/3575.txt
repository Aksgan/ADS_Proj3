minimizing the visibility of its attributes (data). ===Applicability=== This design pattern applies to any class in any object oriented language. ===Structure=== {{Empty section|date=January 2011}} ===Participants=== {{Empty section|date=January 2011}} ===Collaboration=== {{Empty section|date=January 2011}} ===Consequences=== The consequences of using this design pattern include the following: * Controlling write access to class attributes; * Separating of data from methods that use it; * Encapsulating class attribute (data) initialization; and * Providing new type of ''final'': ''final after constructor''. ===Implementation=== The private class data design pattern solves the problems above by extracting a ''data class'' for the target class and giving the target class instance an instance of the extracted ''data class''. *The ''data class'' exposes each attribute (variable or property) through a ''getter''. *The ''data class'' exposes each attribute that must change after construction through a ''setter''. ===Sample code=== The following [[C Sharp (programming language)|C#]] code illustrates an opportunity to use the private class data design pattern: <source lang="csharp"> public class Circle { private double radius; private Color color; private Point origin; public Circle(double radius, Color color, Point origin) { this.radius = radius; this.color = color; this.origin = origin; } public double Circumference { get { return 2 * Math.PI * this.radius; } } public double Diameter { get { return 2 * this.radius; } } public void Draw(Graphics graphics) { //... } } </source> The attributes ''radius'', ''color'', and ''origin'' above should not change after the ''Circle()'' constructor. Note that the visibility is already limited by scoping them as ''private'', but doing methods of class ''Circle'' can still modify them. The excess exposure of the attributes creates a type of (undesirable) coupling between methods that access those attributes. To reduce the visibility of the attributes and thus reduce the coupling, implement the private class data design pattern, as follows: <source lang="csharp"> public class CircleData { private double radius; private Color color; private Point origin; public CircleData(double radius, Color color, Point origin) { this.radius = radius; this.color = color; this.origin = origin; } public double Radius { get { return this.radius; } } public Color Color { get { return this.color; } } public Point Origin { get { return this.origin; } } } public class Circle { private CircleData circleData; public Circle(double radius, Color color, Point origin) { this.circleData = new CircleData(radius, color, origin); } public double Circumference { get { return 2 * this.circleData.Radius * Math.PI; } } public double Diameter { get { return this.circleData.Radius * 2; } } public void Draw(Graphics graphics) { //... } }</source> The ''Circle'' class in the resulting code has an attribute of type ''CircleData'' to encapsulate the attributes previously exposed to all of the methods of the class ''Circle''. That encapsulation prevents methods from changing the attributes after the ''Circle()'' constructor. Note, however, that any method of ''Circle'' can still retrieve the values of the encapsulated attributes. ===Known uses=== {{Empty section|date=January 2011}} ===Related patterns=== See [[Structural pattern]] for related patterns. ==References== *[http://sourcemaking.com/design_patterns/private_class_data Sourcemaking.com article] {{Unreferenced|date=January 2007}} {{DEFAULTSORT:Private Class Data Pattern}} [[Category:Software design patterns]] [[Category:Articles with example C Sharp code]] [[ru:Private class data]]</text> </page> <page> <id>30000</id> <title>Privilege (computing)</title> <text>{{Unreferenced|date=December 2009}} In [[computing]], '''privilege''' is defined as the delegation of authority over a [[computer]] system. A privilege is a [[permission]] to perform an action. Examples of various privileges include the ability to create a [[Computer file|file]] in a [[directory (file systems)|directory]], or to read or delete a file, access a [[Computer hardware|device]], or have read or write permission to a [[Internet socket|socket]] for communicating over the [[Internet]]. Users who have been delegated absolute control are called privileged. Users who lack most privileges are defined as unprivileged, regular, or normal users. ==Theory== Privileges can either be automatic, granted, or applied for. An automatic privilege exists when there is no requirement to have permission to perform an action. For example, on systems where people are required to log into a system to use it, logging out will not require a privilege. Systems that do not implement file protection - such as [[MS-DOS]] - essentially give unlimited privilege to perform any action on a file. A granted privilege exists as a result of presenting some credential to the privilege granting authority. This is usually accomplished by logging on to a system with a [[username]] and [[password]], and if the username and password supplied are correct, the user is granted additional privileges. A privilege is applied for by either an executed program issuing a request for advanced privileges, or by running some program to apply for the additional privileges. An example of a user applying for additional privileges is provided by the [[sudo]] command to run a command as the [[Superuser|root]] user, or by the [[Kerberos (protocol)|Kerberos]] authentication system. Modern processor architectures have [[CPU modes]] that allows the OS to run at different [[privilege levels]]. Some processors have two levels (such as ''user'' and ''supervisor''); [[i386]]+ processors have four levels (#0 with the most, #3 with the least privileges). Tasks are tagged with a privilege level. Resources (segments, pages, ports, etc.) and the privileged instructions are tagged with a demanded privilege level. When a task tries to use a resource, or execute a privileged instruction, the processor determines whether it has the permission (if not, a "protection fault" interrupt is generated). This prevents user tasks from damaging the OS or each other. In computer programming, exceptions related to privileged instruction violations may be caused when an array has been accessed out of bounds or an invalid pointer has been dereferenced when the invalid memory location referenced is a privileged location, such as one controlling device input/output. This is particularly more likely to occur in programming languages such as C which use pointer arithmetic or do not check array bounds automatically. ==Unix== On [[Unix-like]] systems, the [[Superuser]] (commonly known as 'root') owns all the privileges. Ordinary users are granted only enough permissions to accomplish their most common tasks. Unprivileged users usually cannot: *Adjust [[Kernel (computer science)|kernel]] options. *Modify system files, or files of other users. *Change the owner of any files. 