fpTmp = fopen("ClipShop.$$$", "wb"); if (NULL == fpTmp)return FAILURE; endofrun = FALSE; // we are using a look-ahead method, so set a pre-emptive flag // so we know in advance when we have reached the end // so we can encode the last data run before end the encoding term writecnt = 0; // we need to track the sum of the packed data lastbyte = buf[0]; // seed value for comparison offset = 1; // set to second byte - for comparison (one byte delay) runcnt = 1; // ditto... do { nextbyte = buf[offset]; offset++; // Kiss and Dirty // comes to here after doing the last byte in the buffer // dump the last bytes we read using the same code again RunEnd: // end of run if (nextbyte != lastbyte || endofrun == TRUE) { // the data has changed so lets decide what to do if (runcnt < 3 && lastbyte != RunMarker) { // write raw bytes if below an efficent blocksize // but never run raw bytes for a run marker. // the ratio of lost efficiency is variable // depending on the pattern alternation and repetition of // the image and it could be great or negligible. // this encoder is not sophisticated enough to decide // to do a precalc on whether or not to encode. // it is very efficient for 8 bit non-planar images but will // probably not do so well for EGA style 4 plane images. // 'Nuff Said. for (idx = 0; idx < runcnt; idx++)fputc(lastbyte,fpTmp); writecnt += runcnt; } else if (runcnt < 256) { // write the 3 byte block fputc(RunMarker,fpTmp); fputc((unsigned char)runcnt,fpTmp); fputc(lastbyte,fpTmp); writecnt += 3; } else { // write the 6 byte block fputc(RunMarker,fpTmp); // 1 fputc(0,fpTmp); // 2 RunCount = (PICTOR_Int)runcnt; // 3,4 fwrite(&RunCount,2,1,fpTmp); fputc(lastbyte,fpTmp); // 5 writecnt += 5; } lastbyte = nextbyte; runcnt = 0; } if (endofrun == TRUE)break; // we dumped so break runcnt++; if (offset < buflen)continue; // if we are not done get another endofrun = TRUE; // set done and dump the last bytes before breaking goto RunEnd; // the following test is never actually used } while (offset < buflen); // left in place for some semblance of clarity fclose(fpTmp); fpTmp = fopen("ClipShop.$$$", "rb"); if (NULL == fpTmp)return FAILURE; // write the block header BlockSize = 5; BlockSize += writecnt; // blocksize includes header RunLength = 0; RunLength += buflen; fwrite(&BlockSize,2,1,fp); fwrite(&RunLength,2,1,fp); fputc(RunMarker,fp); // write the block for (idx = 0; idx < writecnt; idx++) { c = fgetc(fpTmp); if (EOF == c) break; fputc((unsigned char)c,fp); } fclose(fpTmp); remove("ClipShop.$$$"); if (EOF == c) return FAILURE; return SUCCESS; } </pre> {{Empty section|date=July 2010}} ==References== Encyclopedia of Graphics File Formats, 2nd Edition by Murray, James D. , Van Ryper, William ISBN 1-56592-161-5 http://www.fileformat.info/resource/book/1565921615/index.htm Pictor PC Paint File Format Summary http://www.fileformat.info/format/pictor/ GRASP File Format Summary http://www.fileformat.info/format/grasp/ GLPRO http://en.wikipedia.org/wiki/GLPro PCPAINT/Pictor Page Format Description Format by John Bridges. Document by Microtex Industries, Inc. Revision Date: 2/9/88 http://netghost.narod.ru/gff/vendspec/pictor/pictor.txt The Graphics File Formats Page GL - Another animation format Dr. Martin Reddy Technical Lead, R & D, Pixar Animation Studios http://www.martinreddy.net/gfx/2d/GL.txt The formats of GRASP animation files By George Phillips http://www.programmersheaven.com/download/2157/Zipfilelist.aspx [[Category:Graphics file formats]]</text> </page> <page> <id>12747</id> <title>Examples of SHA digests</title> <text>The following are some examples of [[SHA-1]] and [[SHA-2]] digests. [[ASCII]] encoding is assumed for all messages. ==SHA-1 hashes== SHA1("[[The quick brown fox jumps over the lazy dog]]") = 2fd4e1c6 7a2d28fc ed849ee1 bb76e739 1b93eb12 Even a small change in the message will, with overwhelming probability, result in a completely different hash due to the [[avalanche effect]]. For example, changing <code>dog</code> to <code>cog</code>: SHA1("The quick brown fox jumps over the lazy '''c'''og") = de9f2c7f d25e1b3a fad3e85a 0bd17d9b 100db4b3 The hash of the zero-length message is: SHA1("") = da39a3ee 5e6b4b0d 3255bfef 95601890 afd80709 ==SHA-224 hashes== SHA224("subodh") = 730e109b d7a8a32b 1cb9d9a0 9aa2325d 2430587d dbc0c38b ad911525 Avalanche effect when changing the last word to "cog": SHA224("The quick brown fox jumps over the lazy '''c'''og") = fee755f4 4a55f20f b3362cdc 3c493615 b3cb574e d95ce610 ee5b1e9b The hash of the zero-length message is: SHA224("") = d14a028c 2a3a2bc9 476102bb 288234c4 15a2b01f 828ea62a c5b3e42f ==SHA-256 hashes== SHA256("The quick brown fox jumps over the lazy dog") = d7a8fbb3 07d78094 69ca9abc b0082e4f 8d5651e4 6d3cdb76 2d02d0bf 37c9e592 Avalanche effect when changing the last word to "cog": SHA256("The quick brown fox jumps over the lazy '''c'''og") = e4c4d8f3 bf76b692 de791a17 3e053211 50f7a345 b46484fe 427f6acc 7ecc81be The hash of the zero-length message is: SHA256("") = e3b0c442 98fc1c14 9afbf4c8 996fb924 27ae41e4 649b934c a495991b 7852b855 ==SHA-384 hashes== SHA384("The quick brown fox jumps over the lazy dog") = ca737f10 14a48f4c 0b6dd43c b177b0af d9e51693 67544c49 4011e331 7dbf9a50 9cb1e5dc 1e85a941 bbee3d7f 2afbc9b1 Avalanche effect when changing the last word to "cog": SHA384("The quick brown fox jumps over the lazy '''c'''og") = 098cea62 0b0978ca a5f0befb a6ddcf22 764bea97 7e1c70b3 483edfdf 1de25f4b 40d6cea3 cadf00f8 09d422fe b1f0161b The hash of the zero-length message is: SHA384("") = 38b060a7 51ac9638 4cd9327e b1b1e36a 21fdb711 14be0743 4c0cc7bf 63f6e1da 274edebf e76f65fb d51ad2f1 4898b95b ==SHA-512 hashes== SHA512("The quick brown fox jumps over the lazy dog") = 07e547d9 586f6a73 f73fbac0 435ed769 51218fb7 d0c8d788 a309d785 436bbb64 2e93a252 a954f239 12547d1e 8a3b5ed6 e1bfd709 7821233f a0538f3d b854fee6 Avalanche effect when changing the last word to "cog": SHA512("The quick brown fox jumps over the lazy '''c'''og") = 3eeee1d0 e11733ef 152a6c29 503b3ae2 0c4f1f3c da4cb26f 1bc1a41f 91c7fe4a b3bd8649 4049e201 c4bd5155 f31ecb7a 3c860684 3c4cc8df cab7da11 c8ae5045 The hash of the zero-length message is: SHA512("") = cf83e135 7eefb8bd f1542850 d66d8007 d620e405 0b5715dc 83f4a921 d36ce9ce 47d0d13c 5d85f2b0 ff8318d2 877eec2f 63b931bd 47417a81 a538327a f927da3e [[Category:Cryptographic hash functions|SHA digests, examples of]]</text> </page> <page> <id>12758</id> <title>Excess-3</title> <text>{{Unreferenced|date=December 2009}} '''Excess-3''' [[binary-coded decimal]] '''(XS-3)''', also called '''biased''' representation or '''Excess-''N''''', is a [[numeral system]] used on some older computers that uses a pre-specified number ''N'' as a biasing value. It is a way to represent values with a balanced number of positive and negative numbers. In XS-3, numbers are represented as decimal digits, and each digit is represented by four [[bit]]s as the BCD value plus 3 (the "excess" amount): * The smallest binary 