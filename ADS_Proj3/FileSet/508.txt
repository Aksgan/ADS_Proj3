candidates, returns two or more smaller sets <math>S_1, S_2, \ldots</math> whose union covers <math>S</math>. Note that the minimum of <math>f(x)</math> over <math>S</math> is <math>\min\{v_1, v_2, \ldots\}</math>, where each <math>v_i</math> is the minimum of <math>f(x) </math> within <math>S_i</math>. This step is called '''branching''', since its recursive application defines a [[tree structure]] (the ''search tree'') whose ''nodes'' are the subsets of <math>S</math>. Another tool is a procedure that computes upper and lower bounds for the minimum value of <math>f(x)</math> within a given subset <math>S</math>. This step is called '''bounding'''. The key idea of the BB algorithm is: if the ''lower'' bound for some tree node (set of candidates) <math>A</math> is greater than the ''upper'' bound for some other node <math>B</math>, then A may be safely discarded from the search. This step is called '''pruning''', and is usually implemented by maintaining a global variable <math>m</math> (shared among all nodes of the tree) that records the minimum upper bound seen among all subregions examined so far. Any node whose lower bound is greater than <math>m</math> can be discarded. The recursion stops when the current candidate set <math>S</math> is reduced to a single element; or also when the upper bound for set <math>S</math> matches the lower bound. Either way, any element of <math>S</math> will be a minimum of the function within <math>S</math>. ===Effective subdivision=== The efficiency of the method depends strongly on the node-splitting procedure and on the upper and lower bound estimators. All other things being equal, it is best to choose a splitting method that provides non-overlapping subsets. Ideally the procedure stops when all nodes of the search tree are either pruned or solved. At that point, all non-pruned subregions will have their upper and lower bounds equal to the global minimum of the function. In practice the procedure is often terminated after a given time; at that point, the maximum lower bound and the minimum upper bound, among all non-pruned sections, define a [[interval (mathematics)|range]] of values that contains the global minimum. Alternatively, within an overriding time constraint, the algorithm may be terminated when some ''error criterion'', such as ''(max − min)/(min + max)'', falls below a specified value. The efficiency of the method depends critically on the effectiveness of the branching and bounding algorithms used; bad choices could lead to repeated branching, without any pruning, until the sub-regions become very small. In that case the method would be reduced to an exhaustive enumeration of the domain, which is often impractically large. There is no universal bounding algorithm that works for all problems, and there is little hope that one will ever be found; therefore the general paradigm needs to be implemented separately for each application, with branching and bounding algorithms that are specially designed for it. Branch and bound methods may be classified according to the bounding methods and according to the ways of creating/inspecting the search tree nodes. The branch-and-bound design strategy is very similar to backtracking in that a state space tree is used to solve a problem. The differences are that the branch-and-bound method (1) does not limit us to any particular way of traversing the tree and (2) is used only for optimization problems. This method naturally lends itself for [[parallel computing|parallel]] and [[distributed computing|distributed]] implementations, see, e.g., the [[traveling salesman problem]] article. ==Applications== This approach is used for a number of [[NP-hard]] problems, such as * [[Knapsack problem]] * [[Integer programming]] * [[Nonlinear programming]] * [[Traveling salesman problem]] (TSP) * [[Quadratic assignment problem]] (QAP) * [[Maximum satisfiability problem]] (MAX-SAT) * [[Nearest neighbor search]] (NNS) * [[Cutting stock problem]] * [[False noise analysis]] (FNA) Branch-and-bound may also be a base of various [[heuristic]]s. For example, one may wish to stop branching when the gap between the upper and lower bounds becomes smaller than a certain threshold. This is used when the solution is "good enough for practical purposes" and can greatly reduce the computations required. This type of solution is particularly applicable when the cost function used is [[noise|''noisy'']] or is the result of [[statistics|statistical estimates]] and so is not known precisely but rather only known to lie within a range of values with a specific [[probability]]. An example of its application here is in [[biology]] when performing [[cladistics|cladistic analysis]] to evaluate evolutionary relationships between organisms, where the data sets are often impractically large without heuristics. For this reason, branch-and-bound techniques are often used in [[game tree]] [[search algorithm]]s, most notably through the use of [[alpha-beta pruning]]. ==See also== * [[A* search algorithm]] * [[Algorithm#By_design_paradigm|Classes of algorithms by design paradigm]] ==References== {{Reflist}} {{DEFAULTSORT:Branch And Bound}} [[Category:Optimization algorithms]] [[Category:Combinatorial optimization]] [[ca:Sudoku ramificació i poda]] [[cs:Metoda větví a mezí]] [[de:Branch-and-Bound]] [[es:Ramificación y poda]] [[fr:Séparation et évaluation]] [[ko:분기 한정법]] [[it:Branch and bound]] [[ja:分枝限定法]] [[ru:Метод ветвей и границ]] [[uk:Метод гілок і меж]] {{Optimization algorithms}}</text> </page> <page> <id>4448</id> <title>Branch misprediction</title> <text>{{Unreferenced|date=December 2009}} '''Branch misprediction''' occurs when a [[central processing unit]] (CPU) mispredicts the next instruction to process in [[branch prediction]], which is aimed at speeding up execution. During the execution of certain programs there are places where the program execution flow can continue in several ways. These are called [[Branch (computer science)|branch]]es, or conditional jumps. The CPU also uses a [[Pipeline (computing)|pipeline]] which allows several instructions to be processed at the same time. When the code for a conditional jump is read we do not yet know the next instruction to execute and insert into the execution pipeline. This is where [[branch prediction]] comes in. {{Main|branch predictor}} Branch prediction guesses the next instruction to execute and inserts the next assumed instruction to the pipeline. Guessing wrong is called branch misprediction. The partially processed instructions in the pipeline after the branch have to be discarded and the pipeline has to start over at the correct branch when a branch misprediction is detected. This slows down the program execution. {{DEFAULTSORT:Branch Misprediction}} [[Category:Instruction processing]]</text> </page> <page> <id>4460</id> <title>Brandon-Hill list</title> <text>{{Orphan|date=September 2008}} The '''Brandon-Hill list''' is a list of [[Academic journal|journals]] and [[book]]s recommended for a small [[hospital]] library. Compiled by Alfred Brandon and Dorothy Hill,<ref>{{cite 