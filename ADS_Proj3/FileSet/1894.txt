four items and proceeds to produce the next item: fibs = 0 : 1 : 1 : 2 : 3 : 5 : ... + + + + + + tail fibs = 1 : 1 : 2 : 3 : 5 : ... = = = = = = zipWith ... = 1 : 2 : 3 : 5 : '''8''' : ... fibs = 0 : 1 : 1 : 2 : 3 : 5 : '''8''' : ... The same function, written using GHC's [[parallel list comprehension]] syntax (GHC extensions must be enabled using a special command-line flag '-fglasgow-exts'; see GHC's manual for more): <source lang="haskell"> fibs = 0 : 1 : [ a+b | a <- fibs | b <- tail fibs ] </source> The factorial we saw previously can be written as a sequence of functions: <source lang="haskell"> factorial n = (foldr (.) id [\x -> x*k | k <- [1..n]]) 1 </source> A remarkably concise function that returns the list of [[Hamming numbers]] in order: <source lang="haskell"> hamming = 1 : map (2*) hamming `merge` map (3*) hamming `merge` map (5*) hamming where merge (x:xs) (y:ys) | x < y = x : xs `merge` (y:ys) | x > y = y : (x:xs) `merge` ys | otherwise = x : xs `merge` ys </source> Like the various <code>fibs</code> solutions displayed above, this uses corecursion to produce a list of numbers on demand, starting from the base case of 1 and building new items based on the preceding part of the list. In this case the producer <code>merge</code> is defined in a <code>where</code> clause and used as an operator by enclosing it in back-quotes. <!-- Apart from the different application syntax, operators are like functions whose name consists of symbols instead of letters. Each vertical bar <code>|</code> starts a guard clause with a guard before the equals sign and the corresponding definition after the equals sign. --> The branches of the guards define how <code>merge</code> merges two ascending lists into one ascending list without duplicate items. == Syntax == === Layout === Haskell allows indentation to be used to indicate the beginning of a new declaration. For example, in a ''where'' clause: <source lang="haskell"> product xs = prod xs 1 where prod [] a = a prod (x:xs) a = prod xs (a*x) </source> The two equations for the nested function <tt>prod</tt> are aligned vertically, which allows the semi-colon separator to be omitted. In Haskell, indentation can be used in several syntactic constructs, including <tt>do</tt>, <tt>let</tt>, <tt>case</tt>, <tt>class</tt>, and <tt>instance</tt>. The use of indentation to indicate program structure originates in [[Peter_J._Landin|Landin]]'s [[ISWIM]] language, where it was called the [[off-side rule]]. This was later adopted by [[Miranda_(programming_language)|Miranda]], and Haskell adopted a similar (but rather more complicated) version of Miranda's off-side rule, which it called "layout". Other languages to adopt whitespace-sensitive syntax include [[Python (programming language)|Python]] and [[F Sharp (programming language)|F#]]. The use of layout in Haskell is optional. For example, the function <tt>product</tt> above can also be written: <source lang="haskell"> product xs = prod xs 1 where { prod [] a = a; prod (x:xs) a = prod xs (a*x) } </source> The explicit open brace after the <tt>where</tt> keyword indicates that the programmer has opted to use explicit semi-colons to separate declarations, and that the declaration-list will be terminated by an explicit closing brace. One reason for wanting support for explicit delimiters is that it makes automatic generation of Haskell source code easier. Haskell's layout rule has been criticised for its complexity. In particular, the definition states that if the parser encounters a parse error during processing of a layout section, then it should try inserting a close brace (the "parse error" rule). Implementing this rule in a traditional [[parsing]]/[[Lexical_analysis|lexical-analysis]] combination requires two-way cooperation between the parser and lexical analyser, whereas in most languages these two phases can be considered independently. === Function calls === Applying a function <tt>f</tt> to a value <tt>x</tt> is expressed as simply <tt>f x</tt>. Haskell distinguishes function calls from infix operators syntactically, but not semantically. Function names which are composed of punctuation characters can be used as operators, as can other function names if surrounded with backticks; and operators can be used in prefix notation if surrounded with parentheses. This example shows the ways that functions can be called: <source lang="haskell"> add a b = a + b ten1 = 5 + 5 ten2 = (+) 5 5 ten3 = add 5 5 ten4 = 5 `add` 5 </source> Functions which are defined as taking several parameters can always be partially applied. Binary operators can be partially applied using ''section'' notation: <source lang="haskell"> ten5 = (+ 5) 5 ten6 = (5 +) 5 addfive = (5 +) ten7 = addfive 5 </source> === List comprehensions === See [[List_comprehension#Overview]] for the Haskell example. === Pattern matching === [[Pattern matching]] is used to match on the different constructors of algebraic data types. Here are some functions, each using pattern matching on each of the types above: <source lang="haskell"> -- This type signature says that empty takes a list containing any type, and returns a Bool empty :: [a] -> Bool empty (x:xs) = False empty [] = True -- Will return a value from a Maybe a, given a default value in case a Nothing is encountered fromMaybe :: a -> Maybe a -> a fromMaybe x (Just y) = y fromMaybe x Nothing = x isRight :: Either a b -> Bool isRight (Right _) = True isRight (Left _) = False getName :: Person -> String getName (Person name _ _) = name getSex :: Person -> Sex getSex (Person _ sex _) = sex getAge :: Person -> Int getAge (Person _ _ age) = age </source> Using the above functions, along with the [[Map (higher-order function)|<code>map</code>]] function, we can apply them to each element of a list, to see their results: <source lang="haskell"> map empty [[1,2,3],[],[2],[1..]] -- returns [False,True,False,False] map (fromMaybe 0) [Just 2,Nothing,Just 109238, Nothing] -- 