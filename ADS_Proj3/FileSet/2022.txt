custom enclosure. When he removed the back cover of the device, he found a [[Socket 7]] [[CPU socket]] with a 180 MHz [[Integrated Device Technology|IDT]] [[WinChip|WinChip C6]] CPU, a [[SO-DIMM]] socket, an [[Integrated Drive Electronics|IDE]] plug (which allowed adding a [[hard drive]] and [[CD drive|CD-ROM]], making the device nothing less than a $99 PC with an [[LCD screen]]), and a 16 MB [[SanDisk]] memory chip. However, the pins on the IDE connector were reversed, requiring the making or ordering of special cables and adapters to connect a hard drive to the unit. Attempts by i-Opener to thwart hacking included gluing the [[BIOS]] chip into its socket with [[epoxy]] and modifying its settings (rendering it unable to detect hard drives), limiting the type of CPU one could use to that included with the unit, and even cutting the pins on the IDE [[Electrical connector|connector]]. ==External links== {{Commons category|i-Opener}} * [http://www.linux-hacker.net/ Modding] information from Linux-hacker.net * [http://www.evernex.com/iopener/ Modding] information from Evernex.com * [http://fastolfe.net/misc/i-opener-faq.html Modding] information from Fastolfe.net * [http://www.stonekeep.com/iopener.php Modding] information from Stonekeep.com, including diskless boot image * [http://flickr.com/photos/blakespot/2389644414/] Photo of a modded i-Opener motherboard * [http://m4i.homeip.net/ M4I] A Linux distribution (for the on-board 16MB flash) which includes the Opera Web Browser * [http://tengu.homeip.net/midori/ M4I alternate site] [[Category:Information appliances]] [[Category:1999 introductions]]</text> </page> <page> <id>17233</id> <title>I/O bound</title> <text>In [[computer science]], '''I/O bound''' refers to a condition in which the time it takes to complete a [[computation]] is determined principally by the period of time spent waiting for [[input/output]] operations to be completed. This is the opposite of a task being [[CPU bound]]. This circumstance arises when the rate at which [[data]] is requested is slower than the rate it is consumed or, in other words, more time is spent requesting data than processing it. ==I/O bound as an inherent problem in computing== {{misleading|date=March 2008}}<!-- I/O in this case does not refer to "CPU-to-memory" but exclusively "CPU-to-peripheral"; the whole von Neumann bottleneck story therefore DOES NOT apply to "I/O bound" --> The I/O bound state has been identified as a problem in computing almost since its inception. The [[Von Neumann architecture]], which is employed by many computing devices ever conceived, is based on a logically-separate [[central processor unit]] which requests data from [[main memory]],{{Clarify|date=February 2009}} <!-- main memory access is not I/O access! --> processes it and writes back the results. Since data must be moved between the CPU and memory along a [[Bus (computing)|bus]] which has a limited [[data transfer rate]], there exists a condition that is known as the [[Von Neumann architecture#von Neumann bottleneck|Von Neumann bottleneck]]. Put simply, this means that the data [[Bandwidth (computing)|bandwidth]] between the CPU and memory tends to limit the overall speed of computation. In terms of the actual technology that makes up a computer, the Von Neumann Bottleneck predicts that it is easier to make the CPU perform calculations faster than it is to supply it with data at the necessary rate for this to be possible. In recent history, the Von Neumann bottleneck has become more apparent. The design philosophy of modern computers is based upon a physically-separate CPU and main memory. It is possible to make the CPU run at a high data transfer rate because data is moved between locations inside them across tiny distances. The physical separation between CPU and main memory, however, requires a data bus to move data across comparatively long distances of centimetres or more. The problem of making this part of the system operate sufficiently fast to keep up with the CPU has been a great challenge to designers. ==I/O bound as a practical problem== The I/O bound state is considered undesirable because it means that the [[central processing unit|CPU]] must stall its operation while waiting for data to be loaded or unloaded from [[main memory]] or [[secondary storage]]. With faster computation speed being the primary goal of new computer designs and components such as the CPU and memory being expensive, there is a strong imperative to avoid I/O bound states and eliminating them can yield a more economic improvement in performance than upgrading the CPU or memory. ==References== {{Unreferenced|date=April 2007}} [[Category:Input/output]] {{software-eng-stub}} [[pt:I/O bound]]</text> </page> <page> <id>17235</id> <title>I/O scheduling</title> <text>{{about||process scheduling|scheduling (computing)|process management|process management (computing)}} Input / Output Scheduling or '''I/O Scheduling''' is a term used to describe the method [[computer]] [[operating system]]s decide the order that block [[Input/output|I/O]] operations will be submitted to [[Volume (computing)|storage volumes]]. I/O Scheduling is sometimes called 'disk scheduling'. ==Purpose== I/O schedulers can have many purposes depending on the goal of the I/O scheduler, some common goals are: * To minimize time wasted by [[hard disk]] seeks. * To prioritize a certain [[process (computing)|processes]]' I/O requests. * To give a share of the disk bandwidth to each running process. * To guarantee that certain requests will be issued before a particular deadline. ==Implementation== I/O Scheduling usually has to work with hard disks which share the property that there is long [[Access Time|access time]] for requests which are far away from the current position of the disk head (this operation is called a seek). To minimize the effect this has on system performance, most I/O schedulers implement a variant of the [[elevator algorithm]] which re-orders the incoming randomly ordered requests into the order in which they will be found on the disk. ==Common disk scheduling disciplines== * [[Random Scheduling]] (RSS) * First In, First Out ([[FIFO (computing)|FIFO]]), also known as First Come First Served (FCFS) * Last In, First Out ([[LIFO (computing)|LIFO]]) * [[Shortest seek first]], also known as Shortest Seek / Service Time First (SSTF) * [[Elevator algorithm]], also known as SCAN (including its variants, C-SCAN, LOOK, and C-LOOK) * [[N-Step-SCAN]] SCAN of N records at a time * [[FSCAN]], N-Step-SCAN where N equals queue size at start of the SCAN cycle. * [[CFQ|Completely Fair Queuing (Linux)]] * [[Anticipatory scheduling]] * [[Noop scheduler]] * [[Deadline scheduler]] ==See also== * [[Tagged Command Queuing]] (TCQ) * [[Native Command Queuing]] (NCQ) ==References== *[[Robert Love|Love, R.]] (2005). ''Linux Kernel Development'', Novell Press. ISBN 0-672-32720-1 [[Category:Disk scheduling algorithms]] 