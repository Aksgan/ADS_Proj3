(or all currently existing clusters) equally for each 'clustering decision' and do not perform heuristic weighting based on the distance between these data points. ==Advantages with BIRCH== It is local in that each clustering decision is made without scanning all data points and currently existing clusters. It exploits the observation that data space is not usually uniformly occupied and not every data point is equally important. It makes full use of available memory to derive the finest possible sub-clusters while minimizing I/O costs. It is also an incremental method that does not require the whole [[data set]] in advance. ==BIRCH Clustering Algorithm== For this first we define the following concepts:: Clustering Feature : Given N d-dimensional data points in a cluster, <math>X_i</math>, <math>CF</math> vector of the cluster is defined as a triple <math>CF = (N,LS,SS)</math>, where <math>LS</math> is the linear sum and <math>SS</math> is the square sum of data points. CF tree : A CF tree is a height [[Self-balancing binary search tree|balanced tree]] with two parameters: [[branching factor]] <math>B</math> and threshold <math>T</math>. Each non-leaf node contains at most <math>B</math> entries of the form <math>[CF_i,child_i]</math>, where <math>child_i</math> is a pointer to its <math>i</math>th [[Tree (data structure)|child node]] and <math>CF_i</math> is the subcluster represented by this child. A [[leaf node]] contains at most <math>L</math> entries each of the form <math>[CF_i]</math> . It also has to two pointers prev and next which are used to chain all leaf nodes together. The tree size is a function of T. The larger the T is, the smaller the tree is. We also require a node to fit in a page of size of p. B and L are determined by P. So P can be varied for [[performance tuning]]. It is a very compact representation of the dataset because each entry in a leaf node is not a single data point but a subcluster. In the algorithm in the first step it scans all data and builds an initial memory CF tree using the given amount of memory. In the second step it scans all the leaf entries in the initial CF tree to rebuild a smaller CF tree, while removing outliers and grouping crowded subclusters into larger ones. In step three we use an existing clustering algorithm to cluster all leaf entries. Here an agglomerative hierarchial clustering algorithm is applied directly to the subclusters represented by their CF vectors. It also provides the flexibiltiy of allowing the user to specify either the desired number of clusters or the desired diameter threshold for clusters. After this step we obtain a set of clusters that captures major distribution pattern in the data. However there might exist minor and localized inaccuracies which can be handled by an optional step 4. In step 4 we use the centroids of the clusters produced in step as seeds and redistribute the data points to its closest sees to obtain a new set of clusters. Step 4 also provides us with an option of discarding outliers. That is a point which is too far from its closest seed can be treated as an outlier. ==Awards== It has received <ref>{{Literatur | url = http://www.sigmod.org/sigmod-awards/citations/2006-sigmod-test-of-time-award-1 | Titel = http://www.sigmod.org/sigmod-awards/citations/2006-sigmod-test-of-time-award-1 }}</ref> the SIGMOD 10 year test of time award. ==External links== * http://people.cs.ubc.ca/~rap/teaching/504/2005/slides/Birch.pdf ==Notes== {{Reflist}} {{DEFAULTSORT:Birch (Data Clustering)}} [[Category:Data clustering algorithms]]</text> </page> <page> <id>3142</id> <title>BLIS/COBOL</title> <text>{{Unreferenced stub|auto=yes|date=December 2009}} {{See also|BLISS (programming language)}} {{Infobox OS | name = BLIS/COBOL | logo = | screenshot = | caption = | developer = | source_model = | kernel_type = | supported_platforms = [[Data General Nova]] and [[Data General Eclipse]] [[16-bit]] [[minicomputer]]s | ui = | family = | released = | latest_release_version = | latest_release_date = | latest_test_version = | latest_test_date = | marketing_target = | programmed_in = [[COBOL]] | prog_language = | language = | updatemodel = | package_manager = | working_state = Historic | license = | website = }} '''BLIS/COBOL''' was an [[operating system]] that, unusually, was written in [[COBOL]]. It is the only such system to gain reasonably wide acceptance. It was optimised to [[compile]] business application written in COBOL. BLIS was available on a range of [[Data General Nova]] and [[Data General Eclipse]] [[16-bit]] [[minicomputer]]s. Originally, most operating systems were written in [[assembly language]] for a particular [[central processing unit|processor]] or family of processors. Non-assembler operating systems were comparatively slow, but were easier for revision and repair. One of the reasons for the [[C (programming language)|C]] programming language's low-level features, which resemble assembly language in some ways, is an early intent to use it for writing operating systems. Similar goals led to [[IBM]]'s development of [[IBM PL/S|PL/S]]. The high-level nature of COBOL, which created some problems for operating system development, was partially addressed in BLIS, since it was deliberately optimised for COBOL. {{DEFAULTSORT:Blis/Cobol}} [[Category:Discontinued operating systems]] [[Category:COBOL]] {{Operating-system-stub}}</text> </page> <page> <id>3143</id> <title>BLISS</title> <text>{{Infobox programming language | name = BLISS | logo = | paradigm = [[structured programming|structured]], [[Imperative programming|imperative]] ([[procedural programming|procedural]]) | year = 1970 | designer = [[W. A. Wulf]], [[D. B. Russell]], [[A. N. Habermann]] | developer = [[Carnegie Mellon University]] | latest_release_version = BLISS-64 <!--({{release date|mf=yes|YYYY|MM|DD}})--> | latest release date = | typing = typeless | implementations = | dialects = Common BLISS | influenced_by = [[ALGOL]] | influenced = | operating_system = [[Cross-platform]]: [[PDP-10]], [[PDP-11]], [[DEC Alpha]], [[DEC PRISM]], [[IA-32|Intel IA-32]], [[IA-64|Intel IA-64]], [[VAX]] | license = | website = | file_ext = }} '''BLISS''' is a [[system programming language]] developed at [[Carnegie Mellon University]] by [[W. A. Wulf]], [[D. B. Russell]], and [[A. N. Habermann]] around 1970. It was perhaps the best known systems programming language right up until [[C (programming language)|C]] made its debut a few years later. Since then, C took off and BLISS faded into obscurity. When C was in its infancy, a few projects within [[Bell Labs]] were debating the merits of BLISS vs. C. BLISS is a typeless block-structured language based on expressions rather than statements, and includes constructs for [[exception handling]], [[coroutine]]s, and [[Macro (computer science)|macros]]. It does not include 