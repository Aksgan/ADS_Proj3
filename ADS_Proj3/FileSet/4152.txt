with a sorted list. While the LSD radix sort requires the use of a stable sort, the MSD radix sort algorithm does not (unless stable sorting is desired). In-place MSD radix sort is not stable. It is common for the [[counting sort]] algorithm to be used internally by the radix sort. Hybrid sorting approach, such as using [[insertion sort]] for small bins improves performance of radix sort significantly. === Distribution sort === ''Distribution sort'' refers to any sorting algorithm where data is distributed from its input to multiple intermediate structures which are then gathered and placed on the output. See [[Bucket sort]]. === Timsort === {{Main|Timsort}} ''Timsort'' finds runs in the data, creates runs with insertion sort if necessary, and then uses merge sort to create the final sorted list. It has the same complexity (O(nlogn)) in the average and worst cases, but with pre-sorted data it goes down to O(n). == Memory usage patterns and index sorting == When the size of the array to be sorted approaches or exceeds the available primary memory, so that (much slower) disk or swap space must be employed, the memory usage pattern of a sorting algorithm becomes important, and an algorithm that might have been fairly efficient when the array fit easily in RAM may become impractical. In this scenario, the total number of comparisons becomes (relatively) less important, and the number of times sections of memory must be copied or swapped to and from the disk can dominate the performance characteristics of an algorithm. Thus, the number of passes and the localization of comparisons can be more important than the raw number of comparisons, since comparisons of nearby elements to one another happen at [[computer bus|system bus]] speed (or, with caching, even at [[Central Processing Unit|CPU]] speed), which, compared to disk speed, is virtually instantaneous. For example, the popular recursive [[quicksort]] algorithm provides quite reasonable performance with adequate RAM, but due to the recursive way that it copies portions of the array it becomes much less practical when the array does not fit in RAM, because it may cause a number of slow copy or move operations to and from disk. In that scenario, another algorithm may be preferable even if it requires more total comparisons. One way to work around this problem, which works well when complex records (such as in a [[relational database]]) are being sorted by a relatively small key field, is to create an index into the array and then sort the index, rather than the entire array. (A sorted version of the entire array can then be produced with one pass, reading from the index, but often even that is unnecessary, as having the sorted index is adequate.) Because the index is much smaller than the entire array, it may fit easily in memory where the entire array would not, effectively eliminating the disk-swapping problem. This procedure is sometimes called "tag sort".<ref>[http://www.pcmag.com/encyclopedia_term/0,2542,t=tag+sort&i=52532,00.asp Definition of "tag sort" according to PC Magazine]</ref> Another technique for overcoming the memory-size problem is to combine two algorithms in a way that takes advantages of the strength of each to improve overall performance. For instance, the array might be subdivided into chunks of a size that will fit easily in RAM (say, a few thousand elements), the chunks sorted using an efficient algorithm (such as [[quicksort]] or [[heapsort]]), and the results merged as per [[mergesort]]. This is less efficient than just doing mergesort in the first place, but it requires less physical RAM (to be practical) than a full quicksort on the whole array. Techniques can also be combined. For sorting very large sets of data that vastly exceed system memory, even the index may need to be sorted using an algorithm or combination of algorithms designed to perform reasonably with [[virtual memory]], i.e., to reduce the amount of swapping required. ==Inefficient/humorous sorts== These are algorithms that are extremely slow compared to those discussed above &mdash; [[Bogosort]] <math>O(n\cdot n!)</math>, [[Stooge sort]] <math> O(n^{2.7})</math>. == See also == * [[External sorting]] * [[Sorting network]]s (compare) * [[Cocktail sort]] * [[Collation]] * [[Schwartzian transform]] * [[Shuffle#Shuffling algorithms|Shuffling algorithms]] * [[Search algorithm]]s * [[b:A-level Mathematics/D1/Algorithms|Wikibooks: Algorithms]]: Uses sorting a deck of cards with many sorting algorithms as an example ==References== {{More footnotes|date=September 2009}} {{Reflist}} * [[D. E. Knuth]], ''[[The Art of Computer Programming]], Volume 3: Sorting and Searching''. == External links== {{wikibooks|Algorithm implementation|Sorting|Sorting algorithms}} * [http://www.sorting-algorithms.com/ Sorting Algorithm Animations] - Graphical illustration of how different algorithms handle different kinds of data sets. * [http://www.iti.fh-flensburg.de/lang/algorithmen/sortieren/algoen.htm Sequential and parallel sorting algorithms] - Explanations and analyses of many sorting algorithms. * [http://www.nist.gov/dads/ Dictionary of Algorithms, Data Structures, and Problems] - Dictionary of algorithms, techniques, common functions, and problems. * [http://www.softpanorama.org/Algorithms/sorting.shtml Slightly Skeptical View on Sorting Algorithms] Discusses several classic algorithms and promotes alternatives to the [[quicksort]] algorithm. {{sorting}} {{DEFAULTSORT:Sorting Algorithm}} [[Category:Sorting algorithms|* Sort algorithms]] [[ar:خوارزميات الترتيب]] [[ca:Algorisme d'ordenació]] [[cs:Řadicí algoritmus]] [[da:Sorteringsalgoritme]] [[de:Sortierverfahren]] [[et:Sortimisalgoritm]] [[es:Algoritmo de ordenamiento]] [[fa:الگوریتم مرتب‌سازی]] [[fr:Algorithme de tri]] [[ko:정렬 알고리즘]] [[is:Röðunarreiknirit]] [[it:Algoritmo di ordinamento]] [[he:מיון (מדעי המחשב)]] [[ku:Algorîtmayê rêzkerdişî]] [[lv:Datu šķirošanas algoritmi]] [[lb:Zortéieralgorithmus]] [[lt:Rikiavimo algoritmas]] [[hu:Rendezés (programozás)]] [[nl:Sorteeralgoritme]] [[ja:ソート]] [[no:Sorteringsalgoritme]] [[pl:Sortowanie]] [[pt:Algoritmo de ordenação]] [[ru:Алгоритм сортировки]] [[sk:Triediaci algoritmus]] [[sl:Algoritmi za urejanje podatkov]] [[fi:Lajittelualgoritmi]] [[sv:Sorteringsalgoritm]] [[ta:வரிசையாக்கப் படிமுறை]] [[th:ขั้นตอนวิธีการเรียงลำดับ]] [[tr:Sıralama algoritması]] [[uk:Алгоритм сортування]] [[vi:Thuật toán sắp xếp]] [[zh:排序算法]]</text> </page> <page> <id>35125</id> <title>SoundEdit</title> <text>{{For|the music festival|SOUNDEDIT}} {{Unreferenced stub|auto=yes|date=December 2009}} [[Image:SoundEdit-icon.gif|frame|right|SoundEdit icon]] '''SoundEdit''' was the first popular GUI-based audio editor for digitized audio. It was not only one of the first important audio applications for Macintosh, but one of the first significant audio applications for personal computers in general. SoundEdit was one of three audio applications created during a sabbatical by [[Steve Capps]] during 1986. The Macintosh had no built-in sound input, so the MacRecorder audio digitizer was invented for this purpose in 1985 by Michael Lamoureux, a mathematics student at the University of California, Berkeley. The MacRecorder hardware and software was publicly released through the [[Berkeley Macintosh Users Group]] as a kit in late 1985. SoundEdit first shipped in January 1988, as part of a hardware product called 