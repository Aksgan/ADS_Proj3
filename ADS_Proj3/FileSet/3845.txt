of the Float-Menu, when double-clicking on the suspected Label. Then, once the Application is correctly re-compiled, it may also misbehave because of several minor points, that you may have to fix by hand, after analysis. '''Purpose and scope''' The Disassembler will remain under intensive development for several months. In its final state, it will be a universal Decompiler outputting a complete restoration of the Targeted File, ready for re-compilation in a significant amount of cases. Even in case of failure of the full "Two-Clicks-Disassembler-ReAssembler" process, the results will often be usable, at least, for study and for helping at the translation works. The Disassembler is a Study and Translation Tool designed for the Open Source Movement. The main goal is to make the translations of Demos and Tuts to RosAsm syntax, as easy and fast as possible. Even when having the Sources, a port to Assembly may be not so easy, with big files. We can be sure that the Disassembler will, at least, make fewer translation errors, and will take much less of our working time than we would when translating it by hand. === More features === * Complete set of windows api equates (63763 equates) * Set of 1677 windows api structures * Icon Editor * Resources Editor (Dialogs, menus, strings, images, icons, RC Data) * Guid listing * Tree view listing of data, labels, functions used in the source code * Powerful macro system * Assembly tutorials and demos * Dll, Imports and Exports Scanner * Api Listing * Encoding Tool to analyse small chuncks of code * Code completion * Separation of huge sources by titles * Structure Viewer * Compilation Statistics * Complete executable Help file (named as B_U_Asm) * User defined [[Integrated development environment|IDE]] styles. * Configurable Toolbar '''Note:''' The colors of the images displayed here were made by one of the developers. They are not the default from RosAsm. <gallery> File:RosAsmUserMacro.png| RosAsm user defined macro set File:RosAsmTitleSeparation.png| RosAsm monolitic source separated by Titles File:RosAsmStructureViewer.png| RosAsm structure viewer File:RosAsmGuidViewer.png| RosAsm Guid Viewer File:RosAsmIconEditor.png| RosAsm icon Editor File:RosAsmApiListing.png| RosAsm Api listing File:RosAsmConfiguration.png| RosAsm Configuration Dialog File:RosAsmDllScanner.png| RosAsm Dll Scanner File:RosAsmDialogEditor.png| RosAsm Dialog Editor File:RosAsmEncodingTool.png| RosAsm Encoding Tool File:RosAsmTreeView.png| RosAsm Treeview listing labels, functions, data declarations File:RosAsmCompilation.png| RosAsm compilation statistics </gallery> == Game creation == There are few games created with RosAsm. A remarkable programmer called [http://www.chez.com/asmgges/index.htm GGes] built some interesting and entertaining open source games with RosAsm. Another programmer called [http://nessie.emubase.de Martin] created a remarkable NES emulator called [[Nessie (emulator)]] in a short period of time using RosAsm. <gallery> File:RosAsmGamePacMan.png|Packman game made with RosAsm File:RosAsmGameSnake.png|Snake game made with RosAsm File:RosAsmGameSpace.png|Spacegame made with RosAsm File:RosAsmGameNessie.png|Nessie NES emulator made with RosAsm </gallery> Assembly is a language suitable for creating all sort of applications, and in what concern game development this assertive couldnÂ´t be more true. == Ongoing projects and future == As an opensource program, RosAsm is in constant evolution. The developers works hard to bring to the assembly community a full integrated programming environment, where the creation of programs can be made as easy and fast as possible. RosAsm developers are working hard on the current projects: * In the coming months developments will focus upon the Disassembler, and this will go on, until then Disassembles may be recompiled without (or with very little) hand work, this is to say that it will no more be a Disassembler, but, better said a Decompiler. The perfect state, in which we could guarantee disassembling, interpreting, re-compiling, without any hand work at all, will never be completely achieved, because the interpretation of all the data and what that Data means, inside a PE is not always 100% possible. Most interpretations are based upon probabilities. Nothing more. But, applied on simple Files, or upon Files produced by the user himself, in another language, the outputted results should be worthy of the actual effort, as this implementation will turn RosAsm disassembler onto a full universal decompiler software. * Pre-Parsers will possibly be added. Actually, the Equal_Parser is implemented. The OOA Pre-Parser development is delayed, but the overall plans of its organization and syntax are now well defined (as far as possible). The developers are thinking of using OOA Plans for a first experiment of structured collective Development, as indicated in the above Introduction. Other Pre-Parsers, for example, HLLs ones, like the Equal one, may be added if some volunteers want to. The developers opened a new TITLE inside RosAsm source, whose name is "NewParser", given as a start point, for volunteers implementations. It includes comments that, should help to start working under good conditions. * Wizards (components visual designers) will be implemented, the same way the actual Form Wizard is, either at the end of RosAsm development. The Wizards may physically come under the form of a side DLL, or of an independent EXE, grouping all of the various specific Wizards (for ToolBars, for Images Viewers, and so on), probably around the actual Form Wizard. * The Win32 free documentation project is yet up and running. Its purpose is to have a kind of Data Base for all Win32 Data, immediately available from inside RosAsm, either by a Dialog for viewing Api calls, Equates and Structures, or as directly available informations for the Disassembler HLL interpretations. The huge work for Equates has already been achieved, thanks to Guga. * A Code-Ripper is to be implemented. Its purpose will be to select (after Double-Click upon a Code Label, and user selection of an added [Code Ripper] Option), all of the downward tree of the Routines called from this Label Procedure, with all concerned Data. Useful from disassemblies or for Code Reuse. * A Code symbolic Profiler is also to be implemented. Its purpose will be of outputting something a bit like the Tree-View Dialog, but with an added Bar, at each Label, representing the proportional time each Routine will have been consuming in a given Run. Useful for Strategy Optimizations (the only serious one). * A Code Level Profiler may be 