using a category). Once your method is inserted, RubyCocoa will retrieve the signature of the existing Objective-C method and inject a new one to the Objective-C runtime, of the same signature, but which now points to your code. To accomplish this, RubyCocoa uses the [[libffi]] library to dynamically create a closure that will call the Ruby method, and just passes a pointer to that new closure to the Objective-C runtime. === Accessing the C Bits === Due to the nature of the Objective-C language, you can freely use [[C (programming language)|C]] from Objective-C code. In order to bridge the relevant C parts of an Objective-C framework, such as C structures, functions, enumerations, constants and more, RubyCocoa relies on the [[BridgeSupport]] project. RubyCocoa will interpret at runtime the BridgeSupport files (using the very fast [[libXML]]2's xmlTextReader) and accordingly handle their content. It will for instance construct the Ruby proxy classes for the C structures and also create the functions. Note that the costly operations, such as localizing the symbols, are done on demand, and obviously only once. === Format Strings === RubyCocoa is able to detect APIs that use format strings, like NSLog or NSString.stringWithFormat, and appropriately convert the variable arguments to the types specified in the format string. === Function Pointers === RubyCocoa allows you to pass Ruby <code>Proc</code> objects as function pointer arguments. It will then use the [[libffi]] library to dynamically create a closure and pass it to the underlying function/method. == How to start a Cocoa application written in Ruby == When you install RubyCocoa, the corresponding [[Xcode]] templates are installed automatically. So when you start a new project, select ''Cocoa-Ruby Application '' project type and all necessary files will be generated. == How to call Objective-C methods from Ruby == To invoke an Objective-C method, you replace each colon in the method name except the last with an underscore. Thus, for example, the NSWindow instance method <code>initWithContentRect:styleMask:backing:defer:</code> becomes <code>initWithContentRect_styleMask_backing_defer</code>. All Cocoa classes and functions belong to <code>OSX</code> module, so for example, the Objective-C code: <source lang="objc"> [[NSWindow alloc] initWithContentRect:frame styleMask:NSTitledWindowMask backing:NSBackingStoreBuffered defer:NO] </source> will become: <source lang="ruby"> OSX::NSWindow.alloc.initWithContentRect_styleMask_backing_defer(frame, OSX::NSTitledWindowMask, OSX::NSBackingStoreBuffered, false) </source> As you can see, this decreases the code readability by rendering Objective-C parameter naming useless. So, there is another convenient way to write the method calls â€” the <code>objc_send</code> method, which accepts Ruby symbols as parameter names. For example, the previous code can also be written as: <source lang="ruby"> OSX::NSWindow.alloc.objc_send(:initWithContentRect, frame, :styleMask, OSX::NSTitledWindowMask, :backing, OSX::NSBackingStoreBuffered, :defer, false) </source> == Advantages of RubyCocoa == * As Ruby is an interpreted language, there's no need to recompile the application frequently during development. * Some of Ruby's rich features, like built-in [[regular expression]] support, make writing the code faster, and also make RubyCocoa an ideal tool for prototyping. == Disadvantages == * Ignoring the speed of the Ruby interpreter, RubyCocoa applications will always be slower than Objective-C/Cocoa applications due to the added overhead of object conversion. * Because Ruby isn't thread-safe, it isn't possible to dispatch multiple native threads to execute RubyCocoa code. Ruby's emulated threads, however, can be used. [[Category:Mac OS X software]] [[Category:Ruby programming language]]</text> </page> <page> <id>32550</id> <title>RubyMine</title> <text>{{Infobox Software | name = JetBrains RubyMine | developer = [[JetBrains]] | latest release version = 3.0.1 | latest release date = {{release date|2010|12|17}} | latest preview version = | latest preview date = | operating system = [[Microsoft Windows|Windows]], [[Mac OS X]], [[Linux]] | programming language = [[Java (programming language)|Java]], [[JRuby]] | genre = [[Integrated development environment for Ruby and Rails|Ruby/Rails IDE]] | license = [[Proprietary software|Proprietary]] | website = http://www.jetbrains.com/ruby }} '''JetBrains RubyMine''' is a commercial [[Integrated Development Environment|IDE]] for [[Ruby (programming language)|Ruby]] and [[Ruby on Rails]] built on JetBrains' [[IntelliJ IDEA]] platform. RubyMine provides intelligent code completion for Ruby and Rails code, on-the-fly code analysis and [[refactoring]] support for both plain [[Ruby (programming language)|Ruby]] projects and web applications built with [[Ruby on Rails]]. ==Key Features== In addition to the smart editor RubyMine offers a set of tools for complete development cycle: * Code refactorings for Ruby with knowledge about Rails specifics * [[RSpec]], Cucumber, Shoulda & Test::Unit test frameworks support with test-runner GUI * Specialized support for Rails i18n * Graphical Ruby Debugger * Model Dependency Diagram for Rails projects * Version Control Integrations: [[Subversion (software)|Subversion]], [[Git (software)|Git]], [[Perforce]], [[Concurrent Versions System|CVS]] supported out of the box with changelists and shelved changes * Open API for creating plugins in Ruby or Java ==IntelliJ IDEA Plugin for Ruby== JetBrains also creates [http://www.jetbrains.net/confluence/display/RUBYDEV Ruby plugin] for [[IntelliJ IDEA]]. Plugin provides similar functionality with RubyMine but also supports development with [[JRuby]]. ==See also== *[[Comparison of integrated development environments#Ruby|Comparison of integrated development environments]] ==External links== *[http://www.jetbrains.com/ruby JetBrains RubyMine official site] *[http://blogs.jetbrains.com/ruby JetBrains RubyMine blog] {{Ruby programming language}} [[Category:Integrated development environments]] [[Category:Ruby development tools]] [[Category:Ruby on Rails development tools]] [[Category:Ruby programming language]]</text> </page> <page> <id>32551</id> <title>RubySpec</title> <text>{{Infobox Software | name = RubySpec | logo = | screenshot = | caption = | developer = | latest release version = 0.7.4 | latest release date = {{release date|2010|08|18}} | year = 2006 | operating system = [[Cross-platform]] | programming language = [[Ruby (programming language)|Ruby]] | genre = Ruby programming language specifications tests | license = | website = [http://www.rubyspec.org/ www.rubyspec.org] }} The '''RubySpec''' project aims to write a complete executable specification for the [[Ruby (programming language)|Ruby programming language]]. This project contains specs that describe Ruby language syntax and [[Standard library|standard library]] classes. The project contains two main components: * the RubySpec sources * the MSpec framework The RubySpec test suite captures most of 1.8.6/1.8.7/1.9 behavior as a reference conformance tool. [[Ruby MRI]] 1.9.2 currently passes over 99% of RubySpec.<ref>{{cite web | url=http://www.ruby-lang.org/en/news/2010/08/18/ruby-1-9-2-is-released/ | title=Ruby 1.9.2 is released | accessdate=2010-10-23}}</ref> ==History== The RubySpec tests were initially created in 2006 for the [[Rubinius]] project, with significant contribution from the [[JRuby]] project<ref>{{cite web | url=http://www.rubyspec.org/ | title=RubySpec | quote=''The project began as part of Rubinius (now sponsored by Engine Yard) and most of the work was done by contributors to Rubinius, with 