system has a much lower defect rate than comparable systems.<ref name="hall"/> Since CSP is well-suited to modeling and analyzing systems that incorporate complex message exchanges, it has also been applied to the verification of communications and security protocols. A prominent example of this sort of application is Lowe’s use of CSP and the FDR refinement-checker to discover a previously unknown attack on the [[Needham-Schroeder protocol|Needham-Schroeder public-key authentication protocol]], and then to develop a corrected protocol able to defeat the attack.<ref>{{cite conference|first=G. |last=Lowe|title=Breaking and fixing the Needham-Schroeder public-key protocol using FDR|booktitle=Tools and Algorithms for the Construction and Analysis of Systems (TACAS)|pages=147–166.|publisher=Springer-Verlag|year=1996|url=http://citeseer.ist.psu.edu/lowe96breaking.html}}</ref> == Informal description == As its name suggests, CSP allows the description of systems in terms of component processes that operate independently, and interact with each other solely through [[message passing|message-passing]] communication. However, the ''"Sequential"'' part of the CSP name is now something of a misnomer, since modern CSP allows component processes to be defined both as sequential processes, and as the parallel composition of more primitive processes. The relationships between different processes, and the way each process communicates with its environment, are described using various [[process calculi|process algebraic]] operators. Using this algebraic approach, quite complex process descriptions can be easily constructed from a few primitive elements. === Primitives === CSP provides two classes of primitives in its process algebra: ;Events :Events represent communications or interactions. They are assumed to be indivisible and instantaneous. They may be atomic names (e.g. <math>\mathit{on}</math>, <math>\mathit{off}</math>), compound names (e.g. <math>valve.open</math>, <math>valve.close</math>), or input/output events (e.g. <math>mouse?xy</math>, <math>screen!bitmap</math>). ;Primitive processes: :Primitive processes represent fundamental behaviors: examples include <math>\mathit{STOP}</math> (the process that communicates nothing, also called [[deadlock]]), and <math>\mathit{SKIP}</math> (which represents successful termination) === Algebraic operators === CSP has a wide range of algebraic operators. The principal ones are: ;Prefix :The prefix operator combines an event and a process to produce a new process. For example, ::<math>a \rightarrow P</math> :is the process which is willing to communicate <math>\mathit{a}</math> with its environment, and, after <math>\mathit{a}</math>, behaves like the process <math>\mathit{P}</math>. ;Deterministic Choice :The deterministic (or external) choice operator allows the future evolution of a process to be defined as a choice between two component processes, and allows the environment to resolve the choice by communicating an initial event for one of the processes. For example, ::<math>\left(a \rightarrow P\right) \Box \left(b \rightarrow Q\right)</math> :is the process which is willing to communicate the initial events <math>\mathit{a}</math> and <math>\mathit{b}</math>, and subsequently behaves as either <math>\mathit{P}</math> or <math>\mathit{Q}</math> depending on which initial event the environment chooses to communicate. If both <math>\mathit{a}</math> and <math>\mathit{b}</math> were communicated simultaneously the choice would be resolved nondeterministically. ;Nondeterministic Choice :The nondeterministic (or internal) choice operator allows the future evolution of a process to be defined as a choice between two component processes, but does not allow the environment any control over which of the component processes will be selected. For example, ::<math>\left(a \rightarrow P\right) \sqcap \left(b \rightarrow Q\right)</math> :can behave like either <math>\left(a \rightarrow P\right)</math> or <math>\left(b \rightarrow Q\right)</math>. It can refuse to accept <math>\mathit{a}</math> or <math>\mathit{b}</math>, and is only obliged to communicate if the environment offers both <math>\mathit{a}</math> and <math>\mathit{b}</math>. Nondeterminism can be inadvertently introduced into a nominally deterministic choice if the initial events of both sides of the choice are identical. So, for example, ::<math>\left(a \rightarrow a \rightarrow STOP\right) \Box \left(a \rightarrow b \rightarrow STOP\right)</math> :is equivalent to ::<math>a \rightarrow \left(\left(a \rightarrow STOP\right) \sqcap \left(b \rightarrow STOP\right)\right)</math> ;Interleaving :The interleaving operator represents completely independent concurrent activity. The process ::<math>P \;\vert\vert\vert\; Q</math> :behaves as both <math>\mathit{P}</math> and <math>\mathit{Q}</math> simultaneously. The events from both processes are arbitrarily interleaved in time. ;Interface Parallel :The interface parallel operator represents concurrent activity that requires synchronization between the component processes &ndash; any event in the interface set can only occur when ''all'' component processes are able to engage in that event. For example, the process ::<math>P \left\vert\left[ \left\{ a \right\} \right]\right\vert Q</math> :requires that <math>\mathit{P}</math> and <math>\mathit{Q}</math> must both be able to perform event <math>\mathit{a}</math> before that event can occur. So, for example, the process ::<math>\left(a \rightarrow P\right) \left\vert\left[ \left\{ a \right\} \right]\right\vert \left(a \rightarrow Q\right)</math> :can engage in event <math>\mathit{a}</math>, and become the process ::<math>P \left\vert\left[ \left\{ a \right\} \right]\right\vert Q</math> :while ::<math>\left (a \rightarrow P\right ) \left\vert\left[ \left\{ a, b \right\} \right]\right\vert \left(b \rightarrow Q\right)</math> :will simply deadlock. ;Hiding :The hiding operator provides a way to abstract processes, by making some events unobservable. A trivial example of hiding is ::<math>\left(a \rightarrow P\right) \setminus \left\{ a \right\}</math> :which, assuming that the event <math>\mathit{a}</math> doesn't appear in <math>\mathit{P}</math>, simply reduces to ::<math>\mathit{P}</math> === Examples === One of the archetypal CSP examples is an abstract representation of a chocolate vending machine, and its interactions with a person wishing to buy some chocolate. This vending machine might be able to carry out two different events, “coin” and “choc” which represent the insertion of payment and the delivery of a chocolate respectively. A machine which demands payment before offering a chocolate can be written as: :<math>\textit{VendingMachine} = \textit{coin} \rightarrow \textit{choc} \rightarrow \textit{STOP}</math> A person who might choose to use a coin or card to make payments could be modelled as: :<math>\textit{Person} = (\textit{coin} \rightarrow \textit{STOP}) \Box (\textit{card} \rightarrow \textit{STOP})</math> These two processes can be put in parallel, so that they can interact with each other. The behaviour of the composite process depends on the events that the two component processes must synchronise on. Thus, :<math>\textit{VendingMachine} \left\vert\left[\left\{ \textit{coin}, \textit{card} \right\}\right]\right\vert \textit{Person} \equiv \textit{coin} \rightarrow \textit{choc} \rightarrow \textit{STOP}</math> whereas if synchronization was only required on “coin”, we would obtain :<math>\textit{VendingMachine} \left\vert\left[\left\{ \textit{coin} \right\}\right]\right\vert \textit{Person} \equiv \left (\textit{coin} \rightarrow \textit{choc} \rightarrow \textit{STOP}\right ) \Box \left (\textit{card} \rightarrow \textit{STOP}\right )</math> If we abstract this latter composite process by hiding the “coin” and “card” events, i.e. :<math>\left (\left (\textit{coin} \rightarrow \textit{choc} \rightarrow \textit{STO}P\right ) \Box \left (\textit{card} \rightarrow \textit{STOP}\right )\right ) \setminus \left\{\textit{coin}, card\right\}</math> we get the nondeterministic process :<math>\left (\textit{choc} \rightarrow \textit{STOP}\right ) \sqcap \textit{STOP}</math> This is a process which either offers a “choc” event and then stops, or just stops. In other words, if we treat 