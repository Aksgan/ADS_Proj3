PKCS #11 with java Part 1] * [http://blog.hsohaib.com/2010/11/smart-card-tutorial-part-2.html Using PKCS #11 with java Part 2 (RSA Generation)] == References == {{reflist}} {{Crypto navbox}} [[Category:Cryptography standards]] [[Category:Smart cards]]</text> </page> <page> <id>28110</id> <title>PL/Perl</title> <text>'''PL/Perl (Procedural Language/Perl)''' is a procedural language supported by the [[PostgreSQL]] [[RDBMS]]. PL/Perl, as an [[imperative programming language]], allows more control than the [[relational algebra]] of [[SQL]]. Programs created in the PL/Perl language are called functions and can use most of the features that the [[Perl language]] provides, including common flow control structures and syntax that has incorporated [[regular expressions]] directly. These functions can be evaluated as part of a SQL statement, or in response to a [[Event-driven programming|trigger]] or [[wiktionary:rule|rule]]. The design goals of PL/Perl were to create a loadable procedural language that: * can be used to create functions and trigger procedures, * adds control structures to the SQL language, * can perform complex computations, * can be defined to be either [http://www.postgresql.org/docs/current/static/plperl-trusted.html trusted or untrusted] by the server, * is easy to use. PL/Perl is one of many "PL" languages available for PostgreSQL [[PL/pgSQL]] [http://gborg.postgresql.org/project/pljava/projdisplay.php PL/Java], [http://plphp.commandprompt.com/ plPHP], [http://www.postgresql.org/docs/current/interactive/plpython.html PL/Python], [http://www.joeconway.com/plr/ PL/R], [http://raa.ruby-lang.org/list.rhtml?name=pl-ruby PL/Ruby], [http://developer.postgresql.org/~petere/pgplsh/ PL/sh], and [http://www.postgresql.org/docs/current/interactive/pltcl.html PL/Tcl]. ==References== * [http://www.postgresql.org/docs/current/static/plperl.html PostgreSQL PL/Perl documentation] [[Category:Data management]] [[Category:PostgreSQL]] [[ru:PL/Perl]]</text> </page> <page> <id>28113</id> <title>PL360</title> <text>'''PL360''' is a programming language designed by [[Niklaus Wirth]] for the [[IBM System/360]] computer. It provides facilities for specifying exact machine language instructions and registers similar to [[assembly language]], but also provides features commonly found in [[high-level language]]s, such as complex arithmetic expressions and [[control structure]]s. == External links == * [http://delivery.acm.org/10.1145/330000/321442/p37-wirth.pdf?key1=321442&key2=0588523021&coll=ACM&dl=ACM&CFID=15151515&CFTOKEN=6184618 PL360, a Programming Language for the 360 Computers] * [http://www.fh-jena.de/~kleine/history/languages/pl360man.txt PL360 Reference Manual] * [http://www.slac.stanford.edu/spires/explain/manuals/PL360TXT.HTML PL360 Textbook] * [http://everything2.com/index.pl?node_id=1377870&lastnode_id=13510 PL360@Everything2] [[Category:Procedural programming languages]] {{compu-lang-stub}}</text> </page> <page> <id>28127</id> <title>PLate OPtimizer</title> <text>{{about|the CAD program, PLOP|the computer language conference group, PLoP|Pattern Languages of Programs}} '''PLate OPtimizer''', or '''PLOP''' is a [[CAD]] program used by [[Amateur telescope making|amateur telescope makers]] to design [[primary mirror]] [[Mirror support cell|support cells]] for [[reflecting telescope]]s. It was developed by [[telescope]] maker David Lewis, first described in 1999,<ref>{{Cite journal| last = Lewis| first = David| author-link = | title = | journal = Sky & Telescope| volume = | issue = June| pages = 132â€“135| date = | year = 1999| url = | doi = | id = }}</ref> and used to simplify calculations needed in the design of mirror support cells.<ref>{{cite web| last = Holm| first = Mark| authorlink = | coauthors = | title = Mirror Cells for Amateur Telescope Makers| work = | publisher = | date = | url = http://www.atmsite.org/contrib/Holm/Plop_optimized_cells/index.html| doi = | accessdate = May 3, 2009 }} </ref> It was based on Toshimi Taki's 1993 program PLATE<ref>http://www.asahi-net.or.jp/~zs3t-tk/cell/cell.htm Taki's brief intro to cell design</ref>, however provides a simplified user interface, thus giving it wide acceptance among makers of large [[Dobsonian]] style amateur telescopes, with good support of mirrors as thin as two inches for a diameter of thirty inches.<ref>{{cite web| last = Anderson-Lee | first = Jeff| authorlink =| coauthors = | title = Best of 18 and Over - A collection of plop cell designs | work = | publisher = | date = | url = http://www.cs.berkeley.edu/~jonah/18plus/| format =| doi = | accessdate = May 3, 2009}}</ref> ==Comparisons and limitations== A basic mirror cell may be built using minimal calculation and simple materials such as wood and outdoor carpet, with a good example being [[John Dobson (astronomer)|Dobson's]] original telescopes. However, as amateurs sought to build larger and thinner mirrors, they found such designs inadequate. Many amateur telescope makers use cells which are designed via [[equal area rule]] calculation, using programs such as David Chandler's [[public domain]] program, ''Cell''.<ref>{{Cite web| last = Chandler| first = David| title = Floatation Mirror Cell Design|url = http://www.davidchandler.com/cell.htm| accessdate = 2009-06-21 }}</ref> However, such calculation does not account for mechanical stresses introduced in one part of a telescope mirror by another part, whereas [[finite element analysis]] can be used to reduce such [[Yield (engineering)|stress]]. Although general finite element analysis programs such as [[Nastran]] will work for mirror cells, an advantage of PLOP is that it can be set to ignore [[Deformation (engineering)|deformation]] that merely results in refocus of a mirror's [[parabola]].<ref>[http://www.atmsite.org/contrib/Holm/Plop_optimized_cells/cellfaq.html#old Atmsite PLOP FAQ]</ref> PLOP can be used to calculate floating support points for a mirror's [[Optical axis|axial]] (rear) support; however, additional tools are needed to calculate potential error from a mirror's lateral (edge) [[Lateral support|support]].<ref>http://www.cruxis.com/scope/mirroredgecalculator.htm ''Cruxis'' site mirror edge support calculator tool</ref> Mirror cell calculations, whether using PLOP or another program, do not overcome errors introduced by gluing the mirror to its cell, excessive tightening of edge supports, nor impingement of the cell structure onto the mirror as result of differential cooling shrinkage. The significantly more complex calculations arising from the support needs of large [[honeycomb mirror]]s and those using [[active optics]] systems are outside the design parameters of such programs.<ref>http://medusa.as.arizona.edu/lbto/tech/ua9502.htm Mirror Support System for Large Honeycomb Mirrors</ref> ==See also== * [[Amateur astronomy]] * [[Amateur telescope making]] * [[List of telescope parts and construction]] * [[MATLAB]] * [[Nastran]] * [[Optical aberration]] * [[Optical telescope#Imperfect images]] * [[Whiffletree]] ==Notes== {{reflist|1}} ==External resources== * [http://www.cs.berkeley.edu/~jonah/18plus/p18.html A Study of 18-point Mirror Cell Optimization Using Varying Forces] Jeff Anderson-Lee, January 2003 * [http://www.davidlewistoronto.com/plop/ David Lewis authorlink] * [http://www.cruxis.com/scope/scope1100_mirrorcell.htm Mechanical design of the 110 cm cruxis telescope] * [http://stellafane.org/misc/links.html Stellafane links page] {{DEFAULTSORT:Plate Optimizer}} [[Category:Computer-aided design software]] [[Category:Finite element software]] [[Category:Telescopes]] [[Category:Amateur astronomy|Telescope making]]</text> </page> <page> <id>28129</id> <title>PMD (software)</title> <text>{{distinguish|.pmd}} {{primarysources|date=April 2007}} '''PMD''' is a static ruleset based [[Java (programming language)|Java]] [[source code]] [[Code analyzer|analyzer]] that identifies potential problems like: * ''Possible bugs'' - Empty try/catch/finally/switch blocks. * ''Dead code'' - Unused [[local variable]]s, [[parameter]]s and [[private method]]s. * Empty if/while statements. * ''Overcomplicated expressions'' - Unnecessary if statements, for loops that could be while loops. * ''Suboptimal code'' - Wasteful String/StringBuffer usage. * Classes with high [[Cyclomatic complexity|Cyclomatic Complexity]] measurements. * ''Duplicate code'' - Copied/pasted code can mean copied/pasted bugs, and decreases maintainability. While PMD doesn't officially stand for anything, it has several unofficial names, the most appropriate probably 