<title>Event generator</title> <text>'''Event generators''' are [[software]] [[library (computer science)|libraries]] that generate simulated high-energy [[particle physics]] [[event (particle physics)|events]].<ref>[http://arjournals.annualreviews.org/doi/abs/10.1146/annurev.nucl.55.090704.151505 M. L. Mangano & T. J. Stelzer, Ann. Rev. Nucl. Part. Sci. 55, 555 (2005).]</ref><ref>[http://arxiv.org/abs/hep-ph/0403045 M. A. Dobbs ''et al.'', hep-ph/0403045.]</ref> They randomly generate events as those produced in [[particle accelerators]], [[collider]] experiments or during the initial phases of the Universe creation. Events come in different types called ''processes'' as discussed in the [[Automatic calculation of particle interaction or decay]] article. Despite the simple structure of the tree-level [[perturbation theory|perturbative]] [[quantum field theory]] description of the [[collision]] and [[radioactive decay|decay]] processes in an event, the observed high-energy process usually contains significant amount of modifications, like [[photon]] and [[gluon]] ''[[bremsstrahlung]]'' or loop [[Feynman diagram|diagram]] corrections, that usually are too complex to be easily evaluated in real calculations directly on the diagrammatic level. Furthermore, the non-perturbative nature of [[Quantum chromodynamics|QCD]] [[bound state]]s makes it necessary to include information that is beyond the reach of perturbative quantum field theory, and well beyond present ability of computation in [[lattice QCD]]. And in collisional systems more complex than a few [[lepton]]s and [[hadron]]s (e.g. heavy-ion collisions), the collective behavior of the system would involve a [[phenomenology (particle physics)|phenomenological]] description that also cannot be easily obtained from the fundamental field theory by a simple calculus. Any realistic test of the underlying physical process in a [[particle accelerator]] [[experiment]], therefore, requires an adequate inclusion of these complex behaviors surrounding the actual process. Based on the fact that in most processes a [[factorization]] of the full process into individual problems is possible (which means a negligible effect from [[interference]]{{dn}}), these individual processes are calculated separately, and the [[probability|probabilistic]] branching between them are performed using [[Monte Carlo method]]s. The final-state particles generated by event generators can be fed into the detector simulation, allowing a precise prediction and verification for the entire system of experimental setup. However, as the detector simulation is usually a complex and computationally expensive task, simple event analysis techniques are also performed directly on event generator results. A typical hadronic event generator simulates the following subprocesses: * Initial-state composition and substructure * Initial-state [[particle shower|shower]]s * The hard process * [[Resonance]] decay * Final-state showers * Accompanying semi-hard processes * [[Hadronization]] and further decay A typical heavy-ion event generator usually can be less strict in simulating the rare and rather negligible processes found in a hadronic generator, but would need to simulate the following subprocesses, in addition to those in a hadronic generator: * [[atomic nucleus|Nuclear]] initial-state * High multiplicity, soft processes * In-medium energy loss * Collective behavior of the medium ''(not handled properly by any generators sofar)'' Partly due to historic reasons, most event generators are written in [[FORTRAN 77]], with a few [[C++]] generators slowly emerging in recent years. The [[Particle Data Group]] maintains a [[Standardization|standard]] for designating [[Standard Model]] particles and [[Resonance#Quantum field theory|resonances]] with [[integer]] [[code]]s in event generators (also known as the "PDG code"). == List of event generators == The major event generators that are used by current experiments are: '''Hadronic event generators'''<ref>[http://indico.cern.ch/conferenceDisplay.py?confId=a042790 T. Sjöstrand, "Monte Carlo generators for the LHC (1/4)", CERN Lecture (2005)], p. 22</ref> * [[PYTHIA]] (formerly Pythia/Jetset) * [http://hepwww.rl.ac.uk/theory/seymour/herwig/ HERWIG] * [http://www.nhn.ou.edu/~isajet/ ISAJET] * [http://projects.hepforge.org/sherpa/dokuwiki/doku.php SHERPA] '''Heavy ion event generators''' * [http://www-nsdth.lbl.gov/~xnwang/hijing/ HIJING] '''Neutrino event generators''' * [http://www.genie-mc.org GENIE] * [http://borg.ift.uni.wroc.pl/nuwro/ NuWro] '''Specialized event generators''' * [http://borut.home.cern.ch/borut/ AcerMC] &ndash; [[Large Hadron Collider|LHC]] background processes * [http://mlm.home.cern.ch/mlm/alpgen/ ALPGEN] &ndash; multiple [[Parton (particle physics)|parton]] processes * [http://www.thep.lu.se/~leif/ariadne/ Ariadne] &ndash; QCD cascade with Color Dipole Model * [http://www.hep.phy.cam.ac.uk/theory/webber/MCatNLO/ MC@NLO] &ndash; parton shower with next-to-leading-order QCD matrix elements * [http://hepforge.cedar.ac.uk/jimmy/ JIMMY] &ndash; multiple parton processes '''"Meta-generator"''' * [[CompHEP]] &ndash; automatic evaluation of tree level matrix elements for event generation or export into other event generators ==References== {{reflist}} ==External links == * [http://pdg.lbl.gov/2006/mcdata/mc_particle_id_contents.html 2006 Monte Carlo Number Scheme], from the 2006 [[Review of Particle Physics]]. * [http://www.desy.de/~heramc/mclist.html List of Monte Carlo Programs] &ndash; from [[DESY]] [[Category:Particle physics]] [[Category:Monte Carlo methods]] [[Category:Computational physics]] [[ja:イベントジェネレータ]]</text> </page> <page> <id>12660</id> <title>Event loop</title> <text>In [[computer science]], the '''event loop''', '''message dispatcher''', '''message loop''' or '''message pump''' is a programming construct that waits for and dispatches [[Event-driven programming|events]] or [[Message passing|messages]] in a [[Computer program|program]]. It works by [[Polling (computer science)|polling]] some internal or external "event provider", which generally [[blocking (computing) | blocks]] until an event has arrived, and then calls the relevant [[event handler]] ("dispatches the event"). The event-loop may be used in conjunction with a [[Reactor pattern|reactor]], if the event provider follows the [[#File interface|file interface]] (which can be selected or polled). The event loop almost always operates asynchronously with the message originator. When the event loop forms the central control flow construct of a program, as it often does, and is thus at the highest level of control within the program, it may be termed the '''main loop''' or '''main event loop'''. ==Message passing== Message pumps are said to 'pump' messages from the program's [[message queue]] (assigned and usually owned by the underlying operating system) into the program for processing. In the strictest sense, an event loop is one of the methods for implementing [[inter-process communication]]. In fact, message processing exists in many systems, including a [[Kernel (computer science)|kernel-level]] component of the [[Mach kernel|Mach operating system]]. The event loop is a specific implementation technique of systems that use [[message passing]]. ==Alternative designs== This approach is in contrast to a number of other alternatives: * Traditionally, a program simply ran once then terminated. This type of program was very common in the early days of computing, and lacked any form of user interactivity. This is still used frequently, particularly in the form of [[command line]] driven programs. Any [[parameters]] are set up in advance and passed in one go when the program starts. * Menu-driven designs. These still may feature a main loop but are not usually thought of as event driven in the usual sense. Instead, the user is presented with an ever-narrowing set of options until the task they wish to carry out is 