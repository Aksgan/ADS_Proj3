schools]. The second edition (ISBN 0-262-51087-1) appeared in 1996. Widely considered a classic text in computer science,<ref>{{cite web|url=http://grokcode.com/11/the-top-9-in-a-hackers-bookshelf/ |title=The Top 9 1/2 Books in a Hacker's Bookshelf |accessdate = 2010-10-23}}</ref> it is also known as the '''Wizard Book''' (there is a wizard on the cover), and less commonly, the '''Purple Book'''<ref>{{cite web|url=http://mitpress.mit.edu/sicp/ |title=Official SICP site |accessdate = 2010-09-07}}</ref>. Using a dialect of the [[Lisp programming language]] known as [[Scheme (programming language)|Scheme]], the book explains core computer science concepts, including [[abstraction (computer science)|abstraction]], [[recursion]], [[interpreter (computing)|interpreters]] and [[metalinguistic abstraction]], and teaches [[modular programming]]. The program also introduces a practical implementation of the [[register machine]] concept, defining and developing an [[Assembly language#Assember|assembler]] for such a construct, which is used as a [[virtual machine]] for the implementation of interpreters and compilers in the book, and as a testbed for illustrating the implementation and effect of modifications to the evaluation mechanism. Working Scheme systems based on the design described in this book are quite common student projects. ==Characters== The book uses some fictional characters repeatedly: * Ben Bitdiddle. He considerably predates this class, having been created by Steve Ward for use in problem sets for its predecessor, 6.031, in the 1970s. He has since appeared in a large number of other locations, including other classes at MIT and other institutions. * Eva Lu Ator – the evaluator * Louis Reasoner – the loose reasoner * Alyssa P. Hacker – a lisp hacker ==License== The book is licensed under a [[Creative Commons]] Attribution-Noncommercial 3.0 Unported License.<ref>[http://mitpress.mit.edu/sicp/ Official SICP site]</ref> == See also == SICP has been influential in computer science education, and a number of later books have been inspired by its style. * ''[[Structure and Interpretation of Classical Mechanics]] (SICM)'', another book by Gerald Jay Sussman that uses Scheme * ''[[How to Design Programs]] (HtDP)'', which intends to be a more accessible book for introductory Computer Science, and to address perceived incongruities in SICP (see references below) * ''[[Essentials of Programming Languages]] (EoPL)'' is a book for Programming Languages courses * ''[[Lisp in Small Pieces]] (LiSP)'', a book full of Scheme interpreters and compilers * ''[[Simply Scheme]]'' was written as a "prequel" to SICP * ''[[Concrete Abstractions]]'' has more examples and assumes less math than SICP and has "plenty of echos [sic]" of SICP (out of print but freely available online[http://gustavus.edu/+max/concrete-abstractions.html]) ==References== {{reflist|colwidth=30em}} ==Further reading== *[http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf A critique of Abelson and Sussman - or - Why calculating is better than scheming] *[http://www.cs.brown.edu/~sk/Publications/Papers/Published/fffk-htdp-vs-sicp-journal/paper.pdf The Structure and Interpretation of the Computer Science Curriculum], a critical view of SICP and rationale for HtDP == External links == * [http://mitpress.mit.edu/sicp/ Official SICP site] (including the full text in HTML) * [http://www.scribd.com/doc/15556326/Structure-and-Interpretation-of-Computer-Programs-SICP SICP in PDF format] * [http://www.neilvandyke.org/sicp-texi/ SICP in Texinfo format] * [https://github.com/ieure/sicp SICP in EPUB format] * [http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/ 1986 Videos of SICP Lectures by the authors] * [http://sicp.ai.mit.edu/Spring-2007/ Official 6.001 site for Spring, 2007] (an MIT course that goes by the same name as the book) * [http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/6-001Spring-2005/CourseHome/ The MIT Open Courseware version of the SICP course] * [http://www.codepoetics.com/wiki/index.php?title=Topics:SICP_in_other_languages SICP in other languages] The examples from SICP presented in a variety of languages on code poetics (the semi-official site for [[Concepts, Techniques, and Models of Computer Programming]]) * [http://sicp.org.ua SICP Wiki] (solutions and discussion of exercises from the book) * [http://www.neilvandyke.org/sicp-plt/ SICP Support in PLT Scheme] (for using DrScheme instead of MIT Scheme) [[Category:1985 books]] [[Category:1996 books]] [[Category:Computer science books]] [[Category:Massachusetts Institute of Technology]] [[Category:Scheme programming language]] [[de:Structure and Interpretation of Computer Programs]] [[hr:Structure and Interpretation of Computer Programs]] [[ja:計算機プログラムの構造と解釈]] [[ru:Структура и интерпретация компьютерных программ]] [[sv:Structure and Interpretation of Computer Programs]] [[zh:计算机程序的构造和解释]]</text> </page> <page> <id>35962</id> <title>Structure chart</title> <text>[[File:Structured Chart Example.jpg|thumb|320px|Example of a Structured Chart.<ref name="Sandia92"> Sandia National Laboratories (1992). [http://www.prod.sandia.gov/cgi-bin/techlib/access-control.pl/1985/852348.pdf Sandia Software Guidelines Volume 5 Tools, Techniques,and Methodologies] SANDIA REPORTS 85–2348qUC–32</ref>]] A '''Structure Chart''' (SC) in [[software engineering]] and [[organizational theory]] is a [[chart]], which shows the breakdown of the [[configuration system]] to the lowest manageable levels.<ref name="IRT">IRS (2008) "Configuration Management"] In: ''IRS Resources Part 2. Information Technology Chapter 27. Configuration Management''. Accessed at [http://www.irs.gov/ IRS.GOV] 14 Nov 2008. No longer online Nov 8, 2009.</ref> This chart is used in [[structured programming]] to arrange the program modules in a tree structure. Each module is represented by a box, which contains the module's name. The tree structure visualizes the relationships between the modules.<ref>[[James Martin (author)|James Martin]], Carma L. McClure (1988). ''Structured Techniques: The Basis for Case''. Prentice Hall. p.56.</ref> == Overview == [[File:Sample of Hierarchy chart.png|thumb|upright=1.5|alt=Illustration of simple hierarchy chart.|This illustration is hierarchy chart that represent data passing between two modules. When the module Pay_Bill executed, the pseudocode check if it already pay the bill by search the receipt of payment (execute Search_Receipt). If the receipt is not found then it will execute module Give_Money_To_Debt_Collector to finish the job.]] A structure chart is a [[top-down design|top-down modular design]] tool, constructed of squares representing the different modules in the [[system]], and lines that connect them. The lines represent the connection and or ownership between activities and subactivities as they are used in [[organization chart]]s.<ref>H. Fujita & V. Gruhn (2004). ''New Trends in Software Methodologies, Tools and Techniques''. Page 6.</ref> In [[structured analysis]] structure charts, according to Wolber (2009), "are used to specify the high-level design, or architecture, of a [[computer program]]. As a design tool, they aid the programmer in dividing and conquering a large software problem, that is, recursively breaking a problem down into parts that are small enough to be understood by a human brain. The process is called [[top-down design]], or [[functional decomposition]]. Programmers use a structure chart to build a program in a manner similar to how an architect uses a blueprint to build a house. In the design stage, the chart is drawn and used as a way for the client and the various software designers to communicate. During the actual building of the program (implementation), the chart is continually referred to as the master-plan".<ref name= "Wol"> David Wolber (2009) "[http://www.usfca.edu/~wolberd/cs112/SupplementalNotes/structureChart.doc Structure Charts]: Supplementary Notes Structure Charts and Bottom-up Implementation: Java Version. Accessed Nov 