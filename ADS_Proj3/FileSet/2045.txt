Series architecture should not be confused with [[Virtual machine|the way the term is used in other environments]]. Because each program runs in its own Virtual Machine, the concept may be likened to a [[Process (computing)|process]] in other operating systems, while the 2900 Series process is more like a [[Thread (computer science)|thread]]. The most obvious resource in a Virtual Machine is the virtual store (memory). Other resources include peripherals, files, network connections, and so on. Within a virtual machine, code can run at different layers of protection, called access levels (or ACR levels, after the Access Control Register which controls the mechanism). The most privileged levels of operating system code (the kernel) operate in the same virtual machine as the user application, as do intermediate levels such as the subsystems to implement filestore access and networking. System calls thus involve a change of protection level, but not an expensive call to invoke code in a different virtual machine. Every code module executes at a particular access level, and can invoke the functions offered by lower-level code, but cannot make direct access to memory or other resources at that level. The architecture thus offers a built-in encapsulation mechanism to ensure system integrity. Segments of memory can be shared between virtual machines. There are two kinds of shared memory: public segments used by the operating system (which are present in all virtual machines), and global segments used for application-level shared data: this mechanism is used only when there is an application requirement for two virtual machines to communicate. For example, global memory segments are used for database lock tables. Hardware semaphore instructions are available to synchronise access to such segments. A minor curiosity is that two virtual machines sharing a global segment will use different virtual addresses for the same memory locations, which means that virtual addresses cannot safely be passed from one VM to another. === Addressing mechanisms === The 2900 architecture supports a [[hardware stack]], providing an efficient vehicle for executing high-level language programs, especially those allowing recursive function calls. This was a forward-looking decision at the time, since it was expected that the dominant programming languages would initially be [[COBOL]] and [[FORTRAN]]. The architecture provides built-in mechanisms for making procedure calls using the stack, and special purpose registers for addressing the top of the stack and the base of the current stack frame. Off-stack data is typically addressed via a descriptor. This is a 64-bit structure containing a 32-bit virtual address, plus 32 bits of control information. The control information identifies whether the area being addressed is code or data; in the case of data, the size of the items addressed (1, 8, 32, 64, or 128 bits); a flag to indicate whether hardware array-bound-checking is required; and various other refinements. The 32-bit virtual address comprises a 14-bit segment number and an 18-bit displacement within the segment. Technically the order code is not part of the 2900 architecture: this fact has been exploited to emulate other machines by microcoding their instruction sets. In practice, however, all machines in the 2900 series implement a common order code or instruction set, known as the PLI (Primitive Level Interface). This is designed primarily as a target for high-level language compilers. There are a number of registers, each designed for a special purpose. An accumulator register (ACC) is available for general-purpose use, and may be 32, 64, or 128 bits in size. The B register is used for indexing into arrays; the LNB register points to the base of the current stack frame; the DR register is used for holding descriptors for addressing into the heap, and so on. Data formats recognized by the PLI instructions include 32-bit unsigned integers; 32-bit and 64-bit twos-complement integers; 32-bit, 64-bit and 128-bit floating point; and 32-bit, 64-bit, and 128-bit packed decimal. Conventionally (and strangely to those tutored on C and UNIX) the boolean value true is represented as zero, false as minus one. Strings are held as arrays of 8-bit characters, conventionally encoded in [[EBCDIC]] (though ICL's EBCDIC has minor variations from IBM's version). Because some of the PLI instructions, notably those for procedure calling (especially system calls) are very powerful, instruction rates on 2900 Series are not always directly comparable with those on competitors' hardware. ICL marketing literature tended to use the concept of "IBM equivalent MIPS", being the [[Million_instructions_per_second#Million_instructions_per_second|MIPS]] rating of an IBM mainframe that achieved the same throughput in application benchmarks. The efficiencies achieved by the 2900 architecture, notably the avoidance of system call overheads, compensated for relatively slow raw hardware performance. == Implementations == [[Image:2900SeriesModules.jpg|right]] The first machines announced in the 2900 Series were the 2980 and 2970. The 2980 allowed one or two [[order code processor]]s (OCPs), each operating at up to 3 million instructions per second, with real memory configurable up to 8 megabytes, with a 500 nanosecond access time. The 2980 was initially the most powerful of ICL's New Range mainframe computers. In addition to the OCPs, it consisted of a store multiple access controller (SMAC) and one or more store access controllers (SAC), a general peripheral controller (GPC), one or more disc file controllers (DFC) and a communications link controller (CLC), together with disc drives (a typical configuration would have eight EDS 200 drives), tape decks, an operating station (OPER), line printers and card readers. It supported the VME/B, VME/K and [[Edinburgh Multiple Access System]] (EMAS) operating systems. A typical 2980 configuration would cost about Â£2 million. Unlike the 2980, the 2970 and the subsequent 2960 were microcoded, and thus allowed emulation of instruction sets such as that of the older 1900 Series or the System 4. A 2900 Series machine was constructed from a number of functional modules, each contained in a separate cabinet. Peripheral devices were connected using ICL's Primitive Interface (Socket/Plug and cable set) to a Port Adapter on the SMAC. Logical addressing was employed and used a group scheme to identify system components in terms of Ports, Trunks and Streams. A ''Trunk'' was a generic 