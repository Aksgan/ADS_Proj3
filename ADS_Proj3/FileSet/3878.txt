"Cryptanalysis and Validation" section below]].<ref>Yu Sasaki, Lei Wang, and Kazumaro Aoki, [http://eprint.iacr.org/2009/479.pdf Preimage Attacks on 41-Step SHA-256 and 46-Step SHA-512], accessed 3 Jan 2010</ref> ==Comparison of SHA functions== In the table below, ''internal state'' means the “internal hash sum” after each compression of a data block. {{See|Merkle–Damgård construction}} {| border=1 class="wikitable" ! colspan="2" | Algorithm and <br />variant !Output size (bits) !Internal state size (bits) !Block size (bits) !Max message size (bits) !Word size (bits) !Rounds !Operations ![[Hash collision|Collisions]] found |- align="center" | colspan="2" | '''SHA-0''' || 160 || 160 || 512 || 2<sup>64</sup> − 1 || 32 || 80 || +,and,or,xor,rot || Yes |- align="center" | colspan="2" | '''SHA-1''' || 160 || 160 || 512 || 2<sup>64</sup> − 1 || 32 || 80 || +,and,or,xor,rot || Yes (2<sup>51</sup>)<ref>[http://eprint.iacr.org/2008/469.pdf Classification and Generation of Disturbance Vectors for Collision Attacks against SHA-1]</ref> |- align="center" | rowspan="2" | '''SHA-2''' || ''SHA-256/224'' || 256/224 || 256 || 512 || 2<sup>64</sup> − 1 || 32 || 64 || +,and,or,xor,shr,rot || None |- align="center" | ''SHA-512/384'' || 512/384 || 512 || 1024 || 2<sup>128</sup> − 1 || 64 || 80 || +,and,or,xor,shr,rot || None |} ==Applications== {{details|Cryptographic hash function#Applications}} The SHA-2 hash function is implemented in some widely-used security applications and protocols, including [[Transport Layer Security|TLS]] and [[Secure Sockets Layer|SSL]], [[Pretty Good Privacy|PGP]], [[Secure Shell|SSH]], [[S/MIME]], and [[IPsec]]. Those applications can also use [[SHA-1]] and [[MD5]]. SHA-1 and SHA-2 are the secure hash algorithms required by law for use in certain [[U.S. Government]] applications, including use within other cryptographic algorithms and protocols, for the protection of sensitive unclassified information. FIPS PUB 180-1 also encouraged adoption and use of SHA-1 by private and commercial organizations. SHA-1 is being retired for most government uses; the U.S. National Institute of Standards and Technology says, "Federal agencies '''''should''''' stop using SHA-1 for...applications that require collision resistance as soon as practical, and must use the SHA-2 family of hash functions for these applications after 2010" (emphasis in original).<ref>National Institute on Standards and Technology Computer Security Resource Center, [http://csrc.nist.gov/groups/ST/hash/policy.html NIST's Policy on Hash Functions], accessed March 29, 2009.</ref> ==Cryptanalysis and validation== For a hash function for which ''L'' is the number of [[bits]] in the [[message digest]], finding a message that corresponds to a given message digest can always be done using a [[brute force]] search in 2<sup>''L''</sup> evaluations. This is called a [[preimage attack]] and may or may not be practical depending on ''L'' and the particular computing environment. The second criterion, finding two different messages that produce the same message digest, known as a [[Collision (computer science)|collision]], requires on average only 2<sup>''L''/2</sup> evaluations using a [[birthday attack]]. In terms of practical security, a major concern about these new attacks is that they might pave the way to more efficient ones. Whether this is the case has yet to be seen, but a migration to stronger hashes is believed to be prudent. Some of the applications that use cryptographic hashes, such as password storage, are only minimally affected by a collision attack. Constructing a password that works for a given account requires a preimage attack, as well as access to the hash of the original password (typically in the ''shadow'' file) which may or may not be trivial. Reversing password encryption (e.g., to obtain a password to try against a user's account elsewhere) is not made possible by the attacks. (However, even a secure password hash cannot prevent brute-force attacks on [[password strength|weak passwords]].) In the case of document signing, an attacker could not simply fake a signature from an existing document—the attacker would have to produce a pair of documents, one innocuous and one damaging, and get the private key holder to sign the innocuous document. There are practical circumstances in which this is possible; until the end of 2008, it was possible to create forged [[Transport Layer Security|SSL]] certificates using an [[MD5]] collision.<ref>Alexander Sotirov, Marc Stevens, Jacob Appelbaum, Arjen Lenstra, David Molnar, Dag Arne Osvik, Benne de Weger, [http://www.win.tue.nl/hashclash/rogue-ca/ MD5 considered harmful today: Creating a rogue CA certificate], accessed March 29, 2009</ref> There are two [[Meet-in-the-middle attack|meet-in-the-middle]] [[preimage attack]]s against SHA-2 with a reduced number of rounds. The first one attacks 41-round SHA-256 out of 64 rounds with time complexity of 2<sup>253.5</sup> and space complexity of 2<sup>16</sup>, and 46-round SHA-512 out of 80 rounds with time 2<sup>511.5</sup> and space 2<sup>3</sup>.<ref name=preimage-sasaki /> The second one attacks 42-round SHA-256 with time complexity of 2<sup>251.7</sup> and space complexity of 2<sup>12</sup>, and 42-round SHA-512 with time 2<sup>502</sup> and space 2<sup>22</sup>.<ref name=preimage-guo>{{Cite journal |author=Jian Guo, Krystian Matusiewicz |date=2008-11-25 |title=Preimages for Step-Reduced SHA-2 |url=http://eprint.iacr.org/2009/477.pdf }}</ref> ===Official validation=== {{Main|CMVP}} Implementations of all FIPS-approved security functions can be officially validated through the [[CMVP|CMVP program]], jointly run by the [[National Institute of Standards and Technology]] (NIST) and the [[Communications Security Establishment]] (CSE). For informal verification, a package to generate a high number of test vectors is made available for download on the NIST site; the resulting verification however does not replace in any way the formal CMVP validation, which is required by law for certain applications. For a list of example SHA-2 digests, see [[examples of SHA digests]]. ===SHA-256 (a SHA-2 variant) pseudocode=== [[Pseudocode]] for the SHA-256 algorithm follows. Note the great increase in mixing between bits of the <code>w&#91;16..63&#93;</code> words compared to SHA-1. <span style="color: green;">''Note 1: All variables are unsigned 32 bits and wrap modulo 2<sup>32</sup> when calculating''</span> <span style="color: green;">''Note 2: All constants in this pseudo code are in <u>big endian</u></span> <span style="color:green;">''Initialize variables''</span> <span style="color:green;">(first 32 bits of the <em>fractional parts<em> of the square roots of the first 8 primes 2..19):</span> h0 := 0x6a09e667 h1 := 0xbb67ae85 h2 := 0x3c6ef372 h3 := 0xa54ff53a h4 := 0x510e527f h5 := 0x9b05688c h6 := 0x1f83d9ab h7 := 0x5be0cd19 <span style="color:green;">''Initialize table of round constants''</span> <span style="color:green;">(first 32 bits of the ''fractional parts'' of the cube roots of the first 64 primes 2..311):</span> k&#91;0..63&#93; := 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 