with an incrementally enlarged search region until k answers are obtained. Another possibility is to employ similar queryig ideas in [[The iDistance Technique]]. ===Other queries=== The range query and K Nearest Neighbor query algorithms can be easily extended to support interval queries, continuous queries, etc.<ref name="Lin" /> ==Adapting relational database engines to accommodate moving objects== Since the B<sup>x</sup>-tree is an index built on top of a B+ tree index, all operations in the B<sup>x</sup>-tree, including the insertion, deletion and search, are the same as those in the B+ tree. There is no need to change the implementations of these operations. The only difference is to implement the procedure of deriving the indexing key as a stored procedure in an existing [[DBMS]]. Therefore the B<sup>x</sup>-tree can be easily integrated into existing DBMS without touching the [[Kernel (mathematics)|kernel]]. SpADE<ref>[http://www.comp.nus.edu.sg/~spade SpADE]: A SPatio-temporal Autonomic Database Engine for location-aware services. </ref> is moving object management system built on top of a popular relational database system [[MySQL]], which uses the B<sup>x</sup>-tree for indexing the objects. In the implementation, moving object data is transformed and stored directly on MySQL, and queries are transformed into standard SQL statements which are efficiently processed in the relational engine. Most importantly, all these are achieved neatly and independently without infiltrating into the MySQL core. ==Performance tuning== ===Potential problem with data skew=== The B<sup>x</sup> tree uses a grid for space partitioning while mapping two-dimensional location into one-dimensional key. This may introduce performance degradation to both query and update operations while dealing with skewed data. If grid cell is oversize, many objects are contained in a cell. Since objects in a cell are indistinguishable to the index, there will be some overflow nodes in the underlying B+ tree. The existing of overflow pages not only destroys the balancing of the tree but also increases the update cost. As for the queries, for the given query region, large cell incurs more false positives and increases the processing time. On the other hand, if the space is partitioned with finer grid, i.e. smaller cells, each cell contains few objects. There is hardly overflow pages so that the update cost is minimized. Fewer false positives are retrieved in a query. However, more cells are needed to be searched. The increase in the number of cells searched also increases the workload of a query. ===Index tuning=== The ST<sup>2</sup>B-tree <ref>Su Chen, Beng Chin Ooi, Kan-Lee. Tan, and Mario A. Nacismento, [http://www.comp.nus.edu.sg/~chensu/sigmod08.pdf ST2B-tree: A Self-Tunable Spatio-Temporal B+-tree for Moving Objects]. In Proceedings of ACM SIGMOD International Conference on Management of Data (SIGMOD), page 29-42, 2008.</ref> introduces a self-tuning framework for tuning the performance of the B<sup>x</sup>-tree while dealing with data skew in space and data change with time. In order to deal with data skew in space, the ST<sup>2</sup>B-tree splits the entire space into regions of different object density using a set of reference points. Each region uses an individual grid whose cell size is determined by the object density inside of it. The B<sup>x</sup>-tree have multiple partitions regarding different time intervals. As time elapsed, each partition grows and shrinks alternately. The ST<sup>2</sup>B-tree utilizes this feature to tune the index online in order to adjust the space partitioning to make itself accommodate to the data changes with time. In particular, as a partition shrinks to empty and starts growing, it chooses a new set of reference points and new grid for each reference point according to the latest data density. The tuning is based on the latest statistics collected during a given period of time, so that the way of space partitioning is supposed to fit the latest data distribution best. By this means, the ST<sup>2</sup>B-tree is expected to minimize the effect caused by data skew in space and data changes with time. ==See also== *[[B+ tree]] *[[Hilbert curve]] *[[Z-order (curve)]] ==References== <references/> {{DEFAULTSORT:Bx-Tree Moving Object Index}} [[Category:B-tree]]</text> </page> <page> <id>4845</id> <title>Byte</title> <text>{{About|the information storage unit|the homophone|bite|other uses}} The '''byte''' ({{pron-en|ˈbaɪt}}), is a [[units of information|unit of digital information]] in [[computing]] and [[telecommunications]], that most commonly consists of eight [[bit]]s. Historically, a byte was the number of bits used to encode a single [[character (computing)|character]] of text in a computer<ref name = Bemer1962>{{citation |url=http://archive.computerhistory.org/resources/text/IBM/Stretch/pdfs/Buchholz_102636426.pdf |title=Planning a Computer System – Project Stretch | first1 = RW | last1 = Bemer | first2 = Werner | last2 = Buchholz | editor-first = Werner | editor-last = Buchholz |year=1962 | chapter = 6, Character Set | format = [[PDF]]}}.</ref><ref>{{citation | first = RW | last = Bemer | title = A proposal for a generalized card code of 256 characters | journal = Communications of the ACM | volume = 2 | number = 9 | pages = 19–23 | year = 1959}}.</ref> and it is for this reason the basic [[address space|addressable]] element in many [[computer architecture]]s. The size of the byte has historically been hardware dependent and no definitive standards exist that mandate the size. The [[de facto standard|''de facto'' standard]] of eight bits is a convenient [[power of two]] permitting the values 0 through 255 for one byte. Many types of applications use variables representable in eight or fewer bits, and processor designers optimize for this common usage. The popularity of major commercial computing architectures have aided in the ubiquitous acceptance of the 8-bit size. The term [[Octet (computing)|octet]] was defined to explicitly denote a sequence of 8 bits because of the ambiguity associated with the term byte. ==History== The term ''byte'' was coined by Dr. [[Werner Buchholz]] in July 1956, during the early design phase for the [[IBM 7030|IBM Stretch]] computer.<ref>{{cite web | url = http://archive.computerhistory.org/resources/text/IBM/Stretch/102636400.txt|title= Timeline of the IBM Stretch/Harvest era (1956–1961) | publisher = Computer History | date=July 1956|author=Werner Buchholz}}</ref><ref>{{cite web|url=http://catb.org/~esr/jargon/html/B/byte.html|title=byte definition}}</ref> It is a respelling of ''bite'' to avoid accidental mutation to ''bit''.<ref name=Bemer1962/> Early computers were designed for 4-bit [[BCD]] code ([[binary coded decimal]]) or 6-bit code for printable "graphic set", which included 26 alphabetic characters (only uppercase), 10 Numerical digits, and from 11 to 25 special graphic symbols. To include the control 