numbers = new int[5]{ 20, 1, 42, 15, 34 }; //Short syntax int[] numbers2 = { 20, 1, 42, 15, 34 }; </source> =====Multi-dimensional arrays===== Arrays can have more than one dimension, for example 2 dimensions to represent a grid. <source lang="csharp"> int[,] numbers = new int[3, 3]; number[1,2] = 2; int[,] numbers2 = new int[3, 3] { {2, 3, 2}, {1, 2, 6}, {2, 4, 5} }; </source> '''See also''' * [[Jagged array]] ====Classes==== Classes are self-describing user-defined reference types. Essentially all types in the .NET Framework are classes, including structs and enums, that are compiler generated classes. =====<code>String</code> class===== The <code>System.String</code> class, or simply <code>string</code>, represents an immutable sequence of unicode characters (<code>char</code>). Actions performed on a string will always return a new string. <source lang="csharp"> string text = "Hello World!"; string substr = text.Substring(0, 5); string[] parts = text.Split(new char[]{ ' ' }); </source> The <code>System.StringBuilder</code> class can be used when a mutable "string" is wanted. <source lang="csharp"> StringBuilder sb = new StringBuilder(); sb.Append('H'); sb.Append("el"); sb.AppendLine("lo!"); </source> ====Interface==== Interfaces are data structures that contain member definitions and not actual implementation. They are useful when you want to define a contract between members in different types that have different implementations. You can declare definitions for methods, properties, and indexers. These must be implemented by a class as public members. <source lang="csharp"> interface IBinaryOperation { double A { get; set; } double B { get; set; } double GetResult(double a, double b); } </source> ====Delegates==== C# provides type-safe object-oriented function pointers in the form of ''delegates''. <source lang="csharp"> class Program { //Delegate type delegate int Operation(int a, int b); static int Add(int i1, int i2) { return i1 + i2; } static int Sub(int i1, int i2) { return i1 - i2; } static void Main() { //Instantiate the delegate and assign the method to it. Operation op = Add; //Call the method that the delegate points to. int result1 = op(2, 3); //5 op = Sub; int result2 = op(10, 2); //8 } } </source> Initializing the delegate with an anonymous method. <source lang="csharp"> addition = delegate(int a, int b){ return a + b; }; </source> '''See also''' * [[Delegate (.NET)]] ====Events==== ''Events'' are [[pointer (programming)|pointers]] that can point to multiple methods. More exactly they bind method pointers to one identifier. This can therefore be seen as an extension to [[delegate (.NET)|delegates]]. They are typically used as triggers in UI development. The form used in [[C Sharp (programming language)|C#]] and the rest of the [[Common Language Infrastructure]] is based on that in the classic [[Visual Basic]]. <source lang="csharp"> delegate void MouseEventHandler(object sender, MouseEventArgs e); public class Button : System.Windows.Controls.Control { event MouseEventHandler OnClick; /* Imaginary trigger function */ void click() { this.OnClick(this, new MouseEventArgs(data)); } } </source> An event requires an accompanied ''event handler'' that is made from a special delegate that in a platform specific library like in [[Windows Presentation Foundation]] and [[Windows Forms]] usually takes two parameters: ''sender'' and the ''event arguments''. The type of the event argument-object derive from the EventArgs class that is a part of the CLI base library. Once declared in its class the only way of invoking the event is from inside of the owner. A listener method may be implemented outside to be triggered when the event is fired. <source lang="csharp"> public class MainWindow : System.Windows.Controls.Window { private Button button1; public MainWindow() { button1 = new Button(); button1.Text = "Click me!"; /* Subscribe to the event */ button1.ClickEvent += button1_OnClick; /* Alternate syntax that is considered old: button1.MouseClick += new MouseEventHandler(button1_OnClick); */ } protected void button1_OnClick(object sender, MouseEventArgs e) { MessageBox.Show("Clicked!"); } } </source> '''See also''' * [[Event-driven programming]] ====Nullable types==== :''This is a feature of [[C Sharp 2.0]].'' Nullable types were introduced in C Sharp 2.0 firstly to enable value types to be ''null'' when working with a database. <source lang="csharp"> int? n = 2; n = null; Console.WriteLine(n.HasValue); </source> In reality this is the same as using the <code>Nullable<T></code> struct. <source lang="csharp"> Nullable<int> n = 2; n = null; Console.WriteLine(n.HasValue); </source> ====Pointers==== C# has and allows pointers to value types (primitives, enums and structs) in unsafe context: methods and codeblock marked <code>unsafe</code>. These are syntactically the same as pointers in C and C++. However, runtime-checking is disabled inside <code>unsafe</code> blocks. <source lang="csharp"> static void Main(string[] args) { unsafe { int a = 2; int* b = &a; Console.WriteLine("Address of a: {0}. Value: {1}", (int)&a, a); Console.WriteLine("Address of b: {0}. Value: {1}. Value of *b: {2}", (int)&b, (int)b, *b); //Will output something like: //Address of a: 71953600. Value: 2 //Address of b: 71953596. Value: 71953600. Value of *b: 2 } } </source> Structs are required only to be pure structs with no members of a managed reference type, e.g. a string or any other class. <source lang="csharp"> public struct MyStruct { public char Character; public int Integer; } public struct MyContainerStruct { public byte Byte; public MyStruct MyStruct; } </source> In use: <source lang="csharp"> MyContainerStruct x; MyContainerStruct* ptr = &x; byte value = ptr->Byte; </source> '''See also''' * [[Pointer (programming)]] ====Dynamic==== :''This is a feature of [[C Sharp 4.0]] and [[.NET Framework 4.0]].'' Type <code>dynamic</code> is a feature that enables dynamic runtime lookup to C# in a static manner. Dynamic is a static "type" which exists at runtime. <source lang="csharp"> dynamic x = new Foo(); x.DoSomething(); //Will compile and resolved at runtime. An exception will be cast if invalid. </source> ===Boxing and unboxing=== ''Boxing'' is the operation of converting a value of a value type into a value of a corresponding reference type.<ref name="insidecsharpp2ch4">[[#Archer|Archer]], Part 2, Chapter 4:The Type System</ref> Boxing in C# is implicit. ''Unboxing'' is the operation of converting a value of a reference type (previously boxed) into a value of a value type.<ref name="insidecsharpp2ch4" /> Unboxing in C# requires an explicit type cast. Example: <source lang="csharp"> int foo = 42; // Value type. object bar = foo; // foo is boxed to bar. int foo2 = (int)bar; // Unboxed back to value type. </source> ==Object-oriented programming 