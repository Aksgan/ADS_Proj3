was announced July 1982, but predating the [[NEC SX architecture|NEC SX-2]], which was announced in April 1983. The S-810 was Hitachi's first supercomputer, although the company had previously built a [[vector processor]], the IAP. The first system shipped was a top-end S-810/20 model, which was delivered to the [[University of Tokyo]]'s Large Computer Center in October 1983. The S-810 was succeeded as Hitachi's top-end supercomputer by the [[HITAC S-820]] announced in July 1987. There were three models, the low-end S-810/5, the mid-range S-810/10, and the top-end S-810/20. They differ in the number of vector pipelines installed, the number of scalar registers, the number vector registers, and the amount of memory supported. Hitachi claimed that the S-810/5's peak performance was 160 [[MFLOPS]], the S-810/10's was 315 MFLOPS, and the S-810/20's was 630 MFLOPS. The S-810 implements a Hitachi-designed extension of the [[IBM]] [[System/370]] [[instruction set architecture]] with 83 vector instructions (80 in the S-810/5 and S-810/10). The vector instructions are ''register-to-register'', meaning that they do not directly reference memory. The [[scalar processor]] is a Hitachi HITAC M-280H [[Mainframe computer|mainframe]] with a 28 [[nanosecond]] (ns) [[cycle time]] ([[clock rate]] of approximately 35.71 [[Megahertz|MHz]]). In the S-810/20, there are 32 scalar registers, whereas the other models have 16. In all models, the scalar processor has a large 256 [[kilobyte]] [[CPU cache|cache]]. The vector processor has a 14 ns cycle time (clock rate of approximately 71.43 MHz). The vector registers are 256 elements wide, and each element is 64 bits wide. The S-810/20 has 32 of these registers, whereas the other models have 16. These registers are implemented with 1 [[kilobit]] (Kbit) [[Bipolar junction transistor|bipolar]] RAM [[integrated circuit]]s (ICs) with a 4.5 ns [[access time]]. All models have eight 256-bit vector mask registers and 48 vector address registers. All models have three load pipelines and one load/store pipeline for accessing the main memory. The S-810/20 has two lanes, each with two add, one multiply followed by add, and one multiply or divide followed by add [[floating point]] pipelines, for a total of twelve. The S-810/10 has one lane with the same configuration as the S-810/20 and therefore a total of six pipelines. CPU logic is implemented with two [[emitter-coupled logic]] [[gate array]] IC types, a 550-[[Logic gate|gate]] part with a 250 [[picosecond]] (ps) [[gate delay]] and a 1,500-gate part with a 450 ps gate delay. The [[main memory]] is implemented with 16 Kbit [[complementary metal&ndash;oxide&ndash;semiconductor]] [[static random access memory]] ICs with an access time of 40 ns. The S-810/20 supports 64 to 256 [[megabyte]] (MB) of main memory, whereas the other models support 32 to 128 MB. ==References== * http://museum.ipsj.or.jp/en/computer/super/0007.html * {{Cite news |title=Hitachi Has Supercomputer |agency=Associated Press |newspaper=The New York Times |date=31 August 1982 }} * R.W. Hockney; C.R. Jesshope (1988). ''Parallel Computers 2: Architecture, Programming and Algorithms''. CRC Press. pp. 196&ndash;199. * Y. Oyangi, "Development of Supercomputers in Japan: Hardware and Software," ''Parallel Computing'', Dec. 1999, pp 1545&ndash;1567. [[Category:Supercomputers]] {{super-compu-stub}}</text> </page> <page> <id>16034</id> <title>HMAC</title> <text>[[File:Shahmac.jpg|thumb|right|400px|SHA-1 HMAC Generation.]]In [[cryptography]], '''HMAC''' (Hash-based Message Authentication Code), is a specific construction for calculating a [[message authentication code]] (MAC) involving a [[cryptographic hash function]] in combination with a secret [[cryptographic key|key]]. As with any MAC, it may be used to simultaneously verify both the ''[[data integrity]]'' and the ''[[Authentication|authenticity]]'' of a [[cleartext|message]]. Any cryptographic hash function, such as [[MD5]] or [[SHA-1]], may be used in the calculation of an HMAC; the resulting MAC algorithm is termed HMAC-MD5 or HMAC-SHA1 accordingly. The cryptographic strength of the HMAC depends upon the [[cryptographic strength]] of the underlying hash function, the size of its hash output length in bits and on the size and quality of the cryptographic key. An iterative hash function breaks up a message into blocks of a fixed size and iterates over them with a [[One-way compression function|compression function]]. For example, MD5 and SHA-1 operate on 512-bit blocks. The size of the output of HMAC is the same as that of the underlying hash function (128 or 160 bits in the case of MD5 or SHA-1, respectively), although it can be truncated if desired. The definition and analysis of the HMAC construction was first published in 1996 by [[Mihir Bellare]], Ran Canetti, and Hugo Krawczyk,<ref name=BCK96/> who also wrote RFC 2104. This paper also defined a variant called NMAC that is rarely if ever used. [[Federal Information Processing Standard|FIPS]] PUB 198 generalizes and standardizes the use of HMACs. HMAC-SHA-1 and HMAC-MD5 are used within the [[IPsec]] and [[Transport Layer Security|TLS]] protocols. ==Definition (from RFC 2104)== Let: *'''H'''(·) be a cryptographic hash function *''K'' be a secret key padded to the right with extra zeros to the input block size of the hash function, or the hash of the original key if it's longer than that block size *''m'' be the message to be authenticated *∥ denote [[concatenation]] *⊕ denote [[exclusive or]] (XOR) *opad be the outer padding (0x5c5c5c…5c5c, one-block-long [[hexadecimal]] constant) *ipad be the inner padding (0x363636…3636, one-block-long [[hexadecimal]] constant) Then '''HMAC'''(''K'',''m'') is mathematically defined by :'''HMAC'''(''K'',''m'') = '''H'''<big><big>(</big></big>(''K'' ⊕ opad) ∥ '''H'''<big>(</big>(''K'' ⊕ ipad) ∥ m<big>)<big>)</big></big>. ==Implementation== The following [[pseudocode]] demonstrates how HMAC may be implemented. '''function''' hmac (key, message) '''if''' (length(key) > blocksize) '''then''' key = hash(key) <span style="color: green;">''// keys longer than blocksize are shortened''</span> '''end if''' '''if''' (length(key) < blocksize) '''then''' key = key || [0x00 * (blocksize - length(key))] <span style="color:green;">// keys shorter than blocksize are zero-padded('||' is concatenation) </span> '''end if''' o_key_pad = [0x5c * blocksize] ⊕ key <span style="color: green;">''// Where blocksize is that of the underlying hash function''</span> i_key_pad = [0x36 * blocksize] ⊕ key <span style="color: green;">''// Where ⊕ is exclusive or (XOR)''</span> '''return''' hash(o_key_pad || hash(i_key_pad || message)) <span style="color: green;">''// Where '||' is concatenation''</span> '''end function''' == Example usage == A business that suffers from attackers that place fraudulent [[Internet]] orders may insist that all its customers deposit a secret key with them. Along with an order, a customer must supply the order's HMAC digest, computed using the customer's symmetric key. The business, knowing the customer's 