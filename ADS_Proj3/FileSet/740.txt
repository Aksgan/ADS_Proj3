test1 { public void function() throws CloneNotSupportedException { Y varY1 = new Z(); Y varY2 = (Y) varY1.clone(); } } </source> 2) Every class that has any data other than primitives that has to be cloned must contain a clone() function that handles it. This includes all objects and all primitives that are allocated with the 'new' command such as variable length arrays. (This assumes that the programmer wants the objects to be cloned (deep copy) and not just have their reference copied (shallow copy).) Example - since class Z has a reference to an object of another class, there needs to be specific code to clone that object. <source lang="java"> abstract public class X implements Cloneable { public Object clone() throws CloneNotSupportedException { return super.clone(); } } abstract public class Y extends X { } public class ObjectABC implements Cloneable { public Object clone() throws CloneNotSupportedException { return super.clone(); } } public class Z extends Y { private ObjectABC someABC; public Object clone() throws CloneNotSupportedException { Z newZ = (Z) super.clone(); newZ.someABC = (ObjectABC) someABC.clone(); return newZ; } } public class test1 { public void function() throws CloneNotSupportedException { Y varY1 = new Z(); Y varY2 = (Y) varY1.clone(); } } </source> Easy Solution The easiest solution to this is to make the base class "implements Cloneable" and have the base class and all sub-classes contain the clone() method. When a class has data in it that must be cloned, adding a line or two to the clone() method is straight forward. Example <source lang="java"> abstract public class X implements Cloneable { public Object clone() throws CloneNotSupportedException { return super.clone(); } } abstract public class Y extends X { public Object clone() throws CloneNotSupportedException { return super.clone(); } } public class Z extends Y { public Object clone() throws CloneNotSupportedException { return super.clone(); } } public class test1 { public void function() throws CloneNotSupportedException { Y varY1 = new Z(); Y varY2 = (Y) varY1.clone(); } } </source> Downsides If every class in your hierarchy has a clone() method, then when the actual class is cloned all of these functions will be called, adding some overhead. Over many calls this could be significant. With complex object graphs deep copying can become problematic, with recursive references. Once one object is cloneable, others tend to follow until the entire graph attempts to implement Cloneable. Sooner or later you run into a class that you can't make Cloneable. It is not always appropriate to have multiple copies of the same object floating around. Besides, using clone() tends to defeat the "single object, multiple references" paradigm. ==<code>clone()</code> and <code>final</code> fields== Generally, <code>clone()</code> is incompatible with <code>final</code> fields. Because <code>clone()</code> is essentially a default constructor (one that has no arguments) it is impossible to assign a <code>final</code> field within a <code>clone()</code> method; a compiler error is the result. Where the value of the field is an immutable object this is okay; just let the 'constructor' copy the reference and both the original and its clone will share the same object. But where the value is a mutable object it must be deep copied. The only solution is to remove the <code>final</code> modifier from the field, giving up the benefits the modifier conferred. For this reason, some programmers suggest to make the objects in the hierarchy [[Serialization#Java|Serializable]], and create copies by serializing the old object and then creating a new object from the resulting [[bitstream]], which handles final data members correctly, but is significantly slower.<ref>[http://www.javaworld.com/javaworld/javatips/jw-javatip76.html Java Tip 76: An alternative to the deep copy technique], [[JavaWorld]]</ref> ==External links== * {{cite web|url=http://weblogs.java.net/blog/2007/04/04/cloning-java-objects-using-serialization|title=Cloning Java objects using serialization|last=McManus|first=Eamonn|date=April 4, 2007|work=Eamonn McManus's Blog|publisher=java.net|accessdate=2010-11-16}} * {{cite book|last=Bloch|first=Joshua|title=Effective Java: A Programming Language Guide|publisher=Addison-Wesley|year=2008|edition=2nd|series=The Java Series|isbn=0321356683}} * {{cite web|url=http://www.javapractices.com/topic/TopicAction.do?Id=71|title=Avoid clone|year=2009|work=Collected Java Practices|publisher=Hirondelle Systems|accessdate=2009-07-31}} * {{cite web|url=http://java.sun.com/javase/6/docs/api/java/lang/Object.html#clone()|title=Object (Java Platform SE 6)|year=2008|work=Java Platform Standard Ed. 6|publisher=Sun Microsystems, Inc.|accessdate=2009-07-31}} * Roulo, Mark. (01/01/99) [http://www.javaworld.com/javaworld/jw-01-1999/jw-01-object.html?page=2 How to avoid traps and correctly override methods from java.lang.Object] JavaWorld.com - Covers the basics of implementing the clone method. == References == <references/> {{DEFAULTSORT:Clone (Java Method)}} [[Category:Java programming language]]</text> </page> <page> <id>6523</id> <title>Clone manager</title> <text>{{wikify|date=March 2009}} {{Refimprove|date=March 2009}} '''Clone Manager''' is a commercial bioinformatics software work suite of Sci-Ed, that supports molecular biologists with data management and allows to perform certain ''in silico'' preanalyis. ==features== Cloning Operations * Work with enzymes * Simulate cloning * Draw graphic maps, Enhanced views * Sequence analysis functions Primer Design, Analysis * Design primers, create amplified products * Analyze primers, analyze mixes * Find primers that bind to your molecule * Organize, use primers in collections Alignment Operations * Align multiple sequences * Compare two sequences * Scan for similarities, BLAST searches * Assemble sequences, locate subclones == External links == Description of software * http://www.scied.com Sci-Ed homepage == Similar software in this field == *[[Gene Designer|Gene Designer - A free gene design software suite with a range of design and cloning tools]] *[http://www.biology.utah.edu/jorgensen/wayned/ape/ ApE -A Powerful Multipurpose DNA Engineering Software, Donationware/Freeware] *[http://www.serialbasics.com/Serial_Cloner.html Serial Cloner - A DNA editing and manipulating software for MacOS and Windows] *[http://www.crimsonbase.com/ QuickGene - Actively developed, intuitive DNA analysis software with extensive restriction enzyme information. Particularly useful for cloning. Mac OSX and Windows with a Beta version for Linux coming] *[http://www.acaclone.com/ pDRAW32] *[http://gentle.magnusmanske.de/ GENtle] *[http://www.csc.fi/english/research/sciences/bioscience/programs/ds Discovery Studio] *[http://www.clcbio.com/main CLC Main Workbench] *[[Geneious]] *[[UGENE]] *[[MacVector]] *[[Vector NTI]] [[Category:Bioinformatics]] [[Category:Bioinformatics software]] [[Category:Free science software]]</text> </page> <page> <id>6536</id> <title>Closed linear span</title> <text>In [[functional analysis]], a branch of mathematics, the '''closed linear span''' of a [[Set (mathematics)|set]] of [[vector space|vectors]] is the minimal closed set which contains the [[linear span]] of that set. ==Definition== Suppose that ''X'' is a normed vector space and let ''E'' be any non-empty subset of ''X''. The '''closed linear span''' of ''E'', denoted by <math>\overline{\operatorname{Sp}}(E)</math> or <math>\overline{\operatorname{Span}}(E)</math>, is the intersection of all the closed linear subspaces of ''X'' which contain ''E''. One mathematical formulation of this is :<math>\overline{\operatorname{Sp}}(E)=\{u\in X | \forall\epsilon>0\,\exists x\in\operatorname{Sp}(E) : \|x-u\|<\epsilon\}.</math> ==Notes== The linear span of a set is dense in the closed linear span. Moreover, as stated in the below lemma, the closed linear 