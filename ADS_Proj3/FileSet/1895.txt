returns [2,0,109238,0] map isRight [Left "hello", Right 6, Right 23, Left "world"] -- returns [False, True, True, False] map getName [Person "Sarah" Female 20, Person "Alex" Male 20, tom] -- returns ["Sarah", "Alex", "Tom"], using the definition for tom above </source> * Abstract Types * Lists === Tuples === Tuples in haskell can be used to hold a fixed number of elements. They are used to group pieces of data of differing types: <source lang="haskell"> account :: (String, Integer, Double) -- The type of a three-tuple, representing a name, balance, interest rate account = ("John Smith",102894,5.25) </source> Tuples are commonly used in the zip* functions to place adjacent elements in separate lists together in tuples (zip4 to zip7 are provided in the Data.List module): <source lang="haskell"> -- The definition of the zip function. Other zip* functions are defined similarly zip :: [x] -> [y] -> [(x,y)] zip (x:xs) (y:ys) = (x,y) : zip xs ys zip _ _ = [] zip [1..5] "hello" -- returns [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')] -- and has type [(Integer, Char)] zip3 [1..5] "hello" [False, True, False, False, True] -- returns [(1,'h',False),(2,'e',True),(3,'l',False),(4,'l',False),(5,'o',True)] -- and has type [(Integer,Char,Bool)] </source> In the GHC compiler, tuples are defined with sizes from 2 elements up to 62 elements. * Records == Namespaces == In the [[#More_complex_examples]] section above, <tt>calc</tt> is used in two senses, showing that there is a Haskell type class namespace and also a namespace for values: #a Haskell [[type class]] for <tt>calc</tt>. The [[Domain of a function|domain]] and [[Range (mathematics)|range]] can be explicitly denoted in a Haskell type class. #a Haskell value, formula, or expression for <tt>calc</tt>. == Typeclasses and polymorphism == === Algebraic data types === {{Expand section|date=December 2009}} [[Algebraic data types]] are used extensively in Haskell. Some examples of these are the built in list, <code>Maybe</code> and <code>Either</code> types: <source lang="haskell"> -- A list of a's ([a]) is either an a consed (:) onto another list of a's, or an empty list ([]) data [a] = a : [a] | [] -- Something of type Maybe a is either Just something, or Nothing data Maybe a = Just a | Nothing -- Something of type Either atype btype is either a Left atype, or a Right btype data Either a b = Left a | Right b </source> Users of the language can also define their own [[abstract data type]]s. An example of an ADT used to represent a person's name, sex and age might look like: <source lang="haskell"> data Sex = Male | Female data Person = Person String Sex Int -- Notice that Person is both a constructor and a type -- An example of creating something of type Person tom :: Person tom = Person "Tom" Male 27 </source> === Type system === {{Expand section|date=December 2009}} * [[Type class]]es * Type defaulting * Overloaded Literals * Higher Kinded Polymorphism * Multi-Parameter Type Classes * Functional Dependencies == Monads and input/output == {{Expand section|date=December 2009}} * [[Monad (functional programming)|Overview of the monad framework]] * Applications ** Monadic IO ** Do-notation ** References ** Exceptions === ST monad === The ST monad allows programmers to write imperative algorithms in Haskell, using mutable variables (STRef's) and mutable arrays (STArrays and STUArrays). The advantage of the ST monad is that it allows programmers to write code that has internal side effects, such as destructively updating mutable variables and arrays, while containing these effects inside the monad. The result of this is that functions written using the ST monad appear completely pure to the rest of the program. This allows programmers to produce imperative code where it may be impractical to write functional code, while still keeping all the safety that pure code provides. Here is an example program (taken from the Haskell wiki page on the [http://haskell.org/haskellwiki/Monad/ST ST monad]) that takes a list of numbers, and sums them, using a mutable variable: <source lang="haskell"> import Control.Monad.ST import Data.STRef import Control.Monad sumST :: Num a => [a] -> a sumST xs = runST $ do -- runST takes stateful ST code and makes it pure. summed <- newSTRef 0 -- Create an STRef (a mutable variable) forM_ xs $ \x -> do -- For each element of the argument list xs .. modifySTRef summed (+x) -- add it to what we have in n. readSTRef summed -- read the value of n, which will be returned by the runST above. </source> === STM monad === {{main|Concurrent Haskell}} The STM monad is an implementation of [[Software Transactional Memory]] in Haskell. It is implemented in the GHC compiler, and allows for mutable variables to be modified in [[Database_transaction|transactions]]. === Arrows === * Applicative Functors * Arrows As Haskell is a pure functional language, functions cannot have side effects. Being non-strict, it also does not have a well-defined evaluation order. This is a challenge for real programs, which among other things need to interact with an environment. Haskell solves this with ''[[monad (functional programming)|monadic types]]'' that leverage the type system to ensure the proper sequencing of imperative constructs. The typical example is I/O, but monads are useful for many other purposes, including mutable state, concurrency and transactional memory, exception handling, and error propagation. Haskell provides a special syntax for monadic expressions, so that side-effecting programs can be written in a style similar to current imperative programming languages; no knowledge of the [[Monad (category theory)|mathematics behind monadic I/O]] is required for this. The following program reads a name from the command line and outputs a greeting message: <source lang="haskell"> main = do putStrLn "What's your name?" name <- getLine putStr ("Hello, " ++ name ++ "!\n") </source> The do-notation eases working with monads. This do-expression is equivalent to, but (arguably) easier to write and understand than, the [[desugared|de-sugared]] version employing the monadic operators directly: <source lang="haskell"> main = putStrLn "What's your name?" >> getLine >>= \ name -> putStr ("Hello, " ++ name ++ "!\n") </source> : ''See also [[wikibooks:Transwiki:List of hello world programs#Haskell]] for another example that prints text.'' == Concurrency == The 