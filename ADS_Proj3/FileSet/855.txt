& Borwein.<ref>J. Borwein & P. Borwein. ''Pi and the AGM: A Study in Analytic Number Theory and Computational Complexity''. John Wiley 1987.</ref> ===Elementary functions=== The [[elementary function]]s are constructed by composing arithmetic operations, the [[exponential function]] (exp), the [[natural logarithm]] (log), [[trigonometric function]]s (sin, cos), and their inverses. The complexity of an elementary function is equivalent to that of its inverse, since all elementary functions are [[analytic function|analytic]] and hence invertible by means of Newton's method. In particular, if either exp or log can be computed with some complexity, then that complexity is attainable for all other elementary functions. Below, the size ''n'' refers to the number of digits of precision at which the function is to be evaluated. {| class="wikitable" !Algorithm !Applicability !Complexity |- |[[Taylor series]]; repeated argument reduction (e.g. exp(2''x'') = [exp(''x'')]<sup>2</sup>) and direct summation |exp, log, sin, cos |O(''n''<sup>1/2</sup> ''M''(''n'')) |- |Taylor series; [[Fast Fourier transform|FFT]]-based acceleration |exp, log, sin, cos |O(''n''<sup>1/3</sup> (log ''n'')<sup>2</sup> ''M''(''n'')) |- |Taylor series; [[binary splitting]] + [[bit burst]] method<ref>David and Gregory Chudnovsky. Approximations and complex multiplication according to Ramanujan. ''Ramanujan revisited'', Academic Press, 1988, pp 375–472.</ref> |exp, log, sin, cos |O((log ''n'')<sup>2</sup> ''M''(''n'')) |- |[[Arithmetic-geometric mean]] iteration |log |O(log ''n'' ''M''(''n'')) |} It is not known whether O(log ''n'' ''M''(''n'')) is the optimal complexity for elementary functions. The best known lower bound is the trivial bound O(''M''(''n'')). ===Non-elementary functions=== {| class="wikitable" !Function !Input !Algorithm !Complexity |- |rowspan=3|[[Gamma function]] |''n''-digit number |Series approximation of the [[incomplete gamma function]] |O(''n''<sup>1/2</sup> (log ''n'')<sup>2</sup> ''M''(''n'')) |- |Fixed rational number |Hypergeometric series |O((log ''n'')<sup>2</sup> ''M''(''n'')) |- |''m''/24, ''m'' an integer |[[Arithmetic-geometric mean]] iteration |O(log ''n'' ''M''(''n'')) |- |rowspan=2|[[Hypergeometric function]] ''<sub>p</sub>F<sub>q</sub>'' |''n''-digit number |(As described in Borwein & Borwein) |O(''n''<sup>1/2</sup> (log ''n'')<sup>2</sup> ''M''(''n'')) |- |Fixed rational number |Hypergeometric series |O((log ''n'')<sup>2</sup> ''M''(''n'')) |} ===Mathematical constants=== This table gives the complexity of computing approximations to the given constants to ''n'' correct digits. {| class="wikitable" !Constant !Algorithm !Complexity |- |[[Golden ratio]], φ |[[Newton's method]] |O(''M''(''n'')) |- |[[Square root of 2]], √2 |Newton's method |O(''M''(''n'')) |- |rowspan=2|[[e (mathematical constant)|Euler's number]], ''e'' |[[Binary splitting]] of the Taylor series for the exponential function |O(log ''n'' ''M''(''n'')) |- |Newton inversion of the natural logarithm |O(log ''n'' ''M''(''n'')) |- |rowspan=2|[[Pi]], π |Binary splitting of the arctan series in [[Machin's formula]] |O((log ''n'')<sup>2</sup> ''M''(''n'')) |- |[[Salamin–Brent algorithm]] |O(log ''n'' ''M''(''n'')) |- |[[Euler–Mascheroni constant|Euler's constant]], γ |Sweeney's method (approximation in terms of the [[exponential integral]]) |O((log ''n'')<sup>2</sup> ''M''(''n'')) |} ==Number theory== Algorithms for [[number theory|number theoretical]] calculations are studied in [[computational number theory]]. {| class="wikitable" !Operation !Input !Output !Algorithm !Complexity |- |rowspan=5|[[Greatest common divisor]] |rowspan=5|Two ''n''-digit numbers |rowspan=5|One number with at most ''n'' digits |[[Euclidean algorithm]] |O(''n''<sup>2</sup>) |- |[[Binary GCD algorithm]] |O(''n''<sup>2</sup>) |- |Left/Right k-ary Binary GCD algorithm<ref>{{cite journal | author = J. Sorenson. | title = [http://dx.doi.org/10.1006/jagm.1994.1006 Two Fast GCD Algorithms] | journal = Journal of Algorithms | volume = 16| pages = 110–144 | year = 1994 | doi = 10.1006/jagm.1994.1006}}</ref> |O(''n''<sup>2</sup> / log ''n'') |- |[[Stehlé-Zimmermann algorithm]]<ref>R. Crandall & C. Pomerance. ''Prime Numbers - A Computational Perspective''. Second Edition, Springer 2005.</ref> |O(log ''n'' ''M''(''n'')) |- |[[Schönhage controlled Euclidean descent algorithm]]<ref>{{cite journal | author = Möller N | title = [http://www.lysator.liu.se/~nisse/archive/sgcd.pdf On Schönhage's algorithm and subquadratic integer gcd computation] | journal = Mathematics of Computation | volume = 77 | pages = 589–607 | doi = 10.1090/S0025-5718-07-02017-0 | year = 2008}}</ref> |O(log ''n'' ''M''(''n'')) |- |rowspan=3|[[Jacobi symbol]] |rowspan=3|Two ''n''-digit numbers |rowspan=3|0, -1, or 1 |- |Schönhage controlled Euclidean descent algorithm<ref>{{cite web | author = Bernstein D J | title = Faster Algorithms to Find Non-squares Modulo Worst-case Integers | url = http://cr.yp.to/papers/nonsquare.ps}}</ref> |O(log ''n'' ''M''(''n'')) |- | Stehlé-Zimmermann algorithm<ref>{{cite|author1=Richard P. Brent|author2=Paul Zimmermann|title=An O(M(n) log n) algorithm for the Jacobi symbol|year=2010|id={{arXiv|1004.2091}}}}</ref> |O(log ''n'' ''M''(''n'')) |- |rowspan=3|[[Factorial]] |rowspan=3|A fixed-size number ''m'' |rowspan=3|One O(''m'' log ''m'')-digit number |Bottom-up multiplication |O(''m''<sup>2</sup> log ''m'') |- |Binary splitting |O(log ''m'' ''M''(''m'' log ''m'')) |- |Exponentiation of the prime factors of ''m'' |O(log log ''m'' ''M''(''m'' log ''m''))<ref>P. Borwein. "On the complexity of calculating factorials". ''Journal of Algorithms'' '''6''', 376-380 (1985)</ref>,<br>O(''M''(''m'' log ''m''))<ref>A. Schönhage, A.F.W. Grotefeld, E. Vetter: ''Fast Algorithms—A Multitape Turing Machine Implementation'', BI Wissenschafts-Verlag, Mannheim, 1994</ref> |} ==Matrix algebra== The following complexity figures assume that arithmetic with individual elements has complexity O(1), as is the case with fixed-precision [[floating-point arithmetic]]. {| class="wikitable" !Operation !Input !Output !Algorithm !Complexity |- |rowspan=3|[[Matrix multiplication]] |rowspan=3|Two ''n×n''-matrices |rowspan=3|One ''n×n''-matrix |Schoolbook matrix multiplication |O(''n''<sup>3</sup>) |- |[[Strassen algorithm]] |O(''n''<sup>2.807</sup>) |- |[[Coppersmith–Winograd algorithm]] |O(''n''<sup>2.376</sup>) |- |Matrix multiplication |One ''n×m''-matrix & One ''m×p''-matrix |One ''n×p''-matrix |Schoolbook matrix multiplication |O(''nmp'') |- |rowspan=3|[[Matrix inversion]] |rowspan=3|One ''n×n''-matrix |rowspan=3|One ''n×n''-matrix |[[Gauss–Jordan elimination]] |O(''n''<sup>3</sup>) |- |Strassen algorithm |O(''n''<sup>2.807</sup>) |- |Coppersmith–Winograd algorithm |O(''n''<sup>2.376</sup>) |- |rowspan=4|[[Determinant]] |rowspan=4|One ''n×n''-matrix |rowspan=4|One number with at most O(''n'' log ''n'') bits |[[Laplace expansion]] |O(''n''!) |- |[[LU decomposition]] |O(''n''<sup>3</sup>) |- |[[Bareiss algorithm]] |O(''n''<sup>3</sup>) |- |Fast matrix multiplication |O(''n''<sup>2.376</sup>) |} In 2005, [[Henry Cohn]], [[Robert Kleinberg]], [[Balázs Szegedy]] and [[Christopher Umans]] showed that either of two different conjectures would imply that the exponent of matrix multiplication is 2.<ref>Henry Cohn, Robert Kleinberg, Balazs Szegedy, and Chris Umans. Group-theoretic Algorithms for Matrix Multiplication. {{arXiv|archive=math.GR|id=0511460}}. ''Proceedings of the 46th Annual Symposium on Foundations of Computer Science'', 23-25 October 2005, Pittsburgh, PA, IEEE Computer Society, pp. 379–388.</ref> It has also been conjectured that no fastest algorithm for matrix multiplication exists, in light of the nearly 20 successive improvements leading to the [[Coppersmith–Winograd algorithm]]. ==References== <references/> [[Category:Arbitrary precision algorithms]] [[Category:Computational complexity theory]] [[Category:Mathematics-related lists]] [[Category:Number theoretic algorithms]] [[Category:Unsolved problems in computer science]]</text> </page> <page> <id>7411</id> <title>Computational fluid dynamics</title> <text>{{Multiple issues |weasel=November 2010 |refimprove = June 2008}} {{Computational physics}} '''Computational Fluid Dynamics (CFD)''' is a branch of [[fluid mechanics]] that uses [[numerical methods]] and [[algorithms]] to solve and analyze problems that involve fluid flows. Computers are used to perform the calculations required to simulate the interaction of liquids and gases with surfaces defined by [[boundary conditions]]. With high-speed [[supercomputer]]s, better solutions can be achieved. Ongoing research, however, yield software that improves the accuracy and speed of complex simulation scenarios such as transonic or [[turbulence|turbulent]] flows. Initial validation of 