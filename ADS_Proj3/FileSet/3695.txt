Protocol]] (AMQP) == References == {{reflist}} * {{cite web |date=2009-09-13 |author=Joern Barthel |title=Getting started with AMQP and RabbitMQ |publisher=InfoQ |url=http://www.infoq.com/articles/AMQP-RabbitMQ }} * {{cite web |date=2009-04-09 |author=Peter Cooper |title=RabbitMQ – A Fast, Reliable Queuing Option for Rubyists |publisher=RubyInside |url=http://www.rubyinside.com/rabbitmq-a-fast-reliable-queuing-option-for-rubyists-1681.html }} * {{cite conference |date=2008-09-25 |title=RabbitMQ: An Open Source Messaging Broker That Just Works |publisher=[[Google Tech Talks]] |url=http://google-ukdev.blogspot.com/2008/09/rabbitmq-tech-talk-at-google-london.html }} == External links == * [http://www.rabbitmq.com/ RabbitMQ web site] * [http://wiki.secondlife.com/wiki/Message_Queue_Evaluation_Notes#RabbitMQ Evaluation for Second Life by Linden Labs] * [http://digitalsanctum.com/2010/08/31/using-rabbitmq,-spring-amqp-and-spring-integration/ Using RabbitMQ, Spring AMQP, and Spring Integration] * [http://manning.com/videla/ RabbitMQ in Action] {{software-stub}} [[Category:Message-oriented middleware]] [[Category:Erlang programming language]] [[es:RabbitMQ]] [[ja:RabbitMQ]] [[ru:RabbitMQ]]</text> </page> <page> <id>31093</id> <title>Rabin cryptosystem</title> <text>The '''Rabin cryptosystem''' is an asymmetric [[cryptographic]] technique, whose security, like that of [[RSA]], is related to the difficulty of [[factorization]]. However the Rabin cryptosystem has the advantage that the problem on which it relies has been proved to be as hard as [[integer factorization]], which is not currently known to be true of the [[RSA|RSA problem]]. It has the disadvantage that each output of the Rabin function can be generated by any of four possible inputs; if each output is a ciphertext, extra complexity is required on decryption to identify which of the four possible inputs was the true plaintext. ==History== The process was published in January 1979 by [[Michael O. Rabin]]. The Rabin cryptosystem was the first asymmetric cryptosystem where recovering the entire plaintext from the ciphertext could be proven to be as hard as factoring. ==Key generation== As with all asymmetric cryptosystems, the Rabin system uses both a [[public key|public]] and a [[private key]]. The public key is necessary for later encoding and can be published, while the private key must be possessed only by the recipient of the message. The precise key-generation process follows: *Choose two large distinct primes ''p'' and ''q''. One may choose <math>p \equiv q \equiv 3 \pmod{4}</math> to simplify the computation of square roots modulo ''p'' and ''q'' (see below). But the scheme works with any primes. *Let <math>n = p \cdot q</math>. Then ''n'' is the public key. The primes ''p'' and ''q'' are the private key. To encrypt a message only the public key ''n'' is needed. To decrypt a ciphertext the factors ''p'' and ''q'' of ''n'' are necessary. As a (non-real-world) example, if <math>p = 7</math> and <math>q = 11</math>, then <math>n=77</math>. The public key, 77, would be released, and the message encoded using this key. And, in order to decode the message, the private keys, 7 and 11, would have to be known (of course, this would be a poor choice of keys, as the factorization of 77 is trivial). ==Encryption== For the encryption, only the public key ''n'' is used, thus producing a ciphertext out of the plaintext. The process follows: Let <math>P = \{ 0, \dots, n-1 \}</math> be the plaintext space (consisting of numbers) and <math>m \in P</math> be the [[plaintext]]. Now the [[ciphertext]] <math>c</math> is determined by :<math>c = m^2 \, \bmod \, n</math>. That is, ''c'' is the quadratic remainder of the square of the plaintext, modulo the key-number ''n''. In our simple example, <math>P = \{ 0, \dots, 76 \}</math> is our plaintext space. We will take <math>m = 20</math> as our plaintext. The ciphertext is thus <math>c = m^2 \, \bmod \, n = 400 \, \bmod \, 77 = 15</math>. For exactly four different values of ''m'', the ciphertext 15 is produced, i.e. for <math>m \in \{ 13, 20, 57, 64 \}</math>. This is true for most ciphertexts produced by the Rabin algorithm, i.e. it is a four-to-one function. ==Decryption== To decode the ciphertext, the private keys are necessary. The process follows: If ''c'' and ''r'' are known, the plaintext is then <math>m \in \{ 0, \dots, n-1 \}</math> with <math>m^2 \equiv c\pmod{r}</math>. For a [[Composite number|composite]] ''r'' (that is, like the Rabin algorithm's <math>n = p \cdot q</math>) there is no efficient method known for the finding of ''m''. If, however <math>r \in \mathbb{P}</math> (as are ''p'' and ''q'' in the Rabin algorithm), the [[Chinese remainder theorem]] can be applied to solve for ''m''. Thus the [[square root]]s :<math>m_p = \sqrt{c} \, \bmod \, p</math> and :<math>m_q = \sqrt{c} \, \bmod \, q</math> must be calculated (see section below). In our example we get <math>m_p = 1</math> and <math>m_q = 9</math>. By applying the [[extended Euclidean algorithm]], <math>y_p</math> and <math>y_q</math>, with <math>y_p \cdot p + y_q \cdot q = 1</math> are calculated. In our example, we have <math>y_p = -3</math> and <math>y_q = 2</math>. Now, by invocation of the Chinese remainder theorem, the four square roots <math>+r</math>, <math>-r</math>, <math>+s</math> and <math>-s</math> of <math>c + n \mathbb{Z} \in \mathbb{Z} / n \mathbb{Z}</math> are calculated (<math>\mathbb{Z} / n \mathbb{Z}</math> here stands for the [[modular arithmetic#Ring of congruence classes|ring of congruence classes]] modulo ''n''). The four square roots are in the set <math>\{ 0, \dots, n-1 \}</math>): :<math>\begin{matrix} r & = & ( y_p \cdot p \cdot m_q + y_q \cdot q \cdot m_p) \, \bmod \, n \\ -r & = & n - r \\ s & = & ( y_p \cdot p \cdot m_q - y_q \cdot q \cdot m_p) \, \bmod \, n \\ -s & = & n - s \end{matrix}</math> One of these square roots <math>\mod \, n</math> is the original plaintext ''m''. In our example, <math>m \in \{ 64, \mathbf{20}, 13, 57 \}</math>. ==Computing square roots== The decryption requires to compute square roots of the ciphertext ''c'' modulo the primes ''p'' and ''q''. Choosing <math>p \equiv q \equiv 3\pmod{4}</math> allows to compute square roots by :<math>m_p = c^{\frac{(p+1)}{4}} \, \bmod \, p</math> and :<math>m_q = c^{\frac{(q+1)}{4}} \, \bmod \, q</math>. We can show that this method works for ''p'' as follows. First <math>p \equiv 3\!\!\!\pmod{4}</math> implies that (''p''+1)/4 is an integer. The assumption is trivial for ''c''≡0 (mod ''p''). Thus we may assume that ''p'' does not divide ''c''. Then :<math>m_p^2 \equiv c^{\frac{(p+1)}{2}} \equiv c\cdot c^{\frac{(p-1)}{2}} \equiv c \cdot\left({c\over p}\right) \pmod{p},</math> where <math>\left({c\over p}\right)</math> is a [[Legendre symbol]]. From <math>c\equiv m^2\pmod{pq}</math> 