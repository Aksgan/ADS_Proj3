a string of characters. Most often the key is omitted, the record located sequentially or by direct cylinder-head-record addressing. If it is present, the key is typically a copy of the first n bytes of the data record but can be any data which will be used to find the record. The key (and hence the record) is locatable via hardware commands.<ref>Houtekamer, Gilbert E. and Artis, H. Pat, MVS I/O Subsystems, McGraw-Hill 1991, ISBN 0-07-002553-3</ref> Since the introduction of [[IBM System/360|IBM's System/360]] in 1964 nearly all [[IBM]] large and intermediate system [[Direct Access Storage Device|DASD]]s have used the Count Key Data Architecture<ref name="Sync">Introduction to Nonsynchronous Direct Access Storage Subsystems, IBM GC46-4519-0, January 1990, Chapter 2, Synchronous DASD Operations</ref>. Compare to [[Fixed Block Architecture]] (FBA). The advantages of Count Key Data architecture are: *The record size can be exactly matched to the application block size *CPU and memory requirements can be reduced by exploiting search-key commands. *IBM CKD devices operate synchronously with the system channel and can process information in the gaps between the various fields, thereby achieving higher performance by avoiding the redundant transfer of information to the host<ref name="Sync" />. Reduced CPU and memory prices and higher device and interface speeds have somewhat nullified the advantages of CKD, and it is retained only because IBM's flagship operating system [[z/OS]] does not support sector-oriented interfaces. {{anchor|ECKD}} '''Extended Count Key Data''' (ECKD) refers to the CCW commands used with cached controllers for IBM [[Direct access storage device|DASD]]. The new commands were introduced on the cached versions of the [[IBM 3880]] and were extended on the [[IBM 3990]]. The ECKD channel commands provide improved performance for the obsolete Bus & Tag interface, [[ESCON]] (or Enterprise Systems Connection) interface or the newer [[FICON]] (Fiber Connectivity) protocol. ECKD allows the programmer to provide the control unit with information on intent and to perform operations in a single [[Channel_I/O#Channel_Program|channel program]] that would require multiple channel programms with CKD. ==References== {{Reflist}} [[Category:Computer memory]]</text> </page> <page> <id>8279</id> <title>Counterpropagation network</title> <text>{{unreferenced|date=June 2010}} {{orphan|date=June 2010}} The '''counterpropagation network''' is a hybrid network. It consists of an outstar network and a competitive filter network. It was developed in 1986 by [[Robert Hecht-Nielsen]]. It is guaranteed to find the correct weights, unlike regular back propagation networks that can become trapped in local minimums during training. The input layer [[neurode (neural network)|neurode]] connect to each neurode in the hidden layer. The hidden layer is a Kohonen network which categorizes the pattern that was input. The output layer is an [[outstar]] array which reproduces the correct output pattern for the category. Training is done in two stages. The hidden layer is first taught to categorize the patterns and the weights are then fixed for that layer. Then the output layer is trained. Each pattern that will be input needs a unique node in the hidden layer, which is often too large to work on real world problems. [[Category:Neural networks]]</text> </page> <page> <id>8293</id> <title>Coupling (computer programming)</title> <text>{{moreref|date=September 2010}} In [[computer science]], '''coupling''' or '''dependency''' is the degree to which each program module relies on each one of the other modules. Coupling is usually contrasted with [[cohesion (computer science)|cohesion]]. Low coupling often correlates with high cohesion, and vice versa. The [[software metric|software quality metrics]] of coupling and cohesion were invented by [[Larry Constantine]], an original developer of Structured Design<ref>W. Stevens, G. Myers, L. Constantine, "Structured Design", IBM Systems Journal, 13 (2), 115-139, 1974.</ref> who was also an early proponent of these concepts (see also [[Structured Systems Analysis and Design Methodology|SSADM]]). Low coupling is often a sign of a well-structured [[Computer|computer system]] and a good design, and when combined with high cohesion, supports the general goals of high readability and maintainability. == Types of coupling == [[Image:Coupling sketches cropped 1.svg|thumb|300px|right|upright=2.0|Conceptual model of coupling]] Coupling can be "low" (also "loose" and "weak") or "high" (also "tight" and "strong"). Some types of coupling, in order of highest to lowest coupling, are as follows: ;Content coupling (high): Content coupling is when one module modifies or relies on the internal workings of another module (e.g., accessing local data of another module). :Therefore changing the way the second module produces data (location, type, timing) will lead to changing the dependent module. ;Common coupling: Common coupling is when two modules share the same global data (e.g., a global variable). :Changing the shared resource implies changing all the modules using it. ;External coupling: External coupling occurs when two modules share an externally imposed data format, communication protocol, or device interface. ;Control coupling: Control coupling is one module controlling the flow of another, by passing it information on what to do (e.g., passing a what-to-do flag). ;Stamp coupling (Data-structured coupling): Stamp coupling is when modules share a composite data structure and use only a part of it, possibly a different part (e.g., passing a whole record to a function that only needs one field of it). :This may lead to changing the way a module reads a record because a field that the module doesn't need has been modified. ;Data coupling: Data coupling is when modules share data through, for example, parameters. Each datum is an elementary piece, and these are the only data shared (e.g., passing an integer to a function that computes a square root). ;Message coupling (low): This is the loosest type of coupling. It can be achieved by state decentralization(as in objects)and component communication is done via parameters or message passing.(see [[Message passing]]). ;No coupling: Modules do not communicate at all with one another. === Object-oriented programming === ;Subclass Coupling: Describes the relationship between a child and its parent. The child is connected to its parent, but the parent isn't connected to the child. ;Temporal coupling: When two actions are bundled together into one module just because they happen to occur at the same time. == Disadvantages == Tightly coupled systems tend to exhibit the following developmental characteristics, which are often seen as disadvantages: # A change in one module usually forces a [[ripple effect]] of changes in other modules. 