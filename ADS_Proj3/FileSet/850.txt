properly expose them. A class factory is exposed differently, depending on the nature of the server code. A server which is DLL-based must export a '''DllGetClassObject()''' global function. A server which is EXE-based registers the class factory at runtime via the '''CoRegisterClassObject()''' Windows API function. The following is a general outline of the sequence of object creation via its class factory:<!--applies to list as well--> <ol> <li>The object's class factory is obtained via the '''CoGetClassObject()''' API (a standard Windows API).<br> As part of the call to CoGetClassObject(), the Class ID of the object (to be created) must be supplied. The following C++ code demonstrates this:<pre> IClassFactory* pIClassFactory = NULL; CoGetClassObject(CLSID_SomeObject, CLSCTX_ALL, NULL, IID_IClassFactory, (LPVOID*)&pIClassFactory);</pre>The above code indicates that the Class Factory object of a COM object, which is identified by the class id CLSID_SomeObject, is required. This class factory object is returned by way of its IClassFactory interface.</li> <li>The returned class factory object is then requested to create an instance of the originally intended COM object. The following C++ code demonstrates this:<pre> ISomeObject* pISomeObject = NULL; if (pIClassFactory) { pIClassFactory->CreateInstance (NULL, IID_ISomeObject, (LPVOID*)&pISomeObject); pIClassFactory->Release(); pIClassFactory = NULL; }</pre>The above code indicates the use of the Class Factory object's '''CreateInstance()''' method to create an object which exposes an interface identified by the IID_ISomeObject GUID. A pointer to the ISomeObject interface of this object is returned. Also note that because the class factory object is itself a COM object, it needs to be released when it is no longer required (i.e. its '''Release()''' method must be called).</li> </ol> The above demonstrates, at the most basic level, the use of a class factory to instantiate an object. Higher level constructs are also available, some of which do not even involve direct use of the Windows APIs. For example, the '''CoCreateInstance()''' API can be used by an application to directly create a COM object without acquiring the object's class factory. However, internally, the CoCreateInstance() API itself will invoke the CoGetClassObject() API to obtain the object's class factory and then use the class factory's CreateInstance() method to create the COM object. VBScript supplies the '''New''' keyword as well as the '''CreateObject()''' global function for object instantiation. These language constructs encapsulate the acquisition of the class factory object of the target object (via the CoGetClassObject() API) followed by the invocation of the IClassFactory::CreateInstance() method. Other languages, e.g. PowerBuilder's PowerScript may also provide their own high-level object creation constructs. However, CoGetClassObject() and the IClassFactory interface remain the most fundamental object creation technique. ===Reflection=== {{See also|reflection (computer science)}} At the time of the inception of COM technologies, the only way for a client to find out what features an object would offer was to actually create one instance and call into its QueryInterface method (part of the required IUnknown interface). This way of exploration became awkward for many applications, including the selection of appropriate components for a certain task, and tools to help a developer understand how to use methods provided by an object. As a result, COM Type Libraries were introduced, through which components can describe themselves. A type library contains information such as the CLSID of a component, the IIDs of the interfaces the component implements, and descriptions of each of the methods of those interfaces. Type libraries are typically used by [[Rapid application development|Rapid Application Development]] (RAD) environments such as [[Visual Basic]] or [[Visual Studio]] to assist developers of client applications. ===Programming=== COM is a binary standard (also said to be '''language agnostic''') and may be developed in any programming language capable of understanding and implementing its binary defined data types and interfaces. Runtime libraries (in extreme situations, the programmers) are responsible for entering and leaving the COM environment, instantiating and reference counting COM objects, querying objects for version information, coding to take advantage of advanced object versions, and coding [[graceful degradation]] of function when newer versions are not available. ===Application and network transparency=== COM objects may be instantiated and referenced from within a process, across process boundaries within a computer, and across a network, using the DCOM technology. [[Out-of-process]] and remote objects may use [[serialization|marshalling]] to send method calls and return values back and forth. The marshalling is invisible to the object and the code using the object. ===Threading in COM=== In COM, threading issues are addressed by a concept known as "'''apartment models'''". Here the term "'''apartment'''" refers to an execution context wherein a single thread or a group of threads is associated with one or more '''COM objects'''. Apartments stipulate the following general guidelines for participating threads and objects:<!--applies to list as well--> *Each COM object is associated with one and only one apartment. This is decided at the time the object is created at runtime. After this initial setup, the object remains in that apartment throughout its lifetime. *A COM thread (i.e., a thread in which COM objects are created or COM method calls are made) is also associated with an apartment. Like COM objects, the apartment with which a thread is associated is also decided at initialization time. Each COM thread also remains in its designated apartment until it terminates. *Threads and objects which belong to the same apartment are said to follow the same thread access rules. Method calls which are made inside the same apartment are performed directly without any assistance from COM. *Threads and objects from different apartments are said to play by different thread access rules. Method calls made across apartments are achieved via marshalling. This requires the use of proxies and stubs. There are three types of Apartment Models in the COM world: '''[[Single threading|Single-Threaded]] Apartment (STA)''', '''Multi-Threaded Apartment (MTA)''', and '''Neutral Apartment'''. Each apartment represents one mechanism whereby an object's internal state may be synchronized across multiple threads. The Single-Threaded Apartment (STA) model is a very commonly used model. Here, a COM object stands in a position similar to a desktop application's user interface. In an STA model, a single thread is dedicated to drive an object's methods, i.e. a single thread is always 