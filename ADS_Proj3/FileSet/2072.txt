cap The cap module (sometimes called a "cell" in IP Pascal terminology, after a concept in [[integrated circuit]] design) terminates the stack, and begins a return process that ripples back down until the program terminates. Each module has its startup or entry section performed on the way up the stack, and its finalization or exit section performed on the way back down. This matches the natural dependencies in a program. The most primitive modules, such as the basic I/O support in "serlib", perform their initialization first, and their finalization last, before and after the higher level modules in the stack. == Porting platform == IP Pascal has a series of modules (or "libraries") that form a "porting platform". These libraries present an idealized [[API]] for each function that applies, such as files and extended operating system functions, graphics, midi and sound, etc. The whole collection forms the basis for an implementation on each operating system and machine that IP Pascal appears on. The two important differences between IP Pascal and many other languages that have simply been mated with portable graphics libraries are that: 1. IP Pascal uses its own porting platform for its own low level code, so that once the platform is created for a particular operating system and machine, both the IP system and the programs it compiles can run on that. This is similar to the way [[Java (programming language)|Java]] and the [[UCSD Pascal]] systems work, but with true high optimization compiled code, not interpreted code or "just in time" compiled code. 2. Since modules can override lower level functions such as Pascal's "write" statement, normal, unmodified ISO 7185 Pascal programs can also use advanced aspects of the porting platform. This is unlike many or most portable graphics libraries that force the user to use a completely different I/O methodology to access a windowed graphics system, for example C, other Pascals, and [[Visual Basic]]. IP modules can also be created that are system independent, and rely only on the porting platform modules. The result is that IP Pascal is very highly portable. <!-- Commented out because image was deleted: [[Image:hellogra.png|right|400px]] --> Example: The standard "hello world" program is coupled to output into a graphical window. '''program''' HelloWorld(output);<br/> '''begin'''<br/> writeln('Hello, World!')<br/> '''end'''. <!-- Commented out because image was deleted: [[Image:hellogra3.png|right|400px]] --> Example: "hello world" with graphical commands added. Note that standard Pascal output statements are still used. '''program''' hello(input, output);<br/> '''uses''' gralib;<br/> '''var''' er: evtrec;<br/> '''begin'''<br/> bcolor(output, green); curvis(output, false); auto(output, false); page(output); fcolor(output, red); frect(output, 50, 50, maxxg(output)-50, maxyg(output)-50); fcolorg(output, maxint, maxint-(maxint div 3), maxint-maxint div 3); frect(output, 50, 50, 53, maxyg(output)-50); frect(output, 50, 50, maxxg(output)-50, 53); fcolorg(output, maxint div 2, 0, 0); frect(output, 52, maxyg(output)-53, maxxg(output)-50, maxyg(output)-50); frect(output, maxxg(output)-53, 52, maxxg(output)-50, maxyg(output)-50); font(output, font_sign); fontsiz(output, 100); binvis(output); fcolor(output, cyan); cursorg(output, maxxg(output) div 2-strsiz(output, 'hello, world') div 2+3, maxyg(output) div 2-100 div 2+3); writeln('hello, world'); fcolor(output, blue); cursorg(output, maxxg(output) div 2-strsiz(output, 'hello, world') div 2, maxyg(output) div 2-100 div 2); writeln('hello, world'); '''repeat''' event(input, er) '''until''' er.etype = etterm<br/> '''end'''. [[Image:breakshot.png|right|400px]] Example: Breakout game. [[Image:clockg.png|right]] Example: Graphical clock in a sizable window. Because IP Pascal modules can "override" each other, a graphical extension module (or any other type of module) can override the standard I/O calls implemented in a module below it. Thus, paslib implements standard Pascal statements such as read, write, and other support services. gralib overrides these services and redirects all standard Pascal I/O to graphical windows. The difference between this and such libraries in other implementations is that you typically have to stop using the standard I/O statements and switch to a completely different set of calls and paradigms. This means that you cannot "bring forward" programs implemented with the serial I/O paradigm to graphical systems. Another important difference with IP Pascal is that it uses procedural language methods to access the Windowed graphics library. Most graphics toolkits force the use of [[object-oriented programming]] methods to the toolkit. One reason for this is because [[Object orientation]] is a good match for graphics, but it also occurs because common systems such as Windows force the application program to appear as a service program to the operating system, appearing as a collection of functions called by the operating system, instead of having the program control its own execution and call the operating system. This is commonly known as [[Callback (computer science)|callback]] design. Object-oriented code often works better with callbacks because it permits an object's methods to be called as callbacks, instead of a programmer having to register several pointers to functions to event handling code, each of which would be an individual callback. Object-orientation is a good programming method, but IP Pascal makes it an optional, not a required, methodology to write programs. IP Pascal's ability to use procedural methods to access all graphics functions means that there is no "[[cliff effect]]" for older programs. They don't need to be rewritten just to take advantage of modern programming environments. Another interesting feature of the IP porting platform is that it supports a character mode, even in graphical environments, by providing a "character grid" that overlays the pixel grid, and programs that use only character mode calls (that would work on any terminal or telnet connection) work under graphical environments automatically. == History == === The Z80 implementation === The compiler started out in 1980 on [[Micropolis (company)|Micropolis]] Disk Operating System, but was moved rapidly to [[CP/M]] running on the Z80. The original system was coded in Z80 assembly language, and output direct machine code for the [[Z80]]. It was a single pass compiler without a linker, it included its system support library within the compiler, and relocated and output that into the generated code into the runnable disk file. After the compiler was operational, almost exactly at the new year of 1980, a companion assembler for the compiler was written, in Pascal, followed by a linker, in Z80 assembly language. This odd combination was due to a calculation that showed the linker tables would be 