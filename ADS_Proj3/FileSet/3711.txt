(now incorporated into the [[Autodesk]] [[3D Studio Max]] internal render engine), [[form-Z|formâ€¢Z]] [[RenderZone Plus]] by [[AutoDesSys, Inc.]]), and [[Electric Image Animation System|ElAS]] (Electric Image Animation System). == Visual characteristics == [[Image:Radiosity Comparison.jpg|thumb|484px|right|Difference between standard direct illumination and radiosity]] The inclusion of radiosity calculations in the rendering process often lends an added element of realism to the finished scene, because of the way it mimics real-world phenomena. Consider a simple room scene. The image on the left was rendered with a typical '''direct illumination renderer'''. There are ''three types'' of lighting in this scene which have been specifically chosen and placed by the artist in an attempt to create realistic lighting: '''spot lighting''' with shadows (placed outside the window to create the light shining on the floor), '''ambient lighting''' (without which any part of the room not lit directly by a light source would be totally dark), and '''omnidirectional lighting''' without shadows (to reduce the flatness of the ambient lighting). The image on the right was rendered using a '''radiosity algorithm'''. There is only '''one source of light''': an image of the sky placed outside the window. The difference is marked. The room glows with light. Soft shadows are visible on the floor, and subtle lighting effects are noticeable around the room. Furthermore, the red color from the carpet has bled onto the grey walls, giving them a slightly warm appearance. None of these effects were specifically chosen or designed by the artist. == Overview of the radiosity algorithm == The surfaces of the scene to be rendered are each divided up into one or more smaller surfaces (patches). A [[view factor]] is computed for each pair of patches. View factors (also known as ''form factors'') are coefficients describing how well the patches can see each other. Patches that are far away from each other, or oriented at oblique angles relative to one another, will have smaller view factors. If other patches are in the way, the view factor will be reduced or zero, depending on whether the occlusion is partial or total. The view factors are used as coefficients in a linearized form of the rendering equation, which yields a linear system of equations. Solving this system yields the radiosity, or brightness, of each patch, taking into account diffuse interreflections and soft shadows. Progressive radiosity solves the system iteratively in such a way that after each iteration we have intermediate radiosity values for the patch. These intermediate values correspond to bounce levels. That is, after one iteration, we know how the scene looks after one light bounce, after two passes, two bounces, and so forth. Progressive radiosity is useful for getting an interactive preview of the scene. Also, the user can stop the iterations once the image looks good enough, rather than wait for the computation to numerically converge. [[Image:Radiosity Progress.png|thumb|680px|center|As the algorithm iterates, light can be seen to flow into the scene, as multiple bounces are computed. Individual patches are visible as squares on the walls and floor.]] Another common method for solving the radiosity equation is "shooting radiosity," which iteratively solves the radiosity equation by "shooting" light from the patch with the most error at each step. After the first pass, only those patches which are in direct line of sight of a light-emitting patch will be illuminated. After the second pass, more patches will become illuminated as the light begins to bounce around the scene. The scene continues to grow brighter and eventually reaches a steady state. == Mathematical formulation == The basic radiosity method has its basis in the theory of [[heat|thermal radiation]], since radiosity relies on computing the amount of light energy transferred among surfaces. In order to simplify computations, the method assumes that all scattering is [[Lambert's cosine law|perfectly diffuse]]. Surfaces are typically discretized into quadrilateral or triangular [[finite element method|elements]] over which a piecewise polynomial function is defined. After this breakdown, the amount of light energy transfer can be computed by using the known reflectivity of the reflecting patch, combined with the [[view factor]] of the two patches. This [[Dimensionless number|dimensionless quantity]] is computed from the geometric orientation of two patches, and can be thought of as the fraction of the total possible emitting area of the first patch which is covered by the second patch. More correctly, radiosity is the energy leaving the patch surface per discrete time interval and is the combination of emitted and reflected energy: :<math>B_i\, d A_i = E_i\, d A_i + R_i \int_j B_j F_{ji}\, d A_j,\,\!</math> where: * ''B<sub>i</sub>'' is the [[radiosity (heat transfer)|radiosity]] of patch ''i''. * ''E<sub>i</sub>'' is emitted energy. * ''R<sub>i</sub>'' is the reflectivity of the patch, giving reflected energy by multiplying by the incident energy (the energy which arrives from other patches). * All ''j'' (<math>j \ne i</math>) in the rendered environment are integrated for ''B<sub>j</sub>F<sub>ji</sub>'' ''dA<sub>j</sub>'', to determine the energy leaving each patch ''j'' that arrives at patch ''i''. * ''F<sub>ij</sub>'' is the constant-valued [[view factor]] for the radiation leaving ''i'' and hitting patch ''j''. The reciprocity: :<math>A_i F_{ij} = A_j F_{ji} \,\!</math> gives: :<math>B_i = E_i + R_i \int_j B_j F_{ij}\,\!</math> For ease of use the [[integral]] is replaced and uniform radiosity is assumed over the patch, creating the simpler: :<math>B_i = E_i + R_i \sum_{j=1}^n B_j F_{ij}</math> This equation can then be applied to each patch. The equation is monochromatic, so color radiosity rendering requires calculation for each of the required colors. The [[view factor]] F<sub>ji</sub> can be calculated in a number of ways. Early methods used a ''[[Hemicube (computer graphics)|hemicube]]'' (an imaginary cube centered upon the first surface to which the second surface was projected, devised by Cohen and Greenberg in 1985) to approximate the form factor, which also solved the intervening patch problem. This is quite [[computation]]ally expensive, because ideally [[form factor (radiative transfer)|form factor]]s must be derived for every possible pair of patches, leading to a [[Quadratic function|quadratic]] increase in computation with added geometry. New methods include adaptive integration<ref>G Walton, ''Calculation of Obstructed View Factors by 