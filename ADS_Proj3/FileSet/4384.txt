variables referenced in <math>Op</math>, and <math>T_{1} \dots T_{n}</math> their corresponding types. The ''Input Space'' (IS) of <math>Op</math>, written <math>IS_{Op}</math>, is the Z schema box defined by <math>[x_{1}:T_{1} \dots x_{n}:T_{n}]</math>. ===Valid input space=== Let <math>Op</math> be a Z operation. Let <math>\text{pre } Op</math> be the [[precondition]] of <math>Op</math>. The ''Valid Input Space'' (VIS) of <math>Op</math>, written <math>VIS_{Op}</math>, is the Z schema box defined by <math>[IS_{Op} | \text{pre } Op]</math>. ===Test class=== Let <math>Op</math> be a Z operation and let <math>P</math> be any [[Predicate (mathematical logic)|predicate]] depending on one or more of the variables defined in <math>VIS_{Op}</math>. Then, the Z schema box <math>[VIS_{Op} | P]</math> is a ''test class'' of <math>Op</math>. Note that this schema is equivalent to <math>[IS_{Op} | \text{pre } Op \land P]</math>. This observation can be generalized by saying that if <math>C_{Op}</math> is a test class of <math>Op</math>, then the Z schema box defined by <math>[C_{Op} | P]</math> is also a test class of <math>Op</math>. According to this definition the VIS is also a test class. If <math>C_{Op}</math> is a test class of <math>Op</math>, then the predicate <math>P</math> in <math>C'_{Op} == [C_{Op} | P]</math> is said to be the ''characteristic'' predicate of <math>C'_{Op}</math> or <math>C'_{Op}</math> is ''characterized'' by <math>P</math>. Test classes are also called test objectives {{Harv|Utting|Legeard|2007}}, test templates {{Harv|Stocks|Carrington|1996}} and test specifications. ===Testing tactic=== In the context of the TTF a ''testing tactic''<ref name="testing strategy"/> is a means to [[Partition of a set|partition]] any [[#Test class|test class]] of any operation. However, some of the testing tactics used in practice actually do not always generate a partition of some test classes. Some testing tactics originally proposed for the TTF are the following: *[[Disjunctive Normal Form]] (DNF). By applying this tactic the operation is written in [[Disjunctive Normal Form]] and the [[#Test class|test class]] is divided in as many test classes as terms are in the resulting operation's predicate. The predicate added to each new test class is the [[precondition]] of one of the terms in the operation's predicate. *Standard Partitions (SP). This tactic uses a predefined partition of some mathematical operator {{Harv|Stocks|1993}}. For example, the following is a good partition for expresions of the form <math>S \spadesuit T</math> where <math>\spadesuit</math> is one of <math>\cup</math>, <math>\cap</math> and <math>\setminus</math> (see [[Set theory]]). <center> {| class="wikitable" |- | <math>S = \emptyset, T = \emptyset</math> | <math>S \neq \emptyset, T \neq \emptyset, S \subset T</math> |- | <math>S = \emptyset, T \neq \emptyset</math> | <math>S \neq \emptyset, T \neq \emptyset, T \subset S</math> |- | <math>S \neq \emptyset, T = \emptyset</math> | <math>S \neq \emptyset, T \neq \emptyset, T = S</math> |- | <math>S \neq \emptyset, T \neq \emptyset, S \cap T = \emptyset</math> | <math>S \neq \emptyset, T \neq \emptyset, S \cap T \neq \emptyset, \lnot (S \subseteq T), \lnot (T \subseteq S), S \neq T</math> |} </center> :As can be noticed, standard partitions might change according to how much testing the engineer wants to perform. *Sub-domain Propagation (SDP). This tactic is applied to expressions containing: # Two or more mathematical operators for which there are already defined standard partitions, or # Mathematical operators which are defined in terms of other mathematical operators. :In any of these cases, the standard partitions of the operators appearing in the expression or in the definition of a complex one, are combined to produce a partition for the expression. If the tactic is applied to the second case, then the resulting partition can be considered as the standard partition for that operator. Stocks and Carrington in {{Harv|Stocks|Carrington|1996}} illustrate this situation with <math>R \oplus G = (\text{dom } G \ntriangleleft R)\cup G</math>, where <math>\ntriangleleft</math> means [[Restriction (mathematics)|domain anti-restriction]], by giving standard partitions for <math>\ntriangleleft</math> and <math>\cup</math> and propagating them to calculate a partition for <math>\oplus</math>. *Specification Mutation (SM). The first step of this tactic consists in generating a ''mutant'' of the Z operation. A mutant of a Z operation is similar in concept to a [[Mutation testing|mutant of a program]], i.e. it is a modified version of the operation. The modification is introduced by the engineer with the intention of uncovering an error in the implementation. The mutant should be the specification that the engineer guesses the programmer has implemented. Then, the engineer has to calculate the subset of the VIS that yields different results in both specifications. The predicate of this set is used to derive a new test class. Some other testing tactics that may also be used are the following: *In Set Extension (ISE). It applies to predicates of the form <math>expr \in \{expr_{1}, \dots, expr_{n}\}</math>. In this case, it generates <math>n</math> test classes such that a predicate of the form <math>expr = expr_{i}</math> is added to each of them. *Mandatory Test Set (MTS). This tactic associates a set of constant values to a VIS' variable and generates as many test classes as elements are in the set. Each test class is characterized by a predicate of the form <math>var = val</math> where <math>var</math> is the name of the variable and <math>val</math> is one of the values of the set. *Numeric Ranges (NR). This tactic applies only to VIS' variables of type <math>\mathbb{Z}</math> (or its "subtype" <math>\mathbb{N}</math>). It consists in associating a range to a variable and deriving test classes by comparing the variable with the limits of the range in some ways. More formally, let <math>n</math> be a variable of type <math>\mathbb{Z}</math> and let <math>[i,j]</math> be the associated range. Then, the tactic generates the test classes characterized by the following predicates: <math>n<i</math>, <math>n=i</math>, <math>i<n \land n<j</math>, <math>n=j</math>, <math>n>j</math>. *Free Type (FT). This tactic generates as many test classes as elements a free (enumerated) type has. In other words, if a model defines type <math>COLOUR ::= red | blue | green</math> and some operation uses <math>c</math> of type <math>COLOUR</math>, then by applying this tactic each test class will by divided into three new test classes: one in which <math>c</math> equals <math>red</math>, the other in which <math>c</math> equals <math>blue</math>, and the third where <math>c</math> equals <math>green</math>. *Proper Subset of Set Extension (PSSE). This tactic uses 