The '''1.1.1a''' release fixes a critical buffer overrun issue, and is otherwise completely compatible with 1.1.1. A '''1.1.2''' prerelease was temporarily available but appears to have been abandoned. Version '''2.0''' is currently in development, which includes a minor API refactoring and support for OpenGL profiles GL 1.3 - 3.0, GL 3.1 - 3.3, GL â‰¥ 4.0, ES 1.x and ES 2.x. ==Java2D-OpenGL interoperability== Since the [[Java SE 6]] version of the [[Java (programming language)|Java]] language, [[Java2D]] (the [[API]] for drawing two dimensional graphics in Java) and JOGL have become interoperable, allowing it to : * Overlay [[Swing (Java)|Swing]] components (lightweight menus, tooltips, and other [[Widget_(computing)|widget]]s) on top of [[OpenGL]] rendering. * Draw 3D [[OpenGL]] graphics on top of [[Java2D]] rendering (see [http://www.curious-creature.org/2005/12/21/a-swing-button-with-3d-source-codedemo/ here] for a button with an OpenGL icon). * Use 3D graphics anywhere where ordinarily a [[Swing (Java)|Swing]] [[Widget (computing)|widget]] would be used. (Inside a JTable, JTree, ...) * Draw [[Java2D]] graphics on top of 3D [[OpenGL]] rendering. == 3D tetrahedron example == [[Image:joglpyr.png|right|thumb|240px|JOGL - 3D Tetrahedron Picture]] This program displays a simple 3D rendering of a [[tetrahedron]] using JOGL (version 1.x). <br /><br /><br /><br /><br /><br /> '''<code>JOGLTetrahedron </code> class'''&mdash;This class uses the JOGL API (version 1.x) to render a 3D tetrahedron. <source lang=java> //depends on jogl.jar and gluegen-rt.jar import javax.media.opengl.GL; import javax.media.opengl.GLEventListener; import javax.media.opengl.GLAutoDrawable; import javax.media.opengl.glu.GLU; import java.awt.event.KeyEvent; import java.awt.event.KeyListener; import javax.media.opengl.GLCanvas; import java.awt.Frame; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import com.sun.opengl.util.Animator; public class JOGLTetrahedron implements GLEventListener, KeyListener { float rotateT = 0.0f; static GLU glu = new GLU(); static GLCanvas canvas = new GLCanvas(); static Frame frame = new Frame("Jogl 3D Shape/Rotation"); static Animator animator = new Animator(canvas); public void display(GLAutoDrawable gLDrawable) { final GL gl = gLDrawable.getGL(); gl.glClear(GL.GL_COLOR_BUFFER_BIT); gl.glClear(GL.GL_DEPTH_BUFFER_BIT); gl.glLoadIdentity(); gl.glTranslatef(0.0f, 0.0f, -5.0f); gl.glRotatef(rotateT, 1.0f, 0.0f, 0.0f); gl.glRotatef(rotateT, 0.0f, 1.0f, 0.0f); gl.glRotatef(rotateT, 0.0f, 0.0f, 1.0f); gl.glRotatef(rotateT, 0.0f, 1.0f, 0.0f); gl.glBegin(GL.GL_TRIANGLES); // Front gl.glColor3f(0.0f, 1.0f, 1.0f); gl.glVertex3f(0.0f, 1.0f, 0.0f); gl.glColor3f(0.0f, 0.0f, 1.0f); gl.glVertex3f(-1.0f, -1.0f, 1.0f); gl.glColor3f(0.0f, 0.0f, 0.0f); gl.glVertex3f(1.0f, -1.0f, 1.0f); // Right Side Facing Front gl.glColor3f(0.0f, 1.0f, 1.0f); gl.glVertex3f(0.0f, 1.0f, 0.0f); gl.glColor3f(0.0f, 0.0f, 1.0f); gl.glVertex3f(1.0f, -1.0f, 1.0f); gl.glColor3f(0.0f, 0.0f, 0.0f); gl.glVertex3f(0.0f, -1.0f, -1.0f); // Left Side Facing Front gl.glColor3f(0.0f, 1.0f, 1.0f); gl.glVertex3f(0.0f, 1.0f, 0.0f); gl.glColor3f(0.0f, 0.0f, 1.0f); gl.glVertex3f(0.0f, -1.0f, -1.0f); gl.glColor3f(0.0f, 0.0f, 0.0f); gl.glVertex3f(-1.0f, -1.0f, 1.0f); // Bottom gl.glColor3f(0.0f, 0.0f, 0.0f); gl.glVertex3f(-1.0f, -1.0f, 1.0f); gl.glColor3f(0.1f, 0.1f, 0.1f); gl.glVertex3f(1.0f, -1.0f, 1.0f); gl.glColor3f(0.2f, 0.2f, 0.2f); gl.glVertex3f(0.0f, -1.0f, -1.0f); gl.glEnd(); rotateT += 0.2f; } public void displayChanged(GLAutoDrawable gLDrawable, boolean modeChanged, boolean deviceChanged) { } public void init(GLAutoDrawable gLDrawable) { GL gl = gLDrawable.getGL(); gl.glShadeModel(GL.GL_SMOOTH); gl.glClearColor(0.0f, 0.0f, 0.0f, 0.0f); gl.glClearDepth(1.0f); gl.glEnable(GL.GL_DEPTH_TEST); gl.glDepthFunc(GL.GL_LEQUAL); gl.glHint(GL.GL_PERSPECTIVE_CORRECTION_HINT, GL.GL_NICEST); gLDrawable.addKeyListener(this); } public void reshape(GLAutoDrawable gLDrawable, int x, int y, int width, int height) { GL gl = gLDrawable.getGL(); if(height <= 0) { height = 1; } float h = (float)width / (float)height; gl.glMatrixMode(GL.GL_PROJECTION); gl.glLoadIdentity(); glu.gluPerspective(50.0f, h, 1.0, 1000.0); gl.glMatrixMode(GL.GL_MODELVIEW); gl.glLoadIdentity(); } public void keyPressed(KeyEvent e) { if(e.getKeyCode() == KeyEvent.VK_ESCAPE) { exit(); } } public void keyReleased(KeyEvent e) { } public void keyTyped(KeyEvent e) { } public static void exit(){ animator.stop(); frame.dispose(); System.exit(0); } public static void main(String[] args) { canvas.addGLEventListener(new JOGLTetrahedron()); frame.add(canvas); frame.setSize(640, 480); frame.setUndecorated(true); frame.setExtendedState(Frame.MAXIMIZED_BOTH); frame.addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) { exit(); } }); frame.setVisible(true); animator.start(); canvas.requestFocus(); } } </source> '''<code>JOGLTetrahedron </code> class'''&mdash;This class uses the JOGL API (version 2.0) to render a 3D tetrahedron. <source lang=java> import java.awt.Component; import java.awt.Frame; import java.awt.event.KeyEvent; import java.awt.event.KeyListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import javax.media.opengl.GL; import javax.media.opengl.GL2; import javax.media.opengl.GL2ES1; import javax.media.opengl.GLAutoDrawable; import javax.media.opengl.GLEventListener; import javax.media.opengl.awt.GLCanvas; import javax.media.opengl.fixedfunc.GLLightingFunc; import javax.media.opengl.fixedfunc.GLMatrixFunc; import javax.media.opengl.glu.GLU; import com.jogamp.opengl.util.Animator; /** * ported to JOGL 2.0 by Julien Gouesse (http://tuer.sourceforge.net) */ public class JOGLTetrahedron implements GLEventListener, KeyListener { float rotateT = 0.0f; static GLU glu = new GLU(); static GLCanvas canvas = new GLCanvas(); static Frame frame = new Frame("Jogl 3D Shape/Rotation"); static Animator animator = new Animator(canvas); public void display(GLAutoDrawable gLDrawable) { final GL2 gl = gLDrawable.getGL().getGL2(); gl.glClear(GL.GL_COLOR_BUFFER_BIT); gl.glClear(GL.GL_DEPTH_BUFFER_BIT); gl.glLoadIdentity(); gl.glTranslatef(0.0f, 0.0f, -5.0f); gl.glRotatef(rotateT, 1.0f, 0.0f, 0.0f); gl.glRotatef(rotateT, 0.0f, 1.0f, 0.0f); gl.glRotatef(rotateT, 0.0f, 0.0f, 1.0f); gl.glRotatef(rotateT, 0.0f, 1.0f, 0.0f); gl.glBegin(GL.GL_TRIANGLES); // Front gl.glColor3f(0.0f, 1.0f, 1.0f); gl.glVertex3f(0.0f, 1.0f, 0.0f); gl.glColor3f(0.0f, 0.0f, 1.0f); gl.glVertex3f(-1.0f, -1.0f, 1.0f); gl.glColor3f(0.0f, 0.0f, 0.0f); gl.glVertex3f(1.0f, -1.0f, 1.0f); // Right Side Facing Front gl.glColor3f(0.0f, 1.0f, 1.0f); gl.glVertex3f(0.0f, 1.0f, 0.0f); gl.glColor3f(0.0f, 0.0f, 1.0f); gl.glVertex3f(1.0f, -1.0f, 1.0f); gl.glColor3f(0.0f, 0.0f, 0.0f); gl.glVertex3f(0.0f, -1.0f, -1.0f); // Left Side Facing Front gl.glColor3f(0.0f, 1.0f, 1.0f); gl.glVertex3f(0.0f, 1.0f, 0.0f); gl.glColor3f(0.0f, 0.0f, 1.0f); gl.glVertex3f(0.0f, -1.0f, -1.0f); gl.glColor3f(0.0f, 0.0f, 0.0f); gl.glVertex3f(-1.0f, -1.0f, 1.0f); // Bottom gl.glColor3f(0.0f, 0.0f, 0.0f); gl.glVertex3f(-1.0f, -1.0f, 1.0f); gl.glColor3f(0.1f, 0.1f, 0.1f); gl.glVertex3f(1.0f, -1.0f, 1.0f); gl.glColor3f(0.2f, 0.2f, 0.2f); gl.glVertex3f(0.0f, -1.0f, -1.0f); gl.glEnd(); rotateT += 0.2f; } public void displayChanged(GLAutoDrawable gLDrawable, boolean modeChanged, boolean deviceChanged) { } public void init(GLAutoDrawable gLDrawable) { GL2 gl = gLDrawable.getGL().getGL2(); gl.glShadeModel(GLLightingFunc.GL_SMOOTH); gl.glClearColor(0.0f, 0.0f, 0.0f, 0.0f); gl.glClearDepth(1.0f); gl.glEnable(GL.GL_DEPTH_TEST); gl.glDepthFunc(GL.GL_LEQUAL); gl.glHint(GL2ES1.GL_PERSPECTIVE_CORRECTION_HINT, GL.GL_NICEST); ((Component) gLDrawable).addKeyListener(this); } public void reshape(GLAutoDrawable gLDrawable, int x, int y, int width, int height) { GL2 gl = gLDrawable.getGL().getGL2(); if (height <= 0) { height = 1; } float h = (float) width / (float) height; gl.glMatrixMode(GLMatrixFunc.GL_PROJECTION); gl.glLoadIdentity(); glu.gluPerspective(50.0f, h, 1.0, 1000.0); gl.glMatrixMode(GLMatrixFunc.GL_MODELVIEW); gl.glLoadIdentity(); } public void keyPressed(KeyEvent e) { if (e.getKeyCode() == KeyEvent.VK_ESCAPE) { exit(); } } public void keyReleased(KeyEvent e) { } public void keyTyped(KeyEvent e) { } public static void exit() { animator.stop(); frame.dispose(); System.exit(0); } public static void main(String[] args) { canvas.addGLEventListener(new JOGLTetrahedron()); frame.add(canvas); frame.setSize(640, 480); frame.setUndecorated(true); frame.setExtendedState(Frame.MAXIMIZED_BOTH); frame.addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) { exit(); } }); frame.setVisible(true); animator.start(); canvas.requestFocus(); } public void dispose(GLAutoDrawable gLDrawable) { // do nothing } } </source> ==See also== * [[Java Bindings for OpenGL]], The Java Community Specification Request for which JOGL provides an implementation * [[Lightweight Java Game Library|LWJGL]], an alternative open-source OpenGL wrapper library * [[Ardor3D]], a high performance, professionally oriented scene graph using LWJGL and JOGL * [[Xith3D]], a scene graph based graphics API using JOGL and LWJGL * [[Elflight Engine]], a high performance 3D game engine optimised for the web * [[JMonkey Engine]], a high performance scene graph based graphics API using LWJGL and JOGL * [[Minecraft]], an sandbox indie game using LWJGL * [[Poxnora]], an online multiplayer game using JOGL * [[Wurm Online]], a 