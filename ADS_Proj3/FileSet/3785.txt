features ([[Branch (software)|branch]]), while the other version is where new features are worked on ([[Trunk (software)|trunk]]). At the simplest level, developers could simply retain multiple copies of the different versions of the program, and label them appropriately. This simple approach has been used on many large software projects. While this method can work, it is inefficient as many near-identical copies of the program have to be maintained. This requires a lot of self-discipline on the part of developers, and often leads to mistakes. Consequently, systems to automate some or all of the revision control process have been developed. Moreover, in software development, legal and business practice and other environments, it has become increasingly common for a single document or snippet of code to be edited by a team, the members of which may be geographically dispersed and may pursue different and even contrary interests. Sophisticated revision control that tracks and accounts for ownership of changes to documents and code may be extremely helpful or even necessary in such situations. Revision control may also track changes to configuration files, such as those typically stored in <code>/etc</code> or <code>/usr/local/etc</code> on Unix systems. This gives system administrators another way to easily track changes made and a way to roll back to earlier versions should the need arise. ==Source-management models== Traditional revision control systems use a centralized model where all the revision control functions take place on a shared [[Server (computing)|server]]. If two developers try to change the same file at the same time, without some method of managing access the developers may end up overwriting each other's work. Centralized revision control systems solve this problem in one of two different "source management models": file locking and version merging. ===Atomic operations=== Computer scientists speak of ''atomic'' operations if the system is left in a consistent state even if the operation is interrupted. The ''commit'' operation is usually the most critical in this sense. Commits are operations which tell the revision control system you want to make a group of changes you have been making final and available to all users. Not all revision control systems have atomic commits; notably, the widely-used [[Concurrent Versions System|CVS]] lacks this feature. ===File locking=== The simplest method of preventing "[[concurrent access]]" problems involves [[file locking|locking files]] so that only one developer at a time has write access to the central "repository" copies of those files. Once one developer "checks out" a file, others can read that file, but no one else may change that file until that developer "checks in" the updated version (or cancels the checkout). File locking has both merits and drawbacks. It can provide some protection against difficult merge conflicts when a user is making radical changes to many sections of a large file (or group of files). However, if the files are left exclusively locked for too long, other developers may be tempted to bypass the revision control software and change the files locally, leading to more serious problems. ===Version merging=== {{main | Merge (revision control) }} Most version control systems allow multiple developers to edit the same file at the same time. The first developer to "check in" changes to the central repository always succeeds. The system may provide facilities to [[Merge (revision control)|merge]] further changes into the central repository, and preserve the changes from the first developer when other developers check in. Merging two files can be a very delicate operation, and usually possible only if the data structure is simple, as in [[text file]]s. The result of a merge of two [[image file]]s might not result in an image file at all. The second developer checking in code will need to take care with the merge, to make sure that the changes are compatible and that the merge operation does not introduce its own [[logic]] errors within the files. These problems limit the availability of automatic or semi-automatic merge operations mainly to simple text based documents, unless a specific merge [[plugin]] is available for the file types. The concept of a ''reserved edit'' can provide an optional means to explicitly lock a file for exclusive write access, even when a merging capability exists. ===Baselines, labels and tags=== Most revision control tools will use only one of these similar terms (baseline, label, tag) to refer to the action of identifying a snapshot ("label the project") or the record of the snapshot ("try it with baseline ''X''"). Typically only one of the terms ''baseline'', ''label'', or ''tag'' is used in documentation or discussion{{Citation needed|date=January 2010}}; they can be considered synonyms. In most projects some snapshots are more significant than others, such as those used to indicate published releases, branches, or milestones. When both the term ''baseline'' and either of ''label'' or ''tag'' are used together in the same context, ''label'' and ''tag'' usually refer to the mechanism within the tool of identifying or making the record of the snapshot, and ''baseline'' indicates the increased significance of any given label or tag. Most formal discussion of [[configuration management]] uses the term [[Baseline (configuration management)|''baseline'']]. ==Distributed revision control== {{main|Distributed revision control}} Distributed revision control (DRCS) takes a peer-to-peer approach, as opposed to the client-server approach of centralized systems. Rather than a single, central repository on which clients synchronize, each peer's working copy of the codebase is a [[good faith|bona-fide]] repository.<ref>{{cite web | last = Wheeler | first = David | title = Comments on Open Source Software / Free Software (OSS/FS) Software Configuration Management (SCM) Systems | url = http://www.dwheeler.com/essays/scm.html | accessdate = May 8, 2007 }}</ref> Distributed revision control conducts synchronization by exchanging [[Patch (Unix)|patches]] (change-sets) from peer to peer. This results in some important differences from a centralized system: * No canonical, reference copy of the codebase exists by default; only working copies. * Common operations (such as commits, viewing history, and reverting changes) are fast, because there is no need to communicate with a central server.<ref name='OSullivan'>{{cite web | last = O'Sullivan | first = Bryan | title = Distributed revision control with 