dictionary, in many longer texts, in situations where a small number of differences is to be expected. Here, one of the strings is typically short, while the other is arbitrarily long. This has a wide range of applications, for instance, [[spell checker]]s, correction systems for [[optical character recognition]], and software to assist natural language translation based on [[translation memory]]. The Levenshtein distance can also be computed between two longer strings, but the cost to compute it, which is roughly proportional to the product of the two string lengths, makes this impractical. ==Relationship with other edit distance metrics== Levenshtein distance is not the only popular notion of edit distance. Variations can be obtained by changing the set of allowable edit operations: for instance, * length of the [[longest common subsequence problem|longest common subsequence]] is the metric obtained by allowing only addition and deletion, not substitution; * the [[Damerau–Levenshtein distance]] allows addition, deletion, substitution, and the [[transposition]] of two adjacent characters; * the [[Hamming distance]] only allows substitution (and hence, only applies to strings of the same length). [[Edit distance]] in general is usually defined as a parametrizable metric in which a repertoire of edit operations is available, and each operation is assigned a cost (possibly infinite). This is further generalized by DNA [[sequence alignment]] algorithms such as the [[Smith–Waterman algorithm]], which make an operation's cost depend on where it is applied. ==Computing Levenshtein distance== Computing the Levenshtein distance is based on the observation that if we reserve a [[Matrix (mathematics)|matrix]] to hold the Levenshtein distances between all [[prefix (computer science)|prefix]]es of the first string and all prefixes of the second, then we can compute the values in the matrix by [[flood fill]]ing the matrix, and thus find the distance between the two full strings as the last value computed. This algorithm, an example of bottom-up [[dynamic programming]], is discussed, with variants, in the 1974 article ''The [[String-to-string correction problem]]'' by Robert A. Wagner and Michael J. Fischer. A straightforward implementation, as [[pseudocode]] for a function ''LevenshteinDistance'' that takes two strings, ''s'' of length ''m'', and ''t'' of length ''n'', and returns the Levenshtein distance between them: '''int''' LevenshteinDistance('''char''' s[1..m], '''char''' t[1..n]) '''{''' ''// for all i and j, d[i,j] will hold the Levenshtein distance between'' ''// the first i characters of s and the first j characters of t;'' ''// note that d has (m+1)x(n+1) values '''declare''' '''int''' d[0..m, 0..n] '''for''' i '''from''' 0 '''to''' m d[i, 0] := i ''// the distance of any first string to an empty second string'' '''for''' j '''from''' 0 '''to''' n d[0, j] := j ''// the distance of any second string to an empty first string'' '''for''' j '''from''' 1 '''to''' n '''{''' '''for''' i '''from''' 1 '''to''' m '''{''' '''if''' s[i] = t[j] '''then''' <!-- not: s[i-1] = t[j-1] --> d[i, j] := d[i-1, j-1] ''// no operation required'' '''else''' d[i, j] := minimum ( d[i-1, j] + 1, ''// a deletion'' d[i, j-1] + 1, ''// an insertion'' d[i-1, j-1] + 1 ''// a substitution'' ) '''}''' '''}''' '''return''' d[m,n] '''}''' Two examples of the resulting matrix (hovering over a number reveals the operation performed to get that number): <center> {| | {|class="wikitable" | | !k !i !t !t !e !n |- | ||0 ||1 ||2 ||3 ||4 ||5 ||6 |- !s |1 ||{{H:title|substitution of 'k' for 's'|1}} ||2 ||3 ||4 ||5 ||6 |- !i |2 ||2 ||{{H:title|'i' equals 'i'|1}} ||2 ||3 ||4 ||5 |- !t |3 ||3 ||2 ||{{H:title|'t' equals 't'|1}} ||2 ||3 ||4 |- !t |4 ||4 ||3 ||2 ||{{H:title|'t' equals 't'|1}} ||2 ||3 |- !i |5 ||5 ||4 ||3 ||2 ||{{H:title|substitution of 'e' for 'i'|2}} ||3 |- !n |6 ||6 ||5 ||4 ||3 ||3 ||{{H:title|'n' equals 'n'|2}} |- !g |7 ||7 ||6 ||5 ||4 ||4 ||{{H:title|delete 'g'|3}} |} | {|class="wikitable" | | !S !a !t !u !r !d !a !y |- | |0 ||1 ||2 ||3 ||4 ||5 ||6 ||7 ||8 |- !S |1 ||{{H:title|'S' equals 'S'|0}} ||{{H:title|insert 'a'|1}} ||{{H:title|insert 't'|2}} ||3 ||4 ||5 ||6 ||7 |- !u |2 ||1 ||1 ||2 ||{{H:title|'u' equals 'u'|2}} ||3 ||4 ||5 ||6 |- !n |3 ||2 ||2 ||2 ||3 ||{{H:title|substitution of 'r' for 'n'|3}} ||4 ||5 ||6 |- !d |4 ||3 ||3 ||3 ||3 ||4 ||{{H:title|'d' equals 'd'|3}} ||4 ||5 |- !a |5 ||4 ||3 ||4 ||4 ||4 ||4 ||{{H:title|'a' equals 'a'|3}} ||4 |- !y |6 ||5 ||4 ||4 ||5 ||5 ||5 ||4 ||{{H:title|'y' equals 'y'|3}} |} |} </center> The [[invariant (mathematics)|invariant]] maintained throughout the algorithm is that we can transform the initial segment <code>s[1..i]</code> into <code>t[1..j]</code> using a minimum of <code>d[i,j]</code> operations. At the end, the bottom-right element of the array contains the answer. ===Proof of correctness=== As mentioned earlier, the [[invariant (mathematics)|invariant]] is that we can transform the initial segment <code>s[1..i]</code> into <code>t[1..j]</code> using a minimum of <code>d[i,j]</code> operations. This invariant holds since: * It is initially true on row and column 0 because <code>s[1..i]</code> can be transformed into the empty string <code>t[1..0]</code> by simply dropping all <code>i</code> characters. Similarly, we can transform <code>s[1..0]</code> to <code>t[1..j]</code> by simply adding all <code>j</code> characters. * If <code>s[i] = t[j]</code>, and we can transform <code>s[1..i-1]</code> to <code>t[1..j-1]</code> in <code>k</code> operations, then we can do the same to <code>s[1..i]</code> and just leave the last character alone, giving <code>k</code> operations. * Otherwise, the distance is the minimum of the three possible ways to do the transformation: ** If we can transform <code>s[1..i]</code> to <code>t[1..j-1]</code> in <code>k</code> operations, then we can simply add <code>t[j]</code> afterwards to get <code>t[1..j]</code> in <code>k+1</code> operations (insertion). ** If we can transform <code>s[1..i-1]</code> to <code>t[1..j]</code> in <code>k</code> operations, then we can remove <code>s[i]</code> and then do the same transformation, for a total of <code>k+1</code> operations (deletion). ** If we can transform <code>s[1..i-1]</code> to <code>t[1..j-1]</code> in <code>k</code> operations, then we can do the same to <code>s[1..i]</code>, and exchange the original <code>s[i]</code> for <code>t[j]</code> afterwards, for a total of <code>k+1</code> operations (substitution). * The operations required to transform <code>s[1..n]</code> into <code>t[1..m]</code> is of course the number required to transform all of <code>s</code> 