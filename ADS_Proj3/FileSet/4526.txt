the worst case, a BST takes O(''m'' log ''n'') time. Moreover, in the worst case log(''n'') will approach ''m''. Also, the simple operations tries use during lookup, such as array indexing using a character, are fast on real machines. * Tries can require less space when they contain a large number of short strings, because the keys are not stored explicitly and nodes are shared between keys with common initial subsequences. * Tries facilitate [[Longest prefix match|longest-prefix matching]], helping to find the key sharing the longest possible prefix of characters all unique. The following are the main advantages of tries over [[hash table]]s: * Tries can perform a "closest fit" find almost as quickly as an exact find {{Fact|date=August 2010}}. Hash tables can only perform an exact find as they store no relational state between keys. * Tries tend to be faster on average at insertion than hash tables because hash tables must rebuild their index when it becomes full - which is a very expensive operation. Tries therefore have much better bounded worst case time costs which is important for latency sensitive code. * Tries can be implemented in a way which avoids the need for additional (dynamic) memory i.e. an '''in-place''' implementation. Hash tables must always have additional memory in which to store the hash indexation table. * Looking up keys can be much faster if a hash function can be avoided. Tries can key successfully on arbitrary integer or pointer sized keys without applying a hash function beforehand (i.e. a bitwise trie) to ensure entropy distribution. This makes them faster than hash tables for integer or pointer sized keys in almost all cases as good quality hash functions tend to be a large overhead when hashing just four to eight bytes of data. * Tries support [[longest prefix match|longest-prefix matching]] but hashing does not. == Applications == === As replacement of other data structures === As mentioned, a trie has a number of advantages over binary search trees.<ref name="trieoverbinary">{{cite journal |last1=Bentley|first1=Jon|last2=Sedgewick|first2=Robert|authorlink2=Robert Sedgewick (computer scientist)| title=Ternary Search Trees| journal=[[Dr. Dobb's Journal]]|date=1998-04-01|publisher=Dr Dobb's|url=http://www.ddj.com/windows/184410528|archiveurl=http://web.archive.org/web/20080623071352/http://www.ddj.com/windows/184410528|archivedate=2008-06-23}}</ref> A trie can also be used to replace a [[hash table]], over which it has the following advantages: * Looking up data in a trie is faster in the worst case, O(m) time, compared to an imperfect hash table. An imperfect hash table can have key collisions. A key collision is the hash function mapping of different keys to the same position in a hash table. The worst-case lookup speed in an imperfect hash table is [[Hash table#Chaining|O(N)]] time, but far more typically is O(1), with O(m) time spent evaluating the hash. * There are no collisions of different keys in a trie. * Buckets in a trie which are analogous to hash table buckets that store key collisions are only necessary if a single key is associated with more than one value. * There is no need to provide a hash function or to change hash functions as more keys are added to a trie. * A trie can provide an alphabetical ordering of the entries by key. Tries do have some drawbacks as well: * Tries can be slower in some cases than hash tables for looking up data, especially if the data is directly accessed on a hard disk drive or some other secondary storage device where the random access time is high compared to main memory.<ref name="triememory">{{cite journal | unused_data=DUPLICATE DATA: pages=490 | author=Edward Fredkin| authorlink=Edward Fredkin| title=Trie Memory| journal=Communications of the ACM| year=1960| volume=3| issue=9| pages=490â€“499| doi=10.1145/367390.367400 }}</ref> * It is not easy to represent all keys as strings, such as floating point numbers - a straightforward encoding using the bitstring of their encoding leads to long chains and prefixes that are not particularly meaningful. Nevertheless a bitwise trie can handle standard IEEE single and double format floating point numbers. === Dictionary representation === A common application of a trie is storing a dictionary, such as one found on a [[mobile telephone]]. Such applications take advantage of a trie's ability to quickly search for, insert, and delete entries; however, if storing dictionary words is all that is required (i.e. storage of information auxiliary to each word is not required), a minimal [[acyclic deterministic finite automaton]] would use less space than a trie.{{Fact|date=February 2009}} Tries are also well suited for implementing approximate matching algorithms, including those used in [[spell checking]] and [[hyphenation]]<ref name="Liang1983"/> software. === Algorithms === We can describe trie lookup (and membership) easily. Given a recursive trie type, storing an optional value at each node, and a list of children tries, indexed by the next character, (here, represented as a Haskell data type): <source lang="haskell"> data Trie a = Trie { value :: Maybe a , children :: [(Char,Trie a)] } </source> We can lookup a value in the trie as follows: <source lang="haskell"> find :: String -> Trie a -> Maybe a find [] t = value t find (k:ks) t = case lookup k (children t) of Nothing -> Nothing Just t' -> find ks t' </source> In an imperative style, and assuming an appropriate data type in place, we can describe the same algorithm in Python (here, specifically for testing membership). Note that <code>children</code> is map of a node's children; and we say that a "terminal" node is one which contains a valid word. <source lang=python> def find(node, key): for char in key: if char not in node.children: return None else: node = node.children[char] return node.value </source> === Sorting === Lexicographic sorting of a set of keys can be accomplished with a simple trie-based algorithm as follows: * Insert all keys in a trie. * Output all keys in the trie by means of [[pre-order traversal]], which results in output that is in [[lexicographic order|lexicographically]] increasing order. [[Pre-order traversal]] is a kind of [[depth-first search|depth-first traversal]]. [[In-order traversal]] is another kind of [[depth-first search|depth-first traversal]] that is more appropriate for outputting the values that are in a [[binary search tree]] rather than a trie. This algorithm is 