25 | doi = 10.1109/MAHC.2003.1253887}}</ref> [[Herman Hollerith]] realized that he could encode information on [[punched card|punch card]]s when he observed that [[train]] [[conductor (transportation)|conductors]] encode the appearance of the ticket holders on the train tickets using the position of punched holes on the tickets. Hollerith then encoded the 1890 census data on punch cards. The first computer codes were specialized for their applications. In the first decades of the 20th century, numerical calculations were based on decimal numbers. Eventually it was realized that logic could be represented with numbers, not only with words. For example, [[Alonzo Church]] was able to express the [[lambda calculus]] in a formulaic way. The [[Turing machine]] was an abstraction of the operation of a tape-marking machine, for example, in use at the telephone companies. Turing machines set the basis for storage of programs as data in the [[Von_Neumann_architecture#Development_of_the_stored-program_concept|von Neumann architecture]] of computers by representing a machine through a finite number. However, unlike the lambda calculus, Turing's code does not serve well as a basis for higher-level languages—its principal use is in rigorous analyses of [[Computational complexity theory|algorithmic complexity]]. Like many "firsts" in history, the first modern programming language is hard to identify. From the start, the restrictions of the hardware defined the language. Punch cards allowed 80 columns, but some of the columns had to be used for a sorting number on each card. FORTRAN included some keywords which were the same as English words, such as "IF", "GOTO" (go to) and "CONTINUE". The use of a magnetic drum for memory meant that computer programs also had to be interleaved with the rotations of the drum. Thus the programs were more hardware-dependent. To some people, what was the first modern programming language depends on how much power and human-readability is required before the status of "programming language" is granted. Jacquard looms and Charles Babbage's [[Difference engine|Difference Engine]] both had simple, extremely limited languages for describing the actions that these machines should perform. One can even regard the punch holes on a [[player piano]] scroll as a limited [[domain-specific language]], albeit not designed for human consumption. == The 1940s == In the 1940s, the first recognizably modern, electrically powered computers were created. The limited speed and memory capacity forced programmers to write hand tuned [[assembly language]] programs. It was soon discovered that programming in assembly language required a great deal of intellectual effort and was error-prone. In 1948, [[Konrad Zuse]] published a paper about his programming language [[Plankalkül]].[http://www-history.mcs.st-andrews.ac.uk/history/Mathematicians/Zuse.html] However, it was not implemented in his lifetime and his original contributions were isolated from other developments. Some important languages that were developed in this period include: * 1943 - [[Plankalkül]] (Konrad Zuse), designed, but unimplemented for a half-century * 1943 - [[ENIAC coding system]], machine-specific codeset appearing in 1948<ref>[http://ftp.arl.mil/mike/comphist/48eniac-coding/ R. F. Clippinger (1948) A Logical Coding System Applied to the ENIAC]</ref> * 1949 - 1954 — a series of machine-specific mnemonic instruction sets, like ENIAC's, beginning in 1949 with C-10 for BINAC (which later evolved into UNIVAC).<ref>http://hopl.murdoch.edu.au/showlanguage2.prx?exp=5442 C-10</ref> Each codeset, or instruction set, was tailored to a specific manufacturer. == The 1950s and 1960s == In the 1950s, the first three modern programming languages whose descendants are still in widespread use today were designed: * [[Fortran|FORTRAN]] (1955), the "'''FOR'''mula '''TRAN'''slator", invented by [[John Backus]] et al.; * [[Lisp (programming language)|LISP]] [1958], the "'''LIS'''t '''P'''rocessor", invented by [[John McCarthy (computer scientist)|John McCarthy]] et al.; * [[COBOL]], the '''CO'''mmon '''B'''usiness '''O'''riented '''L'''anguage, created by the Short Range Committee, heavily influenced by [[Grace Hopper]]. Another milestone in the late 1950s was the publication, by a committee of American and European computer scientists, of "a new language for algorithms"; the ''[[ALGOL|ALGOL 60]] Report'' (the "'''ALGO'''rithmic '''L'''anguage"). This report consolidated many ideas circulating at the time and featured two key language innovations: * nested block structure: code sequences and associated declarations could be grouped into [[block (programming)|block]]s without having to be turned into separate, explicitly named procedures; * [[Scope (programming)|lexical scoping]]: a block could have its own private variables, procedures and functions, invisible to code outside that block, i.e. [[information hiding]]. Another innovation, related to this, was in how the language was described: * a mathematically exact notation, [[Backus-Naur Form]] (BNF), was used to describe the language's syntax. Nearly all subsequent programming languages have used a variant of BNF to describe the [[context-free grammar|context-free]] portion of their syntax. Algol 60 was particularly influential in the design of later languages, some of which soon became more popular. The [[Burroughs large systems]] were designed to be programmed in an extended subset of Algol. Algol's key ideas were continued, producing [[ALGOL 68]]: * syntax and semantics became even more orthogonal, with anonymous routines, a recursive typing system with higher-order functions, etc.; * not only the context-free part, but the full language syntax and semantics were defined formally, in terms of [[Van Wijngaarden grammar]], a formalism designed specifically for this purpose. Algol 68's many little-used language features (e.g. concurrent and parallel blocks) and its complex system of syntactic shortcuts and automatic type coercions made it unpopular with implementers and gained it a reputation of being ''difficult''. [[Niklaus Wirth]] actually walked out of the design committee to create the simpler [[Pascal (programming language)|Pascal]] language. Some important languages that were developed in this period include: * 1951 - [[Regional Assembly Language]] * 1952 - [[Autocode]] * 1954 - [[Fortran|FORTRAN]] * 1954 - [[Information Processing Language|IPL]] (forerunner to LISP) * 1955 - [[FLOW-MATIC]] (forerunner to COBOL) * 1957 - [[COMTRAN]] (forerunner to COBOL) * 1958 - [[Lisp (programming language)|LISP]] * 1958 - [[ALGOL 58]] * 1959 - [[FACT computer language|FACT]] (forerunner to COBOL) * 1959 - [[COBOL]] * 1962 - [[APL (programming language)|APL]] * 1962 - [[Simula]] * 1962 - [[SNOBOL]] * 1963 - [[Combined Programming Language|CPL]] (forerunner to C) * 1964 - [[BASIC]] * 1964 - [[PL/I]] * 1967 - [[BCPL]] (forerunner to C) == 1967-1978: establishing fundamental paradigms == The period from the late 1960s to the late 1970s brought a major flowering of programming languages. Most 