an even number (2) heaps of size 1. For misère play, I take the entire B heap, to leave an odd number (1) of heaps of size 1. 0 0 1 001<sub>2</sub>=1<sub>10</sub> You take 1 from C, and lose. The previous strategy for a misère game can be easily implemented in [[Python (programming language)|Python]]. <source lang="python"> def nim(heaps, misere=True): """Computes next move for Nim in a normal or misère (default) game, returns tuple (chosen_heap, nb_remove)""" X = reduce(lambda x,y: x^y, heaps) if X == 0: # Will lose unless all non-empty heaps have size one print "You will lose :(" for i, heap in enumerate(heaps): if heap > 0: # Empty any (non-empty) heap chosen_heap, nb_remove = i, heap break else: sums = [t^X < t for t in heaps] chosen_heap = sums.index(True) nb_remove = heaps[chosen_heap] - (heaps[chosen_heap]^X) heaps_twomore = 0 for i, heap in enumerate(heaps): n = heap-nb_remove if chosen_heap == i else heap if n>1: heaps_twomore += 1 # If move leaves no heap of size 2 or larger, leave an even (misère) or odd (normal) number of heaps of size 1 if heaps_twomore == 0: chosen_heap = heaps.index(max(heaps)) heaps_one = sum(t==1 for t in heaps) # misère (resp. normal) strategy: if it is even (resp. odd) make it odd (resp. even), else do not change nb_remove = heaps[chosen_heap]-1 if heaps_one%2!=misere else heaps[chosen_heap] return chosen_heap, nb_remove </source> == Proof of the winning formula == The soundness of the optimal strategy described above was demonstrated by C. Bouton. '''Theorem'''. In a normal Nim game, the player making the first move has a winning strategy if and only if the nim-sum of the sizes of the heaps is nonzero. Otherwise, the second player has a winning strategy. ''Proof:'' Notice that the nim-sum (⊕) obeys the usual [[associativity|associative]] and [[commutativity|commutative]] laws of addition (+), and also satisfies an additional property, ''x'' ⊕ ''x'' = 0 (technically speaking, the nonnegative integers under ⊕ form an [[Abelian group]] of [[exponent of a group|exponent]] 2). Let ''x''<sub>1</sub>, ..., ''x<sub>n</sub>'' be the sizes of the heaps before a move, and ''y''<sub>1</sub>, ..., ''y<sub>n</sub>'' the corresponding sizes after a move. Let ''s'' = ''x''<sub>1</sub> ⊕ ... ⊕ ''x<sub>n</sub>'' and ''t'' = ''y''<sub>1</sub> ⊕ ... ⊕ ''y<sub>n</sub>''. If the move was in heap ''k'', we have ''x<sub>i</sub>'' = ''y<sub>i</sub>'' for all ''i'' ≠ ''k'', and ''x<sub>k</sub>'' > ''y<sub>k</sub>''. By the properties of ⊕ mentioned above, we have ''t'' = 0 ⊕ ''t'' = ''s'' ⊕ ''s'' ⊕ ''t'' = ''s'' ⊕ (''x''<sub>1</sub> ⊕ ... ⊕ ''x<sub>n</sub>'') ⊕ (''y''<sub>1</sub> ⊕ ... ⊕ ''y<sub>n</sub>'') = ''s'' ⊕ (''x''<sub>1</sub> ⊕ ''y''<sub>1</sub>) ⊕ ... ⊕ (''x<sub>n</sub>'' ⊕ ''y<sub>n</sub>'') = ''s'' ⊕ 0 ⊕ ... ⊕ 0 ⊕ (''x<sub>k</sub>'' ⊕ ''y<sub>k</sub>'') ⊕ 0 ⊕ ... ⊕ 0 = ''s'' ⊕ ''x<sub>k</sub>'' ⊕ ''y<sub>k</sub>'' (*) ''t'' = ''s'' ⊕ ''x<sub>k</sub>'' ⊕ ''y<sub>k</sub>''. The theorem follows by induction on the length of the game from these two lemmas. '''Lemma 1'''. If ''s'' = 0, then ''t'' ≠ 0 no matter what move is made. ''Proof:'' If there is no possible move, then the lemma is [[vacuous truth|vacuously true]] (and the first player loses the normal play game by definition). Otherwise, any move in heap ''k'' will produce ''t'' = ''x<sub>k</sub>'' ⊕ ''y<sub>k</sub>'' from (*). This number is nonzero, since ''x<sub>k</sub>'' ≠ ''y<sub>k</sub>''. '''Lemma 2'''. If ''s'' ≠ 0, it is possible to make a move so that ''t'' = 0. ''Proof:'' Let ''d'' be the position of the leftmost (most significant) nonzero bit in the binary representation of ''s'', and choose ''k'' such that the ''d''th bit of ''x<sub>k</sub>'' is also nonzero. (Such a ''k'' must exist, since otherwise the ''d''th bit of ''s'' would be 0.) Then letting ''y<sub>k</sub>'' = ''s'' ⊕ ''x<sub>k</sub>'', we claim that ''y<sub>k</sub>'' < ''x<sub>k</sub>'': all bits to the left of ''d'' are the same in ''x<sub>k</sub>'' and ''y<sub>k</sub>'', bit ''d'' decreases from 1 to 0 (decreasing the value by 2<sup>''d''</sup>), and any change in the remaining bits will amount to at most 2<sup>''d''</sup>&minus;1. The first player can thus make a move by taking ''x<sub>k</sub>'' &minus; ''y<sub>k</sub>'' objects from heap ''k'', then ''t'' = ''s'' ⊕ ''x<sub>k</sub>'' ⊕ ''y<sub>k</sub>'' (by (*)) = ''s'' ⊕ ''x<sub>k</sub>'' ⊕ (''s'' ⊕ ''x<sub>k</sub>'') = 0. The modification for misère play is demonstrated by noting that the modification first arises in a position that has only one heap of size 2 or more. Notice that in such a position ''s'' ≠ 0, therefore this situation has to arise when it is the turn of the player following the winning strategy. The normal play strategy is for the player to reduce this to size 0 or 1, leaving an even number of heaps with size 1, and the misère strategy is to do the opposite. From that point on, all moves are forced. == Other variations of Nim == === The subtraction game ''S''(1,2,...,''k'') === In another game which is commonly known as Nim (but is better called the [[subtraction game]] ''S'' (1,2,...,''k'')), an upper bound is imposed on the number of objects that can be removed in a turn. Instead of removing arbitrarily many objects, a player can only remove 1 or 2 or ... or ''k'' at a time. This game is commonly played in practice with only one heap (for instance with ''k'' = 3 in the game ''Thai 21'' on [[Survivor: Thailand]], where it appeared as an Immunity Challenge). Bouton's analysis carries over easily to the general multiple-heap version of this game. The only difference is that as a first step, before computing the Nim-sums, we must reduce the sizes of the heaps [[modular arithmetic|modulo]] ''k'' + 1. If this makes all the heaps of size zero (in misère play), the winning move is to take ''k'' objects from one of the heaps. In particular, in a play from a single heap of ''n'' objects, the second player can win [[if and only if|iff]] : ''n'' &equiv; 0 (mod ''k''+1) (in normal play), or : ''n'' &equiv; 1 (mod ''k''+1) (in 