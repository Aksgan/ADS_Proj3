three multiplications in <math>GF(p)</math> * Computing ''xz-yz<sup>''p''</sup>'' takes four multiplications in <math>GF(p)</math>. === Traces over <math>GF(p^2)</math> === [[Field trace| Trace]] in XRT is always considered over <math>GF(p^2)</math>. In other words, conjugates of <math>h \in GF(p^6)</math> over <math>GF(p^2)</math> are <math>h</math>, <math>h^{p^2}</math> and <math>h^{p^4}</math> and the trace of <math>h</math> is their sum: :<math>Tr(h)=h + h^{p^2} + h^{p^4}.</math> Note that <math>Tr(h) \in GF(p^2)</math> since :<math> \begin{align} Tr(h)^{p^2} &= h^{p^2} + h^{p^4} + h^{p^6} \\ &= h + h^{p^2} + h^{p^4} \\ &= Tr(h) \end{align} </math> Consider now <math>g</math>, the generator of XTR subgroup of a prime order <math>q</math>. Remember that <math>\langle g\rangle</math> is a subgroup of XTR supergroup of order <math>p^2-p+1</math> so <math>q \mid p^2-p+1</math>. In the following section we will see how to choose <math>p</math> and <math>q</math>, but for now it is sufficient to assume that <math>q>3</math>. To compute the trace of <math>g</math> note that ''mod'' <math>p^2-p+1</math> we have :<math>p^2 = p-1</math> and :<math>p^4 = (p-1)^2 = p^2 -2p +1 = -p</math> and thus :<math> \begin{align} Tr(g) &= g + g^{p^2} + g^{p^4}\\ &= g + g^{p-1} + g^{-p}. \end{align} </math> Note also that the product of the conjugates of <math>g</math> equals <math>1</math>. The crucial observation in XTR is that the minimal polynomial of <math>g</math> over <math>GF(p^2)</math> :<math>(x-g)(x-g^{p-1})(x-g^{-p})</math> simplifies to :<math>x^3-Tr(g)x^2 + Tr(g)^p x -1</math> which is fully determined by <math>Tr(g)</math>. Consequently, conjugates of <math>g</math>, as roots of the minimal polynomial of <math>g</math> over <math>GF(p^2)</math>, are completely determined by the trace of <math>g</math>. The same is true for any power of <math>g</math>: conjugates of <math>g^n</math> are roots of polynomial :<math>x^3-Tr(g^n)x^2 + Tr(g^n)^p x -1</math> and this polynomial is completely determined by <math>Tr(g^n)</math>. The idea behind using trace is to replace <math>g^n \in GF(p^6)</math> in cryptographic protocols by <math>Tr(g^n) \in GF(p^2)</math> thus obtaining in this way a factor of 3 reduction in representation size. This is, however, only useful if there is a quick way to obtain <math>Tr(g^n)</math> given <math>Tr(g)</math>. Next section gives an algorithm for efficient computation of <math>Tr(g^n)</math>. In addition, computing <math>Tr(g^n)</math> given <math>Tr(g)</math> turns out to be quicker then computing <math>g^n</math> given <math>g</math>. <ref name="XTR-1"/> === Algorithm for quick computation of <math>Tr(g^n)</math> given <math>Tr(g)</math> === Lenstra and Verheul give this algorithm in their paper titled ''The XTR public key system''. <ref name="XTR-2">[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.95.4291&rep=rep1&type=pdf The XTR public key system]</ref> All the definitions and lemmas necessary for the algorithm and the algorithm itself presented here, are taken from that paper. '''Definition''' For c in <math>GF(p^2)</math> define :<math>F(c,X) = X^3 - cX^2 + c^pX - 1 \in GF(p^2)[X].</math> '''Definition''' Let <math>h_0, h_1, h_2</math> denote not necessarily distinct roots of <math>F(c,X)</math> in <math>GF(p^6)</math> and let n be in <math>\mathbb{Z}</math>. Define :<math>c_n=h_0^n + h_1^n + h_2^n.</math> '''Properties of <math>c_n</math> and <math>F(c,X)</math>''' # <math>c=c_1</math> # <math>c_{-n}=c_{np}=c_n^p</math> # <math>c_n \in GF(p^2) \text{ for } n \in \mathbb{Z}</math> # <math>c_{u+v}=c_u c_v - c_v^p c_{u-v} + c_{u-2v} \text{ for } u, v \in \mathbb{Z}</math> # Either all <math>h_j</math> have order dividing <math>p^2-p+1</math> and <math> > 3</math> or all <math>h_j</math> are in <math>GF(p^2)</math>. In particular, <math>F(c,X)</math> is irreducible if and only if its roots have order diving <math>p^2-p+1</math> and <math> > 3</math>. # <math>F(c,X)</math> is reducible over <math>GF(p^2)</math> if and only if <math>c_{p+1} \in GF(p)</math> '''Lemma''' Let <math>c, c_{n-1}, c_n, c_{n+1}</math> be given. # Computing <math>c_{2n} = c_n^2 - 2c_n^p</math> takes two multiplication is <math>GF(p)</math>. # Computing <math>c_{n+2} = c_{n+1} \cdot c - c^p \cdot c_n + c_{n-1}</math> takes four multiplication is <math>GF(p)</math>. # Computing <math>c_{2n-1} = c_{n-1} \cdot c_n - c^p \cdot c_n^p + c_{n+1}^p</math> takes four multiplication is <math>GF(p)</math>. # Computing <math>c_{2n+1} = c_{n+1} \cdot c_n - c \cdot c_n^p + c_{n-1}^p</math> takes four multiplication is <math>GF(p)</math>. '''Definition''' Let <math>S_n(c)=(c_{n-1}, c_n, c_{n+1}) \in GF(p^2)^3</math>. '''Algorithm 1 for computation of <math>S_n(c)</math> given <math>n</math> and <math>c</math>''' * If <math>n<0</math> apply this algorithm to <math>-n</math> and <math>c</math>, and apply Property 2 to the resulting value. * If <math>n=0</math>, then <math>S_0(c)=(c^p, 3, c) </math>. * If <math>n=1</math>, then <math>S_1(c)=(3, c, c^2-2c^p) </math>. * If <math>n=2</math>, use the computation of <math>c_{n+2}= c_{n+1} \cdot c - c^p \cdot c_n + c_{n-1}</math> and <math>S_1(c)</math> to find <math>c_3</math> and thereby <math>S_2(c)</math>. * If <math>n>2</math>, to compute <math>S_n(c)</math> define :::<math>\bar{S}_i(c) = S_{2i+1}(c)</math> ::and <math>\bar{m}=n</math> if n is odd and <math>\bar{m}=n-1</math> otherwise. Let <math>\bar{m}=2m+1, k=1</math> and compute <math>\bar{S}_k(c) = S_3(c)</math> using Lemma above and <math>S_2(c)</math>. Let further :::<math>m=\sum_{j=0}^r m_j 2^j</math> ::with <math>m_j \in {0,1}</math> and <math>m_r=1</math>. For <math>j=r-1, r-2, ..., 0</math> in succession, do the following: ::* If <math>m_j=0</math>, use <math>\bar{S}_k(c)</math> to compute <math>\bar{S}_{2k}(c)</math>. ::* If <math>m_j=1</math>, use <math>\bar{S}_k(c)</math> to compute <math>\bar{S}_{2k+1}(c)</math>. ::* Replace <math>k</math> by <math>2k + m_j</math>. After this iteration <math>k=m</math> and <math>S_{\bar{m}}(c) = \bar{S}_{m}(c)</math>. If n is even use <math>S_{\bar{m}}(c)</math> to compute <math>\bar{S}_{m+1}(c)</math>. == Parameter selection == ===Finite field and subgroup size selection=== In order to take advantage of the above described representations with traces and furthermore assure sufficient security, what will be discussed later, we need to find primes <math>p</math> and <math>q</math>, whereat <math>p</math> denotes the [[characteristic_(algebra)|characteristic]] of the field <math>GF(p^6)</math> and <math>q</math> is the size of the subgroup, such that <math> q</math> divides <math> p^2-p+1</math>. We denote with <math>P</math> and <math>Q</math> the sizes of <math>p</math> and <math>q</math> in bits. To achieve security comparable to 1024-bit [[RSA]], we should choose <math>6P</math> about 1024, i.e. <math> P\approx 170</math> and <math>Q</math> can be around 160. A first easy algorithm to compute such primes <math>p</math> and <math>q</math> is the next Algorithm A: '''Algorithm A''' # Find <math>r\in\mathbb{Z}</math> such that <math>q=r^2-r+1</math> is a <math>Q</math>-bit prime. # Find <math>k\in\mathbb{Z}</math> such that <math>p=r+k\cdot q</math> is a <math>P</math>-bit prime with <math>p\equiv 2\ \text{mod}\ 3</math>. :''Correctness of Algorithm A:'' :It remains to check that <math>q\mid p^2-p+1</math> because all the other necessary properties are obviously satisfied per definition of <math>p</math> and <math>q</math>. We easily see that <math>p^2-p+1=r^2+2rkq+k^2q^2-r-kq+1=r^2-r+1+q(2rk+kq-k)=q(1+2rk+kq-k)</math> which implies that <math>q\mid p^2-p+1</math>. Algorithm A is very fast and can be used to find primes <math>p</math> that satisfy a degree two polynomial with small coefficients. Such <math>p</math> lead to fast arithmetic operations in <math>GF(p)</math>. In particular if the search for <math>k</math> is restricted to <math>k=1</math>, which means to look for an <math>r</math> such that both 