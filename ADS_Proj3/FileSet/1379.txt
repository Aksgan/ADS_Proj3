$2 || '''$45''' |} | {| class="wikitable" style="text-align:center" |+South ! !! Jan !! Feb !! Mar !! Total |- ! Quantity | 760 || 110 || 2950 || '''3820''' |- ! Sales | $76|| $11 || $295 || '''$382''' |- ! Expenses | $60 || $10 || $237 || '''$307''' |- ! Profit | $16 || $1 || $58 || '''$75''' |} | {| class="wikitable" style="text-align:center" |+'''Total Region''' ! !! Jan !! Feb !! Mar !! Total |- ! Quantity | 1000 || 2000 || 3000 || '''6000''' |- ! Sales | $100 || $200 || $300 || '''$600''' |- ! Expenses | $80 || $160 || $240 || '''$480''' |- ! Profit | $20 || $40 || $60 || '''$120''' |} |} An alternative representation of this structure would require a three-dimensional spreadsheet grid, giving rise to the idea that "Time", "Account", and "Region" are [[dimensions]]. As further dimensions are added to the system, it becomes very difficult to maintain spreadsheets that correctly represent the multi-dimensional values. Multidimensional databases such as Essbase provide a data store for values that exist, at least conceptually, in a multi-dimensional "[[OLAP cube|hypercube]]". ===Sparsity=== As the number and size of dimensions increases, developers of multidimensional databases increasingly face technical problems in the physical representation of data. Say the above example was extended to add a "Customer" and "Product" dimension: {| class="wikitable" style="text-align:center" ! Dimension !! Number of dimension values |- ! Accounts | 4 |- ! Time | 4 |- ! Region | 3 |- ! Customer | 10,000 |- ! Product | 5,000 |} If the multidimensional database reserved storage space for every possible value, it would need to store 2,400,000,000 (4 × 4 × 3 × 10,000 × 5,000) cells. If the software maps each cell as a [[double precision|64-bit floating point]] value, this equates to a memory requirement of at least 17 [[gigabytes]] (exactly 19.2GB). In practice, of course, the number of combinations of "Customer" and "Product" that contain meaningful values will be a tiny subset of the total space. This property of multi-dimensional spaces is referred to as [[sparsity]]. ===Aggregation=== [[OLAP]] systems generally provide for multiple levels of detail within each dimension by arranging the members of each dimension into one or more [[hierarchies]]. A time dimension, for example, may be represented as a hierarchy starting with "Total Time", and breaking down into multiple years, then quarters, then months. An Accounts dimension may start with "Profit", which breaks down into "Sales" and "Expenses", and so on. In the example above, if "Product" represents individual product [[Stock Keeping Unit|SKU]]s, analysts may also want to report using aggregations such as "Product Group", "Product Family", "Product Line", etc. Similarly, for "Customer", natural aggregations may arrange customers according to geographic location or industry. The number of aggregate values implied by a set of input data can become surprisingly large. If the Customer and Product dimensions are each in fact six "generations" deep, then 36 (6 × 6) aggregate values are affected by a single data point. It follows that if all these aggregate values are to be stored, the amount of space required is proportional to the [[Product (mathematics)|product]] of the depth of all aggregating dimensions. For large databases, this can cause the effective storage requirements to be many hundred times the size of the data being aggregated. ==Block storage (Essbase Analytics)== Since version 7, Essbase has supported two "storage options" which take advantage of sparsity to minimize the amount of physical memory and disk space required to represent large multidimensional spaces. The Essbase patent<ref name="patent"/> describes the original method, which aimed to reduce the amount of physical memory required without increasing the time required to look up closely-related values. With the introduction of alternative storage options, marketing materials called this the '''Block Storage Option''' ('''Essbase BSO'''), later referred to as '''Essbase Analytics'''. Put briefly, Essbase requires the developer to tag dimensions as "dense" or "sparse". The system then arranges data to represent the hypercube into "blocks", where each block comprises a multi-dimensional array made up of "dense" dimensions, and space is allocated for every potential cell in that block. Sparsity is exploited because the system only creates blocks when required. In the example above, say the developer has tagged "Accounts" and "Time" as "dense", and "Region", "Customer", and "Product" as "sparse". If there are, say, 12,000 combinations of Region, Customer and Product that contain data, then only 12,000 blocks will be created, each block large enough to store every possible combination of Accounts and Time. The number of cells stored is therefore 192000 (4 × 4 × 12000), requiring under 2 [[gigabytes]] of memory (exact 1,536MB), plus the size of the index used to look up the appropriate blocks. Because the database hides this implementation from front-end tools (i.e., a report that attempts to retrieve data from non-existent cells merely sees "null" values), the full hypercube can be navigated naturally, and it is possible to load values into any cell interactively. ===Calculation engine=== Users can specify calculations in Essbase BSO as: * the aggregation of values through dimensional hierarchies; * stored calculations on dimension members; * "dynamically calculated" dimension members; or * procedural "calculation scripts" that act on values stored in the database. The first method (dimension aggregation) takes place implicitly through addition, or by selectively tagging branches of the hierarchy to be subtracted, multiplied, divided or ignored. Also, the result of this aggregation can be stored in the database, or calculated dynamically on demand—members must be tagged as "Stored" or "Dynamic Calc." to specify which method is to be used. The second method (stored calculations) uses a [[formula]] against each calculated dimension member — when Essbase calculates that member, the result is stored against that member just like a data value. The third method (dynamic calculation) is specified in exactly the same format as stored calculations, but calculates a result when a user accesses a value addressed by that member; the system does not store such calculated values. The fourth method (calculation 