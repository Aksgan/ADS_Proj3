[[immutable object|immutable type]]s or mutable types. CLI objects classify as mutable types (which can be edited in-place), and are used to provide an [[object-oriented programming]] model. Immutable types (editing such a type creates a new instance without overwriting the older one) are primarily used for [[functional programming]]. Like [[ML (programming language)|ML]], F# includes a functional programming component supporting [[eager evaluation]]. For functional programming, it provides several constructs and a set of immutable types: ''tuples'', ''records'', ''discriminated unions'' and ''lists''.<ref name="overview"/> An ''[[n-tuple]]'' represents a collection of ''n'' values, where ''n'' â‰¥ 0. The value ''n'' is called the [[arity]] of the tuple. The type <code>[[unit type|unit]]</code> corresponds to the 0-tuple and it has one value only: <code>()</code>, which conveys no information. The type <code>unit</code> is used to implement functions that need no input and/or return no value. A 3-tuple would be represented as <code>(A, B, C)</code>, where A, B and C are values of possibly different types. A tuple can be used only to store values when the number of values is known at design-time and stays constant throughout execution. A ''record'' is a specialization of tuple where the data members are named, as in <code>{ Name:string; Age:int }</code>. Records can be created as <code>{ Name="AB"; Age=42 }</code>. The <code>with</code> keyword is used to create a copy of a record, as in <code>{ r with Name="CD" }</code>, which creates a new record by copying <code>r</code> and changing the value of the <code>Name</code> field (assuming the record created in the last example was named <code>r</code>). The ''list'' type is a regular [[linked list]] represented either using a <code>head::tail</code> notation (<code>::</code> is the [[cons]] operator) or a shorthand as <code>[item1; item2; item3]</code>. An empty list is written <code>[]</code>. The other sort of [[algebraic data type]] mentioned, "[[tagged union|discriminated unions]]" ([[type-safe]] versions of [[union (computer science)|C unions]]), can be defined to hold a value of any of a pre-defined type. For example, <source lang="ocaml"> type A = | ConstructorX of string | ConstructorY of int </source> can hold values as instantiated by either constructor. The type of the values the constructors will act on can be defined as well. Constructors are used to create a view of the data type different from the actual implementation, as required for supporting the [[Active Patterns]] concept.<ref name="overview"/> Data types are created with the <code>type</code> keyword. F# uses the <code>let</code> keyword for binding type values to a name (variable).<ref name="overview">{{cite web | url = http://tomasp.net/articles/fsharp-i-introduction/article.pdf | title = F# Language Overview | accessdate = 2007-12-14}}</ref> F# uses [[pattern matching]] to resolve names into values. It is also used when accessing discriminated unions. Functions using a discriminated union provide different expressions to be invoked, associated with the data type in the union. The union is matched against these data types, and the expression associated with the match is invoked. F# also supports the ''Active Patterns'' pattern. It is used, for example, when a type needs to provide multiple views. For example, an exponential number will provide both the final value, as well as the base and exponents.<ref name="overview"/> All functions in F# are instances of the <code>function</code> type, and are immutable as well.<ref name="overview"/> Functions can either be [[curry function|curried]] or in uncurried form. Being an instance of a type, functions can be passed as arguments to other functions, resulting in [[higher order function]]s. F# supports [[lambda calculus|lambda functions]] and [[closure (computing)|closure]]s as well.<ref name="overview"/> Like other functional programming languages, F# allows [[function composition]] using the <code>>></code> operator. Every statement in F#, including <code>if</code> statements and loops, is a composable expression with a definite return type as well.<ref name="overview"/> Functions and expressions that do not return any value have a return type of <code>unit</code>. The F# extended type system is implemented as [[generic programming|generic]] .NET types. The ''Record'' type creates a .NET class with the field names as properties. ''Tuples'' are generic classes of type <code>Tuple<_,_></code>. The number of type parameters define the number and types of the elements in the tuple. Discriminated unions are implemented as [[tagged union]]s. Functions are of type <code>FastFunc<_,_></code> with type parameters specifying the parameter and return types.<ref>{{cite web | url = http://research.microsoft.com/fsharp/manual/export-interop.aspx | title = F# from C# and other .NET Languages | accessdate = 2007-12-14}}</ref> F#, like other .NET languages, can use .NET types and objects, using an imperative object-oriented style of programming. For imperative programming, F# supports <code>for</code> and <code>while</code> [[Control flow#Loops|loops]], [[array data structure|arrays]] (created with the <code>[| ... |]</code> syntax, and number sequences written in shorthand as in <code>1 .. 25</code>) and support for creating <code>Object types</code> (equivalent to .NET classes).<ref name="overview"/> F# also allows [[metaprogramming|extending the syntax]] to support embedding custom [[domain-specific language]]s within the F# language itself.<ref name="overview"/> F# provides ''sequence expressions''<ref name="seq"/> that allows for a defining a sequence block (<code>seq { ... }</code> or <code>[ ... ]</code> or <code>[| ... |]</code>) encapsulating constructs (either functions, conditional expressions or loops) that act on a collection such that the results and another function (or lambda), such that the function is invoked on the results yielded from the collection collection-processing expressions. For example, <code>seq { for b in 0 .. 25 do if b < 15 then yield b*b }</code> is a sequence expression that forms a sequence of squares of numbers from 0 to 14 by filtering out numbers from the range of numbers from 0 to 25. The sequence is [[lazy evaluation|lazily evaluated]], i. e., the collection is processed and results yielded on-demand. It can be used for filtering and is the basis of support for [[LINQ]] queries. Sequence expressions are generalized as ''Computation Expressions'' which are equivalent to [[monad (functional programming)|monad]]s.<ref name="seq">{{cite web | url = http://blogs.msdn.com/dsyme/archive/2007/09/22/some-details-on-f-computation-expressions-aka-monadic-or-workflow-syntax.aspx | title = Some Details on F# Computation Expressions | accessdate = 2007-12-14}}</ref> Sequence expressions and computation expressions are also used for creating ''asynchronous workflows''.<ref name="aw"/> An asynchronous workflow is defined as a sequence of commands inside a <code>async{ ... }</code>, as in <source lang="ocaml"> let asynctask = async { let req = WebRequest.Create(url) let! response = 