things other than knowledge of a secret value. [[CAPTCHA]]s, for example, are a sort of variant on the [[Turing test]], meant to determine whether a viewer of a [[World Wide Web|Web]] application is a real person. The challenge sent to the viewer is a distorted image of some text, and the viewer responds by typing in that text. The distortion is designed to make automated [[optical character recognition]] (OCR) difficult and preventing a computer program from passing as a human. ==Cryptographic techniques== Non-cryptographic authentication was generally adequate in the days before the [[Internet]], when the user could be sure that the system asking for the password was really the system they were trying to access, and that nobody was likely to be eavesdropping on the [[Channel (communications)|communication channel]] to observe the password being entered. To address the insecure channel problem, a more sophisticated approach is necessary. Many cryptographic solutions involve ''two-way authentication'', where both the user and the system must each convince the other that they know the [[shared secret]] (the password), without this secret ever being transmitted [[in the clear]] over the communication channel, where [[eavesdropper]]s might be lurking. One way this is done involves using the password as the [[encryption]] key to transmit some randomly-generated information as the ''challenge'', whereupon the other end must return as its ''response'' a similarly-encrypted value which is some predetermined function of the originally-offered information, thus proving that it was able to decrypt the challenge. For instance, in [[Kerberos (protocol)|Kerberos]], the challenge is an encrypted integer ''N'', while the response is the encrypted integer ''N + 1'', proving that the other end was able to decrypt the integer ''N''. In other variations, a hash function operates on a password and a random challenge value to create a response value. Such encrypted or hashed exchanges do not directly reveal the password to an eavesdropper. However, they may supply enough information to allow an eavesdropper to deduce what the password is, using a [[dictionary attack]] or [[brute-force attack]]. The use of information which is randomly generated on each exchange (and where the response is different from the challenge) guards against the possibility of a [[replay attack]], where a malicious intermediary simply records the exchanged data and retransmits it at a later time to fool one end into thinking it has authenticated a new connection attempt from the other. Authentication protocols usually employ a [[cryptographic nonce]] as the challenge to ensure that every challenge-response sequence is unique. This protects against a [[replay attack]]. If it is impractical to implement a true nonce, a strong [[cryptographically secure pseudorandom number generator]] and [[cryptographic hash function]] can generate challenges that are highly unlikely to occur more than once. It is important not to use time-based nonces, as these can weaken servers in different time zones and servers with inaccurate clocks. [[Mutual authentication]] is performed using a challenge-response handshake in both directions; the server ensures that the client knows the secret, and the client ''also'' ensures that the server knows the secret, which protects against a rogue server impersonating the real server. Challenge-response authentication can help solve the problem of exchanging session keys for encryption. Using a [[key derivation function]], the challenge value and the secret may be combined to generate an unpredictable encryption key for the session. This is particularly effective against a man-in-the-middle attack, because the attacker will not be able to derive the session key from the challenge without knowing the secret, and therefore will not be able to decrypt the data stream. ==Simple Example mutual authentication sequence== *Server sends a unique challenge value '''''sc''''' to the client *Client generates unique challenge value '''''cc''''' *Client computes '''''cr''''' = hash(cc + sc + secret) *Client sends '''''cr''''' and '''''cc''''' to the server *Server calculates the expected value of '''''cr''''' and ensures the client responded correctly *Server computes '''''sr''''' = hash(sc + cc + secret) *Server sends '''''sr''''' *Client calculates the expected value of '''''sr''''' and ensures the server responded correctly where *'''''sc''''' is the server generated challenge *'''''cc''''' is the client generated challenge *'''''cr''''' is the client response *'''''sr''''' is the server response ==Password storage== To avoid storage of passwords, some operating systems (e.g. [[Unix]]-type) store a [[password#Form of stored passwords|hash of the password]] rather than storing the password itself. During authentication, the system need only verify that the hash of the password entered matches the hash stored in the password database. This makes it more difficult for an intruder to get the passwords, since the password itself is not stored, and it is very difficult to determine a password that matches a given hash. However, this presents a problem for challenge-response algorithms, which require both the client and the server to have a shared secret. Since the password itself is not stored, a challenge-response algorithm will usually have to use the hash of the password as the secret instead of the password itself. In this case, an intruder can use the actual hash, rather than the password, which makes the stored hashes just as sensitive as the actual passwords. ==Examples== Examples of more sophisticated challenge-response [[algorithm]]s are [[zero-knowledge password proof]] and key agreement systems (such as [[Secure remote password protocol|Secure Remote Password (SRP)]]), [[CRAM-MD5]], and [[Secure Shell|ssh]]'s challenge-response system based on [[RSA]] [http://www.cag.lcs.mit.edu/~rugina/ssh-procedures/]. ==See also== *[[Challenge-handshake authentication protocol]] *[[CRAM-MD5]] *[[Cryptographic hash function]] *[[Cryptographic nonce]] *[[Kerberos (protocol)|Kerberos]] *[[Otway-Rees]] *[[Needham-Schroeder]] *[[Wide Mouth Frog]] *[[Password-authenticated key agreement]] *[[CAPTCHA]] *[[reCAPTCHA]] *[[Distance-bounding protocol]] *[[Reflection attack]] *[[Replay attack]] *[[Man-in-the-middle attack]] *[[Physically unclonable function]] [[Category:Cryptographic protocols]] [[cs:Challenge-response]] [[de:Challenge-Response-Authentifizierung]] [[nl:Challenge response-authenticatie]] [[ru:Вызов-ответ (аутентификация)]]</text> </page> <page> <id>5838</id> <title>Chameleon (computing)</title> <text>{{other uses2|Chameleon}} {{unreferenced|date=December 2006}} '''Chameleon''' is a [[computer workstation]] design produced at [[ETH]] [[Zurich]] running the [[Oberon operating system]]. It was also the name of an older [[luggable]] computer from the early 1980s, distinguished by being able to run both the [[MS-DOS]] and [[CP/M-80]] [[operating systems]]. [[Category:Computer workstations]] {{compu-hardware-stub}}</text> </page> <page> <id>5842</id> <title>Chancery hand</title> <text>{{about|the European style of writing|the Chinese style of calligraphy|Clerical script}} A '''Chancery hand''' confusingly signifies two very different styles of [[Paleography|historical handwriting]]. A 