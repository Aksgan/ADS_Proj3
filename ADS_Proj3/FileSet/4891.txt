<math>r^2-r+1\text{ and }r^2+1</math> are prime and such that <math>r^2+1\equiv 2 \text{ mod } 3</math>, the primes <math>p</math> have this nice form. Note that in this case <math>r</math> must be even and <math>r\equiv 1\text{ mod }4</math>. On the other hand such <math>p</math> may be undesirable from a security point of view because they may make an attack with the [[Discrete Logarithm]] variant of the [[Number Field Sieve]] easier. The following Algorithm B doesn't have this disadvantage, but it also doesn't have the fast arithmetic modulo <math>p</math> Algorithm A has in that case. '''Algorithm B''' # Select a <math>Q</math>-bit prime <math>q</math> so that <math>q\equiv7\ \text{mod}\ 12</math>. # Find the roots <math>r_1</math> and <math>r_2</math> of <math>X^2-X+1\ \text{mod}\ q</math>. # Find a <math>k\in\mathbb{Z}</math> such that <math>p=r_i+k\cdot q</math> is a <math>P</math>-bit prime with <math>p\equiv 2\ \text{mod}\ 3</math> for <math>i\in\{1,2\}</math> :''Correctness of Algorithm B:'' :Since we chose <math>q\equiv7\ \text{mod}\ 12</math> it follows immediately that <math>q\equiv1\ \text{mod}\ 3</math> (because <math>7\equiv1\ \text{mod}\ 3</math> and <math>3\mid 12</math>). From that and [[quadratic reciprocity]] we can deduct that <math>r_1</math> and <math>r_2</math> exist. :To check that <math>q\mid p^2-p+1</math> we consider again <math>p^2-p+1\text{ for }r_i\in\{1,2\}</math> and get that <math>p^2-p+1=r_i^2+2r_ikq+k^2q^2-r_i-kq+1=r_i^2-r_i+1+q(2rk+kq-k)=q(2rk+kq-k)</math>, since <math>r_1</math> and <math>r_2</math> are roots of <math>X^2-X+1</math> and hence <math>q\mid p^2-p+1</math>. ===Subgroup selection=== In the last paragraph we have chosen the sizes <math>p</math> and <math>q</math> of the finite field <math>GF(p^6)</math> and the multiplicative subgroup of <math>GF(p^6)^*</math>. Now we do not need to find an explicit <math>g\in GF(p^6)</math>, it suffices to find an element <math>c\in GF(p^2)</math> such that <math>c=Tr(g)</math> for an element <math>g\in GF(p^6)</math> of order <math>q</math>. But, given <math>Tr(g)</math>, a generator <math>g</math> of the XTR (sub)group can be found by determining any root of <math>F(Tr(g),\ X)</math> which has been defined [[XTR#Algorithm_for_quick_computation_of_Tr.28gn.29_given_Tr.28g.29|above]]. To find such a <math>c</math> we can take a look at property 5 of <math>F(c,\ X)</math> [[XTR#Algorithm_for_quick_computation_of_Tr.28gn.29_given_Tr.28g.29|here]] stating that the roots of <math>F(c,\ X)</math> have an order dividing <math>p^2-p+1</math> (and <math>>3</math>) if and only if <math>F(c,\ X)</math> is irreducible. After finding such <math>c</math> we need to check if it really is of order <math>q</math>, but first we focus on how to select <math>c\in GF(p^2)</math> such that <math>F(c,\ X)</math> is irreducible. An initial approach is to select <math>c\in GF(p^2)\backslash GF(p)</math> randomly which is justified by the next lemma. '''Lemma:''' ''For a randomly selected <math>c\in GF(p^2)</math> the probability that <math>X^3-cX^2+c^pX-1\in GF(p^2)[X]</math> is [[irreducible]] is about one third.'' Now the basic algorithm to find a suitable <math>Tr(g)</math> is as follows: '''Outline of the algorithm''' # Pick a random <math>c\in GF(p^2)\backslash GF(p)</math>. # If <math>F(c,\ X)</math> is reducible, then return to Step 1. # Use Algorithm 1 to compute <math>d=c_{(p^2-p+1)/q}</math>. # If <math>d</math> is not of order <math> q</math>, return to Step 1. # Let <math>Tr(g)=d</math>. It turns out that this algorithm indeed computes an element of <math>GF(p^2)</math> that equals <math>Tr(g)</math> for some <math>g\in GF(p^6)</math> of order <math>q</math>. More details to the algorithm, its correctness, runtime and the proof of the Lemma can be found in ''"An overview of the XTR public key system"'' in <ref name="XTR-1"/>. == Cryptographic schemes == In this section it is explained how the concepts above can be applied to cryptography. Two applications of XTR are the [[Diffie-Hellman key agreement]] and the [[ElGamal encryption]]. We will start first with Diffie-Hellman. === XTR-DH key agreement === We suppose that both [[Alice and Bob]] have access to the XTR [[public key]] data <math>\left(p,q,Tr(g)\right)</math> and intend to agree on a [[shared secret]] [[secret key|key]] <math>K</math>. They can do this by using the following XTR version of the Diffie-Hellman key exchange: # Alice picks <math>a\in\mathbb{Z}</math> randomly with <math>1<a<q-2</math>, computes with [[XTR#Algorithm_for_quick_computation_of_Tr.28gn.29_given_Tr.28g.29|Algorithm 1]] <math>S_a(Tr(g))=\left(Tr(g^{a-1}),Tr(g^a),Tr(g^{a+1})\right)\in GF(p^2)^3</math> and sends <math>Tr(g^a)\in GF(p^2)</math> to Bob. # Bob receives <math>Tr(g^a)</math> from Alice, selects at random <math>b\in\mathbb{Z}</math> with <math>1<b<q-2</math>, applies Algorithm 1 to compute <math>S_b(Tr(g))=\left(Tr(g^{b-1}),Tr(g^b),Tr(g^{b+1})\right)\in GF(p^2)^3</math> and sends <math>Tr(g^b)\in GF(p^2)</math> to Alice. # Alice receives <math>Tr(g^b)</math> from Bob and computes with Algorithm 1 <math>S_a(Tr(g^b))=\left(Tr(g^{(a-1)b}),Tr(g^{ab}),Tr(g^{(a+1)b})\right)\in GF(p^2)^3</math> and determines <math>K</math> based on <math>Tr(g^{ab})\in GF(p^2)</math>. # Bob analogously applies Algorithm 1 to compute <math>S_b(Tr(g^a))=\left(Tr(g^{a(b-1)}),Tr(g^{ab}),Tr(g^{a(b+1)})\right)\in GF(p^2)^3</math> and also determines <math>K</math> based on <math>Tr(g^{ab})\in GF(p^2)</math>. === XTR ElGamal encryption === For the ElGamal encryption we suppose now that Alice is the owner of the XTR public key data <math>(p,q,Tr(g))</math> and that she has selected a secret integer <math>k</math>, computed <math>Tr(g^k)</math> and published the result. Given Alice's XTR public key date <math>\left(p,q,Tr(g),Tr(g^k)\right)</math>, Bob can encrypt a message <math>M</math> intended for Alice using the following XTR version of the ElGamal encryption: # Bob selects randomly a <math>b\in\mathbb{Z}</math> with <math>1<b<q-2</math> and computes with [[XTR#Algorithm_for_quick_computation_of_Tr.28gn.29_given_Tr.28g.29|Algorithm 1]] <math>S_b(Tr(g))=\left(Tr(g^{b-1}),Tr(g^b),Tr(g^{b+1})\right)\in GF(p^2)^3</math>. # Bob next applies Algorithm 1 to compute <math>S_b(Tr(g^k))=\left(Tr(g^{(b-1)k}),Tr(g^{bk}),Tr(g^{(b+1)k})\right)\in GF(p^2)^3</math>. # Bob determines a symmetric encryption key <math>K</math> based on <math>Tr(g^{bk})\in GF(p^2)</math>. # Bob uses an agreed upon symmetric encryption method with key <math>K</math> to encrypt his message <math>M</math>, resulting in the encryption <math>E</math>. # Bob sends <math>(Tr(g^b),\ E)</math> to Alice. Upon receipt of <math>(Tr(g^b),\ E)</math>, Alice decrypts the message in the following way: # Alice computes <math>S_k(Tr(g^b))=\left(Tr(g^{b(k-1)}),Tr(g^{bk}),Tr(g^{b(k+1)})\right)\in GF(p^2)^3</math>. # Alice determines the symmetric key <math>K</math> based on <math>Tr(g^{bk})\in GF(p^2)</math>. # Alice uses the agreed upon symmetric encryption method with key <math>K</math> to decrypt <math>E</math>, resulting in the original message <math>M</math>. The here described encryption scheme is based on a common [[hybrid cryptosystem|hybrid]] version of the ElGamal encryption, where the secret key <math>K</math> is obtained by an [[asymmetric key|asymmetric public key]] system and then the message is encrypted with a [[symmetric key]] encryption method Bob and Alice agreed to. In the more traditional ElGamal encryption the message is restricted to the key space, which would here be <math>GF(p^2)</math>, because <math>Tr(g)\in GF(p^2)\ \forall p\in GF(p^6)^{\times}</math>. The encryption in this case is the multiplication of the message with the key which is an invertible operation in the key space <math>GF(p^2)</math>. Concretely this means if Bob wants to encrypt a message <math>M\!\ '</math>, first he has to convert it into an element <math>M</math> of <math>GF(p^2)</math> and then compute the encrypted message <math>E</math> as <math>E=K\cdot M\in GF(p^2)</math>. Upon receipt of the encrypted message <math>E</math> Alice can recover the original message <math>M</math> by computing <math>M=E\cdot K^{-1}</math>, where <math>K^{-1}</math> is the inverse of <math>K</math> in <math>GF(p^2)</math>. ==Security== In order 