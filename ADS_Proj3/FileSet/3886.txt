sites. ==Syntax== Unlike many programming languages, SMX syntax is simple and consistent. All functions begin with a % sign, followed by the name of the function, followed either a single % sign or a parenthetical list of arguments. Arguments can be quoted using double-quotes. Backslashes can be used to escape commas and double-quotes. A single quote at the beginning of an argument turns off interpretation of code in that argument (similar to [[LISP]]). Everything that isn't code, is, by default, output. To change this behavior, use the %nil or %null macros. ===Sample code=== ====Hello World==== Here is a [[Hello World]] code example: <pre><nowiki> %expand% Hello World! </nowiki></pre> Using variables to create output <pre><nowiki> %expand% %set(name,World) Hello %name%! </nowiki></pre> ====Forms processing==== <pre><nowiki> %expand% %if(%form(expr) ,<p>Result is: %expr(%form(expr))</p> ) <form action="%client-url%" method=post> Simple math expression: <input name=expr> </form> </nowiki></pre> ====Page counter==== <pre><nowiki> %expand% %counter(hits) hits </nowiki></pre> ====Database guestbook==== <pre><nowiki> %expand% %if(%not(%exists(/tmp/gbook.sq3)) ,%sql(sqlite:/tmp/gbook.sq3,CREATE TABLE guests (name text, comment text)) ) %if(%and(%form(name),%form(comment)) ,%sql(sqlite:/tmp/gbook.sq3,"INSERT INTO guests (name, comment) VALUES (%sqlq(%form(name)),%sqlq(%form(comment)))") ) %sql(sqlite:/tmp/gbook.sq3,SELECT * FROM guests ,<p>%html-quote(%col(name)) said %html-quote(%col(comment))<hr> <p> <form action="%client-url%" method=post> <br>Name: <input name=name> <br>Comment: <input name=comment> <br><input type=submit> </form> ) </nowiki></pre> == External links == * http://www.smxlang.org/ (open source implementation of SMX in C++) * http://www.gjt.org/javadoc/org/opensmx/opensmx/ (open source implementation of SMX in Java) * http://www.strom.com/pubwork/iwcb.html (review of the original commerce builder) [[Category:Web development software]] [[Category:Scripting languages]] [[Category:Macro programming languages]]</text> </page> <page> <id>32891</id> <title>SM EVM</title> <text>'''SM EVM''' (СМ ЭВМ, abbreviation of '''Система Малых ЭВМ''' - literally '''System of Mini Computers''') was general name for several types of [[Soviet Union|Soviet]] and [[Comecon]] [[minicomputer]]s in 1970s and 1980s. Production started in 1975. Most types of SM EVM have been [[clone (computer science)|clone]]s of [[Digital Equipment Corporation|DEC]] [[PDP-11]] and [[VAX]].<ref>{{cite web | url=http://www.village.org/pdp-11/faq.pages/Soviet11s.html | title=PDP-11 behind the Iron Curtain}}</ref> SM-1 and SM-2 were clones of the Hewlett-Packard minicomputers. The common operating systems for the PDP-11 clones were the translated versions of RSX-11 ('''ОС РВ''') for the higher models and of RT-11 ('''РАФОС''', '''ФОДОС''') for the lower models. Also available for the high-end PDP-11 clones was [[MOS (operating system)|MOS]], a clone of [[Unix|UNIX]]. ==References== {{Reflist}} == See also == * [[SM-4]] * [[SM-1420]] * [[SM-1600]] * [[K 1840|SM-1710]] * [[K 1820|SM-1720]] {{List of Soviet computer systems}} [[Category:Minicomputers]] [[Category:Computing in the Soviet Union]] [[Category:PDP-11]] {{mini-compu-stub}} [[de:System der Kleinrechner]] [[ru:СМ ЭВМ]]</text> </page> <page> <id>32913</id> <title>SOCKS</title> <text>{{About|the internet protocol|other uses|Socks (disambiguation)}} {{pp-semi|small=yes}} '''SOCKS''' is an [[Internet]] [[Protocol (computing)|protocol]] that facilitates the routing of [[Packet (information technology)|network packets]] between [[client–server]] applications via a [[proxy server]]. SOCKS performs at Layer 5 of the [[OSI model]]—the [[session layer]] (an intermediate layer between the [[presentation layer]] and the [[transport layer]]). Port 1080 is the [[registered port]] designated for the SOCKS server. The SOCKS5 protocol was originally a security protocol that made [[Firewall (computing)|firewalls]] and other security products easier to administer. It was approved by the [[Internet Engineering Task Force|IETF]] in 1996. The protocol was developed in collaboration with [[Aventail Corporation]], which markets the technology outside of Asia.<ref>[http://news.cnet.com/Cyberspace-from-outer-space/2100-1001_3-244725.html CNET: Cyberspace from outer space]</ref> == History == The protocol was originally developed by David Koblas, a system administrator of [[MIPS Computer Systems]]. After MIPS was taken over by [[Silicon Graphics]] in 1992, Koblas presented a paper on SOCKS at that year's Usenix Security Symposium and SOCKS became publicly available.<ref>Darmohray, Tina. "[http://www.usenix.org/publications/login/2005-02/pdfs/firewalls.pdf Firewalls and fairy tales]". ;LOGIN:. Vol 30, no. 1.</ref> The protocol was extended to version 4 by Ying-Da Lee of [[NEC]]. The SOCKS reference architecture and client are owned by [[Permeo Technologies]]<ref>{{wayback|url=http://www.socks.permeo.com/}}</ref> a spin-off from [[NEC]]. ([[Blue Coat Systems]] bought out ''Permeo Technologies'').<ref>{{Cite web|url=http://www.bluecoat.com/news/releases/2006/010306_permeo.html |title=News Release from |publisher=Bluecoat |date=2009-06-14 |accessdate=2009-06-19}}</ref><ref>[http://www.infosecurityproductsguide.com/hot2006/PermeoTechnologies.html Article from] Mohammad Asif infosecurityproductsguide.com</ref> == Comparison == {{Unreferenced section|date=March 2010}} The SOCKS and HTTP proxy protocol do to a large extent solve the same problem. SOCKS is usually used to create a raw [[Transmission Control Protocol|TCP]] connection, and the HTTP proxy protocol can do the same with the CONNECT method. In both cases a TCP connection is created from the client to the proxy server, and the IP address and port to which the client requests a connection is communicated over the connection. In both cases the proxy server can grant, reject, redirect and alter connection requests as it likes. HTTP proxies are traditionally more HTTP protocol aware and do more high level filtering (even though that usually only applies to GET and POST methods, not CONNECT). SOCKS proxies can also forward UDP traffic and work in reverse: HTTP proxies cannot. SOCKS uses a handshake protocol to inform the proxy software about the connection that the client is trying to make and may be used for any form of [[Transmission Control Protocol|TCP]] or [[User Datagram Protocol|UDP]] socket connection, whereas an [[HTTP]] proxy analyzes the [[List of HTTP headers|HTTP headers]] sent through it in order to infer the address of the server and therefore may only be used for HTTP traffic. The following examples demonstrate the difference between the SOCKS and HTTP proxy protocols: === SOCKS === Bill wishes to communicate with Jane over the internet, but a firewall exists on his network between them and Bill is not authorized to communicate through it himself. Therefore, he connects to the SOCKS proxy on his network and sends to it information about the connection he wishes to make to Jane. The SOCKS proxy opens a connection through the firewall and facilitates the communication between Bill and Jane. For more information on the technical specifics of the SOCKS protocol, see the sections below. === HTTP === Bill wishes to download a web page from Jane, who runs a web server. Bill cannot directly connect to Jane's server, as a firewall has been put in place on his network. In order to communicate with the server, Bill connects to his network's HTTP proxy. His internet browser communicates with the proxy in exactly the same way it would with the target server—it sends a standard HTTP request header. The HTTP proxy reads the request and looks for the Host header. It then connects to the server specified in the header 