on the state of the inputs, it may only be defined for steady-state signals. As the inputs change state, a small delay will occur before the output changes, due to the physical nature of the electronic system. For a brief period, the output may change to an unwanted state before settling back to the designed state. Certain systems can tolerate such ''[[glitch]]es'', but if for example this output functions as a [[clock signal]] for further systems that contain memory, the system can rapidly depart from its designed behaviour (in effect, the temporary glitch becomes permanent). For example, consider a two input [[AND gate]] fed with a logic signal A on one input and its negation, NOT A, on another input. In theory, the output (A AND NOT A) should never be high. However, if changes in the value of A take longer to propagate to the second input than the first when A changes from false to true, a brief period will ensue during which both inputs are true, and so the gate's output will also be true. <ref>S. H. Unger, "Hazards, Critical Races, and Metastability," Computers, IEEE Transactions on , vol.44, no.6, pp.754-768, Jun 1995</ref> Proper design techniques (e.g. [[Karnaugh map]]s) encourage designers to recognize and eliminate race conditions before they cause problems. As well as these problems, some logic elements can enter [[Metastability in electronics|metastable state]]s, which create further problems for circuit designers. ====Critical and non-critical race conditions==== A '''critical race''' occurs when the order in which internal variables are changed determines the eventual state that the [[Finite state machine|state machine]] will end up in. A '''non-critical race''' occurs when the order in which internal variables are changed does not alter the eventual state. In other words, a non-critical race occurs when moving to a desired state means that more than one internal state variable must be changed at once, but no matter in what order these internal state variables change, the resultant state will be the same. ====Static, dynamic, and essential race conditions==== ;Static race conditions : These are caused when a signal and its complement are combined together. ;Dynamic race conditions : These result in multiple transitions when only one is intended. They are due to interaction between gates (Dynamic race conditions can be eliminated by using not more than two levels of gating). ;Essential race conditions : These are caused when an input has two transitions in less than the total feedback propagation time. Sometimes they are cured using inductive delay-line elements to effectively increase the time duration of an input signal. ==Computing== Race conditions arise in software when separate [[Process (computer science)|processes]] or [[Thread (computer science)|threads]] of execution depend on some shared state. Operations upon shared states are [[critical section]]s that must be [[mutually exclusive]] in order to avoid harmful collision between processes or threads that share those states. Here is a simple example: Let us assume that two threads T1 and T2 each want to increment the value of a global integer by one. Ideally, the following sequence of operations would take place: # Integer i = 0; (memory) # T1 reads the value of i from memory into register1: 0 # T1 increments the value of i in register1: (register1 contents) + 1 = 1 # T1 stores the value of register1 in memory: 1 # T2 reads the value of i from memory into register2: 1 # T2 increments the value of i in register2: (register2 contents) + 1 = 2 # T2 stores the value of register2 in memory: 2 # Integer i = 2; (memory) In the case shown above, the final value of i is 2, as expected. However, if the two threads run simultaneously without locking or synchronization, the outcome of the operation could be wrong. The alternative sequence of operations below demonstrates this scenario: # Integer i = 0; (memory) # T1 reads the value of i from memory into register1: 0 # T2 reads the value of i from memory into register2: 0 # T1 increments the value of i in register1: (register1 contents) + 1 = 1 # T2 increments the value of i in register2: (register2 contents) + 1 = 1 # T1 stores the value of register1 in memory: 1 # T2 stores the value of register2 in memory: 1 # Integer i = 1; (memory) The final value of i is 1 instead of the expected result of 2. This occurs because the increment operations of the second case are not mutually exclusive. [[Mutually-exclusive]] operations are those that cannot be interrupted while accessing some resource such as a memory location. In the first case, T1 was not interrupted while accessing the variable i, so its operation was mutually-exclusive. For another example, consider the following two tasks, in [[pseudocode]]: '''global''' '''int''' A = 0 // increments the value of A and print "RX" // activated whenever an interrupt is received from the serial controller '''task''' Received() A = A + 1 '''print''' "RX" '''end task''' // prints out only the even numbers // is activated every second '''task''' Timeout() '''if''' (A is divisible by 2) '''print''' A '''end if''' '''end task''' Output would look something like: 0 0 0 RX RX 2 RX RX 4 4 Now consider this chain of events, which might occur next: # timeout occurs, activating task <tt>Timeout</tt> # task <tt>Timeout</tt> evaluates <code>A</code> and finds it is divisible by 2, so elects to execute the "print A" next. # data is received on the serial port, causing an interrupt and a switch to task <tt>Received</tt> # task <tt>Received</tt> runs to completion, incrementing A and printing "RX" # control returns to task <tt>Timeout</tt> # task timeout executes print A, using the current value of A, which is 5. [[Mutual exclusion|Mutex]]es are used to address this problem in concurrent programming. ===Real-world examples=== ====File systems==== In [[file system]]s, two or more programs may "collide" in their attempts to modify or access a file, which could result in data corruption. [[File locking]] 