|{{Sort|03|&mdash;}} |style="background:#ddffdd"|<math>\;n \cdot \frac{k}{d}</math> |style="background:#ddffdd"|<math>\;n \cdot \frac{k}{d}</math> |<math>\mathcal{} n + \frac{k}{d} \cdot 2^d </math> |style="background:#ddffdd"| Yes | No | Stable version uses an external array of size n to hold all of the bins |- align="center" |[[Radix sort#Most significant digit radix sorts|MSD Radix Sort]] |{{Sort|03|&mdash;}} |style="background:#ddffdd"|<math>\;n \cdot \frac{k}{d}</math> |style="background:#ddffdd"|<math>\;n \cdot \frac{k}{d}</math> |<math>\frac{k}{d} \cdot 2^d</math> |style="background:#ffdddd"| No | No | In-Place. k / d recursion levels, 2<sup>d</sup> for count array |- align="center" |[[Spreadsort]] |{{Sort|03|&mdash;}} |style="background:#ddffdd"|<math>\;n \cdot \frac{k}{d}</math> |style="background:#ddffdd"|<math>\;n \cdot \left( {\frac{k}{s} + d} \right)</math> |<math>\;\frac{k}{d} \cdot 2^d</math> |style="background:#ffdddd"| No | No | Asymptotics are based on the assumption that n << 2<sup>k</sup>, but the algorithm does not require this. |} The following table describes some sorting algorithms that are impractical for real-life use due to extremely poor performance or a requirement for specialized hardware. {|class="wikitable sortable" !Name !! Best !! Average !! Worst !! Memory !! Stable !! Comparison !! Other notes |- align="center" |[[Bead sort]] |{{Sort|03|&mdash;}} | N/A | N/A |&mdash; | N/A | No |nowrap align="left"| Requires specialized hardware |- align="center" |[[Pancake sorting|Simple pancake sort]] |{{Sort|03|&mdash;}} | <math>\mathcal{} n </math> | <math>\mathcal{} n </math> | <math>\mathcal{} {\log n} </math> | style="background:#ffdddd" | No | Yes | nowrap align="left" | Count is number of flips. |- align="center" |[[Sorting network]]s |{{Sort|03|&mdash;}} |nowrap|<math>\mathcal{} {\log n} </math> |nowrap|<math>\mathcal{} {\log n} </math> | <math>\mathcal{} {n \cdot \log (n)} </math> |style="background:#ddffdd"| Yes | No |nowrap align="left"| Requires a custom circuit of size <math>\mathcal{O}\left( n \cdot \log (n) \right)</math> |} Additionally, theoretical computer scientists have detailed other sorting algorithms that provide better than <math>\mathcal{O}\left( {n \log n} \right)</math> time complexity with additional constraints, including: * Han's algorithm, a deterministic algorithm for sorting keys from a [[domain]] of finite size, taking <math>\mathcal{O}\left( {n \log \log n} \right)</math> time and <math>\mathcal{O}\left( {n} \right)</math> space.<ref>Y. Han. ''Deterministic sorting in <math>\mathcal{O}\left( {n \log \log n} \right)</math> time and linear space''. Proceedings of the thiry-fourth annual ACM symposium on Theory of computing, Montreal, Quebec, Canada, 2002,p.602-608.</ref> * Thorup's algorithm, a randomized algorithm for sorting keys from a domain of finite size, taking <math>\mathcal{O}\left( {n \log \log n} \right)</math> time and <math>\mathcal{O}\left( {n} \right)</math> space.<ref>M. Thorup. ''Randomized Sorting in <math>\mathcal{O}\left( {n \log \log n} \right)</math> Time and Linear Space Using Addition, Shift, and Bit-wise Boolean Operations''. Journal of Algorithms, Volume 42, Number 2, February 2002 , pp. 205-230(26)</ref> * An [[integer]] sorting algorithm taking <math>\mathcal{O}\left( {n \sqrt{\log \log n}} \right)</math> expected time and <math>\mathcal{O}\left( {n} \right)</math> space.<ref>Han, Y. and Thorup, M. 2002. Integer Sorting in <math>\mathcal{O}\left( {n \sqrt{\log \log n}} \right)</math> Expected Time and Linear Space. In ''Proceedings of the 43rd Symposium on Foundations of Computer Science'' (November 16–19, 2002). FOCS. IEEE Computer Society, Washington, DC, 135-144.</ref> Algorithms not yet compared above include: * [[Odd-even sort]] * [[Flashsort]] * [[Burstsort]] * [[Postman sort]] * [[Stooge sort]] * [[Samplesort]] * [[Bitonic sorter]] * [[Cocktail sort]] * [[Topological sort]] == Summaries of popular sorting algorithms == === Bubble sort === [[File:Bubblesort-edited.png|thumb|right|A bubble sort, a sorting algorithm that continuously steps through a list, [[Swap (computer science)|swapping]] items until they appear in the correct order.]] {{Main|Bubble sort}} ''Bubble sort'' is a straightforward and simplistic method of sorting data that is used in computer science education. Bubble sort is based on the principle that an air bubble in water will rise displacing all the heavier water molecules in its way. The algorithm starts at the beginning of the data set. It compares the first two elements, and if the first is greater than the second, then it swaps them. It continues doing this for each pair of adjacent elements to the end of the data set. It then starts again with the first two elements, repeating until no swaps have occurred on the last pass. This algorithm is highly inefficient, and is rarely used{{Citation needed|date=January 2010}}{{dubious|date=July 2010}}, except as a simplistic example. For example, if we have 100 elements then the total number of comparisons will be 10000. A slightly better variant, [[cocktail sort]], works by inverting the ordering criteria and the pass direction on alternating passes. The modified Bubble sort will stop 1 shorter each time through the loop, so the total number of comparisons for 100 elements will be 4950. Bubble sort may, however, be efficiently used on a list that is already sorted, except for a very small number of elements. For example, if only one element is not in order, bubble sort will only take ''2n'' time. If two elements are not in order, bubble sort will only take at most ''3n'' time. Bubble sort average case and worst case are both O(''n''²). === Selection sort === {{Main|Selection sort}} '''Selection sort''' is a sorting algorithm, specifically an [[in-place algorithm|in-place]] [[comparison sort]]. It has [[Big O notation|O]](''n''<sup>2</sup>) complexity, making it inefficient on large lists, and generally performs worse than the similar [[insertion sort]]. Selection sort is noted for its simplicity, and also has performance advantages over more complicated algorithms in certain situations. The algorithm finds the minimum value, swaps it with the value in the first position, and repeats these steps for the remainder of the list. It does no more than ''n'' swaps, and thus is useful where swapping is very expensive. === Insertion sort === {{Main|Insertion sort}} ''Insertion sort'' is a simple sorting algorithm that is relatively efficient for small lists and mostly-sorted lists, and often is used as part of more sophisticated algorithms. It works by taking elements from the list one by one and inserting them in their correct position into a new sorted list. In arrays, the new list and the remaining elements can share the array's space, but insertion is expensive, requiring shifting all following elements over by one. [[Shell sort]] (see below) is a variant of insertion sort that is more efficient for larger lists. === Shell sort === {{Main|Shell sort}} ''Shell sort'' was invented by [[Donald Shell]] in 1959. It improves upon bubble sort and insertion sort by moving out of order elements more than one position at a time. One implementation can be described as 