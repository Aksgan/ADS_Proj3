of comparability graphs and interval graphs | journal = Graphs and Order | editor = I. Rival | publisher = D. Reidel | year = 1985 | pages = 41–101}} *{{cite journal | doi = 10.1007/BF02022041 | last1 = Möhring | first1 = Rolf H. | title = Algorithmic aspects of the substitution decomposition in optimization over relations, set systems and Boolean functions | journal = Annals of Operations Research | volume = 4 | year = 1985 | pages = 195–225}} *{{cite book | last1 = Papadopoulos | first1 = Charis | last2 = Voglis | first2 = Constantinos | contribution = Drawing graphs using modular decomposition | title = [[International Symposium on Graph Drawing|Proc. 13th International Symposium on Graph Drawing (GD'05)]] | series = Lecture Notes in Computer Science | publisher = Springer-Verlag | volume = 3842 | year = 2006 | pages = 343–354 | url = http://www.ii.uib.no/~charis/files/DrawModular.pdf | id = {{MathSciNet | id = 2229205}} | doi = 10.1007/11618058_31}} *{{cite book | last1 = Spinrad | first1=Jeremy P. | series = Fields Institute Monographs | publisher = American Mathematical Society | year = 2003 | title = Efficient Graph Representations}} *{{cite book | last1 = Tedder | first1 = Marc | last2 = Corneil | first2 = Derek | last3 = Habib | first3 = Michel | last4 = Paul | first4 = Christophe | contribution = Simpler Linear-Time Modular Decomposition Via Recursive Factorizing Permutations | series = Lecture Notes in Computer Science | publisher = Springer-Verlag | volume = 5125 | year = 2008 | pages = 634–645 | url = http://arxiv.org/abs/0710.3901 | doi = 10.1007/978-3-540-70575-8_52 | title = [[International Colloquium on Automata, Languages and Programming|Proc. 35th International Colloquium on Automata, Languages and Programming (ICALP 2008)]]}}. == External links == * [http://www.lirmm.fr/~gambette/EnsDecompositionModulaireENG.php A bibliography of modular decomposition algorithms] * A [[Perl]] [http://www.dns.net/dist/graph/ implementation of a modular decomposition algorithm] * A Java [http://code.google.com/p/bpstruct/ implementation of a modular decomposition algorithm] [[Category:Graph theory]]</text> </page> <page> <id>24927</id> <title>Modular programming</title> <text>{{Unreferenced|date=August 2010}} {{Disputed|date=October 2010}} {{Programming paradigms}} '''Modular programming''' is a software design technique that increases the extent to which software is composed of separate, interchangeable components, called '''modules'''. Conceptually, modules represent a [[separation of concerns]], and improve [[maintainability]] by enforcing logical boundaries between components. Modules are typically incorporated into the program through [[interface (computer science)|interfaces]]. A module interface expresses the elements that are provided and required by the module. The elements defined in the interface are detectable by other modules. The [[implementation]] contains the working code that corresponds to the elements declared in the interface. ==Language support== Languages that formally support the module concept include [[IBM/360]] [[Assembler for an assembly language|Assembler]], [[COBOL]], [[IBM RPG|RPG]] and [[PL/1]], [[Ada (programming language)|Ada]], [[D (programming language)|D]], [[F (programming language)|F]], [[Fortran]], [[Haskell (programming language)|Haskell]], [[BlitzMax]], [[OCaml]], [[Pascal (programming language)|Pascal]], [[ML (programming language)|ML]], [[Modula-2]], [[Oberon (programming language)|Oberon]], Morpho, [[Component Pascal]], [[Zonnon]], [[Erlang (programming language)|Erlang]], [[Perl]], [[Python (programming language)|Python]] and [[Ruby (programming language)|Ruby]].{{Or|date=October 2010}} The [[IBM System i]] also uses Modules in [[IBM RPG|RPG]], [[COBOL]] and [[AS/400 Control Language|CL]], when programming in the ILE environment. Modular programming can be performed even where the programming language lacks explicit syntactic features to support named modules. Software tools can create modular code units from groups of components. [[Library (computing)|Libraries]] of components built from separately compiled modules can be combined into a whole by using a [[Linker (computing)|linker]]. ==Key Aspects== With Modular Programming, concerns are separated such that no (or few) modules depend upon other modules of the system{{Dubious|date=October 2010}}. To have as few dependencies as possible is the goal{{Dubious|date=October 2010}}. When creating a modular system, instead of creating a monolithic application (where the smallest component is the whole application), several smaller modules are built (and usually compiled) separately that, when composed together, will construct the executable application program. A [[Just-in-time compilation|just in time compiler]] may perform some of this construction "on-the-fly" at [[run time]]. This makes modular designed systems, if built correctly, far more reusable than a traditional monolithic design - since all (or many) of these modules may then be reused (without change) in other projects. This also facilitates the "breaking down" of projects (through "[[divide and conquer]]") into several smaller projects. Theoretically, a modularized software project will be more easily assembled by large teams, since no team members are creating the whole system, or even need to know about the system as a whole. They can focus just on the assigned smaller task (this, it is claimed, counters the key assumption of [[The Mythical Man Month]] - making it actually possible to add more developers to a late software project - without making it later still). ==Implementation== [[Message passing]] has, more recently, gained ground over the earlier, more conventional, "<code>Call</code>" interfaces, becoming the more dominant linkage between separate modules as an attempt to solve the "versioning problem" (sometimes experienced when using interfaces for communication between the modules). ==History== Traditional programming languages have been used to support modular programming - since at least the 1960s. Modular programming is a loosely defined concept with no official definition. It is, in essence, simply a programming technique{{Dubious|date=October 2010}}. Exactly where modularized programming ends, and [[Dynamic-link library|Dynamically Linked Libraries]] or [[Object-oriented programming]] starts in this context is subjective. It might be defined as the natural predecessor of [[OOP]], or an evolutionary step beyond it - depending upon viewpoint. ==See also== * [[Architecture description language]] * [[Cohesion (computer science)|Cohesion]] * [[Constructionist design methodology]], a methodology for creating modular, broad Artificial Intelligence systems * [[Component-based software engineering]] * [[Coupling (computer science)|Coupling]] * [[David Parnas]] * [[Information hiding]] (encapsulation) * [[Library (computing)]] * [[List of system quality attributes]] * [[Snippet (programming)]] * [[Structured programming]] ==References== <references/> * [http://legosoftwareprocess.org/ O2 Software Process] {{DEFAULTSORT:Modular Programming}} [[Category:Programming paradigms]] [[Category:Holism]] [[de:Modul (Software)]] [[es:Programación modular]] [[fa:برنامه‌نویسی پودمانی]] [[fr:Module (programmation)]] [[ko:모듈성 (프로그래밍)]] [[he:מודול (תוכנה)]] [[ja:モジュール]] [[pt:Programação modular]] [[ru:Модульность (программирование)]] [[tr:Modüler programlama]] [[zh:軟體模塊]]</text> </page> <page> <id>24928</id> <title>Modularity-driven testing</title> <text>{{Unreferenced|date=March 2007}} {{Portal|Software Testing}} '''Modularity-driven testing''' is a term used in the testing of [[software]]. ==Test Script Modularity Framework== The test script modularity framework requires 