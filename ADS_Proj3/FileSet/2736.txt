there, with examples of usage. *[http://71.174.62.16/Demo/AnnoStd The Annotated MUMPS Language Standard], showing the evolution of the language and differences between versions of the [[ANSI]] standard. =="MUMPS" vs. "M" naming debate== While of little interest to those outside the MUMPS/M community, this topic has been contentious there. All of the following positions can, and have been, supported by knowledgeable people at various times: *The language's name became M in 1993 when the M Technology Association adopted it. *The name became M on December 8, 1995 with the approval of ANSI X11.1-1995 *Both M ''and'' MUMPS are officially accepted names. *M is only an "alternate name" or "nickname" for the language, and MUMPS is still the official name. Some of the contention arose in response to strong M advocacy on the part of one commercial interest, [[InterSystems]], whose chief executive disliked the name MUMPS and felt that it represented a serious marketing obstacle. Thus, favoring M to some extent became identified as alignment with InterSystems. The dispute also reflected rivalry between organizations (the M Technology Association, the MUMPS Development Committee, the [[ANSI]] and [[International Organization for Standardization|ISO]] Standards Committees) as to who determines the "official" name of the language. Some writers have attempted to defuse the issue by referring to the language as ''M[UMPS]'', square brackets being the customary notation for optional syntax elements. A leading authority, and the author of an open source MUMPS implementation, Professor Kevin O'Kane, uses only 'MUMPS'. The most recent standard (ISO/IEC 11756:1999, re-affirmed on 6 January 2005), still mentions both M and MUMPS as officially accepted names. ==Epoch choice== In MUMPS, the current [[system time|date and time]] is contained in a special system variable, $H (short for "HOROLOG"). The format is a pair of integers separated by a comma, e.g. "54321,12345" The first number is the number of days since December 31, 1840, i.e. day number 1 is January 1, 1841; the second is the number of seconds since midnight. James M. Poitras has written that he chose this epoch for the date and time routines in a package developed by his group at MGH in 1969: {{cquote|I remembered reading of the oldest (one of the oldest?) U.S. citizen, a [[American Civil War|Civil War]] veteran, who was 121 years old at the time. Since I wanted to be able to represent dates in a [[Julian date|Julian]]-type form so that age could be easily calculated and to be able to represent any birth date in the numeric range selected, I decided that a starting date in the early 1840s would be 'safe.' Since my algorithm worked most logically when every fourth year was a leap year, the first year was taken as 1841. The zero point was then December 31, 1840.... I wasn't party to the MDC negotiations, but I did explain the logic of my choice to members of the Committee.}} (More colorful versions have circulated in the folklore, suggesting, for example, that December 31, 1840 was the exact date of the first entry in the [[Massachusetts General Hospital|MGH]] records, but these seem to be urban legends. Another legend is that the date was chosen to commemorate the first use of ether as an anesthetic at Mass General.) ==Sample programs== The direct execution of source code on historical computing platforms in an era of tiny disks, minuscule RAM and 300 [[baud]] serial connections led to a historical coding style that was terse, dense and expert friendly, even as contemporary MUMPS coding styles produce more readable code. First, an example of M code from 2010, a solution to a benchmarking exercise based on calculating the longest sequence encountered when calculating the longest sequence of the [[Collatz conjecture]] for a range of integers. This example is written in [[GT.M]] and exploits & illustrates many features of MUMPS. <source lang="text"> threeen1f ; Find the maximum number of steps for the 3n+1 problem for all integers through two input integers. ; See http://docs.google.com/View?id=dd5f3337_24gcvprmcw ; Assumes input format is 3 integers separated by a space with the first integer smaller than the second. ; The third integer is the number of parallel computation streams. If it is less than twice the ; number of CPUs or cores, the parameter is modified to that value. An optional fourth integer is the ; sizes of blocks of integers on which spawned child processes operate. If it is not specified, the ; block size is approximately the range divided by the number of parallel streams. If the block size is ; larger than the range divided by the number of execution streams, it is reduced to that value. ; No input error checking is done. ; Although the problem can be solved by using strictly integer subscripts and values, this program is ; written to show that the GT.M key-value store can use arbitrary strings for both keys and values - ; each subscript and value is spelled out using the strings in the program source line labelled "digits". ; Furthermore, the strings are in a number of international languages when GT.M is run in UTF-8 mode. ; K.S. Bhaskar 2010612 ; No claim of copyright is made with respect to this program. ; Variables do not have to be declared before use, but are New'd in subprograms to ensure that they ; do not conflict with names in the caller. ; The program reads the program source at the label digits to get strings (separated by ;) for each language used. digits ;zero;eins;deux;tres;quattro;пять;ستة;सात;捌;ஒன்பது Do digitsinit ; Initialize data for conversion between integers and strings ; Get number of CPUs from /proc/cpuinfo and calculate minimum number of execution streams Open "cpus":(SHELL="/bin/sh":COMMAND="grep -i ^processor /proc/cpuinfo|wc -l":READONLY)::"PIPE" Use "cpus" Read streams Use $PRINCIPAL Close "cpus" Set streams=2*streams ; At least two execution streams per CPU ; At the top level, the program reads and processes input lines, one at a time. Each line specifies ; one problem to solve. Since the program is designed to resume after a crash and reuse partial ; results computed before 