the Secondary Synchronization Codes used in the [[UMTS]] [[W-CDMA]] 3G Wireless Standard * [[VCR Plus|VCR Plus+ codes]] * the [[UTF-8]] system for encoding [[Unicode]] characters ===Techniques=== Commonly used techniques for constructing prefix codes include [[Huffman coding|Huffman codes]] and the earlier [[Shannon-Fano coding|Shannon-Fano codes]], and [[universal code (data compression)|universal code]]s such as: * [[Elias delta coding]] * [[Elias gamma coding]] * [[Elias omega coding]] * [[Fibonacci coding]] * [[Levenshtein coding]] * [[Unary coding]] * [[Golomb Rice code]] * [[Straddling checkerboard]] (simple cryptography technique which produces prefix codes) ==Notes== {{Reflist}} ==References== * P. Elias, Universal codeword sets and representations of integers, IEEE Trans. Inform. Theory 21 (2) (1975) 194–203. * D.A. Huffman, "A method for the construction of minimum-redundancy codes", Proceedings of the I.R.E., Sept. 1952, pp. 1098–1102 (Huffman's original article) * [http://www.huffmancoding.com/david/scientific.html Profile: David A. Huffman], [[Scientific American]], Sept. 1991, pp. 54–58 (Background story) * [[Thomas H. Cormen]], [[Charles E. Leiserson]], [[Ronald L. Rivest]], and [[Clifford Stein]]. ''[[Introduction to Algorithms]]'', Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 16.3, pp.385–392. * {{FS1037C}} ==External links== * [http://plus.maths.org/issue10/features/infotheory/index.html Codes, trees and the prefix property] by Kona Macphee [[Category:Coding theory]] [[Category:Prefixes]] [[Category:Data compression]] [[Category:Lossless compression algorithms]] <!-- do I really need both categories? --> [[cs:Prefixový kód]] [[de:Präfixcode]] [[es:Código prefijo]] [[fr:Code préfixe]] [[ja:接頭符号]] [[pl:Kod prefiksowy]] [[ru:Префиксный код]]</text> </page> <page> <id>29852</id> <title>Prefix header</title> <text>In [[computer programming]], a '''prefix [[header]]''' is a feature found in some [[C (programming language)|C]] or [[C++]] [[compilers]] used to simplify code and/or to reduce compilation time. == Overview == In the [[C (programming language)|C]] and [[C++]] programming languages, a [[header file]] is a [[computer file|file]] whose text is automatically included in another source file by the [[compiler]], usually by the use of [[compiler directive]]s at the beginning of the source file. A prefix header differs from a normal header file in that it is ''automatically'' included at the beginning of every source file by the compiler, without the use of any compiler directives. Prefix headers are usually [[precompiled header|pre-compiled]] in order to reduce compilation times. == Example == On [[Mac OS X]], the [[Xcode]] build system generates prefix headers automatically for new projects. A new [[Cocoa (API)|Cocoa]] project, for instance, gets a prefix header that looks like this: <source lang="objc"> #ifdef __OBJC__ #import <Cocoa/Cocoa.h> #endif </source> As a result, it is unnecessary to explicitly include any of the above files in any [[Objective-C]] code in the program, although doing so is harmless, in the case of Objective-C because of the semantics of the <code>#import</code> directive, but more generally with <code>#include</code> because of the use of [[include guard]]s. Similar prefix headers are generated for other types of project. == See also == * [[Header file]] * [[Precompiled header]] == External links == * [http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/XcodeBuildSystem/800-Reducing_Build_Times/bs_speed_up_build.html#//apple_ref/doc/uid/TP40002695-SW1 Xcode User Guide: Using a Precompiled Prefix Header] [[Category:Source code]] [[Category:C programming language]] [[Category:C++]]</text> </page> <page> <id>29862</id> <title>Preload (software)</title> <text>{{Orphan|date=February 2009}} {{lowercase|preload (software)}} '''preload''' is a [[Free software|Free]] [[Linux]] program written by [[Behdad Esfahbod]] which runs as a [[daemon]] and records statistics about usage of programs using [[Markov chain]]s; files of more frequently-used programs are, during a computer's spare time, loaded into [[Primary storage|memory]].<ref name="thesis">[http://behdad.org/preload.pdf Preload — An Adaptive Prefetching Daemon], [[Behdad Esfahbod]], 2006.</ref> This results in faster [[software application|application]] startup times as less data needs to be fetched from disk. preload is often paired with [[prelink]]. ==External links== *[http://sourceforge.net/projects/preload Project homepage] on [[Sourceforge]] *[http://www.colitti.com/lorenzo/publications/gnome-sane.pdf "Analyzing and improving GNOME startup time"] -([[PDF]]) ==References== {{reflist}} [[Category:Memory management]] [[Category:Linux process and task management-related software]] {{software-stub}} [[pl:Preload (Linux)]] [[pt:Preload]]</text> </page> <page> <id>29867</id> <title>Prenex normal form</title> <text>A [[formula (mathematical logic)|formula]] of the [[predicate calculus]] is in '''prenex<ref>The term 'prenex' comes from the [[Latin]] ''praenexus'' "tied or bound up in front", past participle of ''praenectere'' [http://cs.nyu.edu/pipermail/fom/2007-November/012328.html].</ref> [[normal form]]''' if it is written as a string of [[quantifier]]s followed by a quantifier-free part (referred to as the '''matrix'''). Every formula is equivalent in [[classical logic]] to a formula in prenex normal form. For example, if <math>\phi(y)</math>, <math>\psi(z)</math>, and <math>\rho(x)</math> are quantifier-free formulas with the free variables shown then :<math>\forall x \exists y \exists z (\phi(y) \lor (\psi(z) \rightarrow \rho(x)))</math> is in prenex normal form with matrix <math>\phi(y) \lor (\psi(z) \rightarrow \rho(x))</math>, while :<math>\forall x ((\exists y \phi(y)) \lor ((\exists z \psi(z) ) \rightarrow \rho(x)))</math> is logically equivalent but not in prenex normal form. == Conversion to prenex form == Every [[first-order predicate calculus|first-order]] formula is [[logically equivalent]] (in classical logic) to some formula in prenex normal form. There are several conversion rules that can be recursively applied to convert a formula to prenex normal form. The rules depend on which [[logical connective]]s appear in the formula. === Conjunction and disjunction === The rules for conjunction and disjunction say that :<math>(\forall x \phi) \land \psi</math> is equivalent to <math>\forall x ( \phi \land \psi)</math>, :<math>(\forall x \phi) \lor \psi</math> is equivalent to <math>\forall x ( \phi \lor \psi)</math>; and :<math>(\exists x \phi) \land \psi</math> is equivalent to <math>\exists x (\phi \land \psi)</math>, :<math>(\exists x \phi) \lor \psi</math> is equivalent to <math>\exists x (\phi \lor \psi)</math>. The equivalences are valid when ''x'' does not appear as a [[free variable]] of ψ; if ''x'' does appear free in ψ, it must be replaced with another free variable. For example, in the language of [[ring (mathematics)|rings]], :<math>(\exists x (x^2 = 1)) \land (0 = y)</math> is equivalent to <math>\exists x ( x^2 = 1 \land 0 = y)</math>, but :<math>(\exists x (x^2 = 1)) \land (0 = x)</math> is not equivalent to <math>\exists x ( x^2 = 1 \land 0 = x)</math> because the formula on the left is true in any ring when the free variable ''x'' is equal to 0, while the formula on the right has no free variables and is false in any nontrivial ring. === Negation === The rules for negation say that :<math>\lnot \exists x \phi</math> is equivalent to <math>\forall x \lnot \phi</math> and :<math>\lnot \forall x \phi</math> is equivalent to <math>\exists x \lnot \phi</math>. === Implication === There are four rules for implication: two that remove quantifiers from the antecedent 