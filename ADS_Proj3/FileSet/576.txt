Declaring an uninitialized variable MyInt = 35; // Initializing the variable </source> '''Declare & initialize''' <source lang="csharp"> int MyInt = 35; // Declaring and initializing the variable at the same time </source> Multiple variables of the same type can be declared and initialized in one statement. <source lang="csharp"> int a, b; // Declaring multiple variable of the same type int a = 2, b = 3; // Declaring and initializing multiple variables of the same type </source> ====Type inference==== :''This is a feature of [[C Sharp 3.0|C# 3.0]].'' C# 3.0 introduced type inference, allowing the type specifier of a variable declaration to be replaced by the keyword ''var'', if its actual type can be statically determined from the initializer. This reduces repetition, especially for types with multiple generic [[#Type-parameters|type-parameters]], and adheres more closely to the [[DRY]] principle. <source lang="csharp"> var MyChars = new char[] {'A', 'Ö'}; // or char[] MyChars = new char[] {'A', 'Ö'}; var MyNums = new List<int>(); // or List<int> MyNums = new List<int>(); </source> '''See also''' * [[Type inference]] ===Constants=== Constants are values that are immutable and can not change. ====<code>const</code>==== When declaring a local variable or a field with the <code>const</code> keyword as a prefix the value must be given when it is declared. After that it is locked and cannot change. They can either be declared in the context as a field or a local variable. Constants are implicitly static. <source lang="csharp"> const double PI = 3.14; </source> This shows all the uses of the keyword. <source lang="csharp"> class Foo { const double x = 3; Foo() { const int y = 2; } } </source> ====<code>readonly</code>==== The <code>readonly</code> keyword does a similar thing to fields. Like fields marked as <code>const</code> they cannot change once initialized. The difference is that you can choose to initialize them in a constructor. This only works on fields. Read-only fields can either be members of an instance or static class members. <source lang="csharp"> class Foo { readonly int value; readonly int value2 = 3; readonly StringBuilder sb; Foo() { value = 2; sb = new StringBuilder(); } } </source> ===Code blocks=== The operators <code>{ ... }</code> are used to signify a code block and a new scope. Class members and the body of a method are examples of what can live inside these braces in various contexts. Inside of method bodies you can use the braces to create new scopes like so: <source lang="csharp"> void doSomething() { int a; { int b; a = 1; } a = 2; b = 3; //Will fail because the variable is declared in an inner scope. } </source> ==Program structure== A C# application consists of classes and their members. Classes and other types exist in namespaces but can also be nested inside other classes. ===<code>Main</code> method=== Whether it is a console or a graphical interface application, the program must have an entrypoint of some sort. The entrypoint of the C# application is the <code>Main</code> method. There can only be one, and it is a static method in a class. The method usually returns <code>void</code> and is passed command-line arguments as an array of strings. <source lang="csharp"> static void Main(string[] args) { } </source> A Main-method is also allowed to return an integer value if specified. <source lang="csharp"> static int Main(string[] args) { return 0; } </source> ===Namespaces=== Namespaces are a part of a type name and they are used to group and/or distinguish named entities from other ones. <source lang="csharp"> System.IO.DirectoryInfo //DirectoryInfo is in the System.IO-namespace </source> A namespace is defined like this: <source lang="csharp"> namespace FooNamespace { //Members } </source> ===<code>using</code> statement=== The <code>using</code> statement loads a specific namespace from a referenced assembly. It is usually placed in the top (or header) of a code file but it can be placed elsewhere if wanted, e.g. inside classes. <source lang="csharp"> using System; using System.Collections; </source> You can also use the statement to define another name for an existing namespace or type. This is sometimes useful when names are too long and less readable. <source lang="csharp"> using Net = System.Net; using DirInfo = System.IO.DirectoryInfo; </source> ==Operators== {| class="wikitable" |- !width="200"|Operator category !width="300"|Operators |- |Arithmetic |<code><nowiki>+ - * / %</nowiki></code> |- |Logical (boolean and bitwise) |<code><nowiki>& | ^ ! ~ && ||</nowiki></code> |- |String concatenation |<code><nowiki>+</nowiki></code> |- |Increment, decrement |<code><nowiki>++ --</nowiki></code> |- |Shift |<code><nowiki><< >></nowiki></code> |- |Relational |<code><nowiki>== != < > <= >=</nowiki></code> |- |Assignment |<code><nowiki>= += -= *= /= %= &= |= ^= <<= >>=</nowiki></code> |- |Member access |<code>.</code> |- |Indexing |<code><nowiki>[ ]</nowiki></code> |- |Cast |<code>( )</code> |- |Conditional |<code>? :</code> |- |Delegate concatenation and removal |<code>+ - </code> |- |Object creation |<code>new</code> |- | Type information |<code>as is sizeof typeof </code> |- |Overflow exception control |<code>checked unchecked</code> |- |Indirection and Address |<code>* -> [] &</code> |} ===Operator overloading=== Some of the existing operators can be overloaded by writing an overload method. <source lang="csharp"> public static Foo operator+(Foo foo, Bar bar) { return new Foo(foo.Value + bar.Value); } </source> These are the overloadable operators: {| class="wikitable" |- !width="300"|Operators !width="400"| |- |<code><nowiki>+ - ! ~ ++ -- true false</nowiki></code> |''Unary operators'' |- |<code><nowiki>+ - * / % & | ^ << >></nowiki></code> |''Binary operators'' |- |<code><nowiki>== != < > <= >=</nowiki></code> |''Comparison operators'', must be overloaded in pairs |- |} * ''Assignment operators'' (<code>+=, *=</code> etc.) are combinations of a binary operator and the assignment operator (<code>=</code>) and will be evaluated using the ordinary operators, which can be overloaded. * ''Cast operators'' (<code>( )</code>) cannot be overloaded, but you can define conversion operators. * ''Array indexing'' (<code>[ ]</code>) operator is not overloadable, but you can define new indexers. '''See also''' * [[Operator overloading]] ===Conversion operators=== The cast operator is not overloadable but you can write a conversion operator method which lives in the target class. Conversion methods can define two varieties of operators, implicit and explicit conversion operators. The implicit operator will cast without specifying with the cast operator (<code>( )</code>) and the explicit operator requires it to be used. '''Implicit conversion operator'''</br> 