regular timetable needs routes that take 28 or 58 minutes, in order for a vehicle to make it from one hub to another in time. In contrast, a route that takes 40 minutes would be bad, because vehicles and possibly passengers would have to wait uselessly for their connections. Thus, a route that takes 40 minutes generates nearly the same cost as a route that takes 58 minutes, because vehicles and personnel can't be used in the remaining 20 minutes. Therefore, lines are often cut or extended to meet this requirement when an integrated timetable is introduced. Swiss Federal Railways have adapted their infrastructure in such a way that trains need multiples of 30 minutes between hubs, providing good connections to all means of transport that run every half an hour, which is the case for most lines today. However, on some single tracked lines the published timetables may be 30/30 or 60/60 minutes, while the actual timetables are slightly asymmetrical, because the passing loops are not positioned ideally. == References == <references/> == External links == * [http://www.sma-partner.ch/index.php?option=com_content&view=article&id=273%3Anetzgrafik-fahrplan-s-bahn-zuerich-2009&catid=15%3Aprojekte-und-konzepte&Itemid=140&lang=de Integrated timetable of the Zurich S-Bahn] - The numbers are minutes, timetable repeats every hour {{Public transport}} {{DEFAULTSORT:Clock-face schedules}} [[Category:Transportation planning]] [[Category:Public transport information systems]] [[de:Taktfahrplan]] [[fr:Horaire cadencé]] [[it:Orario cadenzato]] [[hu:Ütemes menetrend]] [[nl:Gecadanseerde dienstregeling]]</text> </page> <page> <id>6519</id> <title>Clone (Java method)</title> <text>{{lowercase}} {{inline|date=August 2010}} '''<code>clone()</code>''' is a [[Method (computer science)|method]] in the [[Java (programming language)|Java programming language]] for [[Object copy|object duplication]]. In Java, objects are manipulated through reference variables, and there is no operator for ''copying'' an object—the assignment operator duplicates the reference, not the object. The clone() method provides this functionality. == Overview == Classes that want copying functionality must implement some method to do so. To a certain extent that function is provided by "<code>clone()</code>". <code>clone()</code> acts like a constructor. Typically it calls the <code>clone()</code> method of its superclass to obtain the copy, etc. until it eventually reaches <code>Object</code>'s <code>clone()</code> method. The special <code>clone()</code> method in the [[Superclass (computer science)|base class]] <code>Object</code> provides a standard mechanism for duplicating objects. The [[class (computer science)|class]] <code>Object</code>'s <code>clone()</code> method creates and returns a copy of the object, with the same class and with all the fields having the same values. However, <code>clone()</code> throws a <code>CloneNotSupportedException</code> unless the class you are trying to use it on implements the [[marker interface pattern|marker interface]] <code>Cloneable</code>. The default implementation of <code>Object.clone()</code> performs a [[shallow copy]]. When a class desires a [[deep copy]] or some other custom behavior, they must perform that in their own <code>clone()</code> method after they obtain the copy from the superclass. The syntax for calling <code>clone</code> in Java is: <source lang="java"> Object copy = obj.clone(); </source> or commonly <source lang="java"> MyClass copy = (MyClass) obj.clone(); </source> which provides the [[typecast]]ing needed to assign the generic <code>Object</code> reference returned from <code>clone</code> to a reference to a <code>MyClass</code> object. One disadvantage with the design of the <code>clone()</code> method is that the return type of <code>clone()</code> is <code>Object</code>, and needs to be explicitly cast back into the appropriate type. However, overriding <code>clone()</code> to return the appropriate type is preferable and eliminates the need for casting in the client (using [[covariant return type]]s, since J2SE 5.0). Another disadvantage is that one often cannot access the <code>clone()</code> method on an abstract type. Most interfaces and abstract classes in Java do not specify a public <code>clone()</code> method. As a result, often the only way to use the <code>clone()</code> method is if you know the actual class of an object; which is contrary to the abstraction principle of using the most generic type possible. For example, if one has a <code>List</code> reference in Java, one cannot invoke <code>clone()</code> on that reference because <code>List</code> specifies no public <code>clone()</code> method. Actual implementations of <code>List</code> like <code>ArrayList</code> and <code>LinkedList</code> all generally have <code>clone()</code> methods themselves, but it is inconvenient and bad abstraction to carry around the actual class type of an object. ==Alternatives== There are alternatives to <code>clone()</code>, notably the use of a [[copy constructor]] - a constructor that accepts as a parameter another instance of the same class - or a [[Factory method pattern|factory method]]. These methods are not always adequate when the concrete type of the cloned object is not known in advance. (However, <code>clone()</code> is often not adequate either for the same reason, as most abstract classes do not implement a public <code>clone()</code> method.) Also the use of serialization and deserialization is another alternative to using clone. ==<code>clone()</code> and the Singleton pattern== When writing a class using the [[Singleton pattern]], only one instance of that class can exist at a time. As a result, the class must not be allowed to make a clone. To prevent this, override the <code>clone()</code> method using the following code: <source lang="java"> public Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(); } </source> (Note: This is only necessary if a superclass implements a public <code>clone()</code> method, or to prevent a subclass from using this class's <code>clone()</code> method to obtain a copy. Since classes don't usually inherit a public <code>clone()</code> method (<code>Object</code> doesn't have a public <code>clone()</code> method), it is usually unnecessary to explicitly implement a non-functional <code>clone()</code> method. ==<code>clone()</code> and class hierarchy== {{examplefarm|section|date=August 2010}} When working with the clone() in a hierarchy of classes, there are several things that must be handled properly. 1) Every type reference that needs to call the clone function must have a clone() method in its own class or a publicly accessible clone() method in its parent classes. That means that if you want to clone a reference to an abstract base class, either the base class must have a clone() method, or one of its parents must have a publicly accessible clone() method. Example - since varY1 is of type Y, then Y must have clone(), or a parent of Y must have clone() <source lang="java"> abstract public class X implements Cloneable { public Object clone() throws CloneNotSupportedException { return super.clone(); } } abstract public class Y extends X { } public class Z extends Y { } public class 