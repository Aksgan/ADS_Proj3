that have data stream [[semantics]] (e.g. a <code>FileStream</code> component used to read or write files). It has the expected <code>Read</code> and <code>Write</code> methods to perform stream reads and writes. Another standard interface is <code>IOleObject</code>, which is exposed by components that expect to be linked or embedded into a container. <code>IOleObject</code> contains methods that allow callers to determine the size of the component's bounding rectangle, whether the component supports operations like 'Open', 'Save' and so on. ====Classes==== A class is COM's language-independent way of defining a class in the object-oriented sense. A class can be a group of similar objects or a class is simply a representation of a type of object; it should be thought of as a blueprint that describes the object. A coclass supplies '''concrete''' implementation(s) of one or more interfaces. In COM, such concrete implementations can be written in any programming language that supports COM component development, e.g. [[CodeGear Delphi|Delphi]], C++, Visual Basic, etc. One of COM's major contributions to the world of Windows development is the awareness of the concept of '''separation of interface from implementation'''. An extension of this fundamental concept is the notion of '''one interface, multiple implementations'''. This means that at runtime, an application can choose to instantiate an interface from one of many different concrete implementations. ===Interface Definition Language and type libraries=== Type libraries contain metadata that represent COM types. However, these types must first be described using [[Microsoft Interface Definition Language]]. This is the common practice in the development of a COM component, i.e. to start with the definition of types using''' IDL.''' An IDL file is what COM provides that allows developers to define object-oriented classes, interfaces, structures, enumerations and other user-defined types in a language independent manner. COM IDL is similar in appearance to C/C++ declarations with the addition of keywords such as "interface" and "library" for defining interfaces and collections of classes, respectively. IDL also requires the use of bracketed attributes before declarations to provide additional information, such as the GUIDs of interfaces and the relationships between pointer parameters and length fields. The IDL file is compiled by the MIDL compiler into a pair of forms for consumption from various languages. For C/C++, the MIDL compiler generates a compiler-independent header file containing struct definitions to match the [[virtual method table|vtbl]]s of the declared interfaces and a C file containing declarations of the interface [[Globally Unique Identifier|GUIDs]]. C++ source code for a proxy module can also be generated by the MIDL compiler. This proxy contains method stubs for converting COM calls into [[Remote Procedure Call]]s, thus enabling DCOM. An IDL file may also be compiled by the [[MIDL]] compiler into a type library (.TLB file). The binary metadata contained within the type library is meant to be processed by language compilers and runtime environments (e.g. VB, Delphi, the .NET CLR etc.). The end result of such TLB processing is that language-specific constructs are produced that represent the COM class defined in the .TLB (and ultimately that which was defined in the originating IDL file). ===COM as an object framework=== The fundamental principles of COM have their roots in Object-Oriented philosophies. It is a platform for the realization of Object-Oriented Development and Deployment. Because COM is a runtime framework, types have to be individually identifiable and specifiable at runtime. To achieve this, '''globally unique identifiers''' ('''GUIDs''') are used. Each COM type is designated its own GUID for identification at runtime (versus compile time). In order for information on COM types to be accessible at both compile time and runtime, COM uses type libraries. It is through the effective use of type libraries that COM achieves its capabilities as a dynamic framework for the interaction of objects. Consider the following example coclass definition in an IDL : coclass MyObject { [default] interface IMyObject; [default, source] dispinterface _IMyObjectEvents; }; The above code fragment declares a COM class named MyObject which must implement an interface named IMyObject and which supports (not implements) the event interface _IMyObjectEvents. Ignoring the event interface bit, this is conceptually equivalent to defining a C++ class like this: class CSomeObject : public ISomeInterface { ... ... ... }; where ISomeInterface is a C++ [[pure virtual class]]. Referring once again to the MyObject COM class: once a coclass definition for it has been formalized in an IDL, and a Type Library compiled from it, the onus is on the individual language compiler to read and appropriately interpret this Type Library and then produce whatever code (in the specific compiler's language) necessary for a developer to implement and ultimately produce the binary executable code which can be deemed by COM to be of coclass MyObject. Once an implementation of a COM coclass is built and is available in the system, next comes the question of how to instantiate it. In languages like C++, we can use the CoCreateInstance() API in which we specify the CLSID (CLSID_MyObject) of the coclass as well as the interface (specified by the IID IID_IMyObject) from that coclass that we want to use to interact with that coclass. Calling CoCreateInstance() like this: CoCreateInstance(CLSID_MyObject, NULL, CLSCTX_INPROC_SERVER, IID_IMyObject, (void**)&m_pIMyObject); is conceptually equivalent to the following C++ code: ISomeInterface* pISomeInterface = new CSomeObject(); In the first case, the COM sub-system is used to obtain a pointer to an object that implements the IMyObject interface and coclass CLSID_MyObject's particular implementation of this interface is required. In the second case, an instance of a C++ class CSomeObject that implements the interface ISomeInterface is created. A coclass, then, is an object-oriented class in the COM world. The main feature of the coclass is that it is (1) binary in nature and consequently (2) programming language-independent. ===Registry=== {{Main|Windows Registry}} In Windows, COM classes, interfaces and type libraries are listed by GUIDs in the [[Windows Registry|registry]], under HKEY_CLASSES_ROOT\CLSID for classes and HKEY_CLASSES_ROOT\Interface for interfaces. The COM libraries use the registry to locate either the correct local libraries for each COM object or the network location for a remote service. Under the key HKCR\clsid, the following 