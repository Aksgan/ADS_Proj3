expressive internal [[Software architecture|architecture]] or [[object model]] to improve [[extensibility]]. {{cquote|''By continuously improving the design of code, we make it easier and easier to work with. This is in sharp contrast to what typically happens: little refactoring and a great deal of attention paid to expediently adding new features. If you get into the hygienic habit of refactoring continuously, you'll find that it is easier to extend and maintain code.''|20px|20px|- Joshua Kerievsky, ''Refactoring to Patterns'' <ref name=kerievsky>{{cite book | last = Kerievsky | first = Joshua | title = Refactoring to Patterns | publisher = Addison Wesley | year = 2004 }}</ref>}} ==Overview== Refactoring is usually motivated by noticing a [[code smell]].<ref name=fowler>{{cite book | last = Fowler| first = Martin |title = Refactoring: Improving the design of existing code | publisher = Addison Wesley | year = 1999 }}</ref> For example the method at hand may be very long, or it may be a near duplicate of another nearby method. Once recognized, such problems can be addressed by ''refactoring'' the [[source code]], or transforming it into a new form that behaves the same as before but that no longer "smells". For a long routine, extract one or more smaller subroutines. Or for duplicate routines, remove the duplication and utilize one shared function in their place. Failure to perform refactoring can result in accumulating [[technical debt]]. There are two general categories of benefits to the activity of refactoring. # Maintainability. It is easier to fix bugs because the source code is easy to read and the intent of its author is easy to grasp.<ref name=martin>{{cite book | last = Martin | first = Robert |title = Clean Code | publisher = Prentice Hall | year = 2009}}</ref> This might be achieved by reducing large monolithic routines into a set of individually concise, well-named, single-purpose methods. It might be achieved by moving a method to a more appropriate class, or by removing misleading comments. # Extensibility. It is easier to extend the capabilities of the application if it uses recognizable [[design patterns]], and it provides some flexibility where none before may have existed.<ref name=kerievsky/> Before refactoring a section of code, a solid set of automatic [[unit testing|unit tests]] is needed. The tests should demonstrate in a few seconds that the behavior of the module is correct. The process is then an iterative cycle of making a small [[program transformation]], testing it to ensure correctness, and making another small transformation. If at any point a test fails, you undo your last small change and try again in a different way. Through many small steps the program moves from where it was to where you want it to be. Proponents of [[extreme programming]] and other [[agile software development|agile methodologies]] describe this activity as an integral part of the [[Software development process|software development cycle]]. ==List of refactoring techniques== Here are some examples of code refactorings. A longer list can be found in Fowler's Refactoring book<ref name=fowler/> and on Fowler's Refactoring Website.<ref>[http://www.refactoring.com/catalog/index.html Refactoring techniques in Fowler's refactoring Website]</ref> * Techniques that allow for more [[Abstraction (computer science)|abstraction]] ** [[Encapsulate Field]] – force code to access the field with getter and setter methods ** [[Generalize Type]] – create more general types to allow for more code sharing ** Replace type-checking code with State/Strategy<ref>[http://www.refactoring.com/catalog/replaceTypeCodeWithStateStrategy.html Replace type-checking code with State/Strategy]</ref> ** Replace conditional with polymorphism<ref>[http://www.refactoring.com/catalog/replaceConditionalWithPolymorphism.html Replace conditional with polymorphism]</ref> * Techniques for breaking code apart into more logical pieces ** Extract Method, to turn part of a larger [[method (computer science)|method]] into a new method. By breaking down code in smaller pieces, it is more easily understandable. This is also applicable to [[Function (programming)|function]]s. ** [[Extract Class]] moves part of the code from an existing class into a new class. * Techniques for improving names and location of code ** Move Method or Move Field – move to a more appropriate [[Class (computer science)|Class]] or source file ** [[Rename Method]] or Rename Field – changing the name into a new one that better reveals its purpose ** [[Pull Up refactoring|Pull Up]] – in [[Object-oriented programming|OOP]], move to a [[Superclass (computer science)|superclass]] ** [[Push Down]] – in [[Object-oriented programming|OOP]], move to a [[Subclass (computer science)|subclass]] ==Hardware refactoring== While the term ''refactoring'' originally referred exclusively to refactoring of software code, in recent years code written in [[hardware description language]]s (HDLs) has also been refactored. The term ''hardware refactoring'' is used as a shorthand term for refactoring of code in hardware description languages. Since HDLs are not considered to be [[programming language]]s by most hardware engineers,<ref>[[Hardware description languages#HDL and programming languages]]</ref> hardware refactoring is to be considered a separate field from traditional code refactoring. Automated refactoring of analog hardware descriptions (in [[VHDL-AMS]]) has been proposed by Zeng and Huss.<ref>Kaiping Zeng, Sorin A. Huss, "Architecture refinements by code refactoring of behavioral VHDL-AMS models". ISCAS 2006</ref> In their approach, refactoring preserves the simulated behavior of a hardware design. The non-functional measurement that improves is that refactored code can be processed by standard synthesis tools, while the original code cannot. Refactoring of digital HDLs, albeit manual refactoring, has also been investigated by [[Synopsys]] [[fellow]] Mike Keating.<ref>M. Keating :"Complexity, Abstraction, and the Challenges of Designing Complex Systems", in DAC'08 tutorial [http://www.dac.com/events/eventdetails.aspx?id=77-130]"Bridging a Verification Gap: C++ to RTL for Practical Design"</ref><ref>M. Keating, P. Bricaud: ''Reuse Methodology Manual for System-on-a-Chip Designs'', Kluwer Academic Publishers, 1999.</ref> His target is to make complex systems easier to understand, which increases the designers' productivity. In the summer of 2008, there was an intense discussion about refactoring of [[VHDL]] code on the news://comp.lang.vhdl [[newsgroup]].<ref>http://newsgroups.derkeiler.com/Archive/Comp/comp.lang.vhdl/2008-06/msg00173.html</ref> The discussion revolved around a specific manual refactoring performed by one engineer, and the question to whether or not automated tools for such refactoring exist. As of late 2009, [[Sigasi]] is offering automated tool support for VHDL refactoring.<ref>[http://www.eetimes.com/news/latest/showArticle.jhtml?articleID=222001855 www.eetimes.com/news/latest/showArticle.jhtml?articleID=222001855]</ref> ==History== In the past refactoring was avoided in development processes. One example of this is that [[Concurrent_Versions_System#Criticism|CVS]] (created in 1984) does not version the moving or renaming of files and directories. Although refactoring code has been done informally for 