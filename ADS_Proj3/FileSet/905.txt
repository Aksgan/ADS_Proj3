Account -> STM () credit amount account = do current <- readTVar account writeTVar account (current + amount) debit :: Integer -> Account -> STM () debit amount account = do current <- readTVar account writeTVar account (current - amount) transfer :: Integer -> Account -> Account -> STM () transfer amount from to = do debit amount from credit amount to </source> The return types of <code>STM ()</code> may be taken to indicate that we are composing scripts for transactions. When the time comes to actually execute such a transaction, a function <code>atomically :: STM a -> IO a</code> is used. The above implementation will make sure that no other transactions interfere with the variables it is using (from and to) while it is executing, allowing the developer to be sure that race conditions like that above are not encountered. More improvements can be made to make sure that some other "[[Business Logic]]" is maintained in the system, ie. that the transaction should not try to take money from an account until there is enough money in it: <source lang="haskell"> transfer :: Integer -> Account -> Account -> STM () transfer amount from to = do fromVal <- readTVar from if (fromVal - amount) >= 0 then do debit amount from credit amount to else retry </source> Here the retry function has been used, which will roll back a transaction, and try it again. Retrying in STM is smart in that it won't try and run the transaction again until one of the variables it references during the transaction has been modified by some other transactional code. This makes the STM monad quite efficient. An example program using the transfer function might look like this: <source lang="haskell"> module Main where import Control.Concurrent.STM type Account = TVar Integer main = do bob <- newAccount 10000 jill <- newAccount 4000 atomically $ transfer 2000 bob jill bobBalance <- atomically $ readTVar bob jillBalance <- atomically $ readTVar jill putStrLn ("Bob's balance: " ++ show bobBalance ++ ", Jill's balance: " ++ show jillBalance) newAccount :: Integer -> IO Account newAccount amount = newTVarIO amount transfer :: Integer -> Account -> Account -> STM () transfer amount from to = do fromVal <- readTVar from if (fromVal - amount) >= 0 then do debit amount from credit amount to else retry credit :: Integer -> Account -> STM () credit amount account = do current <- readTVar account writeTVar account (current + amount) debit :: Integer -> Account -> STM () debit amount account = do current <- readTVar account writeTVar account (current - amount) </source> Which should print out "Bill's balance: 8000, Jill's balance: 6000". Here the atomically function has been used to run STM actions in the IO monad. == References == <references/> [[Category:Haskell programming language family]] {{compu-lang-stub}}</text> </page> <page> <id>7674</id> <title>Concurrent ML</title> <text>'''Concurrent ML''' (CML) is a [[Concurrency (computer science)|concurrent]] extension of the [[Standard ML]] programming language. ==Sample Code== Here is sample code to print "[[hello, world]]" to the console. It spawns a [[thread (computer science)|thread]] which creates a channel for [[string (computer science)|strings]]. This thread then spawns another thread which prints the first string that is received on the channel. The former thread then sends the "hello, world\n" string on the channel. It uses [[Standard ML of New Jersey|SML/NJ]] and CML (note that the heap name will be different on non linux-x86 platforms; you may need to change the line with "cml_test.x86-linux" to something different): '''cml_test.cm''': '''Library''' '''structure''' Hello '''is''' $cml/basis.cm $cml/cml.cm cml_test.sml '''cml_test.sml''': '''structure''' Hello = '''struct''' '''open''' CML '''fun''' hello () = '''let''' '''val''' c : string chan = channel () '''in''' spawn ('''fn''' () => TextIO.print (recv c)); send (c, "hello, world\n"); exit () '''end''' '''fun''' main (name, argv) = RunCML.doit (fn () => ignore (spawn hello), NONE) '''end''' '''Running''': $ '''ml-build cml_test.cm Hello.main''' Standard ML of New Jersey v110.60 [built: Mon Nov 27 14:19:21 2006] [scanning cml_test.cm] [library $cml/basis.cm is stable] [library $cml/cml.cm is stable] [parsing (cml_test.cm):cml_test.sml] [creating directory .cm/SKEL] [library $cml/cml-internal.cm is stable] [library $cml/core-cml.cm is stable] [library $SMLNJ-BASIS/basis.cm is stable] [compiling (cml_test.cm):cml_test.sml] [creating directory .cm/GUID] [creating directory .cm/x86-unix] [code: 2170, data: 42, env: 2561 bytes] [scanning 18518-export.cm] [scanning (18518-export.cm):cml_test.cm] [parsing (18518-export.cm):18518-export.sml] [compiling (18518-export.cm):18518-export.sml] [code: 309, data: 37, env: 42 bytes] $ '''heap2exec cml_test.x86-linux cml_test''' $ '''./cml_test''' hello, world ==External links== *[http://cml.cs.uchicago.edu/ The language homepage] [[Category:ML programming language family]] [[Category:Programming languages created in the 1990s]] [[fr:Concurrent ML]]</text> </page> <page> <id>7679</id> <title>Concurrent constraint logic programming</title> <text>'''Concurrent constraint logic programming''' is a version of [[constraint logic programming]] aimed primarily at programming [[concurrent process]]es rather than (or in addition to) solving [[constraint satisfaction problem]]s. Goals in constraint logic programming are evaluated concurrently; a concurrent process is therefore programmed as the evaluation of a goal by the [[Interpreter (computing)|interpreter]]. Syntactically, concurrent constraints logic programs are similar to non-concurrent programs, the only exception being that clauses include [[Guard (computing)|guards]], which are constraints that may block the applicability of the clause under some conditions. Semantically, concurrent constraint logic programming differs from its non-concurrent versions because a goal evaluation is intended to realize a concurrent process rather than finding a solution to a problem. Most notably, this difference affects how the interpreter behaves when more than one clause is applicable: non-concurrent constraint logic programming [[Recursion|recursively]] tries all clauses; concurrent constraint logic programming chooses only one. This is the most evident effect of an intended ''directionality'' of the interpreter, which never revise a choice it has previously taken. Other effects of this are the semantical possibility of having a goal that cannot be proved while the whole evaluation does not fail, and a particular way for equating a goal and a clause head. [[Constraint handling rules]] can be seen as a form of concurrent constraint logic programming, but are used for programming a constraint simplifier or solver rather than concurrent processes. ==Description== In constraint logic programming, the goals in the current goal are evaluated sequentially, usually proceeding in a [[LIFO (computing)|LIFO]] order in which newer goals are evaluated first. The concurrent 