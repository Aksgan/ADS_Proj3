on two waiting lists, the first one is called '''foreground''' because this is the one in which all processes initially enter, and the second one is called '''background''' because all processes, after using all of their [[Run time (computing)|execution time]] in foreground, are moved to background. When a process becomes ready it begins its execution in foreground immediately, forcing the processor to give up execution of current process in the background and execute newly created process for a predefined period. This period is usually 2 or more [[Preemption (computing)#Time slice|quanta]]. If the process is not finished after its execution in the foreground it is moved to background waiting list where it will be executed only when the foreground list is empty. After being moved to background, process is then run longer than before, usually 4 quanta. The time of execution is increased because the process obviously needs more than 2 quanta to finish (this is the reason it was moved to background). This gives the process the opportunity to finish within this newly designated time. If the process does not finish after this, it is then preempted and moved to the end of the background list. The advantage of the foreground-background algorithm is that it gives process the opportunity to execute immediately after its creation, but scheduling in the background list is pure [[round-robin scheduling]]. {{DEFAULTSORT:Foreground-Background}} [[Category:Scheduling algorithms]]</text> </page> <page> <id>13942</id> <title>Foreign function interface</title> <text>A '''foreign function interface''' (or FFI) is a mechanism by which a program written in one [[programming language]] can call routines or make use of services written in another. The term comes from the specification for [[Common Lisp]], which explicitly refers to the language features for inter-language calls as such; the term is also used officially by the [[Haskell (programming language)|Haskell programming language]]. Other languages use other terminology (the [[Ada programming language]] talks about "language bindings", while [[Java (programming language)|Java]] refers to its FFI as the [[Java Native Interface]], or JNI). Foreign function interface has become generic terminology for mechanisms which provide such services. Despite the name, FFIs are not necessarily restricted to [[function call]]s; many FFIs permit [[method call]]s on objects; and some even permit migration of non-trivial datatypes and/or objects across the language boundary. The term foreign function interface is generally not used to describe multi-lingual runtimes such as the Microsoft [[Common Language Runtime]], where a common "substrate" is provided which enables any CLR-compliant language to use services defined in any other. (However, in this case the CLR does include an FFI, [[P/Invoke]], to call outside the runtime.) In addition, many distributed computing architectures such as the [[Java remote method invocation]] (RMI), RPC, [[CORBA]], [[SOAP]] and [[D-Bus]] permit different services to be written in different languages; such architectures are generally not considered FFIs. In most cases, a FFI is defined by a "higher-level" language, so that it may employ services defined and implemented in a lower level language, typically a systems language like [[C (programming language)|C]] or [[C++]]. This is typically done to either access OS services in the language in which the OS' API is defined, or for performance considerations. Many FFIs also provide the means for the called language to invoke services in the host language as well. ==Operation of an FFI== The primary function of a FFI is to mate the semantics and [[calling convention]]s of one programming language (the ''host'' language, or the language which defines the FFI), with the semantics and conventions of another (the ''guest'' language). This process must also take into consideration the [[runtime environment]]s and/or [[application binary interface]]s of both. This can be done in several ways: * Requiring that guest-language functions which are to be host-language callable be specified or implemented in a particular way; often using a compatibility library of some sort. * Use of a tool to automatically "wrap" guest-language functions with appropriate [[glue code]], which performs any necessary translation. * Use of [[Wrapper library|wrapper libraries]] * Restricting the set of host language capabilities which can be used cross-language. For example, C++ functions called from C may not (in general) include reference parameters or throw exceptions. FFIs may be complicated by the following considerations: * If one language supports [[Garbage collection (computer science)|garbage collection]] (GC) and the other does not; care must be taken that the non-GC language code doesn't do something to cause the GC to fail. In JNI, for example, C code which "holds on to" object references passed from Java must "register" this fact with the Java runtime; otherwise the referred-to objects may be garbage-collected if no more valid references to the object(s) exist within the Java environment. (The C code must likewise release such references manually when the corresponding object is no longer needed). * Complicated or non-trivial objects or datatype may be difficult to map from one environment to another. * It may not be possible for both languages to maintain references to the same instance of a mutable object, due to the mapping issue above. * One or both languages may be running on a [[virtual machine]] (including different VMs). * Cross language [[inheritance (computer science)|inheritance]] or other forms of type or object composition may be especially difficult. == Examples == Examples of FFIs include: * [[Ada (programming language)|Ada]] language bindings, allowing not only to call foreign functions but also to export its functions and methods to be called from non-Ada code.[http://www.adaic.org/standards/05aarm/html/AA-B.html] * [[C++]] has a trivial FFI with [[C programming language|C]], as the languages share a significant common subset. The primary effect of the <tt>[[extern "C"]]</tt> declaration in C++ is to disable [[name mangling]]. * [[Java Native Interface|JNI]], which provides an interface between [[Java (programming language)|Java]] and C/C++, the preferred systems language on most systems where Java is deployed. [[Java Native Access|JNA]] provide an interface with native libraries without having to write [[Glue code]]. * [[Compiled Native Interface|CNI]], alternative to JNI used in the GNU compiler environment. * The {{abbr|FFIs}} of [[Common Lisp]] and [[Haskell (programming language)|Haskell]] * The major [[dynamic language]]s, such as [[Python (programming 