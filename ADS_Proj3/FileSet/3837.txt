in addition to commonly installing into Ring 0 (kernel-mode), where they have complete access to a system. These include [[polymorphic code|polymorphism]], stealth techniques, regeneration, and disabling anti-malware software.<ref name="trlokom">{{Cite journal|url=http://www.trlokom.com/pdf/TrlokomRootkitDefenseWhitePaper.pdf|title=Defeating Rootkits and Keyloggers|date=2006-07-05|accessdate=2010-08-17|author=Trlokom| publisher=Trlokom}}</ref> ==Detection== The fundamental problem with rootkit detection is that if the operating system has been subverted, particularly by a kernel-level rootkit, it cannot be trusted to find unauthorized modifications to itself or its components.<ref name="MIT">{{cite book|chapterurl=http://www.mhprofessional.com/downloads/products/0071591184/0071591184_chap10.pdf|title=Hacking Exposed Malware & Rootkits: Malware & rootkits security secrets & solutions|chapter=Chapter 10: Rootkit Detection|publisher=McGraw Hill Professional|date=2009-09-03|accessdate=2010-08-14|isbn=9780071591188|last=Davis|first=Michael A.|last2=Bodmer|first2=Sean|last3=LeMasters|first3=Aaron|location=New York|format=PDF}}</ref> Actions such as requesting a list of running processes, or a list of files in a directory, cannot be trusted to behave as expected. In other words, rootkit detectors that work while running on infected systems are only effective against rootkits that have some defect in their camouflage, or that run with lower user-mode privileges than the detection software in the kernel.<ref name="UAMT">{{cite web|url=http://download.microsoft.com/download/a/b/e/abefdf1c-96bd-40d6-a138-e320b6b25bd3/understandingantimalwaretechnologies.pdf|title=Understanding Anti-Malware Technologies|2007-02-21|accessdate=2010-08-17|publisher=[[Microsoft]]|format=PDF}}</ref> As with [[computer virus]]es, the detection and elimination of rootkits is an ongoing struggle between both sides of this conflict.<ref name="MIT"/> Detection can take a number of different approaches, including signatures (e.g. antivirus software), integrity checking (e.g. [[digital signature]]s), difference-based detection (comparison of expected vs. actual results), and behavioral detection (e.g. monitoring CPU usage or network traffic). Unix rootkit detection offerings include Zeppoo, [[chkrootkit]], [[rkhunter]] and [[OSSEC]]. For Windows, free detection tools include Microsoft Sysinternals Rootkit Revealer,<ref>{{cite web|url=http://technet.microsoft.com/en-us/sysinternals/bb897445.aspx|publisher=[[Microsoft]]|title=RootkitRevealer v1.71|first=Bryce |last=Cogswell |first2=Mark |last2=Russinovich|date=2006-11-01|accessdate=2010-11-13}}</ref> [[Avast!|Avast! Antivirus]], Sophos Anti-Rootkit, [[F-Secure]] Blacklight, and Radix.<ref>{{cite web|url=http://www.usec.at/rootkit.html|title=RADIX Package|accessdate=2010-11-13|publisher=usec.at}}</ref> Any rootkit detectors that prove effective ultimately contribute to their own ineffectiveness, as malware authors adapt and test their code to escape detection by well-used tools.<ref group="Notes">The process name of Sysinternals Rootkit Revealer was targeted by malware; in an attempt to counter this countermeasure, the tool now uses a randomly-generated process name.</ref> ===Alternative trusted medium=== The best and most reliable method for operating-system-level rootkit detection is to shut down the computer suspected of infection, and then to check its [[computer data storage|storage]] by [[booting]] from an alternative trusted medium (e.g. a rescue [[CD-ROM]] or [[USB flash drive]]).<ref>{{Cite journal|url=http://www.symantec.com/avcenter/reference/testing_methodology_for_rootkit_removal.pdf|title=A Testing Methodology for Rootkit Removal Effectiveness|first=Josh|last= Harriman|publisher=Symantec Security Response|location=Dublin, Ireland|date=2007-10-19|accessdate=2010-08-17}}</ref> The technique is effective because a rootkit cannot actively hide its presence if it is not running. ===Behavioral-based=== The behavioral-based approach to detecting rootkits attempts to infer the presence of a rootkit by looking for rootkit-like behavior. For example, by profiling a system, differences in the timing and frequency of API calls or in overall CPU utilization can be attributed to a rootkit. The method is complex and is hampered by a high incidence of [[Type I and type II errors|false positives]]. Defective rootkits can sometimes introduce very obvious changes to a system: the [[Alureon]] rootkit crashed Windows systems after a security update exposed a design flaw in its code.<ref>{{cite web|url=http://www.symantec.com/connect/blogs/tidserv-and-ms10-015|title=Tidserv and MS10-015|publisher=[[Symantec]]|date=2010-02-12|accessdate=2010-08-19|first=Mircea |last=Cuibotariu}}</ref><ref>{{cite web|url=http://blogs.technet.com/b/msrc/archive/2010/02/11/restart-issues-after-installing-ms10-015.aspx|title=Restart Issues After Installing MS10-015|date=2010-02-11|accessdate=2010-10-05|publisher=[[Microsoft]]}}</ref> Logs from a [[packet analyzer]], [[Firewall (computing)|firewall]] or [[intrusion prevention system]] may present evidence of rootkit behaviour in a networked environment.<ref name="anson-forensics"/> ===Signature-based=== Antivirus products rarely catch all viruses in public tests, even though security software vendors incorporate rootkit detection into their products. Should a rootkit attempt to hide during an antivirus scan, a stealth detector may notice; if the rootkit attempts to temporarily unload itself from the system, signature detection (or "fingerprinting") can still find it. This combined approach forces attackers to implement counterattack mechanisms, or "retro" routines, that attempt to terminate antivirus programs. Signature-based detection methods can be effective against well-published rootkits, but less so against specially-crafted, custom-root rootkits.<ref name="MIT"/> ===Difference-based=== Another method that can detect rootkits compares "trusted" raw data with "tainted" content returned by an API. For example, binaries present on disk can be compared with their copies within operating memory (as the in-memory image should be identical to the on-disk image), or the results returned from [[file system]] or [[Windows Registry]] APIs can be checked against raw structures on the underlying physical disks<ref name="MIT"/><ref>{{cite web|url=http://research.microsoft.com/en-us/um/redmond/projects/strider/rootkit/|publisher=Microsoft Research|title=Strider GhostBuster Rootkit Detection |date-2010-01-28|accessdate=2010-08-14}}</ref>—however, in the case of the former, some valid differences can be introduced by operating system mechanisms like memory relocation or [[Shim (computing)|shimming]]. Difference-based detection was used by Russinovich's ''RootkitRevealer'' tool to find the Sony DRM rootkit.<ref name="McAfee1"/> ===Integrity checking=== [[File:Rkhunter on Mac OS X.png|thumb|right|The [[Rkhunter]] utility uses [[sha-1]] hashes to verify the integrity of system files]] A [[cryptographic hash function]] can be used to compute a "fingerprint", or [[digital signature]], that can help detect subsequent unauthorized changes to on-disk code libraries.<ref>{{ cite web|url=http://msdn.microsoft.com/en-us/library/ms537364(VS.85).aspx|title=Signing and Checking Code with Authenticode|publisher=[[Microsoft]]|accessdate=2008-09-15}}</ref> However, unsophisticated schemes check only whether the code has been modified since release by the "publisher"; subversion prior to that time is not detectable. The fingerprint must be re-established each time changes are made to the system: for example, after installing security updates or a [[service pack]]. The hash function creates a ''message digest'', a relatively short code calculated from each bit in the file using an algorithm that creates large changes in the message digest with even small changes to the original file. By recalculating and comparing the message digest of the installed files at regular intervals against a trusted list of fingerprints, changes in the system can be detected and monitored—as long as the original baseline fingerprint was created before the malware was added. More-sophisticated rootkits are able to subvert the verification process by presenting an unmodified copy of the file for inspection, or by making modifications only in memory, rather than on disk. The technique may therefore be effective only against unsophisticated rootkits—for example, those that replace Unix binaries like "[[ls]]" to mask the presence of a file. Similarly, detection in [[firmware]] can be achieved by computing a cryptographic hash of the firmware and comparing it to a [[whitelist]] of expected values, or by extending the hash value into [[Trusted Platform Module]] (TPM) configuration registers, which are later compared to a whitelist of expected values.<ref>{{ cite web |url=http://www.trustedcomputinggroup.org/files/resource_files/C2426F48-1D09-3519-AD02D13C71B888A6/Whitepaper_Rootkit_Strom_v3.pdf |title=Stopping Rootkits at the Network Edge|year=2007|month=January|publisher=[[Trusted Computing Group]]|accessdate=2008-07-11|location=Beaverton, Oregon|format=PDF}}</ref> The code that performs hash, compare, or extend operations must also be protected—in this 