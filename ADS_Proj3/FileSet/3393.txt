being ''Programming Mistake Detector''. Typically, PMD errors are not true errors, but rather inefficient code, i.e. the application could still function properly even if they were not corrected. ==Rulesets== PMD includes a set of built-in rules and supports the ability to write custom rules. The custom rules can be written in two ways:<br> 1. Using [[XPath]]<br> 2. Using Java classes ==Copy/Paste Detector (CPD)== The '''Copy/Paste Detector (CPD)''' is an add-on to PMD that uses the [[Rabin–Karp string search algorithm]] to find [[Duplicate code|duplicated code]]. CPD works with [[Java (programming language)|Java]], [[JSP]], [[C (programming language)|C]], [[C++]], [[Fortran]] and [[PHP]] code. ==Plugins== PMD has [[plugins]] for [[JDeveloper]], [[Eclipse (computing)|Eclipse]], [[JEdit]], [[JBuilder]], Omnicore's CodeGuide, [[NetBeans]]/[[Sun Studio (software)|Sun Studio]], [[IntelliJ IDEA]], [[TextPad]], [[Maven]], [[Ant (software)|Ant]], Gel, [[JCreator]], [[Hudson (software)|Hudson]], [[Sonar (software quality)|Sonar]] and [[Emacs]]. ==See also== * [[List of tools for static code analysis]] ==External links== * [http://pmd.sf.net/ Home page] at [[SourceForge|SourceForge.net]]. * [http://pmdapplied.com/ Book: "PMD Applied"]. Written by the lead developer, Tom Copeland (http://tomcopeland.blogs.com/). * [http://sonar.codehaus.org/ Sonar (Quality platform)] code quality platform uses PMD and CPD * [http://es.redsauce.net/?pageID=388 Redsauce PMD Parser] Small utility that parses PMD output in HTML syntax <br/> {{compu-soft-stub}} [[Category:Static code analysis]] [[Category:Java development tools]] [[de:PMD (Software)]] [[fr:PMD (logiciel)]]</text> </page> <page> <id>28138</id> <title>POPLmark challenge</title> <text>{{multiple issues |notability=January 2011 |refimprove=January 2011 }} {{no footnotes|date=January 2011}} __NOTOC__ In [[type theory]] and [[programming language]]s, the '''POPLmark challenge''' is a set of [[Benchmarking|benchmarks]] designed to evaluate the state of [[automated reasoning|mechanization]] in the [[metatheory]] of programming languages, and to stimulate discussion and collaboration among a diverse cross section of the [[formal methods]] community. The challenge was initially proposed by the members of the ''PL club'' at the [[University of Pennsylvania]], in association with collaborators around the world. The ''Workshop on Mechanized Metatheory'' is the main meeting of researchers participating in the challenge. The design of the POPLmark benchmark is guided by features common to reasoning about programming languages. The challenge problems do not require the formalisation of large programming languages, but they do require sophistication in reasoning about: ; [[Name binding|Binding]] : Most programming languages have some form of binding, ranging in complexity from the simple binders of [[simply typed lambda calculus]] to complex, potentially infinite binders needed in the treatment of [[record (computer science)|record]] [[pattern matching|pattern]]s. ; [[Mathematical induction|Induction]] : Properties such as [[subject reduction]] and [[strong normalisation]] often require complex induction arguments. ; Reuse : Furthering collaboration being a key aim of the challenge, the solutions are expected to contain reusable components that would allow researchers to share language features and designs without requiring them to start from scratch every time. == The problems == {{As of|2007}}, the POPLmark challenge is composed of three parts. Part 1 concerns solely the types of [[system F-sub|System F<sub><:</sub>]] ([[System F]] with [[subtyping]]), and has problems such as: # Checking that the type system admits [[transitivity]] of subtyping. # Checking the transitivity of subtyping in the presence of [[record (computer science)|record]]s Part 2 concerns the syntax and semantics of System F<sub><:</sub>. It concerns proofs of # [[Type safety]] for the pure fragment # Type safety in the presence of [[pattern matching]] Part 3 concerns the usability of the formalisation of System F<sub><:</sub>. In particular, the challenge asks for: # Simulating and animating the [[operational semantics]] # Extracting useful algorithms from the formalisations Several solutions have been proposed for parts of the POPLmark challenge, using tools such as [[Isabelle theorem prover|Isabelle/HOL]], [[Twelf]], [[Coq]] and [[Matita_proof_assistant|Matita]]. == References == * [[Benjamin C. Pierce]], [[Peter Sewell]], Stephanie Weirich, Steve Zdancewic, ''It Is Time to Mechanize Programming Language Metatheory'', In Bertrand Meyer, Jim Woodcock (Eds.) ''Verified Software: Theories, Tools, Experiments'', [[LNCS]] 4171, Springer Berlin / Heidelberg, 2008, pp. 26-30, ISBN 978-3-540-69147-1 == See also == * [[QED manifesto]] * [[POPL]] conference == External links == * [http://alliance.seas.upenn.edu/~plclub/cgi-bin/poplmark/index.php?title=The_POPLmark_Challenge The POPLmark wiki] {{prog-lang-stub}} [[Category:Programming language topics]] [[Category:Type theory]] [[Category:Formal methods]]</text> </page> <page> <id>28145</id> <title>POST card</title> <text>{{Unreferenced|date=July 2009}} [[Image:BIOS POST card.jpg|thumb|220 px|BIOS POST card for ISA bus. Two [[seven-segment display]]s show the POST-code. Four [[Light-emitting diode|LEDs]] display presence of +/-5V and +/-12V.]] [[Image:POST card 3usd.jpg|BIOS POST card for PCI bus.|thumb|right]] [[Image:POST card 98usd.jpg|Professional BIOS POST card for PCI bus.|thumb|right]] In [[computing]], a '''POST card''' is a diagnostic tool that reports error codes produced by a [[Power-on self-test|POST]]. They are used by technicians to troubleshoot computers that refuse to boot. The cards relay POST codes generated by the system, and the system must therefore have a working CPU and BIOS, in addition to whatever I/O interface the POST card relies on. Thus, POST cards cannot be used to diagnose the cause of e.g. a dead motherboard. POST cards are desirable in situations where video is not available; either because connecting a monitor is impractical, or because the point of failure occurs before the video subsystem can be initialized. POST cards are inserted into an expansion slot, and are available in [[Industry Standard Architecture|ISA]], [[Peripheral Component Interconnect|PCI]] and other variants. The card reports a number, consisting of two [[hexadecimal]] digits, that is output to an [[I/O port]] by the [[BIOS]] while running the [[Power-on self-test|POST]]. Reference tables covering different BIOSes are needed. Some motherboards come with a built-in display to diagnose hardware problems. Most also report POST errors with audible beeps, if a PC speaker is attached. {{DEFAULTSORT:Post Card}} [[Category:Computer peripherals]] {{compu-hardware-stub}} [[cs:POST karta]] [[ru:POST Card]] [[zh:開機自我檢測卡]]</text> </page> <page> <id>28146</id> <title>POU family</title> <text>{{Expert-subject|Science|date=November 2008}} {{Pfam box |Symbol = POU_specific |Name = POU-specific |Pfam = PF00157 |InterPro = IPR000327 |SMART = SM00352 |PROSITE = PDOC00035 |PDB = {{PDB|1au7}} {{PDB|1cqt}} {{PDB|1e3o}} {{PDB|1gt0}} {{PDB|1hf0}} {{PDB|1o4x}} {{PDB|1oct}} {{PDB|1pou}} }} '''POU''' (pronounced 'pow') is a family of [[proteins]] that have well-conserved [[homeodomain]]s.<ref name="pmid11183772">{{cite journal | author = Phillips K, Luisi B | title = The virtuoso of versatility: POU proteins that flex to fit | journal = J. Mol. Biol. | volume = 302 | issue = 5 | pages = 1023–39 | year = 2000 | pmid = 11183772 | doi = 10.1006/jmbi.2000.4107 }}</ref> ==Function== POU [[protein]]s are [[eukaryotic]] [[transcription factors]] containing a bipartite [[DNA]] binding domain referred to 