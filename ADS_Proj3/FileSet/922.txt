and in the clauses used to prove the goal are accumulated into a set called [[constraint store]]. This set contains the constraints the interpreter has assumed satisfiable in order to proceed in the evaluation. As a result, if this set is detected unsatisfiable, the interpreter backtracks. Equations of terms, as used in logic programming, are considered a particular form of constraints which can be simplified using [[unification (computing)|unification]]. As a result, the constraint store can be considered an extension of the concept of [[substitution]] that is used in regular logic programming. The most common kinds of constraints used in constraint logic programming are constraints over integers/rational/real numbers and constraints over finite domains. [[Concurrent constraint logic programming]] languages have also been developed. They significantly differ from non-concurrent constraint logic programming in that they are aimed at programming [[concurrent process]]es that may not terminate. [[Constraint handling rules]] can be seen as a form of concurrent constraint logic programming, but are also sometimes used within a non-concurrent constraint logic programming language. They allow for rewriting constraints or to infer new ones based on the truth of conditions. ===Constraint satisfaction toolkits=== Constraint satisfaction toolkits are [[Software library|software libraries]] for [[imperative programming language]]s that are used to encode and solve a constraint satisfaction problem. * [[Cassowary constraint solver]] is an [[open source]] project for constraint satisfaction (accessible from C, Java, Python and other languages). * [[Comet (programming language)|Comet]], a commercial programming language and toolkit * [[Gecode]], an open source portable toolkit written in C++ developed as a production-quality and highly efficient implementation of a complete theoretical background. * [[JaCoP (solver)]] an open source [http://jacop.osolpro.com/ Java constraint solver] * [http://www.koalog.com/ Koalog] a commercial Java-based constraint solver. * [http://www.logilab.org/projects/constraint logilab-constraint] an open source constraint solver written in pure Python with constraint propagation algorithms. * [http://minion.sourceforge.net/ MINION] an open-source constraint solver written in C++, with a small language for the purpose of specifying models/problems. * [http://www.bracil.net/CSP/cacp/cacpdemo.html ZDC] is an open source program developed in the [http://www.bracil.net/CSP/cacp/ Computer-Aided Constraint Satisfaction Project] for modelling and solving constraint satisfaction problems. ===Other constraint programming languages=== Constraint toolkits are a way for embedding constraints into an [[imperative programming language]]. However, they are only used as external libraries for encoding and solving problems. An approach in which constraints are integrated into an imperative programming language is taken in the [[Kaleidoscope programming language]]. Constraints have also been embedded into [[Functional programming|functional programming languages]]. == See also == * [[Constraint satisfaction problem]] * [[Constraint (mathematics)]] * [[Candidate solution]] * [[Boolean satisfiability problem]] * [[Decision theory]] ==References== *{{cite book | last=Apt| first=Krzysztof | title=Principles of constraint programming | publisher=Cambridge University Press | year=2003 | isbn=0-521-82583-0 }} *{{cite book | last=Dechter | first=Rina | title=Constraint processing | publisher=Morgan Kaufmann | year=2003 | url=http://www.ics.uci.edu/~dechter/books/index.html | isbn=1-55860-890-7 }} *{{cite journal | last=Dincbas | first=M. | last2=Simonis | first2=H. | last3=Van Hentenryck | first3=P. | year= 1990 | title=Solving Large Combinatorial Problems in Logic Programming | journal=Journal of logic programming | volume=8 | issue=1-2 | pages=75–93 | doi=10.1016/0743-1066(90)90052-7 }} *{{cite book | first=Eugene | last=Freuder | coauthors=Alan Mackworth (ed.) | title=Constraint-based reasoning | publisher=MIT Press | year=1994 }} *{{cite book | last=Fr&uuml;hwirth | first=Thom | coauthors=Slim Abdennadher | title=Essentials of constraint programming | year=2003 | publisher=Springer | isbn=3-540-67623-6 }} *{{cite journal | last=Jaffar | first=Joxan | coauthors=Michael J. Maher | title=Constraint logic programming: a survey | journal=Journal of logic programming | volume=19/20 | pages=503–581 | year=1994 | doi=10.1016/0743-1066(94)90033-7 }} *{{cite journal | last=Laurière | first=Jean-Louis | year=1978 | title=A Language and a Program for Stating and Solving Combinatorial Problems | journal=[[Artificial Intelligence (journal)|Artificial intelligence]] | volume=10 | issue=1 | pages=29–127 | doi=10.1016/0004-3702(78)90029-2 }} *{{cite book | last=Lecoutre | first=Christophe | title=Constraint Networks: Techniques and Algorithms | publisher=ISTE/Wiley | year=2009 | url=http://www.iste.co.uk/index.php?f=a&ACTION=View&id=250 | isbn=978-1-84821-106-3 }} *{{cite book | last=Marriot | first=Kim | coauthors=Peter J. Stuckey | title=Programming with constraints: An introduction | year=1998 | publisher=MIT Press | isbn=0-262-13341-5 }} *{{cite book | last=Rossi | first=Francesca | coauthors=Peter van Beek, Toby Walsh (ed.) | title=Handbook of Constraint Programming, | publisher=Elsevier | year=2006 | url=http://www.elsevier.com/wps/find/bookdescription.cws_home/708863/description#description | isbn=978-0-444-52726-4 0-444-52726-5 }} *{{cite book | first=Edward | last=Tsang | title=Foundations of Constraint Satisfaction | publisher=Academic Press | year=1993 | url=http://www.bracil.net/edward/FCS.html | isbn=0-12-701610-4 }} *{{cite book | first=Pascal | last=Van Hentenryck | title=Constraint Satisfaction in Logic Programming | publisher=MIT Press | year=1989 | isbn=0-262-08181-4 }} ==External links== *[http://4c.ucc.ie/web/outreach/tutorial.html CSP Tutorial] {{DEFAULTSORT:Constraint Satisfaction}} [[Category:Constraint satisfaction| ]]</text> </page> <page> <id>7864</id> <title>Constraint satisfaction dual problem</title> <text>The '''dual problem''' is a reformulation of a [[constraint satisfaction problem]] expressing each constraint of the original problem as a variable. Dual problems only contain [[binary constraint]]s, and are therefore solvable by [[algorithm]]s tailored for such problems. The '''join graphs''' and '''join trees''' of a constraint satisfaction problem are [[Graph (graph theory)|graph]]s representing its dual problem or a problem obtained from the dual problem removing some redundant constraints. ==The dual problem== The dual problem of a constraint satisfaction problem contains a variable for each constraint of the original problem. Its domains and constraints are built so to enforce a sort of equivalence to the original problem. In particular, the domain of a variable of the dual problem contains one element for each tuple satisfying the corresponding original constraint. This way, a dual variable can take a value if and only if the corresponding original constraint is satisfied by the corresponding tuple. The constraints of the dual problem forbid two dual variables to take values that correspond to two incompatible tuples. Without these constraints, one dual variable may take the value corresponding to the tuple <math>x=1,y=2</math> while another dual variable takes the value corresponding to <math>y=3,z=1</math>, which assigns a different value to <math>y</math>. More generally, the constraints of the dual problem enforce the same values for all variables shared by two constraints. If two dual variables correspond to constraints sharing some variables, the dual problem contains a constraint between them, enforcing equality of all shared variables. {| cellpadding=10 style="border: thin solid gray;" |- | [[Image:Csp-dual-1.svg]] ---- | The dual variables are the constraints of the original problem. 