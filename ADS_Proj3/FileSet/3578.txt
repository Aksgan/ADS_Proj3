it doesn't need to invoke methods on the returned object. If the need arises, the calling thread is automatically blocked if the result of the method invocation is not yet available. Although a future object has structure similar to that of an active object, a future object is not active. It only has a Stub and a Proxy. ===A simple example=== The code excerpt below highlights the notion of future objects. Suppose a user calls a method <tt>foo</tt> and a method <tt>bar</tt> from an active object <tt>a</tt>; the <tt>foo</tt> method returns void and the <tt>bar</tt> method returns an object of class <tt>V</tt>: <source lang="java"> // a one way typed asynchronous communication towards the (remote) AO a // a request is sent to a a.foo (param); // a typed asynchronous communication with result. // v is first an awaited Future, to be transparently filled up after // service of the request, and reply V v = a.bar (param); ... // use of the result of an asynchronous call. // if v is still an awaited future, it triggers an automatic // wait: Wait-by-necessity v.gee (param); </source> When <tt>foo</tt> is called on an active object <tt>a</tt>, it returns immediately (as the current thread cannot execute methods in the other subsystem). Similarly, when <tt>bar</tt> is called on <tt>a</tt>, it returns immediately but the result <tt>v</tt> can't be computed yet. A future object, which is a placeholder for the result of the method invocation, is returned. From the point of view of the caller subsystem, there is no difference between the future object and the object that would have been returned if the same call had been issued onto a passive object. After both methods have returned, the calling thread continues executing its code as if the call had been effectively performed. The role of the future mechanism is to block the caller thread when the <tt>gee</tt> method is called on <tt>v</tt> and the result has not yet been set : this inter-object synchronization policy is known as ''wait-by-necessity''. ==References== {{Reflist|2}} ==Further reading== {{refbegin|2}} * {{cite journal | url = http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4536336 | title = Scheduling ProActive activities with an XPDL-based workflow engine | last = Ranaldo | first = N. | last2 = Tretola | first2 = G. | last3 = Zimeo | first3 = E. | pages = 1–8 | journal = Parallel and Distributed Processing | issn = 1530-2075 | location = Miami | publisher = [[IEEE]] | doi = 10.1109/IPDPS.2008.4536336 | date = April 14–18, 2008 | isbn = 978-1-4244-1693-6 }} * {{cite book | url = http://www.springerlink.com/content/k0675q5167w8m787 | chapter = Early Experience of Remote and Hot Service Deployment with Trustworthiness in CROWN Grid | last = Sun | first = Hailong | last2 = Zhu | first2 = Yanmin | last3 = Hu | first3 = Chunming | last4 = Huai | first4 = Jinpeng | last5 = Liu | first5 = Yunhao | last6 = Li | first6 = Jianxin | title = Advanced Parallel Processing Technologies | series = Lecture Notes in Computer Science | year = 2005 | publisher = Springer | location = Berlin | doi = 10.1007/11573937_33 | pages = 301–312 | volume = 3756 | editor-last = Cao | editor-first = Jiannong | editor2-last = Nejdl | editor2-first = Wolfgang | editor3-last = Xu | editor3-first = Ming }} * {{cite book | url = http://www.springerlink.com/content/kjctv8gd80ym3x06 | chapter = Asynchronous, Hierarchical, and Scalable Deployment of Component-Based Applications | last = Quéma | first = Vivien | last2 = Balter | first2 = Roland | last3 = Bellissard | first3 = Luc | last4 = Féliot | first4 = David | last5 = Freyssinet | first5 = André | last6 = Lacourte | first6 = Serge | title = Component Deployment | series = Lecture Notes in Computer Science | year = 2004 | publisher = Springer | location = Berlin | doi = 10.1007/978-3-540-24848-4_4 | pages = 50–64 | volume = 3083 | editor-last = Emmerich | editor-first = Wolfgang | editor2-last = Wolf | editor2-first = Alexander L. }} {{refend}} ==External links== * [http://proactive.inria.fr/ The ProActive website] * [http://proactive.inria.fr/index.php?page=ic2d The ProActive IC2D eclipse plugin] * [http://www.coregrid.net/mambo/images/stories/Deliverables/d.pm.04.pdf The Grid Component Model specification] *[http://www.activeeon.com ActiveEon] {{Parallel Computing}} {{DEFAULTSORT:Proactive}} [[Category:Grid computing products]] [[Category:Middleware]] [[Category:Job scheduling]] [[Category:Parallel computing]] [[Category:Cross-platform software]] [[Category:Cloud computing]] [[Category:Cluster computing]]</text> </page> <page> <id>30046</id> <title>Probabilistic method</title> <text>:''This article is '''not''' about [[interactive proof system]]s which use probability to convince a verifier that a proof is correct, '''nor''' about [[probabilistic algorithm]]s, which give the right answer with high probability but not with certainty, '''nor''' about [[Monte Carlo method]]s, which are simulations relying on [[pseudo-randomness]].'' The '''probabilistic method''' is a [[nonconstructive proof|nonconstructive]] method, primarily used in [[combinatorics]] and pioneered by [[Paul Erd&#337;s]], for proving the existence of a prescribed kind of mathematical object. It works by showing that if one randomly chooses objects from a specified class, the [[probability]] that the result is of the prescribed kind is more than zero. Although the proof uses probability, the final conclusion is determined for ''certain'', without any possible error. This method has now been applied to other areas of [[mathematics]] such as [[number theory]], [[linear algebra]], and [[real analysis]], as well as in [[computer science]] (e.g. [[randomized rounding]]). ==Introduction== If every object in a collection of objects fails to have a certain property, then the probability that a random object chosen from the collection has that property is zero. Turning this around, if the probability that the random object has the property is greater than zero, then this proves the existence of at least one object in the collection that has the property. It doesn't matter if the probability is vanishingly small; any positive probability will do. Similarly, showing that the probability is (strictly) less than 1 can be used to prove the existence of an object that does ''not'' satisfy the prescribed properties. Another way to use the probabilistic method is by calculating the [[expected value]] of some [[random variable]]. If it can be shown that the 