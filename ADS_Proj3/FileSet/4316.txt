stochastic behavior. Despite these limitations, however, it is usually reasonable to assume that deviations from these ideals will be small. == LTI Systems == {{main|LTI system theory}} As mentioned above, there are many methods of analysis developed specifically for [[LTI system theory|LTI systems]]. This is due to their simplicity of specification. An [[LTI system theory|LTI system]] is completely specified by its [[transfer function]] (which is a [[rational function]] for digital and lumped analog LTI systems). Alternatively, we can think of an LTI system being completely specified by its [[frequency response]]. A third way to specify an LTI system is by its characteristic [[linear differential equation]] (for analog systems) or linear [[difference equation]] (for digital systems). Which description is most useful depends on the application. The distinction between [[Lumped element model | lumped]] and [[Distributed element model | distributed]] LTI systems is important. A lumped LTI system is specified by a finite number of parameters, be it the [[root of a function|zeros]] and [[Pole (complex analysis)|poles]] of its transfer function, or the [[coefficient]]s of its differential equation, whereas specification of a distributed LTI system requires a complete [[Function (mathematics)|function]] == See also == === Important concepts in system analysis === * [[Transfer function]] * [[LTI system theory]] * [[Feedback]] and [[BIBO stability]] * [[Frequency response]] * [[Steady-state]] and [[Transient state|transient]] behavior * [[Filter (signal processing)|Filter]]s * [[Noise (physics)]] * Transforms ** [[Fourier transform]]: [[Continuous Fourier transform]] & [[Discrete Fourier transform]] ** [[Laplace transform]] ** [[Z-transform]] * [[Information theory]] === Related fields === * [[Control system]] and [[control theory]] * [[Digital signal processing]] * [[Digital image processing]] * [[Telecommunications]] {{DEFAULTSORT:System Analysis}} [[Category:Electrical engineering]] [[Category:Electronic engineering]] [[Category:Digital signal processing]] [[Category:Futurology]] [[Category:Control theory]]</text> </page> <page> <id>36508</id> <title>System deployment</title> <text>The '''deployment''' of a [[mechanical device]], electrical [[system]], [[computer program]], etc., is its assembly or transformation from a packaged form to an operational working state. Deployment implies moving a product from a temporary or development state to a permanent or desired state. == See also == * [[product development|Development]] * [[Innovation]] * [[Software deployment]] {{unreferenced|date=April 2007}} {{engineering-stub}} [[Category:Systems engineering]]</text> </page> <page> <id>36538</id> <title>System testing</title> <text>'''System testing''' of software or hardware is testing conducted on a complete, integrated system to evaluate the system's compliance with its specified [[requirements]]. System testing falls within the scope of [[black box testing]], and as such, should require no knowledge of the inner design of the code or logic. <ref name="ieee">''IEEE Standard Computer Dictionary: A Compilation of IEEE Standard Computer Glossaries''; ''[[IEEE]]''; New York, NY.; 1990.</ref> As a rule, system testing takes, as its input, all of the "integrated" software components that have successfully passed [[integration testing]] and also the software system itself integrated with any applicable hardware system(s). The purpose of integration testing is to detect any inconsistencies between the software units that are integrated together (called ''assemblages'') or between any of the ''assemblages'' and the hardware. System testing is a more limited type of testing; it seeks to detect defects both within the "inter-assemblages" and also within the system as a whole. {{portal|Software Testing}} ==Testing the whole system== System testing is performed on the entire system in the context of a [[Functional requirements|Functional Requirement]] Specification(s) (FRS) and/or a [[Requirements analysis|System Requirement]] Specification (SRS). System testing tests not only the design, but also the behaviour and even the believed expectations of the customer. It is also intended to test up to and beyond the bounds defined in the software/hardware requirements specification(s).{{Citation needed|date=April 2008}} == Types of tests to include in system testing == The following examples are different types of testing that should be considered during System testing: * [[GUI software testing]] * [[Usability testing]] * [[Performance testing]] * [[Compatibility testing]] * [[Error handling testing]] * [[Load testing]] * [[Volume testing]] * [[Stress testing]] * [[Security testing]] * [[Scalability testing]] * [[Sanity test]]ing * [[Smoke_test#Smoke_testing_in_software_development|Smoke testing]] * [[Exploratory testing]] * [[Ad hoc testing]] * [[Regression testing]] * [[Reliability testing]] * [[Installation testing]] * [[Maintenance testing]] * [[Recovery testing]] and failover testing. * [[Accessibility]] testing, including compliance with: ** [[Americans with Disabilities Act of 1990]] ** [[Section 508 Amendment to the Rehabilitation Act of 1973]] ** [[Web Accessibility Initiative]] (WAI) of the [[World Wide Web Consortium]] (W3C) Although different testing organizations may prescribe different tests as part of System testing, this list serves as a general framework or foundation to begin with. ==See also== *[[Automatic test equipment]] *[[Software testing]] *[[Unit testing]] *[[Integration testing]] *[[Test case]] *[[Test fixture]] *[[Test plan]] *[[Automated testing]] *[[Quality control]] *[[Software development process]] *[[Computer accessibility]] ==References== {{reflist}} {{refbegin}} * Black, Rex; (2002). Managing the Testing Process (2nd ed.). Wiley Publishing. ISBN 0-471-22398-0 {{refend}} [[Category:Software testing]] [[Category:Hardware testing]] [[ca:Proves de sistema]] [[de:Softwaretest#Systemtest]] [[nl:Systeemtest]] [[ja:システムテスト]] [[pt:Teste de sistema]] [[ru:Системное тестирование]] [[uk:Системне тестування]] [[vi:Kiểm lỗi hệ thống]] [[zh:系统测试]]</text> </page> <page> <id>36542</id> <title>Systematic code</title> <text>In [[coding theory]], a '''systematic code''' is any [[error-correcting code]] in which the input data is embedded in the encoded output. Conversely, in a '''non-systematic code''' the output does not contain the input symbols. Systematic codes have the advantage that the parity data can simply be appended to the source block, and receivers do not need to recover the original source symbols if received correctly &ndash; this is useful for example if error-correction coding is combined with a hash function for quickly determining the correctness of the received source symbols, or in cases where errors occur in [[erasure channel|erasures]] and a received symbol is thus always correct. Furthermore, for engineering purposes such as synchronization and monitoring, it is desirable to get reasonable good estimates of the received source symbols without going through the lengthy decoding process which may be carried out at a remote site at a later time.<ref name="nonsystematic">{{cite journal|author=[[James L. Massey]], [[Daniel J. Costello, Jr.]]|title=Nonsystematic convolutional codes for sequential decoding in space applications|journal=[[IEEE]] Transactions on Communication Technology|volume=19|issue=5|year=1971|doi=10.1109/TCOM.1971.1090720}}</ref> ==Properties== Every non-systematic code can be transformed into a systematic code with essentially the same properties (i.e., minimum distance).<ref name="nonsystematic"/><ref name=" Richard_Blahut">{{cite book|title=Algebraic codes for data transmission|author=Richard E. Blahut|pages=53–54|year=2003|publisher=Cambridge. Univ. Press|isbn=9780521553742|edition = 2nd}}</ref> Because of the advantages cited above, [[linear 