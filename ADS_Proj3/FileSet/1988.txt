of Secure Computation'', 1978.</ref> A solution proved more elusive; for more than 30 years, it was unclear whether fully homomorphic encryption was even possible. During this period, the best result was the Boneh-Goh-Nissim cryptosystem which supports evaluation of an unlimited number of addition operations but at most one multiplication. In 2009, Craig Gentry<ref> Craig Gentry. [http://portal.acm.org/citation.cfm?id=1536414.1536440 Fully Homomorphic Encryption Using Ideal Lattices]. In ''the 41st ACM Symposium on Theory of Computing (STOC)'', 2009.</ref> using [[lattice-based cryptography]] showed the first fully homomorphic encryption scheme as announced by IBM on June 25.<ref>http://www-03.ibm.com/press/us/en/pressrelease/27840.wss</ref><ref> {{cite web |title=IBM touts encryption innovation |url=http://www.computerworld.com/s/article/9134823/IBM_touts_encryption_innovation?taxonomyId=152&intsrc=kc_top&taxonomyName=compliance |publisher=[[Computer World]] |date=2009-06-25 |accessdate=2009-07-14 |author=Michael Cooney }}</ref> His scheme supports evaluations of arbitrary depth circuits. His construction starts from a ''somewhat homomorphic'' encryption scheme using ideal lattices that is limited to evaluating low-degree polynomials over encrypted data. (It is limited because each ciphertext is noisy in some sense, and this noise grows as one adds and multiplies ciphertexts, until ultimately the noise makes the resulting ciphertext indecipherable.) He then shows how to modify this scheme to make it ''bootstrappable'' -- in particular, he shows that by modifying the somewhat homomorphic scheme slightly, it can actually evaluate its own decryption circuit, a self-referential property. Finally, he shows that any bootstrappable somewhat homomorphic encryption scheme can be converted into a fully homomorphic encryption through a recursive self-embedding. In the particular case of Gentry's ideal-lattice-based somewhat homomorphic scheme, the effect of this bootstrapping procedure is to "refresh" a ciphertext -- i.e., to reduce the noise associated to a ciphertext -- so that it can thereafter be used in more additions and multiplications without resulting in an indecipherable ciphertext. Gentry based the security of his scheme on the assumed hardness of two problems -- certain worst-case problems over ideal lattices, and the sparse (or low-weight) subset sum problem. Regarding performance, ciphertexts in Gentry's scheme remain compact -- that is, their length does not depend at all on the complexity of the function that is evaluated over the encrypted data. The computational time only depends linearly on the number of operations performed. However, the scheme is impractical for many applications, because ciphertext size and computation time increase sharply as one increases the security level. To obtain 2<sup>''k''</sup> security against known attacks, the computation time and ciphertext size are high-degree polynomials in ''k''. Recently, Stehle and Steinfeld reduced the dependence on ''k'' substantially.<ref> {{cite web |title=Faster Fully Homomorphic Encryption |url=http://eprint.iacr.org/2010/299 |publisher=International Association for Cryptologic Research |date=2010-05-19 |accessdate=2010-09-15 |author=Damien Stehle |coauthors=Ron Steinfeld |format=PDF }}</ref> They presented optimizations that permit the computation to be only quasi-''k''<sup>3.5</sup> per boolean gate of the function being evaluated. Gentry's Ph.D. thesis<ref> {{cite web |title=A Fully Homomorphic Encryption Scheme (Ph.D. thesis) |url=http://crypto.stanford.edu/craig/ |author=Craig Gentry |format=PDF }}</ref> provides additional details. Gentry also published a high-level overview of the van Dijk et al. construction (described below) in the March 2010 issue of Communications of the ACM.<ref> {{cite web |title=Computing Arbitrary Functions of Encrypted Data |url=http://cacm.acm.org/magazines/2010/3/76272-computing-arbitrary-functions-of-encrypted-data/fulltext |publisher=[[Association for Computing Machinery]] |author=Craig Gentry }}</ref> In 2009, Marten van Dijk, Craig Gentry, Shai Halevi and Vinod Vaikuntanathan presented a second fully homomorphic encryption scheme,<ref> {{cite web |title=Fully Homomorphic Encryption over the Integers |url=http://eprint.iacr.org/2009/616 |publisher=International Association for Cryptologic Research |date=2009-12-11 |accessdate=2010-03-18 |author=Marten van Dijk |coauthors=Craig Gentry, Shai Halevi, and Vinod Vaikuntanathan |format=PDF }}</ref> which uses many of the tools of Gentry's construction, but which does not require ideal lattices. Instead, they show that the somewhat homomorphic component of Gentry's scheme (which uses ideal lattices) can be replaced with a very simple somewhat homomorphic scheme that uses integers. The scheme is therefore conceptually simpler than Gentry's ideal lattice scheme, but has similar properties with regards to homomorphic operations and efficiency. The somewhat homomorphic component in the work of van Dijk et al. is similar to an encryption scheme proposed by Levieil and Naccache in 2008,<ref>{{cite web |title=Cryptographic Test Correction |url=http://en.wikipedia.org/wiki/Cryptographic_Test_Correction }}</ref> and also to one that was proposed by Bram Cohen in 1998.<ref> {{cite web |title=Simple Public Key Encryption |url=http://bramcohen.com/simple_public_key.html |url=http://en.wikipedia.org/wiki/Cohen's_cryptosystem |author=Bram Cohen }}</ref> Cohen's method is not even additively homomorphic, however. The Levieil-Naccache scheme is additively homomorphic, and can be modified to support also a small number of multiplications. In 2010, [[Nigel Smart (cryptographer)|Nigel P. Smart]] and [[Frederik Vercauteren]] presented a refinement of Gentry's scheme giving smaller key and ciphertext sizes, but which is still not fully practical.<ref>[http://www.zdnet.co.uk/news/emerging-tech/2010/05/26/british-researcher-cracks-crypto-problem-40089057 News report] http://www.info.unicaen.fr/M2-AMI/articles-2009-2010/smart.pdf paper] [http://www.math.leidenuniv.nl/~dfreeman/smart.pdf pdf slides]</ref> At the rump session of Eurocrypt 2010, Craig Gentry and Shai Halevi presented a working implementation of fully homomorphic encryption -- that is, an implementation of the entire bootstrapping procedure -- together with performance numbers.<ref> {{cite web |title=A Working Implementation of Fully Homomorphic Encryption |url=http://eurocrypt2010rump.cr.yp.to/9854ad3cab48983f7c2c5a2258e27717.pdf |author=Craig Gentry |coauthor=Shai Halevi |format=PDF }}</ref> ==References== {{Reflist}} ==External links== *[http://research.cyber.ee/~lipmaa/crypto/link/public/homomorphic.php Homomorphic encryption] in [http://research.cyber.ee/~lipmaa/crypto/ Cryptology Pointers] *[http://code.google.com/p/thep/ The Homomorphic Encryption Project] {{DEFAULTSORT:Homomorphic Encryption}} [[Category:Cryptography]] [[pl:Szyfrowanie homomorficzne]] [[ru:Гомоморфное шифрование]]</text> </page> <page> <id>16915</id> <title>Homomorphic secret sharing</title> <text>{{Multiple issues|context =April 2009|confusing =April 2009|notability =November 2007|unreferenced =November 2007}} In [[cryptography]], '''homomorphic secret sharing''' is a type of [[secret sharing]] [[algorithm]] in which the secret is encrypted via [[homomorphic encryption]]. A [[homomorphism]] is a transformation from one type of [[algebraic structure]] into another so that the structure is preserved. Importantly, this means that for every kind of manipulation of the original data, there is a corresponding manipulation of the transformed data. == Technique == Homomorphic secret sharing is used to transmit a secret to several recipients as follows: # Transform the "secret" using a homomorphism. This often puts the secret into a form which is easy to manipulate or store. In particular, there may be a natural way to 'split' the new form as required by step (2). # Split the transformed secret into several parts, one for each recipient. The secret must be split in such a way that it can only be recovered when all or most of the parts are combined. (See [[secret sharing]]) # Distribute the parts of the secret to each of the recipients. # Combine each of the recipients parts to recover the transformed secret, perhaps at a specified time. 