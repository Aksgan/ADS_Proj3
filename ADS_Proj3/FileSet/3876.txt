each chunk break chunk into sixteen 32-bit big-endian words w[i], 0 ≤ i ≤ 15 <span style="color: green;">''Extend the sixteen 32-bit words into eighty 32-bit words:''</span> '''for''' i '''from''' 16 to 79 w[i] = (w[i-3] '''xor''' w[i-8] '''xor''' w[i-14] '''xor''' w[i-16]) '''[[Circular shift|leftrotate]]''' 1 <span style="color: green;">''Initialize hash value for this chunk:''</span> a = h0 b = h1 c = h2 d = h3 e = h4 <span style="color: green;">''Main loop:''</span> <ref>http://www.faqs.org/rfcs/rfc3174.html</ref> '''for''' i '''from''' 0 '''to''' 79 '''if''' 0 ≤ i ≤ 19 '''then''' f = (b '''and''' c) '''or''' (('''not''' b) '''and''' d) k = 0x5A827999 '''else if''' 20 ≤ i ≤ 39 f = b '''xor''' c '''xor''' d k = 0x6ED9EBA1 '''else if''' 40 ≤ i ≤ 59 f = (b '''and''' c) '''or''' (b '''and''' d) '''or''' (c '''and''' d) k = 0x8F1BBCDC '''else if''' 60 ≤ i ≤ 79 f = b '''xor''' c '''xor''' d k = 0xCA62C1D6 temp = (a '''leftrotate''' 5) + f + e + k + w[i] e = d d = c c = b '''leftrotate''' 30 b = a a = temp <span style="color: green;">''Add this chunk's hash to result so far:''</span> h0 = h0 + a h1 = h1 + b h2 = h2 + c h3 = h3 + d h4 = h4 + e <span style="color:green;">''Produce the final hash value (big-endian):''</span> digest = hash = h0 '''append''' h1 '''append''' h2 '''append''' h3 '''append''' h4 The constant values used are chosen as [[nothing up my sleeve number]]s: the four round constants <code>k</code> are 2<sup>30</sup> times the square roots of 2, 3, 5 and 10. The first four starting values for <code>h0</code> through <code>h3</code> are the same as the MD5 algorithm, and the fifth (for <code>h4</code>) is similar. Instead of the formulation from the original FIPS PUB 180-1 shown, the following equivalent expressions may be used to compute <code>f</code> in the main loop above: (0 ≤ i ≤ 19): f = d '''xor''' (b '''and''' (c '''xor''' d)) <span style="color: green;">''(alternative 1)''</span> (0 ≤ i ≤ 19): f = (b '''and''' c) '''xor''' (('''not''' b) '''and''' d) <span style="color: green;">''(alternative 2)''</span> (0 ≤ i ≤ 19): f = (b '''and''' c) + (('''not''' b) '''and''' d) <span style="color: green;">''(alternative 3)''</span> (0 ≤ i ≤ 19): f = vec_sel(d, c, b) <span style="color: green;">''(alternative 4)''</span> (40 ≤ i ≤ 59): f = (b '''and''' c) '''or''' (d '''and''' (b '''or''' c)) <span style="color: green;">''(alternative 1)''</span> (40 ≤ i ≤ 59): f = (b '''and''' c) '''or''' (d '''and''' (b '''xor''' c)) <span style="color: green;">''(alternative 2)''</span> (40 ≤ i ≤ 59): f = (b '''and''' c) + (d '''and''' (b '''xor''' c)) <span style="color: green;">''(alternative 3)''</span> (40 ≤ i ≤ 59): f = (b '''and''' c) '''xor''' (b '''and''' d) '''xor''' (c '''and''' d) <span style="color: green;">''(alternative 4)''</span> Max Locktyukhin has also shown<ref>{{Citation |first1=Max |last1=Locktyukhin |first2=Kathy |last2=Farrel |url=http://software.intel.com/en-us/articles/improving-the-performance-of-the-secure-hash-algorithm-1/ |title=Improving the Performance of the Secure Hash Algorithm (SHA-1) |journal=Intel Software Knowledge Base |publisher=Intel |date=2010-03-31 |accessdate=2010-04-02}}</ref> that for the rounds 32–79 the computation of: w[i] = (w[i-3] '''xor''' w[i-8] '''xor''' w[i-14] '''xor''' w[i-16]) '''[[Circular shift|leftrotate]]''' 1 can be replaced with: w[i] = (w[i-6] '''xor''' w[i-16] '''xor''' w[i-28] '''xor''' w[i-32]) '''[[Circular shift|leftrotate]]''' 2 This transformation keeps all operands 64-bit aligned and, by removing the dependency of <code>w[i]</code> on <code>w[i-3]</code>, allows efficient SIMD implementation with a vector length of 4 such as [[x86]] [[Streaming SIMD Extensions|SSE]] instructions. ==See also== * [[Comparison of cryptographic hash functions]] * [[Digital timestamping]] * [[FORK-256]] * [[Hash collision]] * [[Hashcash]] * [[International Association for Cryptologic Research]] (IACR) * [[RIPEMD-160]] * [[Secure Hash Standard]] * <tt>[[sha1sum]]</tt> * [[Tiger (cryptography)|Tiger]] * [[Whirlpool (cryptography)|Whirlpool]] ==References== {{refbegin|colwidth=30em}} <references/> * Florent Chabaud, Antoine Joux: Differential Collisions in SHA-0. [[CRYPTO]] 1998. pp56–71 * [[Eli Biham]], Rafi Chen, Near-Collisions of SHA-0, Cryptology ePrint Archive, Report 2004/146, 2004 (appeared on CRYPTO 2004), [http://eprint.iacr.org/2004/146/ IACR.org] * [[Xiaoyun Wang]], Hongbo Yu and Yiqun Lisa Yin, Efficient Collision Search Attacks on SHA-0, CRYPTO 2005, [http://www.cs.cmu.edu/~dbrumley/srg/spring06/sha-0.pdf CMU.edu] * [[Xiaoyun Wang]], Yiqun Lisa Yin and Hongbo Yu, Finding Collisions in the Full SHA-1, Crypto 2005 [http://people.csail.mit.edu/yiqun/SHA1AttackProceedingVersion.pdf MIT.edu] * [[Henri Gilbert]], [[Helena Handschuh]]: Security Analysis of SHA-256 and Sisters. [[Selected Areas in Cryptography]] 2003: pp175–193 * {{cite journal|title=Proposed Revision of Federal Information Processing Standard (FIPS) 180, Secure Hash Standard|journal=Federal Register|date=1994-07-11|first=|last=|coauthors=|volume=59|issue=131|pages=35317–35318|id= |url=http://frwebgate1.access.gpo.gov/cgi-bin/waisgate.cgi?WAISdocID=5963452267+0+0+0&WAISaction=retrieve|format=|accessdate=2007-04-26}} {{refend}} ==External links== <!-- We suffer from a lot of self promotion here. --- Please do not add a link to your own site. See http://en.wikipedia.org/w/index.php?title=WP:COI --- It will be removed, and you may be blocked without further warning. --> ===Standards: SHA-1, SHA-2=== * [http://www.eff.org/Privacy/Digital_signature/?f=fips_sha_shs.standard.txt Specifications for a Secure Hash Standard (SHS)] – Draft for proposed SHS (SHA-0) * [http://www.eff.org/Privacy/Digital_signature/?f=fips_sha_shs.info.txt Secure Hash Standard (SHS)] – Proposed SHS (SHA-0) * [http://csrc.nist.gov/CryptoToolkit/tkhash.html CSRC Cryptographic Toolkit] – Official [[National Institute of Standards and Technology|NIST]] site for the Secure Hash Standard ** [http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf FIPS 180-2: Secure Hash Standard (SHS)] ([[Portable Document Format|PDF]], 236 kB) – Current version of the Secure Hash Standard (SHA-1, SHA-224, SHA-256, SHA-384, and SHA-512), 1 August 2002, amended 25 February 2004 * RFC 3174 (with sample C implementation) ===Cryptanalysis=== * [http://news.zdnet.com/2100-1009_22-5598536.html Interview with Yiqun Lisa Yin concerning the attack on SHA-1] * [http://cm.bell-labs.com/who/akl/hash.pdf Lenstra's Summary of impact of the February 2005 cryptanalytic results] * [http://www.heise-online.co.uk/security/Hash-cracked--/features/75686 Explanation of the successful attacks on SHA-1] (3 pages, 2006) * [http://www.cryptography.com/cnews/hash.html Cryptography Research – Hash Collision Q&A] * [http://www.OnlineHashcrack.com Online SHA1 hash crack using Rainbow tables] * [http://www.hashproject.eu Hash Project Web Site: software- and hardware-based cryptanalysis of SHA-1] ===Implementations=== <!-- This section should include only implementations that are commercially or algorithmically significant, such as those widely used in existing technologies and platforms --> ;[http://directory.fsf.org/project/libgcrypt/ Libgcrypt]: A general purpose cryptographic library based on the code from [[GNU Privacy Guard]]. ;[[OpenSSL]]: The widely used OpenSSL <code>crypto</code> library includes [[free software|free]], [[open source|open-source]] – implementations of SHA-1, SHA-224, SHA-256, SHA-384, and SHA-512 ;[[Crypto++]]: A public domain C++ class library of cryptographic schemes, including implementations of the SHA-1, SHA-224, SHA-256, SHA-384, and SHA-512 algorithms. ;[[Bouncy Castle (cryptography)|Bouncy Castle]]: The Bouncy Castle Library is a free Java and C# 