testing and debugging complex logic elements; [[CPU]]s are common, but [[FPGA]]s and [[ASIC]]s include other complex elements which need to be debugged. Licensees of this core integrate it into chips, usually combining it with other TAPs as well as numerous peripherals and memory. (Peripherals and memory comprise the bulk of [[System-on-a-chip|SoC]] designs; ARM cores don't take up much chip area.) One of those other TAPs will handle boundary scan testing for the whole chip; it is not supported by the debug tap. Examples of such chips include: * The [[Texas Instruments OMAP|OMAP2420]] includes a boundary scan TAP, the ARM1136 Debug TAP, an ETB11 trace buffer tap, a [[Texas Instruments TMS320|C55x DSP]], and a tap for an [[ARM7]]TDMI-based imaging engine, with the boundary scan TAP ("ICEpick-B") having the ability to splice TAPs into and out of the JTAG scan chain.<ref name="omap2420">Documentation for the OMAP2420 is not publicly available. However, a [[Texas Instruments]] document [http://wiki.davincidsp.com/images/9/90/Dbjtag_users_guide.pdf The User's Guide to DBGJTAG] discussing a JTAG diagnostic tool presents this OMAP2420 scan chain example (and others).</ref> * The [[i.MX31]] processor is similar, although its "System JTAG" boundary scan TAP<ref name="iMX31">See "i.MX35 (MCIMX35) Multimedia Applications Processor Reference Manual" from the [[Freescale]] web site. Chapter 44 presents its "Secure JTAG Controller" (SJC).</ref> is very different from ICEpick, and it includes a TAP for its DMA engine instead of a DSP and imaging engine. Those processors are both intended for use in wireless handsets such as cell phones, which is part of the reason they include TAP controllers which modify the JTAG scan chain: debugging low power operation requires accessing chips when they are largely powered off, and thus when not all TAPs are operational. That scan chain modification functionality is one subject of a forthcoming IEEE 1149.7<ref name="ieee-1149.7"/> standard. ===JTAG Facilities=== This debug tap exposes several standard instructions, and a few specifically designed for hardware-assisted [[debugging]], where a software tool (the "debugger") uses JTAG to communicate with a system being debugged: * BYPASS, IDCODE ... standard instructions as described above * EXTEST, INTEST ... standard instructions, but operating on the core instead of an external boundary scan chain. EXTEST is nominally for writing data to the core, INTEST is nominally for reading it; but two scan chains are exceptions to that rule. * SCAN_N ... ARM instruction to select the numbered scan chain used with EXTEST or INTEST. There are six scan chains: ** 0 ... Device ID Register, 40 bits of read-only identification data ** 1 ... Debug Status and Control Register (DSCR), 32 bits used to operate the debug facilities ** 4 ... Instruction Transfer Register (ITR), 33 bits (32 instruction plus one status bit) used to execute processor instructions while in a special "Debug Mode" (see below) ** 5 ... Debug Communications Channel (DCC), 34 bits (one long data word plus two status bits) used for bidirectional data transfer to the core. This is used both in debug mode, and possibly at runtime when talking to debugger-aware software. ** 6 ... Embedded Trace Module (ETM), 40 bits (7 bit address, one 32-bit long data word, and a R/W bit) used to control the operation of a passive instruction and data trace mechanism. This feeds either an on-chip Embedded Trace Buffer (ETB), or an external high speed trace data collection pod. Tracing supports passive debugging (examining execution history) and profiling for performance tuning. ** 7 ... debug module, 40 bits (7 bit address, one 32-bit long data word, and a R/W bit) used to access hardware breakpoints, watchpoints, and more. These can be written while the processor is running; it does not need to be in Debug Mode. * HALT, RESTART ... ARM11-specific instructions to halt and restart the CPU. Halting it puts the core into the "Debug Mode", where the ITR can be used to execute instructions, including using the DCC to transfer data between the debug (JTAG) host and the CPU. * ITRSEL ... ARM11-specific instruction to accelerate some operations with ITR. That model resembles the model used in other ARM cores. Non-ARM systems generally have similar capabilities, perhaps implemented using the [[Nexus (standard)|Nexus]] protocols on top of JTAG, or other vendor-specific schemes. Older [[ARM7]] and [[ARM9]] cores include an ''EmbeddedICE'' module<ref name="arm9ejs">[http://infocenter.arm.com/help/topic/com.arm.doc.ddi0222b/DDI0222.pdf ARM9EJ-S Technical Reference Manual] revision r1p2. Appendix B "Debug in Depth" presents the EmbeddedICE-RT module, as seen in the popular ARM926ejs core.</ref> which combines most of those facilities, but has an awkward mechanism for instruction execution: the debugger must drive the CPU instruction pipeline, clock by clock, and directly access the data buses to read and write data to the CPU. The ARM11 uses the same model for trace support (ETM, ETB) as those older cores. Newer ARM cores, such as the Cortex-A8, closely resemble this debug model, but build on a ''Debug Access Port'' (DAP) instead of direct CPU access. They are also decoupled from JTAG so they can be hosted over ARM's two-wire "SWD" interface instead of just the six-wire JTAG interface. (ARM takes the four standard JTAG signals and adds the optional TRST, plus the RTCK signal used for adaptive clocking.) Also, the newer cores have updated trace support. ===Halt Mode Debugging=== One basic way to debug software is to present a single threaded model, where the debugger periodically stops execution of the program and examines its state as exposed by register contents and memory (including peripheral controller registers). When interesting program events approach, a person may want to single step instructions (or lines of source code) to watch how a particular misbehavior happens. So for example a JTAG host might HALT the core, entering Debug Mode, and then read CPU registers using ITR and DCC. After saving processor state, it could write those registers with whatever values it needs, then execute arbitrary algorithms on the CPU, accessing memory and peripherals to help characterize the system state. After the debugger performs those operations, the state may be restored and execution continued using the RESTART instruction. Debug mode is also entered asynchronously by the debug module triggering a 