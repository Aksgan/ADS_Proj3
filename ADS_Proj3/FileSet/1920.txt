|title=DEADBABE sanity check |date= |accessdate=2009-10-01}}</ref> * 0xDEADBEEF ("dead beef") is frequently used to indicate a software crash or deadlock in embedded systems. It is used by IBM [[RS/6000]] systems, [[Mac OS]] on 32-bit [[PowerPC]] processors and the [[Commodore International|Commodore]] [[Amiga]] as a magic debug value. On [[Sun Microsystems]]' [[Solaris (operating system)|Solaris]], it marks freed kernel memory. On [[OpenVMS]] running on Alpha processors, DEAD_BEEF can be seen by pressing CTRL-T. The DEC Alpha SRM console has a background process that traps memory errors, identified by PS as "BeefEater waiting on 0xdeadbeef".<ref>{{cite web|url=http://www.catb.org/~esr/jargon/html/D/DEADBEEF.html |title=Jargon File entry for DEADBEEF |publisher=Catb.org |date= |accessdate=2009-10-01}}</ref>. * 0xDEADDEAD ("dead dead") is the bug check (STOP) code displayed when invoking a [[blue_screen_of_death|Blue Screen of Death]] either by telling the kernel via the attached debugger, or by using a special keystroke combination.<ref>{{cite web|url=http://msdn.microsoft.com/en-us/library/ms797162.aspx |title=Bug Check 0xDEADDEAD: MANUALLY_INITIATED_CRASH, MSDN |publisher=msdn.microsoft.com |date=2009-10-01 |accessdate=2009-10-13}}</ref> This is usually seen by driver developers, as it is used to get a memory dump on Windows NT based systems. An alternative to 0xDEADDEAD is the bug check code 0x000000E2,<ref>{{cite web|url=http://msdn.microsoft.com/en-us/library/ms797144.aspx |title=Bug Check 0xE2: MANUALLY_INITIATED_CRASH, MSDN |publisher=msdn.microsoft.com |date=2009-10-01 |accessdate=2009-10-13}}</ref> as they are both called MANUALLY_INITIATED_CRASH as seen on the Microsoft Developer Network. * 0xDEADFA11 ("dead fall") is used by [[Apple Inc.|Apple]] in [[IOS_(Apple)|iOS]] crash reports, when user force quit the application.<ref name="DAC1"/> * 0xDEFEC8ED ("defecated") is the magic number for [[OpenSolaris]] [[core dump]]s.<ref>{{cite web|url=http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/sys/dumphdr.h |title=Opensolaris header line 48 for 0xDEFEC8ED |publisher=Cvs.opensolaris.org |date= |accessdate=2009-10-01}}</ref> * 0xFACEFEED ("face feed") is used by Alpha servers running Windows NT. The Alpha [[Hardware Abstraction Layer]] (HAL) generates this error when it encounters a hardware failure.<ref>{{cite web|url=http://support.microsoft.com/kb/132349 |title=Technet article for 0xFACEFEED |publisher=Support.microsoft.com |date=2006-11-01 |accessdate=2009-10-01}}</ref> * 0xFEE1DEAD ("feel dead") is used as a magic number in the [[Linux]] reboot system call.<ref>{{cite web|url=http://git.kernel.org/?p=linux/kernel/git/next/linux-next.git;a=blob_plain;f=include/linux/reboot.h;hb=HEAD |title=include/linux/reboot.h }}</ref> * 0xE011CFD0 is used as [[magic number (programming)|magic number]] for Microsoft Office files. In [[little endian]] this reads D0CF11E0, "docfile0".<ref>{{cite web|url=http://support.microsoft.com/kb/318326 |title=Documents That Are Supported by the Office Filter}}</ref> == Alternative letters == * In the [[Ada (programming language)|Ada programming language]], hexadecimal numbers are enclosed by "16#" and "#". For example, "16#Ada_Ada_Ada_Ada#". * The [[C (programming language)|C programming language]] notation uses the "0x" prefix to indicate a hexadecimal number; the "0x" is usually ignored when reading the letters or numbers. * In the [[x86-assembly|Intel assembly language]], hexadecimal numbers are denoted by a "h" suffix. For example: FEEDADEADF15h ("feed a dead fish"). Note that numbers in this notation that begin with a letter have to start with a zero to distinguish them from variable names. "FEEDADEADF15h" would then be "0FEEDADEADF15h". * In [[6502]] [[assembly language]] , hexadecimal numbers are denoted by a "$" prefix. This allows for words starting with the letter "S", for example $EED ("seed"). == See also == * [[Leet]] * [[file (command)]] == References == {{reflist}} [[Category:Source code]] [[Category:Obfuscation]] [[Category:Computer humor]] [[ru:Hexspeak]] [[de:Hexspeak]] [[el:Hexspeak]] [[it:Hexspeak]] [[ja:Hexspeak]] [[pl:0xDEADBEEF]]</text> </page> <page> <id>16623</id> <title>Hibernate (Java)</title> <text>{{More footnotes|date=April 2010}} {{Infobox software | logo = [[Image:Hibernate.png]] | name = Hibernate | developer = [[Red Hat]] | status = Active | latest release version = 3.6.0 Final | latest release date = {{release date|2010|10|13}} | operating system = [[Cross-platform]] ([[JVM]]) | platform = [[Java Virtual Machine]] | programming language = [[Java (programming language)|Java]] | genre = [[Object-relational mapping]] | license = [[GNU Lesser General Public License]] | website = http://www.hibernate.org }} '''Hibernate''' is an [[object-relational mapping]] (ORM) library for the [[Java (programming language)|Java]] language, providing a [[Software framework|framework]] for mapping an [[Object-oriented programming|object-oriented]] [[domain model]] to a traditional [[relational database]]. Hibernate solves [[object-relational impedance mismatch]] problems by replacing direct [[Persistence (computer science)|persistence]]-related database accesses with high-level object handling functions. Hibernate is [[free software]] that is distributed under the [[GNU Lesser General Public License]]. Hibernate's primary feature is mapping from Java classes to database tables (and from Java data types to [[SQL]] data types). Hibernate also provides data query and retrieval facilities. Hibernate generates the SQL calls and attempts to relieve the developer from manual result set handling and object conversion and keep the application portable to all supported SQL databases with little performance overhead. ==Mapping== Mapping Java classes to database tables is accomplished through the configuration of an [[XML]] file or by using [[Java annotation|Java Annotations]]. When using an XML file, Hibernate can [[Program synthesis|generate]] skeletal [[source code]] for the persistence classes. This is unnecessary when annotation is used. Hibernate can use the XML file or the annotation to maintain the [[database schema]]. Facilities to arrange [[one-to-many]] and [[Many-to-many (data model)|many-to-many]] relationships between classes are provided. In addition to managing association between objects, Hibernate can also manage [[Reflexive relation|reflexive]] associations where an object has a one-to-many relationship with other instances of its own [[data type|type]]. Hibernate supports the mapping of custom value types. This makes the following scenarios possible: * Overriding the default SQL type that Hibernate chooses when mapping a column to a property. * Mapping Java [[Enumerated type|Enum]] to columns as if they were regular properties. * Mapping a single property to multiple columns. ==Persistence== Hibernate provides transparent persistence for [[Plain Old Java Object]]s (POJOs). The only strict requirement for a persistent class is a no-argument [[Constructor (computer science)|constructor]], not necessarily ''public''. Proper behavior in some applications also requires special attention to the ''equals()'' and ''hashCode()'' methods.<ref>[http://www.hibernate.org/109.html Equals and HashCode]</ref> Collections of data objects are typically stored in Java collection objects such as Set and List. [[Generics in Java|Java generics]], introduced in Java 5, are supported. Hibernate can be configured to [[lazy load]] associated collections. Lazy loading is the default as of Hibernate 3. Related objects can be configured to ''cascade'' operations from one to the other. For example, a parent such as an Album object can be configured to cascade its save and/or delete operation to its child Track objects. This can reduce development time and ensure [[referential integrity]]. A ''dirty checking'' feature avoids unnecessary database write actions by performing SQL updates only on the modified fields of persistent objects. ==Hibernate Query Language (HQL)== Hibernate provides an [[SQL]] inspired language called [[Hibernate Query Language]] (HQL) which allows SQL-like queries to 