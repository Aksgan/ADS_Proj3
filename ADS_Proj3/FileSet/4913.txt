be inferred from the block sequence number and the chunk offset within the block. Thereby when YAFFS2 scans the flash and detects multiple chunks that have identical ObjectIDs and ChunkNumbers, it can choose which to use by taking the greatest sequence number. For efficiency reasons YAFFS2 also introduces the concept of shrink headers. For example when a file is resized to a smaller size, YAFFS1 will mark all of the affected chunks as dirty - YAFFS2 cannot do this due to the "write once" rule. YAFFS2 instead writes a "shrink header", which indicates that a certain number of pages before that point are invalid. This lets YAFFS2 reconstruct the final state of the filesystem when the system reboots. YAFFS2 uses a more abstract definition of the NAND flash allowing it to be used with a wider variety of flash parts with different geometries, bad block handling rules etc. YAFFS2 now supports "checkpointing" which bypasses normal mount scanning, allowing very fast mount times. Mileage will vary, but mount times of 3 seconds for 2 [[gigabyte|GB]] have been reported. ==See also== * [[List of file systems]] * [[JFFS]] * [[JFFS2]] * [[UBIFS]] * [[LogFS]] * [[Open NAND Flash Interface Working Group]] ==References== {{Reflist}} ==External links== *[http://www.yaffs.net/ YAFFS - Yet Another Flash Filing System main website] &ndash; a filing system optimised for NAND Flash chips (for embedded use) *[http://www.linuxdevices.com/articles/AT9680239525.html Introducing YAFFS, the first NAND-specific flash file system] * [http://code.google.com/p/unyaffs/ Unyaffs]: A simple program to unpack YAFFS2 images. {{Filesystem}} {{DEFAULTSORT:Yaffs}} [[Category:Flash file systems]] [[Category:Embedded Linux]] [[es:YAFFS]] [[ja:YAFFS]] [[ru:YAFFS]]</text> </page> <page> <id>40832</id> <title>YAK (cryptography)</title> <text>The '''YAK''' is a public-key authenticated [[key agreement]] protocol<ref>F. Hao, [http://sites.google.com/site/haofeng662/YAK-short-final.pdf On Robust Key Agreement Based on Public Key Authentication]. ''Proceedings of the 14th International Conference on Financial Cryptography and Data Security, Tenerife, Spain, LNCS 6052, pp. 383-390, Jan, 2010.</ref>. It is considered the simplest among the related protocols, including [[MQV]], HMQV, [[Station-to-Station protocol]], [[Secure Sockets Layer | SSL]]/[[Transport Layer Security | TLS]] etc. The authentication is based on public key pairs. As with other protocols, YAK normally requires a [[Public Key Infrastructure]] to distribute authentic public keys to the communicating parties. The author suggests that YAK may be unencumbered by patent. ==Description== Two parties, Alice and Bob, agree on a group <math>G</math> with generator <math>g</math> of prime order <math>q</math> in which the discrete log problem is hard. Typically a [[Schnorr group]] is used. In general, YAK can use any prime order group that is suitable for public key cryptography, including [[Elliptic curve cryptography]]. Let <math>g^a</math> be Alice's long-term public key and <math>g^b</math> be Bob's. The protocol executes in one round. '''One round''': Alice selects <math>x \in_R [0, q-1]</math> and sends out <math>g^x</math> together with a [[Zero-knowledge proof]] (using for example [[Schnorr signature]]) for the proof of the exponent <math>x</math>. Similarly, Bob selects <math>y \in_R [0, q-1]</math> and sends out <math>g^{y}</math> together with a [[Zero-knowledge proof]] for the proof of the exponent <math>y</math>. The above communication can be completed in one round as neither party depends on the other. When it finishes, Alice and Bob verify the received [[Zero-knowledge proofs]]. Alice then computes <math>K = (g^{y} g^{b}) ^ {x + a}= g^{(x + a) (y + b)}</math>. Similarly, Bob computes <math>K = (g^{x} g^{a}) ^ {y + b} = g^{(x + a) (y + b)}</math>. With the same keying material <math>K</math>, Alice and Bob can derive a session key using a [[Cryptographic hash function]]: <math>\kappa = H(K)</math>. ==Security properties== Given that the underlying [[Non-interactive zero-knowledge proof | zero knowledge proof]] primitive is secure, the YAK protocol is proved to fulfill the following properties. # '''Private key security''' - An attacker cannot learn the user's static private key even if he is able to learn all session specific secrets in any compromised session. # '''Full forward secrecy''' - Session keys that were securely established in the past uncorrupted sessions will remain incomputable in the future even when both users' static private keys are disclosed. # '''Session key security''' - An attacker cannot compute the session key if he impersonates a user but has no access to the user's private key. ==References== <references/> ==External links== * [http://eprint.iacr.org/2010/136.pdf On Robust Key Agreement Based on Public Key Authentication (Full Paper)] [[Category:Cryptography]] [[Category:Cryptographic protocols]]</text> </page> <page> <id>40849</id> <title>Yacc</title> <text>{{lowercase|title=yacc}} The [[computer program]] '''yacc''' is a [[parser generator]] developed by [[Stephen C. Johnson]] at [[AT&T]] for the [[Unix]] operating system. The name is an acronym for "[[Yet Another]] [[Compiler Compiler]]." It generates a [[parsing|parser]] (the part of a [[compiler]] that tries to make syntactic sense of the [[source code]]) based on an [[Formal grammar|analytic grammar]] written in a notation similar to [[Backus-Naur form|BNF]]. Historically, Yacc has generated the [[code]] for the [[parser]] in the [[C (programming language)|C programming language]].[http://www.techworld.com.au/article/252319/-z_programming_languages_yacc?pp=1] Yacc used to be available as the default parser generator on most Unix systems. It has since been supplanted as the default by more recent, largely compatible, programs such as [[Berkeley Yacc]], [[GNU bison]], [[MKS Inc.|MKS]] yacc and Abraxas pcyacc. An updated version of the original AT&T version is included as part of [[Sun Microsystems|Sun's]] [[OpenSolaris]] project. Each offers slight improvements and additional features over the original yacc, but the concept has remained the same. Yacc has also been rewritten for other languages, including [[Ratfor]], [[ML programming language|ML]], [[Ada programming language|Ada]], [[Pascal (programming language)|Pascal]], [[Java (programming language)|Java]], [[Python (programming language)|Python]] and [[Common Lisp]]. The parser generated by yacc requires a [[lexical analyzer]]. Lexical analyzer generators, such as [[Lex programming tool|Lex]] or [[Flex lexical analyser|Flex]] are widely available. The [[IEEE]] [[POSIX]] P1003.2 standard defines the functionality and requirements for both Lex and Yacc. Some versions of AT&T Yacc have become [[open source]]. For example, [[source code]] (for different implementations) is available with the standard distributions of [[Plan 9 from Bell Labs|Plan 9]] and [[OpenSolaris]]. ==See also== * [[LALR parser]]: The underlying parsing algorithm in Yacc. * [[GNU bison|Bison]]: The GNU version of Yacc. * [[Lex programming tool|Lex]] (and [[Flex lexical analyser]]), the token parser commonly used in conjunction with yacc (and Bison). * [[Backus-Naur form|BNF]], is a [[metasyntax]] used 