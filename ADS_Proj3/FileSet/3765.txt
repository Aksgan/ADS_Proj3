* [http://davidmlane.com/hyperstat/B153351.html A non-mathematical explanation of regression toward the mean.] * [http://onlinestatbook.com/stat_sim/reg_to_mean/index.html A simulation of regression toward the mean.] * Amanda Wachsmuth, Leland Wilkinson, Gerard E. Dallal. [http://www.spss.com/research/wilkinson/Publications/galton.pdf Galton's Bend: An Undiscovered Nonlinearity in Galton's Family Stature Regression Data and a Likely Explanation Based on Pearson and Lee's Stature Data] ''(A modern look at Galton's analysis.)'' * Massachusetts standardized test scores, interpreted by a statistician as an example of regression: see [http://groups.google.com/groups?q=g:thl3845480903d&dq=&hl=en&lr=&ie=UTF-8&oe=UTF-8&safe=off&selm=93ikdr%24i20%241%40nnrp1.deja.com discussion in sci.stat.edu] and [http://groups.google.com/group/sci.stat.edu/tree/browse_frm/thread/c1086922ef405246/60bb528144835a38?rnum=21&hl=en&_done=%2Fgroup%2Fsci.sta its continuation]. {{Statistics}} {{DEFAULTSORT:Regression Toward The Mean}} [[Category:Statistical terminology]] [[Category:Regression analysis]] [[Category:Statistical laws]] [[de:Regression zur Mitte]] [[es:Regresión (estadística)]] [[ja:平均への回帰]]</text> </page> <page> <id>31676</id> <title>Regsvr32</title> <text>{{lowercase}} '''<code>regsvr32</code>''' (Microsoft&copy; Register Server) is a command-line utility in [[Microsoft Windows]] [[operating system]]s for registering and unregistering [[Dynamic-link library|DLL]]s and [[ActiveX]] controls in the [[Windows Registry]].<ref>[http://technet.microsoft.com/en-us/library/bb490985.aspx Microsoft TechNet Regsvr32 article]</ref> To be used with ''regsvr32'', a DLL must export the functions <code>DllRegisterServer</code> and <code>DllUnregisterServer</code>.<ref>[http://support.microsoft.com/?id=207132 INFO: How Regsvr32.exe Registers and Unregisters COM DLLs]</ref> == Example usage == <code>regsvr32 shmedia.dll</code> for installing a file <code>regsvr32 /u shmedia.dll</code> for uninstalling a file If another copy of ''shmedia.dll'' exists in the system search path, regsvr32 may choose that copy instead of the one in the current directory. This problem can usually be solved by specifying a full path (e.g., ''c:\windows\system32\shmedia.dll'') or using the following syntax: <code>regsvr32 .\shmedia.dll</code> == References == {{reflist}} ==External links== *[http://technet.microsoft.com/en-us/library/bb490985.aspx Microsoft TechNet Regsvr32 article] *[http://support.microsoft.com/kb/q249873/ Explanation of Regsvr32 Usage and Error Messages] *[http://blogs.msdn.com/csharpfaq/archive/2004/08/02/206158.aspx C# Frequently Asked Questions: What is the equivalent to regsvr32 in .NET?] *[http://www.sourcecodestore.com/Article.aspx?ID=9 A free graphical user interface for the Regsvr32 utility: C++ source code download] {{Windows commands}} {{Windows Components}} {{windows-stub}} [[Category:Windows administration]] [[Category:Computing commands]] [[es:Regsvr32]] [[it:Regsvr32]] [[zh:Regsvr32]]</text> </page> <page> <id>31684</id> <title>Regular language</title> <text>{{for|natural language that is regulated|List of language regulators}} In [[theoretical computer science]], a '''regular language''' is a [[formal language]] (i.e., a possibly infinite set of finite sequences of symbols from a finite alphabet) that satisfies the following equivalent properties: * it can be accepted by a [[deterministic finite state machine]]. * it can be accepted by a [[nondeterministic finite state machine]] * it can be accepted by an [[alternating finite automaton]] * it can be described by a formal [[Regular expression#Formal_language_theory|regular expression]]. Note that the "regular expression" features provided with many programming languages are augmented with features that make them capable of recognizing languages which are not regular, and are therefore not strictly equivalent to formal regular expressions. * it can be generated by a [[regular grammar]] * it can be generated by a [[prefix grammar]] * it can be accepted by a read-only [[Turing machine]] * it can be defined in [[monadic predicate calculus|monadic]] [[second-order logic]] * it is recognized by some finitely generated [[monoid]] * it is the [[preimage]] of a subset of a finite monoid under a homomorphism from the free monoid on its alphabet ==Regular languages == The collection of regular languages over an alphabet Σ is defined recursively as follows: * the empty language Ø is a regular language. * the [[empty string]] language { ε } is a regular language. * For each ''a'' ∈ Σ (''a'' belongs to Σ ), the [[Singleton (mathematics)|singleton]] language { ''a'' } is a regular language. * If ''A'' and ''B'' are regular languages, then ''A'' ∪ ''B'' (union), ''A'' • ''B'' (concatenation), and ''A''* ([[Kleene star]]) are regular languages. * No other languages over Σ are regular. All finite languages are regular. Other typical examples include the language consisting of all strings over the alphabet {''a'', ''b''} which contain an even number of ''a''s, or the language consisting of all strings of the form: several ''a''s followed by several ''b''s. A simple example of a language that is not regular is the set of strings <math>\{a^nb^n\,\vert\; n\ge 0\}</math>. == Complexity results == In [[computational complexity theory]], the [[complexity class]] of all regular languages is sometimes referred to as '''REGULAR''' or '''REG''' and equals [[DSPACE]](O(1)), the [[decision problem]]s that can be solved in constant space (the space used is independent of the input size). '''REGULAR''' ≠ [[AC0|'''AC'''<sup>0</sup>]], since it (trivially) contains the parity problem of determining whether the number of 1 bits in the input is even or odd and this problem is not in '''AC'''<sup>0</sup>.<ref>M. Furst, J. B. Saxe, and M. Sipser. Parity, circuits, and the polynomial-time hierarchy. Math. Systems Theory, 17:13–27, 1984.</ref> On the other hand, it is not known to contain '''AC'''<sup>0</sup>. If a language is ''not'' regular, it requires a machine with at least [[Big O notation|&Omega;]](log log ''n'') space to recognize (where ''n'' is the input size).<ref>J. Hartmanis, P. L. Lewis II, and R. E. Stearns. Hierarchies of memory-limited computations. ''Proceedings of the 6th Annual IEEE Symposium on Switching Circuit Theory and Logic Design'', pp. 179&ndash;190. 1965.</ref> In other words, DSPACE([[Big O notation|o]](log log ''n'')) equals the class of regular languages. In practice, most nonregular problems are solved by machines taking at least [[logarithmic space]]. == Closure properties == The regular languages are [[closure (mathematics)|closed]] under the various operations. Below, ''K'' and ''L'' represent regular languages. * the set theoretic Boolean operations: [[union (set theory)|union]] <math>K \cup L</math>, [[intersection (set theory)|intersection]] <math>K \cap L</math>, and [[complement (set theory)|complement]] <math>\bar{L}</math>. From this also [[difference]] <math>K-L</math> follows. * the regular operations: [[union (set theory)|union]] <math>K \cup L</math>, [[concatenation]] <math>K\circ L</math>, and [[Kleene star]] <math>L^*</math>. * the [[abstract family of languages|trio]] operations: [[string homomorphism]], inverse string homomorphism, and intersection with regular languages. As a consequence they are closed under arbitrary [[finite state transducer|finite state transductions]], like [[right quotient|quotient]] <math>K / L</math> with a regular language. * the reverse (or mirror image) <math>L^R</math>. ==Deciding whether a language is regular== To locate the regular languages in the [[Chomsky hierarchy]], one notices that every regular language is [[Context free language|context-free]]. The converse is not true: for example the language consisting of all strings having the same number of ''a''<nowiki>'</nowiki>s as ''b''<nowiki>'</nowiki>s is context-free but not regular. To prove that a language such as this is not regular, one uses the [[Myhill-Nerode theorem]] or the [[pumping lemma]]. There are two purely algebraic approaches 