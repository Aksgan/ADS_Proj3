used to execute the methods of the object. In such an arrangement, method calls from threads outside of the apartment are [[Marshalling (computer science)|marshalled]] and automatically queued by the system (via a standard Windows message queue). Thus, there is no worry about race conditions or lack of synchronicity because each method call of an object is always executed to completion before another is invoked. If the COM object's methods perform their own synchronization, multiple threads dedicated to calling methods on the COM object are permitted. This is termed the Multiple Threaded Apartment (MTA). Calls to an MTA object from a thread in an STA are also marshaled. A process can consist of multiple COM objects, some of which may use STA and others of which may use MTA. The Thread Neutral Apartment allows different threads, none of which is necessarily dedicated to calling methods on the object, to make such calls. The only provision is that all methods on the object must be serially reentrant. ==Criticisms== Since COM has a fairly complex implementation, programmers can be distracted by some of the "plumbing" issues. ===Message pumping=== When an STA is initialized it creates a hidden window that is used for inter-apartment and inter-process message routing. This window must have its message queue regularly pumped. This construct is known as a [[message pump]]. On earlier versions of Windows, failure to do so could cause system-wide deadlocks. This problem is especially nasty because some Windows APIs initialize COM as part of their implementation, which causes a leak of implementation details. ===Reference counting=== Reference counting within COM may cause problems if two or more objects are [[circular reference|circularly referenced]]. The design of an application must take this into account so that objects are not left orphaned. Objects may also be left with active reference counts if the COM "event sink" model is used. Since the object that fires the event needs a reference to the object reacting to the event, the object's reference count will never reach zero. Reference cycles are typically broken using either out-of-band termination or split identities. In the out of band termination technique, an object exposes a method which, when called, forces it to drop its references to other objects, thereby breaking the cycle. In the split identity technique, a single implementation exposes two separate COM objects (also known as identities). This creates a [[weak reference]] between the COM objects, preventing a reference cycle. ===DLL hell=== {{Main|DLL hell}} Because the location of each component is stored in a system-wide location (the [[Windows registry]]), there can be only one version of a certain component installed. This limitation can seriously complicate the deployment of COM-based applications, due to the possibility that different programs, or even different versions of the same program, may be designed to work with different versions of the same COM component. This condition is known as [[DLL hell]]. While this condition has been known to occur with OS components, it is generally a condition created by application developers in the use of their own components. The problem can be reduced or eliminated completely by careful [[software versioning]] and [[regression testing]]. [[Windows XP]] introduced a new mode of COM object registration called "'''Registration-free COM'''". This facility makes it possible for applications that need to install COM objects to store all the required COM registry information in the application's directory, instead of in the global registry, so that, strictly speaking, only that application will ever see/use it. DLL hell can be substantially avoided using Registration-free COM, the only limitation being it requires at least [[Windows XP]] or later Windows versions and that it must not be used for EXE COM servers or system-wide components such as [[MDAC]], [[MSXML]], [[DirectX]] or [[Internet Explorer]]. ==RegFree COM== '''RegFree COM''' (or '''Registration-Free COM''') is a technology introduced with [[Windows XP]] that allows Component Object Model (COM) [[software componentry|components]] to store activation [[metadata]] and CLSID (<code>[[Class (computing)|Class]] ID</code>) for the component without using the [[Windows Registry|registry]]. Instead, the metadata and CLSIDs of the classes implemented in the component are declared in an assembly manifest (described using [[XML]]), stored either as a resource in the executable or as a separate file installed with the component.<ref name="msdndocs">{{cite web | url = http://msdn.microsoft.com/en-us/library/aa374219(VS.85).aspx | title = Assembly Manifests | publisher = [[MSDN]] | accessdate = 2009-11-05}}</ref> This allows multiple versions of the same component to be installed in different directories, described by their own manifests, as well as [[XCOPY deployment]].<ref name="msdnmag">{{cite web | url = http://msdn.microsoft.com/en-us/magazine/cc188708.aspx | title = Simplify App Deployment with ClickOnce and Registration-Free COM | author = Dave Templin | publisher = [[MSDN]] Magazine | accessdate = 2008-04-22}}</ref> During application loading, the Windows loader searches for the manifest.<ref name="isoconcept">{{cite web | url = http://msdn.microsoft.com/en-us/library/ms235531(VS.80).aspx | title = Concepts of Isolated Applications and Side-by-side Assemblies | publisher = [[MSDN]] | accessdate = 2009-11-05}}</ref> If it is present, the loader adds information from it to the activation context <ref name="msdnmag"/> When the COM class factory tries to instantiate a class, the activation context is first checked to see if an implementation for the CLSID can be found. Only if the lookup fails is the [[Windows Registry|registry]] scanned.<ref name="msdnmag"/> == See also == * [[Portable object (computing)]] cross language cross platform Object Model definition * [[Distributed Component Object Model]] (DCOM), extension making COM able to work in networks * [[Common Language Infrastructure]] current .Net cross language cross platform Object Model * [[CORBA]] Common Object Request Broker Architecture, open cross language cross platform object model * [[Freedesktop.org]] [[D-Bus]] current open cross language cross platform Object Model * [[GNOME]] [[Bonobo (computing)|Bonobo]] deprecated GNOME cross language Object Model * [[KDE]] [[DCOP]] deprecated KDE interprocess and software componentry communication system * [[KDE]] [[KPart]] deprecated KDE component framework * [[XPCOM]] Mozilla applications cross Platform Component Object Model * [[IBM System Object Model]] SOM, a component system from IBM used in OS/2 * [[Java Beans]] * [[Java Remote Method Invocation]] * [[Internet Communications Engine]] * [[Language binding]] * [[Foreign function interface]] * [[Calling convention]] * 