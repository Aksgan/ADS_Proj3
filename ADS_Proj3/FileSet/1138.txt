It has been highly influential to the field of software engineering and is regarded as an important source for object-oriented design theory and practice. More than 500,000 copies have been sold in English and in 13 other languages. ==Introduction, Chapter 1== Chapter 1 is a discussion of [[object-oriented]] design techniques, based on the authors' experience, which they believe would lead to good object-oriented software design, including: * "Program to an 'interface', not an ''''implementation''''." (Gang of Four 1995:18) * "Favor '[[object composition]]' over '[[Inheritance (computer science)|class inheritance]]'." (Gang of Four 1995:20) The authors claim the following as advantages of [[Interface (computer science)|interfaces]] over implementation: * clients remain unaware of the specific types of objects they use, as long as the object adheres to the interface * clients remain unaware of the classes that implement these objects; clients only know about the abstract class(es) defining the interface Use of an interface also leads to [[Dynamic binding (computer science)|dynamic binding]] and [[Polymorphism in object-oriented programming|polymorphism]], which is consequentially important to object-oriented programming. The authors refer to [[Inheritance (object-oriented programming)|inheritance]] as ''[[White box (software engineering)|white-box reuse]]'', with white-box referring to visibility, because the internals of parent classes are often visible to [[Subclass (computer science)|subclasses]]. In contrast, the authors refer to [[object composition]] (in which objects with well-defined interfaces are used dynamically at runtime by objects obtaining references to other objects) as ''[[Black box|black-box reuse]]'' because no internal details of composed objects need be visible in the code using them. The authors discuss the tension between inheritance and encapsulation at length and state that in their experience, designers overuse inheritance (Gang of Four 1995:20). The danger is stated as follows: :"Because inheritance exposes a [[Subclass (computer science)|subclass]] to details of its parent's implementation, it's often said that 'inheritance breaks encapsulation'". (Gang of Four 1995:19) They warn that the implementation of a subclass can become so bound up with the implementation of its parent class that any change in the parent's implementation will force the subclass to change. Furthermore, they claim that a way to avoid this is to inherit only from abstract classes—but then, they point out that there is minimal code reuse. Using inheritance is recommended mainly when adding to the functionality of existing components, reusing most of the old code and adding relatively small amounts of new code. To the authors, 'delegation' is an extreme form of object composition that can always be used to replace inheritance. Delegation involves two objects: a 'sender' passes itself to a 'delegate' to let the delegate refer to the sender. Thus the link between two parts of a system are established only at runtime, not at compile-time. The [[Callback (computer science)|Callback]] article has more information about delegation. The authors also discuss so-called '''parameterized types''', which are also known as [[Generic programming|generics]] (Ada, Eiffel, [[Generics in Java|Java]], C#, VB.NET, and Delphi) or templates (C++). These allow any type to be defined without specifying all the other types it uses—the unspecified types are supplied as 'parameters' at the point of use. The authors admit that delegation and parameterization are very powerful but add a warning: :"Dynamic, highly parameterized software is harder to understand and build than more static software." (Gang of Four 1995:21) The authors further distinguish between '[[Object composition#Aggregation|Aggregation]]', where one object 'has' or 'is part of' another object (implying that an aggregate object and its owner have identical lifetimes) and '''acquaintance''', where one object merely 'knows of' another object. Sometimes acquaintance is called 'association' or the 'using' relationship. Acquaintance objects may request operations of each other, but they aren't responsible for each other. Acquaintance is a weaker relationship than aggregation and suggests much looser coupling between objects, which can often be desirable for maximum maintainability in a design. The authors employ the term 'toolkit' where others might today use 'class library', as in C# or Java. In their parlance, toolkits are the object-oriented equivalent of subroutine libraries, whereas a '[[Software framework|framework]]' is a set of cooperating classes that make up a reusable design for a specific class of software. They state that '''applications''' are hard to design, '''toolkits''' are harder, and '''frameworks''' are the hardest to design. ==Case study, Chapter 2== Chapter 2 is a step-by-step case study on "the design of a '[[WYSIWYG|What-You-See-Is-What-You-Get]]' (or 'WYSIWYG') document editor called Lexi." (pp33) The chapter goes through seven problems that must be addressed in order to properly design Lexi, including any constraints that must be followed. Each problem is analyzed in-depth, and solutions are proposed. Each solution is explained in full, including [[pseudo-code]] and [[Unified Modeling Language]] where appropriate. Finally, each solution is associated directly with one or more design patterns. It is shown how the solution is a direct implementation of that design pattern. The seven problems (including their constraints) and their solutions (including the pattern(s) referenced), are as follows: ===Document Structure=== The document is "an arrangement of basic graphical elements" such as characters, lines, other shapes, etc, that "capture the total information content of the document"(pp35<!-- Should this be just one p? Or should it use "35ff"? -->). The structure of the document contains a collection of these elements, and each element can in turn be a substructure of other elements. '''Problems and Constraints''' #Text and graphics should be treated the same way (that is, graphics aren't a derived instance of text, nor vice versa) #The implementation should treat complex and simple structures the same way. It should not have to know the difference between the two. #Specific derivatives of abstract elements should have specialized analytical elements. '''Solution and Pattern''' A ''recursive composition'' is a hierarchical structure of elements, that builds "increasingly complex elements out of simpler ones" (pp36<!-- Should this be just one p? Or should it use "35ff"? -->). Each node in the structure knows of its own children and its parent. If an operation is to be performed on the whole structure, each node calls the operation on its children (recursively). This is an implementation of the [[composite pattern]], which is a collection 