than the stunted versions within ipchains and ipfwadm. == iptables == {{Main|iptables}} The kernel modules named ''ip_tables'', ''ip6_tables'', ''arp_tables'' (underscores part of the name) and ''ebtables'' are one of the significant users of the Netfilter hook system. They provide a table-based system for defining firewall rules that can filter or transform packets. The tables can be administered through the user-space tools '''iptables''', '''ip6tables''', '''arptables''' and '''ebtables''', respectively. Each table is actually its own hook, and each table was introduced to serve a specific purpose. As far as Netfilter is concerned, usually to run said table in a specific order with respect to other tables. Other than that however, all tables will call the same table processing function to further iterate over, and execute rules. Chains in this regard equate to ''where from'' the Netfilter stack was invoked, such as packet reception (PREROUTING), locally delivered (INPUT), forwarded (FORWARD), locally output (OUTPUT) and packet send (POSTROUTING). Netfilter modules that do not provide tables (see below) may also check for the origin to select their mode of operation. * the ''iptable_raw'' module will, when loaded, register a hook that will be called before any other Netfilter hook. It provides a table called ''raw'' that can be used to filter packets before they reach more memory-demanding operations such as Connection Tracking. * the ''iptable_mangle'' module registers a hook and ''mangle'' table to run after Connection Tracking (but still before any other table), so that modifications can be made to the packet that may influence further rules such as NAT or filtering. * the ''iptable_nat'' module registers two hooks: DNAT-based transformations are applied before the filter hook, SNAT-based transformations are applied afterwards. The ''nat'' table that is made available to iptables is merely a “configuration database” for [[Network address translation|NAT]] mappings only, and not intended for filtering of any kind. * the ''iptable_filter'' module registers the ''filter'' table, used for general-purpose filtering (firewalling). == nftables == {{Main|nftables}} Patrick McHardy intends to replace iptables with nftables in the future. The project is currently in the alpha stage of development. The four modules of iptables ([[IPv4]], [[IPv6]], [[Address Resolution Protocol|ARP]], and Ethernet [[bridging (networking)|bridging]]) are replaced with a single unified implementation, implemented on the top of a [[virtual machine]]. == Packet Defragmentation == {{See also|IP fragmentation}} The ''nf_defrag_ipv4'' module will defragment IPv4 packets before Connection Tracking (''nf_conntrack_ipv4'' module) sees them. This is necessary for the in-kernel Connection Tracking and NAT helper modules (which are a form of “mini-[[Application-level gateway|ALGs]]”) that only work reliably on entire packets, not necessarily fragments. The IPv6 defragmenter is not a module in its own right, but is integrated into the ''nf_conntrack_ipv6'' module. == Connection Tracking == {{See also|Stateful Packet Inspection}} One of the important features built on top of the Netfilter framework is connection tracking.<ref>Netfilter's Connection Tracking System, by Pablo Neira Ayuso, June 14, 2006: http://people.netfilter.org/pablo/docs/login.pdf</ref> Connection tracking allows the kernel to keep track of all logical network connections or [[Session (computer science)|sessions]], and thereby relate all of the packets which may make up that connection. NAT relies on this information to translate all related packets in the same way, and iptables can use this information to act as a stateful firewall. The connection state however is completely independent of any upper-level state, such as TCP's or SCTP's state. Part of the reason for this is that when merely forwarding packets, i.e. no local delivery, the TCP engine may not necessarily be invoked at all. Even [[connectionless-mode transmission]]s such as [[User Datagram Protocol|UDP]], [[IPsec]] (AH/ESP), [[Generic Routing Encapsulation|GRE]] and other [[tunneling protocol]]s have a, at least pseudo, connection state. The heuristic for such protocols is often based upon a preset timeout value for inactivity, after whose expiration a Netfilter connection is dropped. Each Netfilter connection is uniquely identified by a (layer-3 protocol, source address, destination address, layer-4 protocol, layer-4 key) tuple. The layer-4 key depends on the transport protocol; for TCP/UDP it is the port numbers, for tunnels it can be their tunnel ID, but otherwise is just zero, as if it were not part of the tuple. To be able to inspect the TCP port in all cases, packets will be mandatorily defragmented. Netfilter connections can be manipulated with the user-space tool ''conntrack''. Iptables can make use of checking the connection's information such as states, statuses and more to make packet filtering rules more powerful and easier to manage. The most common states are: * “NEW”: trying to create a new connection * “ESTABLISHED”: part of an already-existing connection * “RELATED”: assigned to a packet that is initiating a new connection and which has been “expected”. The aforementioned mini-ALGs set up these expectations, for example, when the ''nf_conntrack_ftp'' module sees an [[File transfer protocol|FTP]] “PASV” command. * “INVALID”: the packet was found to be [[invalid packet|invalid]], e.g. it would not adhere to the [[Transmission_Control_Protocol#Protocol_operation|TCP state]] diagram. * “UNTRACKED” is a special state that can be assigned by the administrator to bypass connection tracking for a particular packet (see raw table, above) A normal example would be that the first packet the conntrack subsystem sees will be classified “new”, the reply would be classified “established” and an [[Internet Control Message Protocol|ICMP]] error would be “related”. An ICMP error packet which did not match any known connection would be “invalid”. === Connection tracking helpers === Through the use of plugin modules, connection tracking can be given knowledge of application-layer protocols and thus understand that two or more distinct connections are “related”. For example, consider the [[File Transfer Protocol|FTP]] protocol. A control connection is established, but whenever data is transferred, a separate connection is established to transfer it. When the ''nf_conntrack_ftp'' module is loaded, the first packet of an FTP data connection will be classified as “related” instead of “new”, as it is logically part of an existing connection. The helpers only inspect one packet at a time, so if vital information for connection tracking is split across two packets, either due to [[IP fragmentation]] or TCP segmentation, the helper will not necessarily recognize 