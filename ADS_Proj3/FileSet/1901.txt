O(log ''n'')* || O(log ''n'') |- | insert || Θ(log ''n'') || O(log ''n'') || Θ(1) || O(1)* || Θ(1) |- | decreaseKey || Θ(log ''n'') || Θ(log ''n'') || Θ(1)* || O(log ''n'')* || Θ(1) |- | merge || Θ(''n'') || O(log ''n'') || Θ(1) || O(0)* || Θ(1) |} Note that a "Brodal queue" is an implementation of a parallel priority queue created by Gerth Stølting Brodal et. all.<ref>{{cite | web|url=http://www.ceid.upatras.gr/faculty/zaro/pub/jou/J9-JPDC-pq.pdf | title=A Parallel Priority Queue with Constant Time Operations}}</ref> ==Heap applications== The heap data structure has many applications. * [[Heapsort]]: One of the best sorting methods being in-place and with no quadratic worst-case scenarios. * [[Selection algorithm]]s: Finding the min, max, both the min and max, median, or even the ''k''-th largest element can be done in linear time (often constant time) using heaps.<ref>{{citation | last = Frederickson | first = Greg N. | contribution = An Optimal Algorithm for Selection in a Min-Heap | doi = 10.1006/inco.1993.1030 | pages = 197–214 | publisher = Academic Press | title = Information and Computation | volume = 104 | issue = 2 | year = 1993 | url = http://ftp.cs.purdue.edu/research/technical_reports/1991/TR%2091-027.pdf}}</ref> * [[List of algorithms#Graph algorithms|Graph algorithms]]: By using heaps as internal traversal data structures, run time will be reduced by polynomial order. Examples of such problems are [[Prim's algorithm|Prim's minimal spanning tree algorithm]] and [[Dijkstra's algorithm|Dijkstra's shortest path problem]]. Full and almost full binary heaps may be represented in a very space-efficient way using an [[array data structure|array]] alone. The first (or last) element will contain the root. The next two elements of the array contain its children. The next four contain the four children of the two child nodes, etc. Thus the children of the node at position <code>n</code> would be at positions <code>2n</code> and <code>2n+1</code> in a one-based array, or <code>2n+1</code> and <code>2n+2</code> in a zero-based array. This allows moving up or down the tree by doing simple index computations. Balancing a heap is done by swapping elements which are out of order. As we can build a heap from an array without requiring extra memory (for the nodes, for example), heapsort can be used to sort an array in-place. One more advantage of heaps over trees in some applications is that construction of heaps can be done in linear time using [[Tarjan's algorithm]]. ==Heap implementations== * The [[C++]] [[Standard Template Library]] provides the make_heap, push_heap and pop_heap algorithms for heaps (usually implemented as binary heaps), which operate on arbitrary random access [[iterator]]s. It treats the iterators as a reference to an array, and uses the array-to-heap conversion. * The Java 2 platform (since version 1.5) provides the binary heap implementation with class java.util.PriorityQueue<E> in [[Java Collections Framework]]. * Python has a [http://docs.python.org/library/heapq.html heapq] module that implements a priority queue using a binary heap. * [[PHP]] has both maxheap (SplMaxHeap) and minheap (SplMinHeap) as of version 5.3 in the Standard PHP Library. * [[Perl]] has implementations of binary, binomial, and Fibonacci heaps in the [http://search.cpan.org/perldoc?Heap Heap] distribution available on [[CPAN]]. ==See also== * [[Fibonacci heap]] * [[Stack (data structure)]] * [[Sorting algorithm]] == References== {{Commons category|Heaps}} {{Wikibooks|Data Structures|Min and Max Heaps}} {{Reflist}} {{CS-Trees}} {{Data structures}} {{DEFAULTSORT:Heap (Data Structure)}} [[Category:Heaps (structure)|*]] [[cs:Halda (datová struktura)]] [[da:Hob (datastruktur)]] [[de:Heap (Datenstruktur)]] [[es:Montículo (informática)]] [[fr:Tas (informatique)]] [[ko:힙 (자료 구조)]] [[is:Hrúga (tölvunarfræði)]] [[it:Heap]] [[he:ערימה]] [[lt:Krūva]] [[hu:Kupac (adatszerkezet)]] [[ml:ഹീപ് (ഡാറ്റാ സ്ട്രക്‌ച്ചർ)]] [[nl:Heap]] [[ja:ヒープ]] [[no:Heap]] [[pl:Kopiec (informatyka)]] [[pt:Heap]] [[sk:Halda (dátová štruktúra)]] [[sl:Kopica]] [[fi:Keko (tietorakenne)]] [[sv:Heap (datastruktur)]] [[th:ฮีป]] [[tr:Öbek (bilgisayar bilimi)]] [[uk:Купа (структура даних)]] [[zh:堆 (数据结构)]]</text> </page> <page> <id>16442</id> <title>Heap feng shui</title> <text>In [[computer security]], '''heap feng shui''' is a technique used in [[exploit (computer security)|exploits]] to facilitate [[arbitrary code execution]].<ref>{{cite web|url=http://blog.trendmicro.com/heaps-and-bounds/|title=Heaps and Bounds|publisher=Trend Micro|date=September 3rd, 2007|accessdate=2009-08-10}}</ref> The technique attempts to manipulate the layout of the [[Heap (programming)|heap]] by making heap allocations of carefully selected sizes. It is named after [[feng shui]], an ancient Chinese system of aesthetics that involves the selection of precise alignments in space. == References == {{reflist}} == See also == * [[Heap spraying]] == External links == * [http://www.blackhat.com/presentations/bh-europe-07/Sotirov/Presentation/bh-eu-07-sotirov-apr19.pdf Heap Feng Shui in JavaScript] - Slides of the BlackHat presentation on this subject. {{compu-stub}} [[Category:Computer security exploits]]</text> </page> <page> <id>16444</id> <title>Heap spraying</title> <text>In [[computer security]], '''heap spraying''' is a technique used in [[exploit (computer security)|exploits]] to facilitate [[arbitrary code execution]]. The term is also used to describe the part of the [[source code]] of an exploit that implements this technique. In general, code that ''sprays the heap'' attempts to put a certain sequence of bytes at a predetermined location in the [[Random access memory|memory]] of a target [[Process (computing)|process]] by having it allocate (large) blocks on the process' [[Heap (programming)|heap]] and fill the bytes in these blocks with the right values. They commonly take advantage from the fact that these heap blocks will roughly be in the same location every time the heap spray is run. Execution flow can be redirected to the heap sprays via [[buffer overflow]] or [[heap overflow]] flaws. == History == Heap sprays have been used occasionally in exploits since at least 2001,<ref>[http://research.eeye.com/html/advisories/published/AD20010618.html eEye Digital Security - Research<!-- Bot generated title -->]</ref> but the technique started to see widespread use in exploits for [[web browser]]s in the summer of 2005 after the release of several such exploits which used the technique against wide range of bugs in [[Internet Explorer]].<ref>[http://skypher.com/wiki/index.php?title=Www.edup.tudelft.nl/~bjwever/advisory_iframe.html.php InternetExploiter 1: MSIE IFRAME src&name parameter BoF exploit]</ref><ref>[http://skypher.com/wiki/index.php?title=Www.edup.tudelft.nl/~bjwever/details_msie_ani.html.php InternetExploiter 3: MSIE .ANI file "anih" header BoF exploit]</ref><ref>[http://skypher.com/wiki/index.php?title=Www.edup.tudelft.nl/~bjwever/advisory_msie_R6025.html.php InternetExploiter 2: MSIE DHTML Object handling race condition exploit]</ref><ref>[http://www.frsirt.com/english/advisories/2005/0935 FrSIRT - Microsoft Internet Explorer javaprxy.dll COM Object Vulnerability / Exploit (Security Advisories)<!-- Bot generated title -->]</ref><ref>[http://www.frsirt.com/english/advisories/2005/1450 FrSIRT - Microsoft Internet Explorer "Msdds.dll" Remote Code Execution / Exploit (Security Advisories)<!-- Bot generated title -->]</ref> The heap sprays used in all these exploits were very similar, which showed its versatility and ease of use without need for major modifications between exploits. It proved simple enough to understand and use to allow novice [[Hacker (computer security)|hackers]] to quickly write reliable exploits for many types of [[Vulnerability (computing)|vulnerabilities]] in web browsers and web browser 