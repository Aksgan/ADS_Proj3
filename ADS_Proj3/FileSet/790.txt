the abstraction as an external view of the system (e.g., someone who does not see the decision reached by the person), [[Nondeterministic algorithm|nondeterminism]] has been introduced. == Formal definition == === Syntax === The syntax of CSP defines the “legal” ways in which processes and events may be combined. Let <math>\mathit{e}</math> be an event, and <math>\mathit{X}</math> be a set of events. Then the basic [[syntax]] of CSP can be defined as: :<math> \begin{matrix} Proc & ::= & \textit{STOP} & \; \\ &|& \textit{SKIP} & \; \\ &|& e \rightarrow \textit{Proc} & (\textit{prefixing})\\ &|& \textit{Proc} \;\Box\; \textit{Proc} & (\textit{external} \; \textit{choice})\\ &|& \textit{Proc} \;\sqcap\; \textit{Proc} & (\textit{nondeterministic} \; \textit{choice})\\ &|& \textit{Proc} \;\vert\vert\vert\; \textit{Proc} & (\textit{interleaving}) \\ &|& \textit{Proc} \;|[ \{ X \} ]| \;\textit{Proc} & (\textit{interface} \; \textit{parallel})\\ &|& \textit{Proc} \setminus X & (\textit{hiding})\\ &|& \textit{Proc} ; \textit{Proc} & (\textit{sequential} \; \textit{composition})\\ &|& \mathrm{if} \; b \; \mathrm{then} \; \textit{Proc}\; \mathrm{else}\; Proc & (\textit{boolean} \; \textit{conditional})\\ &|& \textit{Proc} \;\triangleright\; \textit{Proc} & (\textit{timeout})\\ &|& \textit{Proc} \;\triangle\; \textit{Proc} & (\textit{interrupt}) \end{matrix} </math> Note that, in the interests of brevity, the syntax presented above omits the <math>\mathbf{div}</math> process, which represents [[Divergence (computer science)|divergence]], as well as various operators such as alphabetized parallel, piping, and indexed choices. === Formal semantics === {{Expand section|date=June 2008}} CSP has been imbued with several different [[Semantics#Computer science|formal semantics]], which define the ''meaning'' of syntactically correct CSP expressions. The theory of CSP includes mutually consistent [[denotational semantics]], [[algebraic semantics]], and [[operational semantics]]. ==== Denotational semantics ==== The three major denotational models of CSP are the ''traces'' model, the ''stable failures'' model, and the ''failures/divergences'' model. Semantic mappings from process expressions to each of these three models provide the denotational semantics for CSP.<ref name="roscoe"/> The ''traces model'' defines the meaning of a process expression as the set of sequences of events (traces) that the process can be observed to perform. For example, :* <math>traces\left(STOP\right) = \left\{ \langle\rangle \right\}</math> since <math>STOP</math> performs no events :* <math>traces\left(a\rightarrow b \rightarrow STOP\right) = \left\{\langle\rangle ,\langle a \rangle, \langle a, b \rangle \right\}</math> since the process <math>(a\rightarrow b \rightarrow STOP)</math> can be observed to have performed no events, the event <math>a</math>, or the sequence of events <math>a</math> followed by <math>b</math> More formally, the meaning of a process <math>P</math> in the traces model is defined as <math>traces\left(P\right) \subseteq \Sigma^{\ast}</math> such that: # <math>\langle\rangle \in traces\left(P\right)</math> (i.e. <math>traces\left(P\right)</math> contains the empty sequence) # <math>s_1 \smallfrown s_2 \in traces\left(P\right) \implies s_1 \in traces\left(P\right)</math> (i.e. <math>traces\left(P\right)</math> is prefix-closed) where <math>\Sigma^{\ast}</math> is the set of all possible finite sequences of events. The ''stable failures model'' extends the traces model with refusal sets, which are sets of events <math>X \subseteq \Sigma</math> that a process can refuse to perform. A ''failure'' is a pair <math>\left(s,X\right)</math>, consisting of a trace <math>s</math>, and a refusal set <math>X</math> which identifies the events that a process may refuse once it has executed the trace <math>s</math>. The observed behavior of a process in the stable failures model is described by the pair <math>\left(traces\left(P\right), failures\left(P\right)\right)</math>. For example, :* <math>failures\left(\left(a \rightarrow STOP\right) \Box \left(b \rightarrow STOP\right)\right) = \left\{\left(\langle\rangle,\emptyset\right), \left(\langle a \rangle, \left\{a,b\right\}\right), \left(\langle b \rangle,\left\{a,b\right\}\right) \right\}</math> :* <math>failures\left(\left(a \rightarrow STOP\right) \sqcap \left(b \rightarrow STOP\right)\right) = \left\{ \left(\langle\rangle,\left\{a\right\}\right), \left(\langle\rangle,\left\{b\right\}\right), \left(\langle a \rangle, \left\{a,b\right\}\right), \left(\langle b \rangle,\left\{a,b\right\}\right) \right\}</math> The ''failures/divergence model'' further extends the failures model to handle [[divergence (computer science)|divergence]]. A process in the failures/divergences model is a pair <math>\left(failures_\perp\left(P\right), divergences\left(P\right)\right)</math> where <math>divergences\left(P\right)</math> is defined as the set of all traces that can lead to divergent behavior and <math>failures_\perp\left(P\right) = failures\left(P\right) \cup \left\{\left(s,X\right) \vert s \in divergences\left(P\right)\right\}</math>. == Tools == Over the years, a number of tools for analyzing and understanding systems described using CSP have been produced. Early tool implementations used a variety of machine-readable syntaxes for CSP, making input files written for different tools incompatible. However, most CSP tools have now standardized on the machine-readable dialect of CSP devised by Bryan Scattergood, sometimes referred to as CSP<sub>''M''</sub><ref>{{cite paper|author=Scattergood, J.B.|title=The Semantics and Implementation of Machine-Readable CSP|version=D.Phil.|publisher=[[Oxford University Computing Laboratory]]|year=1998}}</ref>. The CSP<sub>''M''</sub> dialect of CSP possesses a formally defined [[operational semantics]], which includes an embedded [[functional programming language]]. The most well-known CSP tool is probably ''Failures/Divergence Refinement 2'' (''[[FDR2]]''), which is a commercial product developed by Formal Systems (Europe) Ltd. FDR2 is often described as a [[model checker]], but is technically a ''refinement'' checker, in that it converts two CSP process expressions into [[Labelled transition system|Labelled Transition System]]s (LTSs), and then determines whether one of the processes is a refinement of the other within some specified semantic model (traces, failures, or failures/divergence)<ref>{{cite paper|author=[[Bill Roscoe|A.W. Roscoe]]|title=Model-checking CSP|version=In ''A Classical Mind: essays in Honour of C.A.R. Hoare''|publisher=Prentice Hall|year=1994}}</ref>. FDR2 applies various state-space compression algorithms to the process LTSs in order to reduce the size of the state-space that must be explored during a refinement check. The ''Adelaide Refinement Checker'' (''ARC'') <ref>{{cite conference |first=Atanas N. |last= Parashkevov|coauthors=Jay Yantchev |title=ARC - a tool for efficient refinement and equivalence checking for CSP |booktitle=IEEE Int. Conf. on Algorithms and Architectures for Parallel Processing ICA3PP '96 |pages= 68–75|year=1996 |url=http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.3212 |accessdate=2008-11-26 }}</ref> is a CSP refinement checker developed by the Formal Modelling and Verification Group at [[The University of Adelaide]]. ARC differs from FDR2 in that it internally represents CSP processes as [[Binary decision diagram|Ordered Binary Decision Diagram]]s (OBDDs), which alleviates the state explosion problem of explicit LTS representations without requiring the use of state-space compression algorithms such as those used in FDR2. The ''ProB'' project<ref>{{cite conference| first = Michael |last=Leuschel |coauthors= Marc Fontaine| title = Probing the Depths of CSP-M: A new FDR-compliant Validation Tool| booktitle = ICFEM 2008|publisher = Springer-Verlag|year=2008|url=http://www.stups.uni-duesseldorf.de/publications/main.pdf|format=PDF|accessdate=2008-11-26}}</ref>, which is hosted by the Institut für Informatik, Heinrich-Heine-Universität Düsseldorf, was originally created to support analysis of specifications constructed in the [[B method]]. However, it also includes support for analysis of CSP processes both through refinement checking, and [[Linear Temporal Logic|LTL]] model-checking. ProB can also be used to verify properties of combined CSP and B specifications. The ''Process Analysis Toolkit'' (PAT) <ref>{{cite conference|last=Sun |first=Jun|coauthors= Yang Liu and Jin Song Dong| title = PAT: Towards Flexible Verification under 