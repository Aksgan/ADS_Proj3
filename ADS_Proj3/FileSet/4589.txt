endl; // This time it breaks! return 0; } </source> The two child classes have members of different types. When a pointer to a less-specific parent class is converted to a pointer to a more-specific child class, the resulting pointer may or may not point to a valid object of its type. In the first conversion, the pointer is valid, and in the second, it is not. Again, a garbage value is printed and a memory exception may be raised. ==See also== *[[datatype]] *[[type theory]] ==References== <references /> *{{Cite book|authorlink=Benjamin C. Pierce |last=Pierce |first=Benjamin C. |title=Types and Programming Languages |publisher=MIT Press |year=2002 |isbn=0-262-16209-1 |url=http://www.cis.upenn.edu/~bcpierce/tapl/}} *{{Cite web|title=Type Safe |work=Portland Pattern Repository Wiki |url=http://c2.com/cgi/wiki?TypeSafe}} *{{Cite journal|last=Wright |first=Andrew K. |coauthors=[[Matthias Felleisen]] |title=A Syntactic Approach to Type Soundness |journal=Information and Computation |volume=115 |issue=1 |pages=38–94 |year=1994 |url=http://citeseer.ist.psu.edu/wright92syntactic.html |doi=10.1006/inco.1994.1093}} *{{Cite journal|first=Stavros |last=Macrakis |title=Safety and power |journal=ACM SIGSOFT Software Engineering Notes |volume=7 |issue=2 |pages=25–26 |month=April |year=1982 |url=http://portal.acm.org/citation.cfm?id=1005937.1005941 |format=requires subscription |doi=10.1145/1005937.1005941}} {{DEFAULTSORT:Type Safety}} [[Category:Type theory]] [[Category:Programming language topics]] [[de:Typsicherheit]] [[fr:Sûreté du typage]] [[zh:型別安全]]</text> </page> <page> <id>38517</id> <title>Type theory</title> <text>In [[mathematics]], [[logic]] and [[computer science]], '''type theory''' is any of several [[formal systems]] that can serve as alternatives to [[naive set theory]], or the study of such formalisms in general. In [[programming language theory]], a branch of [[computer science]], ''type theory'' can refer to the design, analysis and study of [[type system]]s, although some computer scientists limit the term's meaning to the study of abstract formalisms such as [[typed lambda calculus|typed λ-calculi]]. [[Bertrand Russell]] invented the first type theory in response to his discovery that [[Gottlob Frege]]'s version of [[naive set theory]] was afflicted with [[Russell's paradox]]. This theory of types features prominently in [[Alfred North Whitehead|Whitehead]] and [[Bertrand Russell|Russell]]'s ''[[Principia Mathematica]]''. It avoids Russell's paradox by first creating a hierarchy of types, then assigning each mathematical (and possibly other) entity to a type. Objects of a given type are built exclusively from objects of preceding types (those lower in the hierarchy), thus preventing loops. [[Alonzo Church]], inventor of the [[lambda calculus]], developed a [[higher-order logic]] commonly called ''Church's Theory of Types'',<ref name="church">[[Alonzo Church]], [http://www.jstor.org/stable/2266170 ''A formulation of the simple theory of types''], The Journal of Symbolic Logic 5(2):56&ndash;68 (1940)</ref> in order to avoid the [[Kleene–Rosser paradox]] afflicting the original pure lambda calculus. Church's type theory is a variant of the lambda calculus in which expressions (also called formulas or λ-terms) are classified into types, and the types of expressions restrict the ways in which they can be combined. In other words, it is a [[typed lambda calculus]]. Today many other such calculi are in use, including [[Per Martin-Löf]]'s [[Intuitionistic type theory]], [[Jean-Yves Girard]]'s [[System F]] and the [[Calculus of Constructions]]. In typed lambda calculi, types play a role similar to that of [[Set (mathematics)|sets]] in [[set theory]]. ==Simple theory of types== In the 1920s, [[Leon Chwistek]]<ref>L. Chwistek, Antynomje logikiformalnej, Przeglad Filozoficzny 24 (1921) 164–171</ref> and [[Frank P. Ramsey]]<ref>F.P. Ramsey, The foundations of mathematics, Proceedings of the London Mathematical Society, Series 2 25 (1926) 338–384.</ref> noticed that, if one is willing to give up the [[vicious circle principle]], the hierarchy of levels of types in the "ramified theory of types" (see the History section for more on this) can be collapsed. The resulting simplified logic is called the simple theory of types or, more briefly, simple type theory. ST is equivalent with Russell's ramified theory plus the [[Axiom of reducibility]]. Detailed formulations of simple type theory were published in the late 1920s and early 1930s by R. Carnap, K. Gödel, W.V.O. Quine, and A. Tarski. In 1940 [[Alonzo Church]] (re)formulated it as [[simply typed lambda calculus]].<ref>A. Church, A formulation of the simple theory of types, Journal of Symbolic Logic 5 (1940) 56–68.</ref> The following system is Mendelson's (1997, 289–293) '''ST'''. The [[domain of discourse|domain of quantification]] is partitioned into an ascending hierarchy of types, with all [[individual]]s assigned a type. Quantified variables range over only one type; hence the underlying logic is [[first-order logic]]. '''ST''' is "simple" (relative to the type theory of ''[[Principia Mathematica]]'') primarily because all members of the [[relation (mathematics)|domain]] and [[relation (mathematics)|codomain]] of any [[relation (mathematics)|relation]] must be of the same type. There is a lowest type, whose individuals have no members and are members of the second lowest type. Individuals of the lowest type correspond to the [[urelement]]s of certain set theories. Each type has a next higher type, analogous to the notion of [[successor function|successor]] in [[Peano arithmetic]]. While '''ST''' is silent as to whether there is a maximal type, a [[transfinite]] number of types poses no difficulty. These facts, reminiscent of the Peano axioms, make it convenient and conventional to assign a [[natural number]] to each type, starting with 0 for the lowest type. But type theory does not require a prior definition of the naturals. The symbols peculiar to '''ST''' are primed variables and infix <math>\in</math>. In any given formula, unprimed variables all have the same type, while primed variables (<math>x'</math>) range over the next higher type. The [[atomic formula]]s of '''ST''' are of two forms, <math>x=y</math> ([[identity (mathematics)|identity]]) and <math>y\in x'</math>. The [[infix]] symbol <math>\in</math> suggests the intended [[model theory|interpretation]], set membership. All variables appearing in the definition of identity and in the axioms ''Extensionality'' and ''Comprehension'', range over individuals of one of two consecutive types. Only unprimed variables (ranging over the "lower" type) can appear to the left of '<math>\in</math>', where as to its right, only primed variables (ranging over the "higher" type) can appear. The first-order formulation of '''ST''' rules out quantifying over types. Hence each pair of consecutive types requires its own axiom of Extensionality and of Comprehension, which is possible if ''Extensionality'' and ''Comprehension'' below are taken as [[axiom scheme|axiom schemata]] "ranging over" types. * '''Identity''', defined by <math>x=y\leftrightarrow\forall z' [x\in z'\leftrightarrow y\in z']</math>. * '''[[Axiom of extensionality|Extensionality]]'''. An [[axiom schema]]. <math>\forall x[x\in y' \leftrightarrow x\in z'] \rightarrow y'=z'</math>. : Let <math>\Phi(x)</math> denote any [[first-order logic|first-order formula]] containing the [[free variable]] <math>x</math>. * '''Comprehension'''. An [[axiom schema]]. <math>\exists z'\forall x[x\in z'\leftrightarrow \Phi(x)]</math>. : ''Remark''. Any collection 