<source lang="csharp"> class Foo { public int Value; public static implicit operator Foo(int value) { return new Foo(value) } } //Implicit conversion Foo foo = 2; </source> '''Explicit conversion operator'''</br> <source lang="csharp"> class Foo { public int Value; public static explicit operator Foo(int value) { return new Foo(value) } } //Explicit conversion Foo foo = (Foo)2; </source> ====<code>as</code> operator==== The <code>as</code> operator will attempt to do a silent cast to a given type. If it succeeds it will return the object as the new type, if it fails it will return a null reference. <source lang="csharp"> Stream stream = File.Open(@"C:\Temp\data.dat"); FileStream fstream = stream as FileStream; //Will return an object. String str = stream as String; //Will fail and return null. </source> ===Null coalesce operator=== The following <source lang="csharp"> return ifNotNullValue ?? otherwiseValue; </source> Is shorthand for <source lang="csharp"> return ifNotNullValue != null ? ifNotNullValue : otherwiseValue; </source> Meaning that if the content of variable <code>ifNotNullValue</code> is not null, that content will be returned, otherwise the content of variable <code>otherwiseValue</code> is returned. One can also have nullable scalar types such as <source lang="csharp"> int? i = null; </source> (Both new in [[C Sharp 2.0]].) ==Control structures== C# inherits most of the control structures of C/C++ and also adds new ones like the <code>foreach</code> statement. ===Conditional structures=== These structures controls the flow of the program through given conditions. ====<code>if</code> statement==== The <code>if</code> statement is entered when the given condition is true. Single-line case statements do not require block braces although it is mostly preferred by convention. Simple one-line statement: <source lang="csharp"> if (i == 3) ... ; </source> Multi-line with else-block (without any braces): <source lang="csharp"> if (i == 2) ... else ... </source> Recommended coding conventions for an if-statement. <source lang="csharp"> if (i == 3) { ... } else if (i == 2) { ... } else { ... } </source> ====<code>switch</code> statement==== The <code>switch</code> construct serves as a filter for different values. Each value leads to a "case". It is not allowed to fall through cases and therefore the use of the keyword <code>break</code> is required to end a case. Many cases may lead to the same code though. The default case handles all the other cases not handled by the construct. <source lang="csharp"> switch (ch) { case 'A': ... break; case 'B': case 'C': ... break; default: ... break; } </source> ===Iteration structures=== Iteration statements are statements that are repeatedly executed when a given condition is evaluated as true. ====<code>while</code> loop==== <source lang="csharp"> while (i == true) { ... } </source> ====<code>do ... while</code> loop==== <source lang="csharp"> do { ... } while (i == true); </source> ====<code>for</code> loop==== The <code>for</code> loop consists of three parts: ''declaration'', ''condition'' and ''increment''. Any of them can be left out as they are optional. <source lang="csharp"> for (int i = 0; i < 10; i++) { ... } </source> Is equivalent to this code represented with a <code>while</code> statement. <source lang="csharp"> { int i = 0; while (i < 10) { // ... i++; } } </source> ====<code>foreach</code> loop==== The <code>foreach</code> statement is derived from the <code>for</code> statement and makes use of a certain pattern described in C#'s language specification in order to obtain and use an enumerator of elements to iterate over. Each item in the given collection will be returned and reachable in the context of the code block. When the block has been executed the next item will be returned until there are no items remaining. <source lang="csharp"> foreach (int i in intList) { ... } </source> ===Jump statements=== Jump statements are inherited from C/C++ and ultimately assembly languages through it. They simply represent the jump-instructions of an assembly language that controls the flow of a program. ====Labels and <code>goto</code> statement==== Labels are given points in code that can be jumped to by using the <code>goto</code> statement. <source lang="csharp"> start: ... goto start; </source> The <code>goto</code> statement can be used in <code>switch</code> statements to jump from one case to another or to fall through from one case to the next. <source lang="csharp"> switch(n) { case 1: Console.WriteLine("Case 1"); break; case 2: Console.WriteLine("Case 2"); goto case 1; case 3: Console.WriteLine("Case 3"); case 4: // Compilation will fail here as cases cannot fall through in C#. Console.WriteLine("Case 4"); goto default; // This is the correct way to fall through to the next case. default: Console.WriteLine("Default"); } </source> ====<code>break</code> statement==== The <code>break</code> statement breaks out of the closest loop or <code>switch</code> statement. Execution continues in the statement after the terminated statement, if any. <source lang="csharp"> int e = 10; for (int i=0; i < e; i++) { while (true) { break; } // Will break to this point. } </source> ====<code>continue</code> statement==== The <code>continue</code> statement discontinues the current iteration of the current control statement and begins the next iteration. <source lang="csharp"> int ch; while ((ch = GetChar()) >= 0) { if (ch == ' ') continue; // Skips the rest of the while-loop // Rest of the while-loop ... } </source> The <code>while</code> loop in the code above reads characters by calling <code>GetChar()</code>, skipping the statements in the body of the loop if the characters are spaces. ===Exception handling=== C# has a neat way of handling runtime exceptions that is inherited from Java and C/C++ through it. The base class library has a class called <code>System.Exception</code> from which all exceptions are derived. An <code>Exception</code>-object contains all the information about a specific exception and also the inner exceptions that were caused. The programmer may define their own exceptions by deriving from the <code>Exception</code> class. An exception can be thrown this way: <source lang="csharp"> throw new NotImplementedException(); </source> ====<code>try</code> ... <code>catch</code> ... <code>finally</code> statements==== Exceptions are managed within <code>try</code> ... <code>catch</code> blocks. <source lang="csharp"> try { // Statements which may throw exceptions ... } catch (Exception ex) { // Exception caught and handled here ... } finally { // Statements always executed after the try/catch blocks ... } </source> The statements within the <code>try</code> block are executed, and if any of them throws an 