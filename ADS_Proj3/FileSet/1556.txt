number of faces contained in a model. * Sprite images from 3D content. * Keyframe editor. * Character animation using Inverse Kinematics. * Support for up to 4 weighting values per vertex. * Selective subdivision of faces. * Unwrap arbitrary geometry into a plane and save the image into a texture. * View attached objects such as weapons and equipment. * Create your own plugins using LUA script or C++. * Customizable user interface, with support for user-defined scripts. * Convenient splitter. * Keyboard shortcuts. * Set background images into the viewer as a frame of reference. * User-defined classes. * Modify existing classes by adding user-defined properties, methods or events. * Skeletons with up to 255 bones. * Full undo/redo. == Scripting == fragMOTION is fully scriptable, and supports [[Lua (programming language)|Lua]] and [[C++]] scripts.<ref>[http://www.fragmosoft.com/fragMOTION/Help/Content/LuaScript/LuaScript.html Scripting with LUA]</ref><ref>[http://www.garagegames.com/community/blogs/view/11340 Adventures in fragMOTION | Rex | Blogs | Community | GarageGames]</ref> == See also == *[[Gamestudio]] == References == {{reflist}} == External links == * [http://www.fragmosoft.com/fragMOTION/Help/fragMOTION.html Official website] * [http://developer.valvesoftware.com/wiki/Fragmotion Fragmotion - Valve Developer Community] {{DEFAULTSORT:Fragmotion}} [[Category:3D graphics software]] [[Category:Windows-only software]]</text> </page> <page> <id>14085</id> <title>Fragile binary interface problem</title> <text>{{Citations missing|date=May 2009}} The '''fragile binary interface problem''' or '''FBI''' is a shortcoming of certain [[object-oriented programming]] language [[compiler]]s, in which internal changes to an underlying class library can cause descendant libraries or programs to cease working. It is an example of [[software brittleness]]. Note that this problem is more often called the '''fragile base class problem''' or '''FBC'''; however, that term also has a different (but related) sense. (''See'' [[fragile base class]].) ==Cause== The problem occurs due to a "shortcut" used with compilers for many common object-oriented (OO) languages, a design feature that was kept when OO languages were evolving from earlier non-OO [[structured programming]] languages such as [[C (programming language)|C]] and [[Pascal (programming language)|Pascal]]. In these languages there were no objects in the modern sense, but there was a similar construct known as a [[record (computer science)|record]] (or "struct" in C) that held a variety of related information in one piece of memory. The parts within a particular record were accessed by keeping track of the starting location of the record, and knowing the offset from that starting point to the part in question. For instance a "person" record might have a first name, last name and middle initial, to access the initial the programmer writes <code>thisPerson.middleInitial</code> which the compiler turns into something like <code>a = location(thisPerson) + offset(middleInitial)</code>. Modern CPUs typically include instructions for this common sort of access. When object-oriented language compilers were first being developed, much of the existing compiler technology was used, and objects were built on top of the record concept. In these languages the objects were referred to by their starting point, and their public data, known as "fields", were accessed through the known offset. In effect the only change was to add another field to the record, one that lists the various methods (functions), such that the record knows about both its data and functions. When compiled, the offsets are used to access both the data and the code. ==Symptoms== This leads to a problem in larger [[computer program|programs]] when they are constructed from [[library (software)|libraries]]. If the author of the library changes the size or layout of the public fields within the object, the offsets are now invalid and the program will no longer work. This is the FBI problem. Although changes in implementation may be expected to cause problems, the insidious thing about FBI is that nothing ''really'' changed, only the layout of the object that is hidden in a compiled library. One might expect that if you change <code>doSomething</code> to <code>doSomethingElse</code> that it might cause a problem, but in this case you can cause problems without changing <code>doSomething</code>, it can be caused as easily as moving lines of source code around for clarity. Worse, the programmer has little or no control over the resulting layout generated by the compiler, making this problem almost completely hidden from view. In complex object-oriented [[computer program|programs]] or [[library (software)|libraries]] the highest-level classes may be inheriting from tens of classes. Each of those base classes could be inherited by hundreds of other classes as well. These base classes are fragile because a small change to one of them could cause problems for any class that inherits from it, either directly or from inheriting another class that does. This can cause the library to collapse like a house of cards as many classes are damaged by one change to a base class. The problem may not be noticed as the modifications are being written if the inheritance tree is complex. ==Solutions== ===Languages=== The best solution to the fragile binary interface problem is to write a language that knows the problem exists, and does not let it happen in the first place. Most custom-written OO languages, as opposed to those evolved from earlier languages, construct all of their offset tables at load time. Changes to the layout of the library will be "noticed" at that point. Other OO languages, like [[Self (programming language)|Self]], construct everything at runtime by copying and modifying the objects found in the libraries, and therefore do not really have a base class that can be fragile. Some languages, like [[Java (programming language)|Java]], have extensive documentation on what changes are safe to make without causing FBI problems. Another solution is to write out an intermediate file listing the offsets and other information from the compile stage, known as meta-data. The linker then uses this information to correct itself when the library is loaded into an application. Platforms such as [[Microsoft .NET|.NET]] do this. However, the market has selected programming languages such as [[C++]] that are indeed "position dependent" and therefore exhibit FBI. In these cases there are still a number of solutions to the problem. One puts the burden on the library author by having them insert a number of "placeholder" objects in case they need to add additional functionality in the future (this can 