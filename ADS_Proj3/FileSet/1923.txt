C.; Jiajun, B. (2007), “Surface rendering for parallel slice of contours from medical imaging”, Computing in science & engineering, 9(1), January&ndash;February 2007, P 32&ndash;37</ref> and modified by Babkov V.<ref>Babkov, V.S. (2008) “Modification of hierarchical RBF method for 3D-modelling based on laser scan result”. Proc. Int. Conference “Modern problems and achievement of radio, communication and informatics”, Zaporizhzhya National Technical University, [http://babkov.name/article/2008-08.pdf] (in Ukrainian)</ref> ==References== {{reflist}} {{DEFAULTSORT:Hierarchical Rbf}} [[Category:Geometric algorithms]] [[Category:Computer graphics]] [[Category:Interpolation]]</text> </page> <page> <id>16659</id> <title>High-availability Seamless Redundancy</title> <text>{{Wikify|date=August 2010}} '''HSR''' (High-availability Seamless Redundancy, pronounce: HASAR) is a redundancy protocol for [[Ethernet]] (IEEE 802.3) networks. It provides zero-time failover in case of failure of one component. It is therefore suited for applications that demand high availability and very short reaction time, such as protection for electrical substation automation and controllers for synchronized drives, for instance in printing machines. HSR has been standardized by the [[International Electrotechnical Commission]], Geneva, as '''IEC 62439-3 Clause 5'''. It is one of the redundancy protocols selected for substation automation in the IEC 61850 standard. HSR is application-protocol independent and can be used by most Industrial Ethernet of the IEC 61784 suite. The nodes (devices) in an HSR network are attached by two Ethernet ports. A source node sends the same frame over both ports. A destination should receive, in the fault-free state, two identical frames within a certain time skew, forward the first frame to the application and discard the second frame when (and if) it comes. In contrast to [[Parallel Redundancy Protocol|PRP]] (IEC 62439-3- Clause 4), with which it shares the operating principle, HSR nodes can be arranged into a ring, which allows to operate without dedicated switches, since every node is able to forward frames from port to port. HSR originally meant "High-availability Seamless Ring". But its topology is not limited to a single ring, a system of rings with many structures can be built. == External links == * [http://lamspeople.epfl.ch/kirrmann/Pubs/IEC_61439-3/IEC_62439-3.5_HSR_Kirrmann.pps HSR presentation] * [http://lamspeople.epfl.ch/kirrmann/Pubs/IEC_61439-3/WG15-11-yz_62439-3_CDV_081110b.pdf IEC standard draft (not official)] [[Category:Networking standards]] [[ru:High Availability Seamless Ring Redundancy]]</text> </page> <page> <id>16670</id> <title>High-water mark (computer security)</title> <text>{{Context|date=October 2009}} '''High-water mark''' was introduced in Clark Weissmann's ''Security controls in the ADEPT-50 timesharing system'' published in the AFIPS Conference Proceedings, volume 35, pages 119—133. FJCC, 1969. It pre-dates the [[Bell-La Padula model‎|Bell-La Padula]] security model, whose first volume appeared in 1972. Under high-water mark, any object less than the user's security level can be opened, but the object is relabeled to reflect the highest security level currently open. Hence the name. The practical effect of the high-water mark was a gradual movement of all objects towards the highest security level in the system. If user A is writing a CONFIDENTIAL document, and checks the unclassified dictionary, the dictionary becomes CONFIDENTIAL. Then, when user B is writing a SECRET report and checks the spelling of a word, the dictionary becomes SECRET. Finally, if user C is assigned to assemble the daily intelligence briefing at the TOP SECRET level, reference to the dictionary makes the dictionary TOP SECRET, too. ==See also== * [[Watermark (data synchronization)]] * [[Low watermark (computer security)]] {{DEFAULTSORT:High-Water Mark (Computer Security)}} [[Category:Computer security models]] {{Compu-network-stub}}</text> </page> <page> <id>16674</id> <title>High Assurance Guard</title> <text>{{Unreferenced stub|auto=yes|date=December 2009}} A '''High Assurance Guard''' (HAG) is a [[Multilevel security]] computer device which is used to communicate between different [[Security Domains]], such as [[NIPRNet]] to [[SIPRNet]]. A HAG is one example of a [[Controlled Interface]] between security levels. HAGs are approved through the [[Common Criteria]] process. ==Operation== A HAG runs multiple [[virtual machines]] - one subsystem for the lower classification, one subsystem for the higher classification. The hardware runs a type of [[Knowledge Management]] software that examines data coming out of the higher classification subsystem and rejects any data that is classified higher than the lower classification. In general, a HAG allows lower classified data that resides on a higher classified system to be moved to another lower classified system. For example, in the US, it would allow unclassified information residing on a classified secret system to be moved to another unclassified system. Through various rules and filters, the HAG ensures that data is of the lower classification and then allows the transfer. ==Importance, risks== The HAG is mostly used in email and [[Defense Message System|DMS]] environments as certain organizations may only have unclassified network access, and they need to send a message to an organization that has only secret network access. The HAG provides them this ability. == External links == * http://www.deep-secure.com/ [[Category:Computer security]] {{Computer-stub}}</text> </page> <page> <id>16682</id> <title>High Performance Fortran</title> <text>'''High Performance Fortran''' ('''HPF''') is an extension of [[Fortran 90]] with constructs that support [[parallel computing]], published by the ''High Performance Fortran Forum'' (HPFF). The HPFF was convened and chaired by [[Ken Kennedy (computer scientist)|Ken Kennedy]] of [[Rice University]]. The first version of the HPF Report was published in 1993. Building on the array syntax introduced in Fortran 90, HPF uses a [[data parallelism|data parallel]] model of computation to support spreading the work of a single [[Array data structure|array]] computation over multiple processors. This allows efficient implementation on both [[SIMD]] and [[MIMD]] style architectures. HPF features included: * New Fortran statements, such as <code>FORALL</code>, and the ability to create [[pure function|<code>PURE</code>]] ([[side effect (computer science)|side effect]] free) procedures * Compiler directives for recommended distributions of array data * ''Extrinsic procedure'' interface for interfacing to non-HPF parallel procedures such as those using [[message passing]] * Additional library routines - including environmental inquiry, parallel prefix/suffix (e.g., [[prefix sum|'scan']]), data scattering, and [[sorting]] operations Fortran 95 incorporated several HPF capabilities. In response, the HPFF again convened and published the HPF 2.0 Report. The updated report removed material which was already covered by Fortran 95. The report was also reorganized and revised based on experience with HPF 1.0. While some vendors did incorporate HPF into their compilers in the 1990s, some aspects proved difficult to implement and of questionable use. Since then, most vendors and users have moved to [[OpenMP]]-based parallel processing.{{citation needed|date=March 2007}} However HPF continues to have influence. For example the proposed <code>BIT</code> 