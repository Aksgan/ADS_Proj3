solution because he believes it increases the enjoyment of the room by its occupants. Other authors might come to different conclusions, if they place higher value on heating costs, or material costs. These values, used by the pattern's author to determine which solution is "best", must also be documented within the pattern. A pattern must also explain when it is applicable. Since two houses may be very different from one another, a design pattern for houses must be broad enough to apply to both of them, but not so vague that it doesn't help the designer make decisions. The range of situations in which a pattern can be used is called its context. Some examples might be "all houses", "all two-story houses", or "all places where people spend time". The context must be documented within the pattern. For instance, in Christopher Alexander's work, bus stops and waiting rooms in a surgery center are both part of the context for the pattern "A PLACE TO WAIT". == Domain-specific articles == *[[Pattern (architecture)]], a way of capturing and communicating design ideas in architecture. *[[Design pattern (computer science)]], a standard solution to common problems in [[software design]]. *[[Architectural pattern (computer science)]], a standard solution to architectural problems in software engineering. *[[Interaction design pattern]], used in interaction design / HCI. *[[Pedagogical patterns]], documenting good practices in teaching. == See also == * [[Style guide]], repeatable graphic design elements and styles. == References == {{reflist}} == Further reading == * {{cite book |first=Christopher |last=Alexander |authorlink=Christopher Alexander |title=[[A Pattern Language|A Pattern Language: Towns, Buildings, Construction]] |publisher=[[Oxford University Press]] |year=1977 |isbn=0195019199 |ref=Alexander, A Pattern Language }} * Frank Buschmann, [[Kevlin Henney]], [[Douglas C. Schmidt]] [http://media.wiley.com/product_data/excerpt/28/04700590/0470059028.pdf "On Patterns and Pattern Languages"] * {{cite book |title=[[Design Patterns (book)|Design Patterns (the '''Gang of Four''' book)]] |author=Gamma, Helm, Johnson & Vlissides |publisher=Addison-Wesley |year=1994 |isbn=0-201-63361-2 |ref=Gang of Four }} * [[Wolfgang Pree]]. ''Design Patterns for Object-Oriented Software Development'' * Jenifer Tidwell. ''Designing Interfaces'' * {{cite book |author= [[Thomas Erl|Erl, Thomas]] |title=SOA Design Patterns |publisher=Prentice Hall/PearsonPTR |location=New York |year=2009 |pages=864 |isbn=0-13-613516-1 |oclc= |doi=}} {{DEFAULTSORT:Design Pattern}} [[Category:Architectural design]] [[Category:Software design patterns]] [[fa:الگوی طراحی]] [[fr:Patron de conception]] [[ja:デザインパターン]] [[pl:Wzorzec projektowy]] [[th:ดีไซน์แพตเทิร์น]] [[vi:Mẫu thiết kế]] [[zh:设计模式]]</text> </page> <page> <id>10055</id> <title>Design predicates</title> <text>{{Unreferenced|date=January 2007}} '''Design predicates''' are a method, invented by Thomas McCabe, to quantify the complexity of the integration of two units of software. Each of the four types of design predicates have an associated integration complexity rating. For pieces of code that apply more than one design predicate, integration complexity ratings can be combined. The sum of the integration complexity for a unit of code, plus one, is the maximum number of test cases necessary to exercise the integration fully. Though a test engineer can typically reduce this by covering as many previously uncovered design predicates as possible with each new test. Also, some combinations of design predicates might be logically impossible. ==Types of Calls== ===Unconditional Call=== Unit A always calls unit B. This has an integration complexity of 0. For example: unitA::functionA() { unitB->functionB(); } ===Conditional Call=== Unit A may or may not call unit B. This integration has a complexity of 1, and needs two tests: one that calls B, and one that doesn't. unitA::functionA() { if (condition) unitB->functionB(); } ===Mutually Exclusive Conditional Call=== This is like a programming language's switch statement. Unit A calls exactly one of several possible units. Integration complexity is n - 1, where n is the number of possible units to call. unitA::functionA() { switch (condition) { case 1: unitB->functionB(); break; case 2: unitC->functionC(); break; ... default: unitN->functionN(); break; } } ===Iterative Call=== In an iterative call, unit A calls unit B at least once, but maybe more. This integration has a complexity of 1. It also requires two tests: one that calls unit B once, and one test that calls it more than once. unitA::functionA() { do { unitB->functionB(); } while (condition); } ==Combining Calls== Any particular integration can combine several types of calls. For example, unit A may or may not call unit B; and if it does, it can call it one or more times. This integration combines a conditional call, with its integration complexity of 1, and an iterative call, with its integration complexity of 1. The combined integration complexity totals 2. unitA::functionA() { if (someNumber > 0) { for ( i = 0 ; i < someNumber ; i++ ) { unitB->functionB(); } } } Since the number of necessary tests is the total integration complexity plus one, this integration would require 3 tests. In one, where someNumber isn't greater than 0, unit B isn't called. In another, where someNumber is 1, unit B is called once. And in the final, someNumber is greater than 1, unit B is called more than once. ==See also== {{Portal|Software Testing}} * [[Cyclomatic complexity]] * [[Integration testing]] * [[White box testing]] {{DEFAULTSORT:Design Predicates}} [[Category:Software testing]] [[Category:Software metrics]]</text> </page> <page> <id>10056</id> <title>Design rationale</title> <text>[[File:Decision Based Design Structure.jpg|thumb|360px|A Decision Based Design Structure, which spans the areas of [[Engineering Design]], Design Rationale and [[Decision Analysis]].]] A '''Design Rationale''' is an explicit documentation of the [[reason]]s behind [[Decision making|decisions]] made when [[design]]ing a [[system]] or [[Artifact (archaeology)|artifact]]. As initially developed by W.R. Kunz and [[Horst Rittel]], design rationale seeks to provide [[argumentation]]-based structure to the political, collaborative process of addressing [[wicked problems]]. <ref name="Kunz, W. 1970"/> == Overview == A design rationale is the explicit listing of [[Decision making|decisions]] made during a [[design process]], and the reasons why those decisions were made.<ref name="Jarczyk, Alex P. 1992 pp. 577-586">Jarczyk, Alex P.; Löffler, Peter; Shipman III, Frank M. (1992), "Design Rationale for Software Engineering: A Survey", ''25th Hawaii International Conference on System Sciences'', 2, pp. 577-586</ref> Its primary goal is to support [[designer]]s by providing a means to [[document|record]] and [[communicate]] the argumentation and reasoning behind the design process.<ref name="HoAt06"> Horner, J.; Atwood, M.E. (2006), "Effective Design Rationale: Understanding the Barriers", in Dutoit, A.H.; McCall, R.; Mistrík, I. et al., Rationale Management in Software Engineering, Springer Berlin Heidelberg, pp. 73-90</ref> It should therefore 