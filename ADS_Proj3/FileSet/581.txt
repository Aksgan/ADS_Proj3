instance. (see section ''static'') * '''<code>unsafe</code>''' - Specifies an unsafe context, which allows the use of pointers. * '''<code>virtual</code>''' - Specifies that a method or property declaration can be overridden by a derived class. * '''<code>volatile</code>''' - Specifies a field which may be modified by an external process and prevents an optimizing compiler from modifying the use of the field. =====Access modifiers===== The ''access modifiers'', or ''inheritance modifiers'', set the accessibility of classes, methods, and other members. Something marked <code>public</code> can be reached from anywhere. <code>private</code> members can only be accessed from inside of the class they are declared in and will be hidden when inherited. Members with the <code>protected</code> modifier will be ''private,'' but accessible when inherited. <code>internal</code> classes and members will only be accessible from the inside of the declaring assembly. Classes and structs are implicitly <code>internal</code> and members are implicitly <code>private</code> if they do not have an access modifier. <source lang="csharp"> public class Foo { public int Do() { return 0; } public class Bar { } } </source> {| class="wikitable" ! !Unnested types !Members (incl. Nested types) |- !<code>public</code> |yes |yes |- !<code>private</code> |no |yes (default) |- !<code>protected</code> |no |yes |- !<code>internal</code> |yes (default) |yes |- !<code>protected internal</code> |no |yes |- |} =====<code>static</code>===== The <code>static</code> modifier states that a member belongs to the class and not to a specific object. Classes marked static are only allowed to contain static members. Static members are sometimes referred to as ''class members'' since they apply to the class as a whole and not to its instances. <source lang="csharp"> public class Foo { public static void Something() { ... } } //Calling the class method. Foo.Something(); </source> ====Constructors==== A constructor is a special method that is called when an object is going to be initialized. Its purpose is to initialize the members of the object. The main differences between constructors and ordinary methods are that constructors are named after the class and do not return anything. They may take parameters as any method. <source lang="csharp"> class Foo { Foo() { ... } } </source> Constructors can be <code>public</code>, <code>private</code>, or <code>internal</code>. '''See also''' * [[Constructor (computer science)]] ====Destructor==== The destructor is called when the object is being collected by the garbage collector to perform some manual clean-up. There is a default destructor method called <code>finalize</code> that can be overridden by declaring your own. The syntax is similar to the one of constructors. The difference is that the name is preceded by a ~ and it cannot contain any parameters. There cannot be more than one destructor. <source lang="csharp"> class Foo { ... ~Foo() { ... } } </source> Finalizers are always <code>private</code>. '''See also''' * [[Destructor (computer science)]] ====Methods==== Like in C and C++ there are functions that group reusable code. The main difference is that functions just like in Java have to reside inside of a class. A function is therefore called a ''method''. A method has a return value, a name and usually some parameters initialized when it is called with some arguments. It can either belong to an instance of a class or be a static member. <source lang="csharp"> class Foo { int Bar(int a, int b) { return a % b; } } </source> A method is called using <code>.</code> notation on a specific variable, or as in the case of static methods, the name of a type. <source lang="csharp"> Foo foo = new Foo(); int r = foo.Bar(7, 2) Console.WriteLine(r); </source> '''See also''' * [[Method (computer science)]] =====<code>ref</code> and <code>out</code> parameters===== One can explicitly make arguments be passed by reference when calling a method with parameters preceded by keywords <code>ref</code> or <code>out</code>. These managed pointers come in handy when passing value type variables that you want to be modified inside the method by reference. The main difference between the two is that an <code>out</code> parameter must have been assigned within the method by the time the method returns, while ref need not assign a value. <source lang="csharp"> void PassRef(ref int x) { if(x == 2) x = 10; } int Z; PassRef(ref Z); void PassOut(out int x) { x = 2; } int Q; PassOut(out Q); </source> =====Optional parameters===== :''This is a feature of [[C Sharp 4.0]].'' C# 4.0 introduces optional parameters with default values as seen in C++. For example: <source lang="csharp"> void Increment(ref int x, int dx = 1) { x += dx; } int x = 0; Increment(ref x); // dx takes the default value of 1 Increment(ref x, 2); // dx takes the value 2 </source> In addition, to complement optional parameters, it is possible to explicitly specify parameter names in method calls, allowing to selectively pass any given subset of optional parameters for a method. The only restriction is that named parameters must be placed after the unnamed parameters. Parameter names can be specified for both optional and required parameters, and can be used to improve readability or arbitrarily reorder arguments in a call. For example: <source lang="csharp"> Stream OpenFile(string name, FileMode mode = FileMode.Open, FileAccess access = FileAccess.Read) { ... } OpenFile("file.txt"); // use default values for both "mode" and "access" OpenFile("file.txt", mode: FileMode.Create); // use default value for "access" OpenFile("file.txt", access: FileAccess.Read); // use default value for "mode" OpenFile(name: "file.txt", access: FileAccess.Read, mode: FileMode.Create); // name all parameters for extra readability, // and use order different from method declaration </source> Optional parameters make interoperating with COM easier. Previously, C# had to pass in every parameter in the method of the COM component, even those that are optional. For example: <source lang="csharp"> object fileName = "Test.docx"; object missing = System.Reflection.Missing.Value; doc.SaveAs(ref fileName, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing); console.writeline("File saved successfully"); </source> With support for optional parameters, the code can be shortened as <source lang="csharp"> doc.SaveAs(ref fileName); </source> =====<code>extern</code>===== A feature of C# is the ability to call native code. A method signature is simply 