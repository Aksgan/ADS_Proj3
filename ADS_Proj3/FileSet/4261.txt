body, implies knowing the six independent components of the stress tensor <math>(\sigma_{11}, \sigma_{22}, \sigma_{33}, \sigma_{12}, \sigma_{23}, \sigma_{13})\,\!</math>, or the three principal stresses <math>(\sigma_1, \sigma_2, \sigma_3)\,\!</math>, at each material point in the body at that time. However, numerical analysis and analytical methods allow only for the calculation of the stress tensor at a certain number of discrete material points. To graphically represent in two dimensions this partial picture of the stress field different sets of [[contour lines]] can be used<ref>{{Cite book | last = Jaeger | first = John Conrad | coauthors = Cook, N.G.W, & Zimmerman, R.W. | title = Fundamentals of rock mechanics | publisher = Wiley-Blackwell | year = 2007 | pages = 9â€“41 | edition = Fourth | url=http://books.google.com/books?id=FqADDkunVNAC&lpg=PP1&pg=PA10#v=onepage&q=&f=false | isbn = 0632057599}}</ref>: * ''Isobars'' are curves along which the principal stress, e.g., <math>\sigma_1\,\!</math> is constant. * ''Isochromatics'' are curves along which the [[Stress (mechanics)#Maximum and minimum shear stresses|maximum shear stress]] is constant. This curves are directly determined using photoelasticity methods. * ''Isopachs'' are curves along which the [[Stress (mechanics)#Stress deviator tensor|mean normal stress]] is constant * ''Isostatics'' or ''stress trajectories'' are a system of curves which are at each material point tangent to the principal axes of stress. * ''Isoclinics'' are curves on which the principal axes make a constant angle with a given fixed reference direction. These curves can also be obtained directly by photoelasticity methods. * ''Slip lines'' are curves on which the shear stress is a maximum. ==List of stress analysis software== ===General Extensive Packages=== *[[ABAQUS]] *[[ANSYS]] *[[NEi Nastran]] *[[ADINA]] *[[patran]] *[[Nastran]] *[[DIANA]] *[[PAM-MEDYSA]] *[[ALGOR]] ===Specific Packages (Geotechnical, structural,mechanical ..etc) === *[http://www.plaxis.com PLAXIS Geotechnical Software] *[[Midas FEA]] *[[Pro/Engineer|Pro/Mechanica (Pro/Engineer)]] *[[HyperSizer]] *[[MSC Software]] *[[ROHR2 (analysis software)]] *[http://www.coade.com/products/caesarii Caesar II (link to coade website)] ==See also== *[[Forensic engineering]] *[[Structural analysis]] *[[Stress (physics)|Stress]] *[[Piping]] *[[Worst case circuit analysis|Worst Case Circuit Analysis]] ==References== {{reflist}} {{DEFAULTSORT:Stress Analysis}} [[Category:Structural analysis]] [[de:Festigkeitsberechnung]] [[it:Analisi delle sollecitazioni (ASME)]]</text> </page> <page> <id>35902</id> <title>Strict programming language</title> <text>{{Unreferenced|date=October 2006}} A '''strict programming language''' is one in which only [[strict function]]s (functions whose parameters must be evaluated completely before they may be called) may be defined by the user. A '''non-strict programming language''' allows the user to define non-strict functions, and hence may allow [[lazy evaluation]]. == Examples == Nearly all [[programming language]]s in common use today are strict. Examples include [[C (programming language)|C]], [[C++]], [[Java (programming language)|Java]], [[Perl]] (up through version 5), [[Python (programming language)|Python]], [[Ruby (programming language)|Ruby]], [[Common Lisp]], [[Scheme (programming language)|Scheme]], and [[ML (programming language)|ML]]. The best known non-strict languages are [[Haskell (programming language)|Haskell]], [[Miranda (programming language)|Miranda]], and [[Clean (programming language)|Clean]]. == Explanation == In most non-strict languages the non-strictness extends to [[algebraic data type|data constructor]]s. This allows conceptually infinite data structures (such as the list of all [[prime number]]s) to be manipulated in the same way as ordinary finite data structures. It also allows for the use of very large but finite data structures such as the complete [[game tree]] of [[chess]]. Non-strictness has several disadvantages which have prevented widespread adoption: * Because of the uncertainty regarding if and when expressions will be evaluated, non-strict languages generally must be [[purely functional]] to be useful. * All [[computer architecture|hardware architecture]]s in common use are optimized for strict languages, so the best compilers for non-strict languages produce slower code than the best compilers for strict languages, with the notable exception of the [[Glasgow Haskell Compiler]] which outperforms many strict language compilers{{Citation needed|date=April 2010}}. * [[Space complexity]] of non-strict programs is difficult to understand and predict. Strict programming languages are often associated with [[eager evaluation]], and non-strict languages with [[lazy evaluation]], but other [[evaluation strategy|evaluation strategies]] are possible in each case. The terms "eager programming language" and "lazy programming language" are often used as synonyms for "strict programming language" and "non-strict programming language" respectively. In many strict languages, some advantages of non-strict functions can be obtained through the use of [[Macro (computer science)|macros]] or [[thunk]]s. [[Category:Programming paradigms]]</text> </page> <page> <id>35930</id> <title>Strong key</title> <text>{{Expert-subject|Computer science|date=April 2009}} Strong Key is a naming convention used in [[computer programming]]. There can be more than one component (eg: DLL) with the same naming, but with different versions. This can lead to many conflicts. A '''Strong Key''' (also called '''SN Key''' or '''Strong Name''') is used in the [[Microsoft]] [[.NET framework]] to uniquely identify a component. This is done partly with [[Public-key cryptography]]. Strong keys or names provide security of reference from one component to another or from a root key to a component. This is not the same as tamper-resistance of the file containing any given component.<ref>[http://www.codeproject.com/KB/security/NeCoder03.aspx CodeProject: Building Security Awareness in .NET Assemblies : Part 3 - Learn to break Strong Name .NET Assemblies.]</ref> Strong names also are a counter measure against [[dll hell]]. This key is produced by another computer program as a pair. ==External links== *[http://www.codeproject.com/KB/security/StrongNameExplained.aspx CodeProject: Strong Names Explained] *[http://msdn.microsoft.com/en-us/library/wd40t7ad.aspx MSDN: Strong-Named Assemblies] ==References== {{reflist}} [[Category:Programming constructs]] [[Category:.NET framework]] {{compu-prog-stub}}</text> </page> <page> <id>35933</id> <title>Strong reference</title> <text>{{Unreferenced|date=May 2009}} In [[computer programming]], a '''strong reference''' is a normal [[Reference (computer science)|reference]] that protects the referred object from collection by a [[garbage collection (computer science)|garbage collector]]. The term is used to distinguish the reference from [[weak reference]]s. [[Category:Programming constructs]] [[Category:Memory management]] {{compu-lang-stub}}</text> </page> <page> <id>35950</id> <title>Structural complexity theory</title> <text>In [[computational complexity theory]] of [[computer science]], the '''structural complexity theory''' or simply '''structural complexity''' is the study of [[complexity class]]es, rather than computational complexity of individual problems and algorithms. It involves the research of both internal structures of various complexity classes and the relations between different complexity classes.<ref name=jha>[[Juris Hartmanis]], "New Developments in Structural Complexity Theory" (invited lecture), Proc. 15th International Colloquium on Automata, Languages and Programming, 1988 (ICALP 88), ''[[Lecture Notes in Computer Science]]'', vol. 317 (1988), pp. 271-286.</ref> The theory has emerged as a result of (still failing) attempts to resolve the first and still the most important question of this kind, the [[P = NP problem]]. Most of the research is done basing on the assumption of P != NP and on a more far-reaching conjecture that 