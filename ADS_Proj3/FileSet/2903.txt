permitting competing implementations, would prevent the implementation of the system's required functionality.<ref name="Liedtke_95">{{cite conference | first=Jochen | last=Liedtke | authorlink = Jochen Liedtke |title=On µ-Kernel Construction | booktitle = 15th ACM symposium on Operating Systems Principles | pages=237&ndash;250 | year=1995 | month=December |doi=10.1145/224056.224075}}</ref></blockquote> Everything else can be done in a usermode program, although device drivers implemented as user programs may on some processor architectures require special privileges to access I/O hardware. Related to the minimality principle, and equally important for microkernel design, is the [[separation of mechanism and policy]], it is what enables the construction of arbitrary systems on top of a minimal kernel. Any policy built into the kernel cannot be overwritten at user level and therefore limits the generality of the microkernel.<ref name="Liedtke_96"/> Policy implemented in user-level servers can be changed by replacing the servers (or letting the application choose between competing servers offering similar services). For efficiency, most microkernels contain schedulers and manage timers, in violation of the minimality principle and the principle of policy-mechanism separation. Start up ([[booting]]) of a microkernel-based system requires [[device drivers]], which are not part of the kernel. Typically this means that they are packaged with the kernel in the boot image, and the kernel supports a bootstrap protocol that defines how the drivers are located and started; this is the traditional bootstrap procedure of [[L4 microkernel family|L4 Microkernels]]. Some microkernels simplify this by placing some key drivers inside the kernel (in violation of the minimality principle), [[LynxOS]] and the original [[Minix]] are examples. Some even include a [[file system]] in the kernel to simplify booting. On other cases microkernel-based system may boot via multiboot compatible boot loader, [[GNU GRUB]] for example, such systems usually load statically-linked servers to make an initial bootstrap or mount an OS image to continue bootstrapping. A key component of a microkernel is a good [[Inter-process communication|IPC]] system and virtual-memory-manager design that allows implementing page-fault handling and swapping in usermode servers in a safe way. Since all services are performed by usermode programs, efficient means of communication between programs are essential, far more so than in monolithic kernels. The design of the IPC system makes or breaks a microkernel. To be effective, the IPC system must not only have low overhead, but also interact well with CPU scheduling. ==Performance== On most mainstream processors, obtaining a service is inherently more expensive in a microkernel-based system than a monolithic system.<ref name="Liedtke_96"/> In the monolithic system, the service is obtained by a single system call, which requires two ''mode switches'' (changes of the processor's [[ring (computer security)|ring]] or [[CPU modes|CPU mode]]). In the microkernel-based system, the service is obtained by sending an IPC message to a server, and obtaining the result in another IPC message from the server. This requires a [[context switch]] if the drivers are implemented as processes, or a function call if they are implemented as procedures. In addition, passing actual data to the server and back may incur extra copying overhead, while in a monolithic system the kernel can directly access the data in the client's buffers. Performance is therefore a potential issue in microkernel systems. Indeed, the experience of first-generation microkernels such as [[Mach (kernel)|Mach]] and [[ChorusOS|Chorus]] showed that systems based on them performed very poorly.<ref name="Chen_Bershad_93">{{cite conference | first = Bradley | last = Chen | coauthors = Bershad, Brian | title = The Impact of Operating System Structure on Memory System Performance | booktitle = 14th ACM Symposium on Operating System Principles | pages = 120&ndash;33 | publisher = | month = December | year = 1993 | location = Asheville, NC, USA | accessdate = | doi = 10.1145/168619.168629 }}</ref> However, [[Jochen Liedtke]] showed that Mach's performance problems were the result of poor design and implementation, and specifically Mach's excessive [[cache]] footprint.<ref name="Liedtke_95"/> Liedtke demonstrated with his own [[L4 microkernel]] that through careful design and implementation, and especially by following the minimality principle, IPC costs could be reduced by more than an order of magnitude compared to Mach. L4's IPC performance is still unbeaten across a range of architectures.<ref name="Liedtke_ESHHIJ_97">{{cite conference | first = Jochen | last = Liedtke | authorlink = Jochen Liedtke | coauthors = Elphinstone, Kevin; Schönberg, Sebastian; Härtig, Hermann; [[Gernot Heiser|Heiser, Gernot]]; Islam, Nayeem; Jaeger, Trent | title = Achieved IPC performance (still the foundation for extensibility) | booktitle = 6th Workshop on Hot Topics in Operating Systems | pages = 28&ndash;31 | publisher = IEEE | month = May | year = 1997 | location = Cape Cod, MA, USA | url = http://ieeexplore.ieee.org/xpl/RecentCon.jsp?punumber=4643 | accessdate = | id = }}</ref><ref name="Gray_CCMH_05">{{cite conference |first=Charles |last=Gray |coauthors=Chapman, Matthew; Chubb, Peter; Mosberger-Tang, David; [[Gernot Heiser|Heiser, Gernot]] |title=Itanium&mdash;a system implementor's tale |booktitle=USENIX Annual Technical Conference |pages=264&ndash;278 |date=April 2005|location=Annaheim, CA, USA |url=http://www.usenix.org/publications/library/proceedings/usenix05/tech/general/gray.html }}</ref><ref name="vanSchaik_Heiser_07"> {{cite conference | first = Carl | last = van Schaik | coauthors = [[Gernot Heiser|Heiser, Gernot]] | title = High-performance microkernels and virtualisation on ARM and segmented architectures | booktitle = 1st International Workshop on Microkernels for Embedded Systems | pages = 11&ndash;21 | publisher = NICTA | date = January 2007 | location = Sydney, Australia | url = http://ertos.nicta.com.au/publications | accessdate = 2007-04-01 | id = }}</ref> While these results demonstrate that the poor performance of systems based on first-generation microkernels is not representative for second-generation kernels such as L4, this constitutes no proof that microkernel-based systems can be built with good performance. It has been shown that a monolithic Linux server ported to L4 exhibits only a few percent overhead over native Linux.<ref name="Hartig_97">{{cite journal | first = Hermann | last = Härtig | coauthors=Hohmuth, Michael; [[Jochen Liedtke|Liedtke, Jochen]]; Schönberg, Sebastian|title=The performance of µ-kernel-based systems | journal = Proceedings of the sixteenth ACM symposium on Operating systems principles | year=1997 | month = October|id=ISBN 0-89791-916-5 | url = http://portal.acm.org/citation.cfm?id=266660&dl=ACM&coll=&CFID=15151515&CFTOKEN=6184618 | pages=66&ndash;77|doi=10.1145/268998.266660 }}</ref> However, such a single-server system exhibits few, if any, of the advantages microkernels are supposed to provide by structuring operating system functionality into separate servers. A number of commercial multi-server systems 