the global conflict graph are eliminated by atomic commitment) together with Local serializability (i.e., each database system maintains serializability locally; all local cycles are eliminated) imply Global serializability (all cycles are eliminated). This means that if each database system in a multidatabase environment provides local serializability (by ''any'' mechanism) and enforces the ''voting strategy'' in the theorem above (a generalization of CO's voting strategy), then ''Global serializability'' is guaranteed (no local CO is needed anymore). Similarly to CO as well, the ECO ''voting-deadlock'' situation can be summarized as follows: *'''The ECO Voting-Deadlock Theorem''' :Let a multidatabase environment comprise database systems that enforce, each, both ''Global ECO'' (using the condition in the theorem above) and ''local conflict serializability'' (which eliminates local cycles in the global conflict graph). Then, a ''voting-deadlock'' occurs [[if and only if]] a ''global cycle'' (spans two or more databases) exists in the ''Global augmented conflict graph'' (also blocking by a data-access lock is represented by an edge). If the cycle does not break by any abort, then all the ''global transactions'' on it are involved with the respective voting-deadlock, and eventually each has its vote blocked (either directly, or indirectly by a data-access lock). If a local transaction resides on the cycle, it may be in any unaborted state (running, ready, or committed; unlike CO no local commit blocking is needed). As with CO this means that also global deadlocks due to data-access locking (with at least one lock blocking) are voting deadlocks, and are automatically resolved by atomic commitment. ===Multi-version CO (MVCO)=== '''Multi-version Commitment Ordering''' (MVCO; ([[#Raz1993b|Raz 1993b]])) is a generalization of CO for databases with [[Multiversion concurrency control|multi-version resources (data)]]. With such resources ''read-only transactions'' do not block or being blocked for better performance. Utilizing such resources is a common way nowadays to increase concurrency and performance by generating a new version of a database object each time the object is written, and allowing transactions' read operations of several last relevant versions (of each object). MVCO implies ''One-copy-serializability'' (1SER or 1SR) which is the generalization of [[serializability]] for multi-version resources. Like CO, MVCO is non-blocking, and can be combined with any relevant multi-version concurrency control mechanism without interfering with it. In the introduced underlying theory for MVCO conflicts are generalized for different versions of a same resource (differently from earlier multi-version theories). For different versions conflict chronological order is replaced by version order, and possibly reversed, while keeping the usual definitions for conflicting operations. Results for the regular and augmented conflict graphs remain unchanged, and similarly to CO a distributed MVCO enforcing algorithm exists, now for a mixed environment with both single-version and multi-version resources (now single-version is a special case of multi-version). As for CO, the MVCO algorithm needs only (unmodified) [[atomic commitment]] protocol messages with no additional communication overhead. Locking-based global deadlocks translate to voting deadlocks and are resolved automatically. In analogy to CO the following holds: *'''The MVCO and Global one-copy-serializability Theorem''' #MVCO compliance of every ''autonomous'' database system (or transactional object) in a mixed multidatabase environment of single-version and multi-version databases is a ''necessary condition'' for guaranteeing Global one-copy-serializability (1SER). #MVCO compliance of every database system is a ''sufficient condition'' for guaranteeing Global 1SER. #Locking-based global deadlocks are resolved automatically. :'''Comment''': Now a CO compliant single-version database system is automatically also MVCO compliant. MVCO can be further generalized to employ the generalization of ECO (MVECO). See also [[Multiversion concurrency control]]. ====Example: CO based snapshot isolation (COSI)==== '''CO based snapshot isolation''' (COSI) is the intersection of ''[[Snapshot isolation]]'' (SI) with MVCO. SI is a [[multiversion concurrency control]] method widely utilized due to good performance and similarity to serializability (1SER) in several aspects. The theory in (Raz 1993b) for MVCO described above is utilized later in (Fekete et al. 2005) and other articles on SI, e.g., (Cahill et al. 2008);<ref name=Cahill08>Michael J. Cahill, Uwe RÃ¶hm, Alan D. Fekete (2008): [http://portal.acm.org/citation.cfm?id=1376690 "Serializable isolation for snapshot databases"], ''Proceedings of the 2008 ACM SIGMOD international conference on Management of data'', pp. 729-738, Vancouver, Canada, June 2008, ISBN 978-1-60558-102-6 (SIGMOD 2008 best paper award</ref> see also [[Snapshot isolation#Making Snapshot Isolation Serializable|Making snapshot isolation serializable]] and the references there), for analyzing conflicts in SI in order to make it serializable. The method presented in (Cahill et al. 2008), ''Serializable snapshot isolation'' ([[Snapshot isolation#Making Snapshot Isolation Serializable|SerializableSI]]), a low overhead modification of SI, provides good performance results versus SI, with only small penalty for enforcing serializability. The first article above is unaware of MVCO and does not reference it, but later articles on the subject reference it. These articles utilize the theory without using MVCO itself. A different method, by combining SI with MVCO (COSI), makes SI serializable as well, with a relatively low overhead, similarly to combining the generic CO algorithm with single-version mechanisms. Furthermore, the resulting combination, COSI, being MVCO compliant, allows COSI compliant database systems to inter-operate and transparently participate in a CO solution for distributed/global serializability (see below). However, no performance results about COSI are known yet, and it is unclear how it compares with SerializableSI. Besides overheads also protocols' behaviors need to be compared quantitatively: On one hand, all serializable SI schedules can be made MVCO by COSI (by possible commit delays when needed, a minus) without aborting transactions (a plus). On the other hand, SerializableSI is known to unnecessarily abort and restart certain percentages of transactions also in serializable SI schedules (a minus). ===CO and its variants are transparently interoperable for global serializability=== With CO and its variants (e.g., SS2PL, SCO, OCO, ECO, and MVCO above) global serializability is achieved via ''[[atomic commitment]]'' protocol based distributed algorithms. For CO and all its variants atomic commitment protocol is the instrument to eliminate global cycles (cycles that span two or more databases) in the ''global augmented'' (and thus also regular) ''conflict graph'' (implicitly; no global data structure implementation is needed). In cases of either incompatible local commitment orders in two or more databases (when no global [[partial order]] can [[Embedding|embed]] the respective local partial orders 