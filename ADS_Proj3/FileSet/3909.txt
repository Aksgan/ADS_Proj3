[[Category:Parser generators]] [[Category:Free software programmed in Java]]</text> </page> <page> <id>33287</id> <title>Schedule (workplace)</title> <text>{{Citations missing|date=June 2008}} [[Image:WeeklySchedule.png|thumb|300px|An example of a weekly workplace schedule]] A '''[[wikt:schedule#English|schedule]]''', often called a '''rota''', is a list of [[employment|employees]] who are working on any given day, week, or month in a [[wiktionary:Workplace|workplace]]. A schedule is necessary for the day-to-day operation of any [[retailing|retail store]] or [[manufacturing]] facility. The process of creating a schedule is called '''scheduling'''. An effective workplace schedule balances the needs of employees, tasks, and in some cases, [[customer]]s. A ''daily'' schedule is usually ordered [[chronology|chronologically]], which means the first employees working that day are listed at the top, followed by the employee who comes in next, ''et cetera''. A ''weekly'' or ''monthly'' schedule is usually ordered [[collation|alphabetically]], employees being listed on the left hand side of a grid, with the days of the week on the top of the grid. A schedule is most often created by a [[Management|manager]]. In larger operations, a [[Human resources|Human Resources]] manager or scheduling [[specialist (disambiguation)|specialist]] may be solely dedicated to writing the schedule. A schedule by this definition is sometimes referred to as [[workflow]]. In some cases [[employee scheduling software|scheduling software]] is used to allow organizations to better manage staff scheduling. Employee scheduling software supports shift and employee assignments and improves staff utilization.<ref>http://www.goalsystems.com/index.php?option=com_content&task=view&id=256&Itemid=54&lang=en GoalBus and GoalDriver softwares for improving staff and vehicle utilization</ref> Organizations commonly use [[spreadsheet]] software or employee scheduling software to create and manage shifts, assignments, and employee preferences. == See also == * [[Shift work]] * Graphical or at a glance staff scheduling * [[Timebar scheduling]] * [[Field Service Management]] * [[Employee scheduling software]] [[Category:Employment]] [[Category:Process management]] == References == {{Reflist}} {{Business-stub}}</text> </page> <page> <id>33289</id> <title>Scheduled-task pattern</title> <text>{{Unreferenced|date=November 2008}} A '''scheduled-task pattern''' is a type of [[design pattern (computer science)|software design pattern]] used with real-time systems. It is not to be confused with the "[[scheduler pattern]]". While the [[scheduler pattern]] delays access to a resource (be it a function, variable, or otherwise) only as long as absolutely needed, the scheduled-task pattern delays execution until a determined time. This is important in real-time systems for a variety of reasons. ==See also== *[[Command pattern]] *[[Memento pattern]] [[Category:Software design patterns]] {{compu-stub}}</text> </page> <page> <id>33291</id> <title>Scheduler pattern</title> <text>{{Unreferenced|date=December 2009}} In [[computer programming]], the '''scheduler pattern''' is a [[software design pattern]]. It is a [[Concurrency (computer science)|concurrency]] pattern used to explicitly control when [[thread (software engineering)|thread]]s may [[execution (computers)|execute]] single-threaded [[source code|code]], like write operation to a file. The scheduler pattern uses an object that explicitly sequences waiting threads. It provides a mechanism to implement a [[scheduling policy]], but is independent of any specific scheduling policy &mdash; the policy is encapsulated in its own class and is reusable. The [[Read write lock pattern|read/write lock pattern]] is usually implemented using the scheduler pattern to ensure fairness in scheduling. Note that the scheduler pattern adds significant overhead beyond that required to call a synchronized [[method (computer science)|method]]. The scheduler pattern is not quite the same as the [[scheduled-task pattern]] used for real-time systems. ==See also== *[[Mediator pattern]] {{DEFAULTSORT:Scheduler Pattern}} [[Category:Software design patterns]] {{Comp-sci-stub}} [[ru:Scheduler]]</text> </page> <page> <id>33294</id> <title>Scheduling algorithm</title> <text>In [[computer science]], a '''scheduling algorithm''' is the method by which [[Thread (computer science)|threads]], [[Process (computing)|processes]] or data [[Flow (computer networking)|flows]] are given access to system resources (e.g. processor time, communications bandwidth). This is usually done to [[Load balancing (computing)|load balance]] a system effectively or achieve a target [[quality of service]]. The need for a scheduling algorithm arises from the requirement for most modern systems to perform [[computer multitasking|multitasking]] (execute more than one process at a time) and [[multiplexing]] (transmit multiple flows simultaneously). ==In computing and multitasking== The algorithm used may be as simple as [[Round-robin scheduling|round-robin]] in which each process is given equal time (for instance 1 ms, usually between 1 ms and 100 ms) in a cycling list. So, process A executes for 1 ms, then process B, then process C, then back to process A. More advanced algorithms take into account process priority, or the importance of the process. This allows some processes to use more time than other processes. The kernel always uses whatever resources it needs to ensure proper functioning of the system, and so can be said to have infinite priority. In [[Symmetric multiprocessing|SMP]](symmetric multiprocessing) systems, [[processor affinity]] is considered to increase overall system performance, even if it may cause a process itself to run more slowly. This generally improves performance by reducing [[cache thrashing]]. ==In computer networks and multiplexing== In [[packet-switched]] [[computer networks]] and other [[statistical multiplexing]], the notion of a '''scheduling algorithm''' is used as an alternative to [[FIFO (computing)|first-come first-served]] queuing of data packets. The simplest best-effort scheduling algorithms are [[round-robin scheduling|round-robin]], [[fair queuing]] (a [[max-min fair]] scheduling algorithm), [[proportionally fair]] scheduling and [[maximum throughput scheduling|maximum throughput]]. If differentiated or guaranteed [[quality of service]] is offered, as opposed to best-effort communication, [[weighted fair queuing]] may be utilized. In advanced packet radio wireless networks such as [[HSDPA]] (High-Speed Downlink Packet Access ) [[3.5G]] cellular system, '''channel-dependent scheduling''' may be used to take advantage of [[channel state information]]. If the channel conditions are favourable, the [[throughput]] and [[system spectral efficiency]] may be increased. In even more advanced systems such as [[LTE_Advanced|LTE]], the scheduling is combined by channel-dependent packet-by-packet [[dynamic channel allocation]], or by assigning [[OFDMA]] multi-carriers or other [[frequency-domain equalization]] components to the users that best can utilize them. ==In computer I/O== Determines the order in which disk I/O requests are pushed to the disk device. ==See also== * [[Atropos scheduler]] * [[Completely Fair Scheduler]] * [[Dynamic priority scheduling]] * [[Earliest deadline first scheduling]] * [[Foreground-background]] * [[I/O scheduling]] * [[Job Shop Scheduling]] * [[Least slack time scheduling]] * [[Lottery scheduling]] * [[Multilevel feedback queue]] * [[O(1) scheduler]] * [[Rate-monotonic scheduling]] * [[Round-robin scheduling]] * [[Scheduling (communications)]] * [[Scheduling (computing)]] ==External links== * [http://joshaas.net/linux/ Josh Aas' introduction to the Linux 2.6.8.1 CPU scheduler implementation] * Peter Brucker, Sigrid Knust. Complexity results for scheduling problems [http://www.mathematik.uni-osnabrueck.de/research/OR/class/] *[http://rtime.felk.cvut.cz/scheduling-toolbox TORSCHE Scheduling Toolbox for Matlab] is a toolbox of 