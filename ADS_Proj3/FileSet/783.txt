SCO has shorter average blocking periods, and more concurrency (e.g., performance simulations of a single database for the most significant variant of ''[[locks with ordered sharing]],'' which is identical to SCO, clearly show this, with approximately 100% gain for some transaction loads; also for identical transaction loads SCO can reach higher transaction rates than SS2PL before ''lock [[Thrashing (computer science)|thrashing]]'' occurs). More concurrency means that with given computing resources more transactions are completed in time unit (higher transaction rate, [[throughput]]), and the average duration of a transaction is shorter (faster completion; see chart). The advantage of SCO is especially significant during lock contention. *'''The SCO Vs. SS2PL Performance Theorem''' :SCO provides shorter average transaction completion time than SS2PL, if read-write conflicts exist. SCO and SS2PL are identical otherwise (have identical blocking behavior with write-read and write-write conflicts). SCO is as practical as SS2PL since as SS2PL it provides besides serializability also strictness, which is widely utilized as a basis for efficient recovery of databases from failure. An SS2PL mechanism can be converted to an SCO one for better performance in a straightforward way without changing recovery methods. SS2PL is a [[proper subset]] of SCO (which is another explanation why SCO is less constraining and provides more concurrency than SS2PL). ===Optimistic CO (OCO)=== For implementing '''[[Optimistic concurrency control|Optimistic]] commitment ordering''' (OCO) the [[Commitment ordering#A generic local CO algorithm|generic local CO algorithm]] above is utilized without data access blocking, and thus without local deadlocks. OCO without transaction or operation scheduling constraints covers the entire CO class, and is not a special case of the CO class, but rather a useful CO variant and mechanism characterization. See also [[Commitment ordering#Distributed optimistic CO (DOCO)|Distributed optimistic CO (DOCO)]] above: All transactional data managers (resource managers) there employ OCO. ===Extended CO (ECO)=== ====General characterization of ECO==== '''Extended Commitment Ordering''' (ECO; ([[#Raz1993a|Raz 1993a]])) generalizes CO. When local transactions (transactions confined to a single database) can be distinguished from global (distributed) transactions (transactions that span two databases or more), commitment order is applied to global transactions only. Thus, for a local (to a database) schedule to have the ECO property, the chronological (partial) order of commit events of global transactions only (unimportant for local transactions) is consistent with their order on the respective local conflict graph. *'''Definition - Extended commitment ordering''' :Let <math>T_{1}, T_{2}</math> be two committed ''global'' transactions in a schedule, such that a ''directed path'' of unaborted transactions exists in the ''conflict graph'' ([[precedence graph]]) from <math>T_{1}</math> to <math>T_{2}</math> (<math>T_{1}</math> precedes <math>T_{2}</math>, possibly [[transitive relation|transitively]], indirectly). The schedule has the '''Extended commitment ordering''' (ECO) property, if for every two such transactions <math>T_{1}</math> commits before <math>T_{2}</math> commits. A distributed algorithm to guarantee global ECO exists. As for CO, the algorithm needs only (unmodified) [[atomic commitment]] protocol messages. In order to guarantee global serializability, each database needs to guarantee also the conflict serializability of its own transactions by any (local) concurrency control mechanism. * '''The ECO and Global Serializability Theorem''' #(Local, which implies global) ECO together with local conflict serializability, is a sufficient condition to guarantee global conflict serializability. #When no concurrency control information beyond atomic commitment messages is shared outside a database (autonomy), and local transactions can be identified, it is also a necessary condition. :See a necessity proof in ([[#Raz1993a|Raz 1993a]]). This condition (ECO with local serializability) is weaker than CO, and allows more concurrency at the cost of a little more complicated local algorithm (however, no practical overhead difference with CO exists). When all the transactions are assumed to be global (e.g., if no information is available about transactions being local), ECO reduces to CO. ====The ECO algorithm==== Before a global transaction is committed, a generic local (to a database) ECO algorithm aborts a minimal set of undecided transactions (neither committed, nor aborted; either local transactions, or global that run locally), that can cause later a cycle in the conflict graph. This set of aborted transactions (not unique, contrary to CO) can be optimized , if each transaction is assigned with a weight (that can be determined by transaction's importance and by the computing resources already invested in the running transaction; optimization can be carried out, for example, by a reduction from the ''[[Max flow in networks]]'' problem ([[#Raz1993a|Raz 1993a]])). Like for CO such a set is time dependent, and becomes empty eventually. Practically, almost in all needed implementations a transaction should be committed only when the set is empty (and no set optimization is applicable). The local (to the database) concurrency control mechanism (separate from the ECO algorithm) ensures that local cycles are eliminated (unlike with CO, which implies serializability by itself; however, practically also for CO a local concurrency mechanism is utilized, at least to ensure Recoverability). Local transactions can be always committed concurrently (even if a precedence relation exists, unlike CO). When the overall transactions' local partial order (which is determined by the local conflict graph, now only with possible temporary local cycles, since cycles are eliminated by a local serializability mechanism) allows, also global transactions can be voted on to be committed concurrently (when all their [[transitive relation|transitively]] (indirect) preceding (via conflict) ''global'' transactions are committed, while transitively preceding local transactions can be at any state. This in analogy to the distributed CO algorithm's stronger concurrent voting condition, where all the transitively preceding transactions need to be committed). The condition for guaranteeing ''Global ECO'' can be summarized similarly to CO: *'''The Global ECO Enforcing Voting Strategy Theorem''' :Let <math>T_{1}, T_{2}</math> be undecided (neither committed nor aborted) ''global transactions'' in a database system that ensures serializability locally, such that a ''directed path'' of unaborted transactions exists in the ''local conflict graph'' (that of the database itself) from <math>T_{1}</math> to <math>T_{2}</math>. Then, having <math>T_{1}</math> ended (either committed or aborted) before <math>T_{2}</math> is voted on to be committed, in every such database system in a multidatabase environment, is a [[necessary and sufficient condition]] for guaranteeing Global ECO (the condition guarantees Global ECO, which may be violated without it). Global ECO (all global cycles in 