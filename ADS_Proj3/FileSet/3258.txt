do the barking. ===Message passing=== {{Main|Message passing}} "The process by which an object sends data to another object or asks the other object to invoke a method."<ref name="ArmstrongQuarks"/> Also known to some programming languages as interfacing. For example, the object called <code>Breeder</code> may tell the <code>Lassie</code> object to sit by passing a "sit" message that invokes Lassie's "sit" method. The syntax varies between languages, for example: <code>[Lassie sit]</code> in Objective-C. In Java, code-level message passing corresponds to "method calling". Some dynamic languages use double-dispatch or [[Multiple dispatch|multi-dispatch]] to find and pass messages. Method is a block of code which we call multiple times,supports re-useability [<modifiers>]<void/type><name>([<parameters>]) { statement; } ===Abstraction=== {{Main|Abstraction (computer science)}} Abstraction means grouping the common behaviors. Abstraction refers to the act of representing essential features without including the background details or explanations. Classes use the concept of abstraction and are defined as a list of abstract attributes. <br /> Abstraction is a mechanism where we hide the implementation or another way of looking , we want to achieve loose coupling. ===Encapsulation=== {{Main|Encapsulation (object-oriented programming)}} Encapsulation conceals the functional details of a class from objects that send messages to it. For example, the <code>Dog</code> class has a <code>bark()</code> method variable, data. The code for the <code>bark()</code> method defines exactly how a bark happens (e.g., by <code>inhale()</code> and then <code>exhale()</code>, at a particular pitch and volume). Timmy, <code>Lassie</code>'s friend, however, does not need to know exactly how she barks. Encapsulation is achieved by specifying which classes may use the members of an object. The result is that each object exposes to any class a certain ''[[interface (computer science)|interface]]'' — those members accessible to that class. The reason for encapsulation is to prevent clients of an interface from depending on those parts of the implementation that are likely to change in the future, thereby allowing those changes to be made more easily, that is, without changes to clients. For example, an interface can ensure that puppies can only be added to an object of the class <code>Dog</code> by code in that class. Members are often specified as '''public''', '''protected''' or '''private''', determining whether they are available to all classes, sub-classes or only the defining class. Some languages go further: [[Java (programming language)|Java]] uses the '''default''' access modifier to restrict access also to classes in the same package, [[C Sharp (programming language)|C#]] and [[Visual Basic.NET|VB.NET]] reserve some members to classes in the same assembly using keywords '''internal''' (C#) or '''Friend''' (VB.NET). [[Eiffel (programming language)|Eiffel]] and [[C++]] allow one to specify which classes may access any member. ===Inheritance=== {{Main|Inheritance (object-oriented programming)}} Inheritance allows the programmer to treat derived class members just like their parent class's members. This type of relationship is called child-Parent or is-a relationship. "Subclasses" are more specialized versions of a class, which ''inherit'' attributes and behaviors from their parent classes, and can introduce their own. For example, the class <code>Dog</code> might have sub-classes called <code>Collie</code>, <code>Chihuahua</code>, and <code>GoldenRetriever</code>. In this case, <code>Lassie</code> would be an instance of the <code>Collie</code> subclass. Suppose the <code>Dog</code> class defines a method called <code>bark()</code> and a property called <code>furColor</code>. Each of its sub-classes (<code>Collie</code>, <code>Chihuahua</code>, and <code>GoldenRetriever</code>) will inherit these members, meaning that the programmer only needs to write the code for them once. Each subclass can alter its inherited traits. For example, the <code>Collie</code> subclass might specify that the default <code>furColor</code> for a collie is brown-and-white. The <code>Chihuahua</code> subclass might specify that the <code>bark()</code> method produces a high pitch by default. Subclasses can also add new members. The <code>Chihuahua</code> subclass could add a method called <code>tremble()</code>. So an individual chihuahua instance would use a high-pitched <code>bark()</code> from the <code>Chihuahua</code> subclass, which in turn inherited the usual <code>bark()</code> from <code>Dog</code>. The chihuahua object would also have the <code>tremble()</code> method, but <code>Lassie</code> would not, because she is a <code>Collie</code>, not a <code>Chihuahua</code>. In fact, inheritance is an "'''''a''… is a'''" relationship between classes, while instantiation is an "'''is a'''" relationship between an object and a class: '''''a''''' <code>Collie</code> ''is a'' <code>Dog</code> ("a… is a"), but <code>Lassie</code> ''is a'' <code>Collie</code> ("is a"). Thus, the object named <code>Lassie</code> has the methods from both classes <code>Collie</code> and <code>Dog</code>. [[Multiple inheritance]] is inheritance from more than one ancestor class, neither of these ancestors being an ancestor of the other. For example, independent classes could define <code>Dog</code>s and <code>Cat</code>s, and a <code>Chimera</code> object could be created from these two that inherits all the (multiple) behavior of cats and dogs. This is not always supported, as it can be hard to implement. ===(Subtype) polymorphism=== {{Main|Subtype polymorphism}} Polymorphism is a process in which a class has all the state and behavior of another class. More precisely, [[Polymorphism in object-oriented programming]] is the ability of [[Object (computer science)|objects]] belonging to different [[data type]]s to respond to calls of [[Method (computer science)|methods]] of the same name, each one according to an appropriate type-specific behavior. One method, or an operator such as +, -, or *, can be abstractly applied in many different situations. If a <code>Dog</code> is commanded to <code>speak()</code>, this may elicit a <code>bark()</code>. However, if a <code>Pig<code> is commanded to <code>speak()</code>, this may elicit an <code>oink()</code>. Each subclass overrides the <code>speak()</code> method inherited from the parent class <code>Animal</code>. ===Decoupling=== Decoupling allows for the separation of object interactions from classes and inheritance into distinct layers of abstraction. A common use of decoupling is to polymorphically decouple the encapsulation, {{Clarify|date=August 2010}} which is the practice of using reusable code to prevent discrete code modules from interacting with each other. However, in practice decoupling often involves trade-offs with regard to which patterns of change to favor. The science of measuring these trade-offs in respect to actual change in an objective way is still in its infancy.{{Citation needed|date=August 2010}} ==Formal definition== There have been several attempts at formalizing the concepts used in object-oriented programming. The following concepts and constructs have been used as interpretations of OOP concepts: * [[F-Coalgebra|coalgebraic datatypes]]{{Dubious|Formal def issues|date=August 2009}} * [[abstract data type]]s (which have [[existential types]]) allow the definition of [[Module (programming)|modules]] 