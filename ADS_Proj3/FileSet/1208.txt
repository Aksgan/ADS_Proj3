should maintain a list of TPMs identified by their EK known to be rogue and reject requests from them, secondly if a privacy CA receives too many requests from a particular TPM it may reject them and blacklist the TPMs EK. The number of permitted requests should be subject to a risk management exercise. This solution is problematic since the privacy CA must take part in every transaction and thus must provide high availability whilst remaining secure. Furthermore privacy requirements may be violated if the privacy CA and verifier collude. Although the latter issue can probably be resolved using blind signatures, the first remains. == Overview == The DAA protocol is based on three entities and two different steps. The entities are the TPM platform, the DAA Issuer and the DAA verifier. The issuer is charged to verify the TPM platform during the Join step and to issue DAA credential to the platform. The platform uses the DAA credential with the verifier during the Sign step. Through a [[zero-knowledge proof]] the verifier can verify the credential without attempting to violate the platform's privacy. The protocol also supports a blacklisting capability so that verifiers can identify attestations from TPM's that have been compromised. == Privacy properties == The protocol allows differing degrees of privacy. Interactions are always anonymous, but the user/verifier may negotiate as to whether the verifier is able to link transactions. This would allow user profiling and/or the rejection of requests originating from a host which has made too many requests. ==See also== * [[Cryptographic protocol]] * [[Digital credential]] * [[Trusted platform module]] * [[Privacy enhancing technologies]] ==References== <references/> ==External links== * E. Brickell, J. Camenisch, and L. Chen: ''Direct anonymous attestation''. In Proceedings of 11th ACM Conference on Computer and Communications Security, ACM Press, 2004. ([http://www.zurich.ibm.com/~jca/papers/brcach04.pdf PDF]) * E. Brickell, J. Camenisch, and L. Chen: ''Direct anonymous attestation'' . ([http://eprint.iacr.org/2004/205.pdf]) * [http://www.ma.rhul.ac.uk/techreports/2005/RHUL-MA-2005-13.pdf ''Interdomain User Authentication and Privacy''] by Andreas Pashalidis - section 6 provides a useful introduction to DAA * [http://www.zurich.ibm.com/security/idemix/ ''IBM idemix (identity mixer)''] an 'anonymous credential system' under development by IBM * Heiko Stamer - [http://www.theory.informatik.uni-kassel.de/~stamer/KryptoTag_Bochum.pdf Implementing Direct Anonymous Attestation for the TPM Emulator Project ] [[Category:Cryptography]] [[Category:Internet privacy]] [[it:Direct Anonymous Attestation]]</text> </page> <page> <id>10576</id> <title>Direct binding</title> <text>{{Orphan|date=February 2009}} '''Direct binding''' is a feature of the [[Linker (computing)|linker]] and [[dynamic linker]] on [[Solaris Operating System|Solaris]] and [[OpenSolaris]]. It provides a method to allow libraries to directly bind symbols to other libraries, rather than weakly bind to them and leave the dynamic linker to figure out which library contains the symbol. == Theory == When linking a shared library or dynamic linked executable, the linker normally populates the [[symbol table]] for that library with all symbols used. Symbols in the current object are added with their offset; while those which are not defined in the object are left unresolved. Unresolved symbols still have to be known at link time, however; the linker is passed shared libraries to link with and, when it finds a symbol in another library, places a note in the output library indicating that it depends on these other shared libraries. This kind of weak linking forces the dynamic linker to resolve which library contains which symbol when the executable is run. The dynamic linker on Linux, for example, will read through the DT_NEEDED section of an [[Executable and Linkable Format|ELF]] object and load the needed libraries; but it won't be told where the symbols it needs are. For this, it has to iterate through each unresolved symbol in the object; and for each of these, iterate through each loaded library, checking for a matching symbol, until it finds one. This can be very time consuming. Direct linking works around this problem by storing an equivalent list of pointers to DT_NEEDED entries in a separate ELF section. Each pointer corresponds to a symbol in the object; thus, these pointers create a relation between a symbol and a DT_NEEDED entry. This allows the linker to locate the library specified by a particular DT_NEEDED entry and check only its symbol table for each symbol, rather than iterate through potentially every library for every symbol. == References == *[http://blogs.sun.com/roller/page/msw/20050614 Library Bindings - let's be a little bit more precise shall we] == External links == *[http://bugs.gentoo.org/114008 Work on a direct binding implementation for Gentoo Linux] [[Category:OpenSolaris]] {{unix-stub}}</text> </page> <page> <id>10585</id> <title>Direct method in the calculus of variations</title> <text>In the [[calculus of variations]], a topic in [[mathematics]], '''the direct method''' is a general method for constructing a proof of the existence of a minimizer for a given [[Functional (mathematics)|functional]]<ref>Dacorogna, pp. 1&ndash;43.</ref>. The method relies on methods of [[functional analysis]] and [[topology]]. As well as being used to prove the existence of a solution, direct methods may be used to compute the solution to desired accuracy.<ref>{{cite book |title=Calculus of Variations |coauthors=I. M. Gelfand, S. V. Fomin |year=1991 |publisher=Dover Publications |isbn=978-0-486-41448-5}}</ref> == The method == The calculus of variations deals with functionals <math>J:V\to\bar\mathbb{R}</math>, where <math>V</math> is some [[function space]] and <math>\bar\mathbb{R} = \mathbb{R} \cup \infty</math>. The main interest of the subject is to find ''minimizers'' for such functionals, that is, functions <math>v \in V</math> such that :<math>J(v) \leq J(u)\text{ for every }u \in V. \, </math> The standard tool for obtaining necessary conditions for a function to be a minimizer is the [[Euler&ndash;Lagrange equation]]. But seeking a minimizer amongst functions satisfying these may lead to false conclusions if the existence of a minimizer is not established beforehand. The functional <math>J</math> must be bounded from below to have a minimizer. This means :<math>\inf\{J(u)|u\in V\} > -\infty.\,</math> It is not enough to know that a minimizer exists, but it shows the existence of a ''minimizing sequence'', that is, a sequence <math>(u_n)</math> in <math>V</math> such that :<math>J(u_n) \to \inf\{J(u)|u\in V\}. \, </math> The direct method may broken into the following steps # Take a minimizing sequence <math>(u_n)</math> for <math>J</math>. # Show that <math>(u_n)</math> admits some [[subsequence]] <math>(u_{n_k})</math>, that converges to a <math>u_0\in V</math> with respect to a topology <math>\tau</math> on <math>V</math>. # Show 