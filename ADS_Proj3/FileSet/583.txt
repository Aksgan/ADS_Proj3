} double IBinaryOperation.GetResult() { return A + B; } } </source> In use: <source lang="csharp"> Adder add = new Adder(); // These members are not accessible. // add.A = 2; // add.B = 3; // double result = add.GetResult(); //Cast to the interface type to access them. IBinaryOperation add2 = add; add2.A = 2; add2.B = 3; double result = add2.GetResult(); </source> '''Note:''' The properties in the class that extends <code>IBinaryOperation</code> are auto-implemented by the compiler. Both get a backingfield. '''Extending multiple interfaces''' Interfaces and classes are allowed to extend multiple interfaces. <source lang="csharp"> class MyClass : IInterfaceA, IInterfaceB { ... } </source> Here is a interface that extends two interfaces. <source lang="csharp"> interface IInterfaceC : IInterfaceA, IInterfaceB { ... } </source> ====Interfaces vs . Abstract classes ==== Interfaces and abstract classes are similar. The following describes some important differences: * An abstract class may have member variables as well as non-abstract methods or properties. An interface cannot. * A class or abstract class can only inherit from one class or abstract class. * A class or abstract class may implement one or more interfaces. * An interface can only extend other interfaces. * An abstract class may have non-public methods and properties (also abstract ones). An interface can only have public members. * An abstract class may have constants, static methods and static members. An interface cannot. * An abstract class may have constructors. An interface cannot. ==Generics== :''This is a feature of [[C Sharp 2.0]] and [[.NET Framework 2.0]].'' [[generic programming|Generics]], or parameterized types, or [[polymorphism in object-oriented programming#Parametric Polymorphism|parametric polymorphism]] is a .NET 2.0 feature supported by C#. Unlike C++ templates, .NET parameterized types are instantiated at runtime rather than by the compiler; hence they can be cross-language whereas C++ templates cannot. They support some features not supported directly by C++ templates such as type constraints on generic parameters by use of interfaces. On the other hand, C# does not support non-type generic parameters. Unlike generics in Java, .NET generics use [[reification (computer science)|reification]] to make parameterized types first-class objects in the [[Common Language Infrastructure]] (CLI) Virtual Machine, which allows for optimizations and preservation of the type information.<ref>{{cite web |url=http://msdn.microsoft.com/en-us/library/ms379564.aspx |title=An Introduction to C# Generics |month=January |year=2005 |publisher=[[Microsoft]] |accessdate=June 18, 2009 }}</ref> '''See also''' * [[Generic programming]] ===Using Generics=== ====Generic classes==== Classes and structs can be generic. <source lang="csharp"> public class List<T> { ... public void Add(T item) { ... } } List<int> list = new List<int>(); list.Add(6); list.Add(2); </source> ====Generic interfaces==== <source lang="csharp"> interface IEnumerable<T> { ... } </source> ====Generic delegates==== <source lang="csharp"> delegate R Func<T1, T2, R>(T1 a1, T2 a2); </source> ====Generic methods==== <source lang="csharp"> public static T[] CombineArrays<T>(T[] a, T[] b) { T[] newArray = new T[a.Length + b.Length]; a.CopyTo(newArray, 0); b.CopyTo(newArray, a.Length); return newArray; } string[] a = new string[] { "a", "b", "c" }; string[] b = new string[] { "1", "2", "3" }; string[] c = CombineArrays(a, b); double[] da = new double[] { 1.2, 2.17, 3.141592 }; double[] db = new double[] { 4.44, 5.6, 6.02 }; double[] dc = CombineArrays(da, db); //c is a string array containing { "a", "b", "c", "1", "2", "3"} //dc is a double array containing { 1.2, 2.17, 3.141592, 4.44, 5.6, 6.02} </source> ===Type-parameters=== Type-parameters are names used in place of concrete types when defining a new generic. They may be associated with classes or methods by placing the type parameter in angle brackets < >. When instantiating (or calling) a generic, you can then substitute a concrete type for the type-parameter you gave in its declaration. Type parameters may be constrained by use of the ''where'' keyword and a constraint specification, any of the six comma separated constraints may be used: {| class="wikitable" border="1" |- ! Constraint ! Explanation |- | where T : struct | type parameter must be a value type |- | where T : class | type parameter must be a reference type |- | where T : new() | type parameter must have a constructor with no parameters (must appear last) |- | where T : <base_class> | type parameter must inherit from <base_class> |- | where T : <interface> | type parameter must be, or must implement this interface |- | where T : U | naked type parameter constraint |} ====Covariance and contravariance==== :''This is a feature of [[C Sharp 4.0]] and [[.NET Framework 4.0]].'' [[Generic programming|Generic]] interfaces and delegates can have their type parameters marked as [[Covariance and contravariance (computer science)|covariant]] or [[Covariance and contravariance (computer science)|contravariant]], using keywords <code>out</code> and <code>in</code>, respectively. These declarations are then respected for type conversions, both implicit and explicit, and both compile-time and run-time. For example, the existing interface <code>IEnumerable<T></code> has been redefined as follows: <source lang="csharp"> interface IEnumerable<out T> { IEnumerator<T> GetEnumerator(); } </source> Therefore, any class that implements <code>IEnumerable<Derived></code> for some class <code>Derived</code> is also considered to be compatible with <code>IEnumerable<Base></code> for all classes and interfaces <code>Base</code> that <code>Derived</code> extends, directly, or indirectly. In practice, it makes it possible to write code such as: <source lang="csharp"> void PrintAll(IEnumerable<object> objects) { foreach (object o in objects) { System.Console.WriteLine(o); } } IEnumerable<string> strings = new List<string>(); PrintAll(strings); // IEnumerable<string> is implicitly converted to IEnumerable<object> </source> For contravariance, the existing interface <code>IComparer<T></code> has been redefined as follows: <source lang="csharp"> public interface IComparer<in T> { int Compare(T x, T y); } </source> Therefore, any class that implements <code>IComparer<Base></code> for some class <code>Base</code> is also considered to be compatible with <code>IComparer<Derived></code> for all classes and interfaces <code>Derived</code> that are extended from <code>Base</code>. It makes it possible to write code such as: <source lang="csharp"> IComparer<object> objectComparer = GetComparer(); IComparer<string> stringComparer = objectComparer; </source> '''See also''' * [[Covariance and contravariance]] ==Enumerators== An ''enumerator'' is an iterator. Enumerators are typically obtained by calling the <code>GetEnumerator()</code> method of an object implementing the <code>IEnumerable</code> interface. Container classes typically implement this interface. However, the [[foreach]] statement in [[C Sharp (programming language)|C#]] can operate on any object providing such a method, even if it doesn't implement <code>IEnumerable</code>. Both interfaces 