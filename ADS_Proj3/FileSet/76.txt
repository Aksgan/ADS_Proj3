token whether the user owning the process is eligible to access the data, and if so, what operations (read, write/modify, etc.) the user is allowed to do. If the accessing operation is allowed in the context of the user, Windows allows the process to continue with the operation, else it is denied access. ==Types of tokens== There are two types of tokens: ;Primary token: Primary tokens can only be associated to [[Process (computing)|processes]], and they represent a process's security subject. The creation of primary tokens and their association to processes are both privileged operations, requiring two different privileges in the name of [[privilege separation]] - the typical scenario sees the authentication service creating the token, and a logon service associating it to the user's [[operating system shell]]. Processes initially inherit a copy of the parent process's primary token. Impersonation tokens can only be associated to [[thread (computer science)|threads]], and they represent a ''client'' process's security subject. Impersonation tokens are usually created and associated to the current thread implicitly, by [[Inter-process communication|IPC]] mechanisms such as DCE [[Remote procedure call|RPC]], [[Dynamic Data Exchange|DDE]] and [[named pipe]]s. ;Impersonation token: Impersonation is a security concept unique to Windows NT, that allows a server application to temporarily "be" the client in terms of access to secure objects. Impersonation has three possible levels: ''identification'', letting the server inspect the client's identity, ''impersonation'', letting the server act on behalf of the client, and ''delegation'', same as impersonation but extended to remote systems to which the server connects (through the preservation of credentials). The client can choose the maximum impersonation level (if any) available to the server as a connection parameter. Delegation and impersonation are privileged operations (impersonation initially wasn't, but historical carelessness in the implementation of client [[application programming interface|API]]s failing to restrict the default level to "identification", letting an unprivileged server impersonate an unwilling privileged client, called for it). ==Contents of a token== A token is composed of various fields, including but not limited to: * an identifier. * the identifier of the associated logon session. The session is maintained by the authentication service, and is populated by the authentication packages with a collection of all the information ([[credentials]]) the user provided when logging in. Credentials are used to access remote systems without the need for the user to re-authenticate ([[single sign-on]]), provided that all the systems involved share an authentication authority (e.g. a [[Kerberos (protocol)|Kerberos]] ticket server) * the user identifier. This field is the most important and it's strictly read-only. * the identifiers of groups the user (or, more precisely, the subject) is part of. Group identifiers cannot be deleted, but they can be disabled. At most one of the groups is designated as the ''session id'', a volatile group representing the logon session, allowing access to volatile objects associated to the session, such as the display. * the restricting group identifiers (optional). This additional set of groups doesn't grant additional access, but further restricts it: access to an object is only allowed if it's allowed ''also'' to one of these groups. Restricting groups cannot be deleted nor disabled. Restricting groups are a recent addition, and they are used in the implementation of [[sandbox (security)|sandboxes]]. * the privileges, i.e. special capabilities the user has. Most privileges are disabled by default, to prevent damage from non-security-conscious programs. Starting in Windows XP Service Pack 2 and Windows Server 2003 privileges can be permanently removed from a token by a call to <code>AdjustTokenPrivileges()</code> with the <code>SE_PRIVILEGE_REMOVED</code> attribute. * the default owner, primary group and ACL for objects created by the subject associated to the token. ==References== {{Reflist}} {{Windows Components}} {{DEFAULTSORT:Access Token}} [[Category:Computer security]] [[Category:Microsoft Windows security technology]] [[id:Access token]] [[it:Access token]]</text> </page> <page> <id>803</id> <title>Accounting method</title> <text>{{dablink|For accounting methods in business and financial reporting, see [[Accounting methods]].}} In the field of [[analysis of algorithms]] in [[computer science]], the '''accounting method''' is a method of [[amortized analysis]] based on [[accounting]]. The accounting method often gives a more intuitive account of the amortized cost of an operation than either [[aggregate analysis]] or the [[potential method]]. Note, however, that this does not guarantee such analysis will be immediately obvious; often, choosing the correct parameters for the accounting method requires as much knowledge of the problem and the complexity bounds one is attempting to prove as the other two methods. The accounting method is most naturally suited for proving a [[Big O notation|O]](1) bound on time. The method as explained here is for proving such a bound. ==The method== Preliminarily, we choose a set of elementary operations which will be used in the [[algorithm]], and arbitrarily set their cost to 1. The fact that the costs of these operations may in reality differ presents no difficulty in principle. What is important, is that each elementary operation has a constant cost. Each aggregate operation is assigned a "payment". The payment is intended to cover the cost of elementary operations needed to complete this particular operation, with some of the payment left over, placed in a pool to be used later. The difficulty with problems that require amortized analysis is that, in general, some of the operations will require greater than constant cost. This means that no constant payment will be enough to cover the worst case cost of an operation, in and of itself. With proper selection of payment, however, this is no longer a difficulty; the expensive operations will only occur when there is sufficient payment in the pool to cover their costs. ==Examples== A few examples will help to illustrate the use of the accounting method. ===Table expansion=== It is often necessary to create a table before it is known how much space is needed. One possible strategy is to double the size of the table when it is full. Here we will use the accounting method to show that the amortized cost of an insertion operation in such a table is [[O]](1). Before looking at the procedure in detail, we need some definitions. Let T be a table, E 