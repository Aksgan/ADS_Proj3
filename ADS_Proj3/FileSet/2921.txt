target [[16-bit]], [[32-bit]] and is supplied as a 64 bit version ML64.EXE for [[64-bit]] [[Computing platform|platform]]s. Versions 5.0 and earlier were [[MS-DOS]] applications. Versions 5.1 and 6.0 were available as both [[MS-DOS]] and [[OS/2]] applications.<ref name = "InfoWorld Apr 1991">{{Cite journal | last = Marshall | first = Martin | title = Macro Assembler Update Adds High-Level Features | journal = InfoWorld | volume = 13 | issue = 17 | page = p. 21 | date = April 29, 1991 | url = http://books.google.com/books?id=y1AEAAAAMBAJ&pg=PT20 | issn = 0199-6649}}</ref> Versions 6.12 to 6.14 were implemented as patches for version 6.11 which converted them from 16 bit MZ executables to 32 bit PE executable files. All later versions have been 32 bit PE executable files built as [[Win32 console]] mode applications. ==History== The Microsoft Assembler has been in production since 1981 and is upgraded by Microsoft to keep abreast with operating system needs and processor developments.<ref name = "InfoWorld Jan 1985">{{Cite journal | last = Watt | first = Peggy | coauthors = Christine McGeever | title = Macintosh Vs. IBM PC At One Year | journal = InfoWorld | volume = 7 | issue = 1 | pages = pp. 15â€“16 | date = January 7, 1985 | url = http://books.google.com/books?id=-i4EAAAAMBAJ&pg=PA16 | issn = 0199-6649}} The IBM PC Macro Assembler was released in December 1981.</ref> Prior to Microsoft Assembler, the abbreviation MASM referred to Meta Assembler.<ref name = "Sperry Unisys">{{Cite web | title = Sperry and Unisys Reference Manuals, 1977-1997. | work = Online Finding Aids | publisher = University of Minnesota Libraries | url = http://discover.lib.umn.edu/cgi/f/findaid/findaid-idx?c=umfa;cc=umfa;rgn=main;view=text;didno=cbi000187 | accessdate = February 2, 2010}} Meta-Assembler [MASM] Programming Reference Manual - MASM Usage, undated.</ref> MASM 6.0 was released in 1992 and was the first version to include high-level programming support (in particular if/endif macros) and a more [[C (programming language)|C]]-like syntax. By the end of the year, version 6.1A updated the memory management to be compatible with code produced by [[Visual C++]]. In 1993, full support for 32-bit applications and the [[Intel P5 (microarchitecture)|Pentium]] instruction set had been added, plus [[Phar Lap (company)|Phar Lap]]'s DOS extender. By the end of 1997, MASM fully supported Windows 95, did not require the DOS extender, and included some [[AMD]]-specific instructions.<ref name="harvey">{{cite web |archiveurl=http://web.archive.org/web/20080216121237/http://ourworld.compuserve.com/homepages/r_harvey/doc_book.htm |archivedate=16 February 2008 |year=2007 |accessdate=4 February 2010 |title=Assemblers |author=R. E. Harvey |url=http://ourworld.compuserve.com/homepages/r_harvey/doc_book.htm}}</ref> In 1999, Intel released macros for [[SIMD]] and [[MMX (instruction set)|MMX]] instructions, which were shortly after supported natively by MASM. With the 6.15 release in 2000, Microsoft discontinued support for MASM as a separate product, instead subsuming it into the [[Visual Studio]] toolset, though it was still compatible with [[Windows 98]], though current versions of Visual Studio were not.<ref name="harvey" /> Support for 64-bit processors was not added until the release of [[Visual Studio 2005]], with MASM given the version number 8.0. ==Usage== The Microsoft assembler has been the main vehicle for preserving the earlier Intel assembler notation and it can still be written as a fully specified language, a format that many dis-assemblers produce. The most common notation of this type are the data size specifiers, '''BYTE PTR''' The data size specifier for the target being 8 bit. '''WORD PTR''' The data size specifier for the target being 16 bit. '''DWORD PTR''' The data size specifier for the target being 32 bit. ===Addressing Notation=== ML.EXE maintains the historical distinction between transient stack addressing and fixed data addressing by using the notation '''OFFSET''' to denote data in either the initialised or uninitialised data sections. Transient stack addressing is handled by a number of methods. With a procedure that uses a stack frame, named LOCAL variables are used for readability purposes and where the address of the variable is required it can be accessed by the '''LEA''' mnemonic or in an INVOKE call by the '''ADDR''' operator. The '''LOCAL''' variables are [EBP] stack addresses when used within a procedure. Procedures written without a stack frame are generally written purely in mnemonics using direct [ESP] based argument addressing. To maintain compatibility with the historical MASM method of pseudo high level notation, there is a notation to turn off the stack frame generation for the procedure on a needs basis. ===Square Brackets=== ML.EXE does not require the addition of square brackets around a named variable but will tolerate such notation deviation by ignoring the notation. This notation difference has at time been a source of confusion for programmers familiar with other assemblers that use the square brackets to denote an address. '''mov eax, local_var''' ; Standard ML.EXE notation '''mov eax, [local_var]''' ; Square brackets are ignored by ML.EXE in this context. There is no Intel mnemonic that will produce the extra level of indirection implied by placing un-necessary square brackets around a named variable and the practice leads to confusion of programmers who are experienced in using other x86 assemblers that use the square bracket notation differently. ML.EXE uses square brackets around direct mnemonic code to perform the dereferencing operation as in the following example. '''lea eax, variable_name''' ; load the address of a stack variable into the EAX register '''mov eax, [eax]''' ; dereference the '''CONTENT''' of the variable and copy it into the EAX register. ML.EXE will allow the following. '''mov eax, [eax+ebx]''' '''mov eax, [eax][ebx]''' In this context the second pair of square brackets perform the '''ADDITION''' function within the complex addressing notation ===Notation Abbreviation=== Over a long period a form of shorthand notation has developed as the parsers in early versions improved. Generally the data size specifier is not necessary if the assembler can determine the size of the data, although it still can be used. This shorthand has confused some users who have used other assemblers which are not by default data size specified tools. It can lead to problems when the user is not familiar with the default data size specifiers while using the shorthand notation. '''movzx eax, [esi]''' ; This fails as the assembler cannot determine the size of data to be zero extended into the 