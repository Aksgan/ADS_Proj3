a priority and the parent node has higher priority than its children. Two other titles describing binary search trees are that of a '''complete''' and '''degenerate''' tree. A complete tree is a tree with n levels, where for each level d <= n - 1, the number of existing nodes at level d is equal to 2<sup>d</sup>. This means all possible nodes exist at these levels. An additional requirement for a complete binary tree is that for the n<sup>th</sup> level, while every node does not have to exist, the nodes that do exist must fill from left to right. A degenerate tree is a tree where for each parent node, there is only one associated child node. What this means is that in a performance measurement, the tree will essentially behave like a linked list data structure. ===Performance comparisons=== D. A. Heger (2004)<ref> {{Citation | title=A Disquisition on The Performance Behavior of Binary Search Tree Data Structures | first1=Dominique A. | last1=Heger | year=2004 | journal=European Journal for the Informatics Professional | volume=5 | url=http://www.cepis.org/upgrade/files/full-2004-V.pdf | issue=5 | pages=67–75}} </ref> presented a performance comparison of binary search trees. [[Treap]] was found to have the best average performance, while [[red-black tree]] was found to have the smallest amount of performance fluctuations. ===Optimal binary search trees=== If we don't plan on modifying a search tree, and we know exactly how often each item will be accessed, we can construct an '''optimal binary search tree''', which is a search tree where the average cost of looking up an item (the ''expected search cost'') is minimized. Even if we only have estimates of the search costs, such a system can considerably speed up lookups on average. For example, if you have a BST of English words used in a [[spell checker]], you might balance the tree based on word frequency in [[text corpus|text corpora]], placing words like "the" near the root and words like "agerasia" near the leaves. Such a tree might be compared with [[Huffman tree]]s, which similarly seek to place frequently-used items near the root in order to produce a dense information encoding; however, Huffman trees only store data elements in leaves and these elements need not be ordered. If we do not know the sequence in which the elements in the tree will be accessed in advance, we can use [[splay tree]]s which are asymptotically as good as any static search tree we can construct for any particular sequence of lookup operations. '''Alphabetic trees''' are Huffman trees with the additional constraint on order, or, equivalently, search trees with the modification that all elements are stored in the leaves. Faster algorithms exist for '''optimal alphabetic binary trees''' (OABTs). Example: <pre lang="python"> procedure Optimum Search Tree(f, f´, c): for j = 0 to n do c[j, j] = 0, F[j, j] = f´j for d = 1 to n do for i = 0 to (n − d) do j = i + d F[i, j] = F[i, j − 1] + f´ + f´j c[i, j] = MIN(i<k<=j){c[i, k − 1] + c[k, j]} + F[i, j] </pre> ==See also== <div style="-moz-column-count:2; column-count:2;"> *[[Binary search]] *[[Search tree]] *[[Binary tree]] *[[Binary search algorithm]] *[[Self-balancing binary search tree]] *[[Randomized binary search tree]] *[[Red-black tree]] *[[B-tree]] *[[Data structure]] *[[Trie]] *[[Ternary search tree]] *[[Elastic binary tree]] *[[Hash table]] *[[Skip list]] </div> ==References== {{Reflist}} ==Further reading== *[[Donald Knuth]]. ''The Art of Computer Programming'', Volume 3: ''Sorting and Searching'', Third Edition. Addison-Wesley, 1997. ISBN 0-201-89685-0. Section 6.2.2: Binary Tree Searching, pp.426&ndash;458. *[[Thomas H. Cormen]], [[Charles E. Leiserson]], [[Ronald L. Rivest]], and [[Clifford Stein]]. ''[[Introduction to Algorithms]]'', Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Chapter 12: Binary search trees, pp.253&ndash;272. Section 15.5: Optimal binary search trees, pp.356&ndash;363. ==External links== * [http://www.student.seas.gwu.edu/~idsv/idsv.html Binary Search Trees Animation] *[http://jdserver.homelinux.org/wiki/Binary_Search_Tree Full source code to an efficient implementation in C++] *[http://wiki.portugal-a-programar.org/c:snippet:binary_search_tree Implementation of Binary Search Trees in C] *[http://cg.scs.carleton.ca/~dana/pbst Implementation of a Persistent Binary Search Tree in C] *[http://www.24bytes.com/Binary-Search-Tree.html Implementation of Binary Search Trees in Java] *[http://www.goletas.com/solutions/collections/ Iterative Implementation of Binary Search Trees in C#] *[http://cslibrary.stanford.edu/110/ An introduction to binary trees from Stanford] *[http://www.nist.gov/dads/HTML/binarySearchTree.html Dictionary of Algorithms and Data Structures - Binary Search Tree] *[http://code.activestate.com/recipes/286239/ Binary Search Tree Example in Python] *[http://webpages.ull.es/users/jriera/Docencia/AVL/AVL%20tree%20applet.htm Java Model illustrating the behaviour of binary search trees(In JAVA Applet)] *[http://nova.umuc.edu/~jarc/idsv/lesson1.html Interactive Data Structure Visualizations - Binary Tree Traversals] *[http://en.literateprograms.org/Category:Binary_search_tree Literate implementations of binary search trees in various languages] on LiteratePrograms *[http://people.ksp.sk/~kuko/bak/index.html BST Tree Applet] by Kubo Kovac *[http://www.algolist.net/Data_structures/Binary_search_tree Well-illustrated explanation of binary search tree. Implementations in Java and C++] *[http://employees.oneonta.edu/zhangs/PowerPointPlatform/index.php Teacing Binary Search Tree through visualization ] {{CS-Trees}} {{Data structures}} [[Category:Articles with example C++ code]] [[Category:Articles with example Python code]] [[Category:Binary trees]] [[ca:Arbre binari de cerca]] [[cs:Binární vyhledávací strom]] [[da:Binært søgetræ]] [[de:Binärer Suchbaum]] [[es:Árbol binario de búsqueda]] [[fa:درخت جستجوی دودویی]] [[fr:Arbre binaire de recherche]] [[ko:이진 탐색 트리]] [[id:Pohon biner terurut]] [[it:Albero binario di ricerca]] [[he:עץ חיפוש]] [[nl:Binaire zoekboom]] [[ja:2分探索木]] [[pl:Binarne drzewo poszukiwań]] [[pt:Árvore binária de busca]] [[ro:Arbore binar de căutare]] [[ru:Двоичное дерево поиска]] [[sk:Binárny vyhľadávací strom]] [[fi:Binäärinen hakupuu]] [[sv:Binärt sökträd]] [[th:ต้นไม้ค้นหาแบบทวิภาค]] [[uk:Бінарне дерево пошуку]] [[vi:Cây tìm kiếm nhị phân]] [[zh:二元搜尋樹]]</text> </page> <page> <id>3839</id> <title>Binary tree</title> <text>{{distinguish|B-tree}} [[Image:binary tree.svg|right|192|thumb|A simple binary tree of size 9 and height 4, with a root node whose value is 2. The above tree is unbalanced and not sorted.]] In [[computer science]], a '''binary tree''' is a [[tree (data structure)|tree data structure]] in which each node has at most two [[child node]]s, usually distinguished as "left" and "right". Nodes with children are [[parent node]]s, and child nodes may contain references to their parents. Outside the tree, there is often a reference to the "root" node (the ancestor of all nodes), if it exists. Any node in the data structure can be reached by starting at root node and repeatedly following references to either the left or right child. Binary trees are used to implement [[binary search tree]]s and [[binary heap]]s. ==Definitions for rooted trees== * A '''directed edge''' refers to the link from the [[parent node|parent]] to the [[child node|child]] (the arrows in the 