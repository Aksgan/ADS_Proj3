model, where the outer level is composed of task parallel skeletons, while data parallel skeletons may be used in the inner level [64]. Type verification is performed at the data flow level, when the programmer explicitly specifies the type of the input and output streams, and by specifying the flow of data between sub-modules. '''SkIE''' <ref>''B. Bacci, M. Danelutto, S. Pelagatti, and M. Vanneschi.'' "Skie: a heterogeneous environment for HPC applications." Parallel Comput., 25(13-14):1827–1852, 1999.</ref> (Skeleton-based Integrated Environment) is quite similar to '''P3L''', as it is also based on a coordination language, but provides advanced features such as debugging tools, performance analysis, visualization and graphical user interface. Instead of directly using the coordination language, programmers interact with a graphical tool, where parallel modules based on skeletons can be composed. '''SKELib''' <ref>''M. Danelutto and M. Stigliani.'' "Skelib: Parallel programming with skeletons in C." In Euro-Par ’00: Proceedings from the 6th International Euro-Par Conference on Parallel Processing, pages 1175–1184, London, UK, 2000. Springer-Verlag.</ref> builds upon the contributions of '''P3L''' and '''SkIE''' by inheriting, among others, the template system. It differs from them because a coordination language is no longer used, but instead skeletons are provided as a library in C, with performance similar as the one achieved in '''P3L'''. Contrary to '''Skil''', another C like skeleton framework, type safety is not addressed in '''SKELib'''. ===PAS and EPAS=== '''PAS''' (Parallel Architectural Skeletons) is a framework for skeleton programming developed in C++ and MPI <ref>''D. Goswami, A. Singh, and B. R. Preiss.'' "From desgign patterns to parallel architectural skeletons." J. Parallel Distrib. Comput., 62(4):669–695, 2002.</ref><ref>''D. Goswami, A. Singh, and B. R. Preiss.'' "Using object-oriented techniques for realizing parallel architectural skeletons." In ISCOPE ’99: Proceedings of the Third International Symposium on Computing in Object-Oriented Parallel Environments, Lecture Notes in Computer Science, pages 130–141, London, UK, 1999. Springer-Verlag.</ref>. Programmers use an extension of C++ to write their skeleton applications1 . The code is then passed through a Perl script which expands the code to pure C++ where skeletons are specialized through inheritance. In '''PAS''', every skeleton has a Representative (Rep) object which must be provided by the programmer and is in charge of coordinating the skeleton’s execution. Skeletons can be nested in a hierarchical fashion via the Rep objects. Besides the skeleton’s execution, the Rep also explicitly manages the reception of data from the higher level skeleton, and the sending of data to the sub-skeletons. A parametrized communication/synchronization protocol is used to send and receive data between parent and sub-skeletons. An extension of PAS labeled as '''SuperPas''' <ref>''M. M. Akon, D. Goswami, and H. F. Li.'' "Superpas: A parallel architectural skeleton model supporting extensibility and skeleton composition." In Parallel and Distributed Processing and Applications Second International Symposium, ISPA, Lecture Notes in Computer Science, pages 985–996. Springer-Verlag, 2004.</ref> and later as '''EPAS''' <ref>''M. M. Akon, A. Singh, D. Goswami, and H. F. Li.'' "Extensible parallel architectural skeletons." In High Performance Computing HiPC 2005, 12th International Conference, volume 3769 of Lecture Notes in Computer Science, pages 290–301, Goa, India, December 2005. Springer-Verlag.</ref> addresses skeleton extensibility concerns. With the '''EPAS''' tool, new skeletons can be added to '''PAS'''. A Skeleton Description Language (SDL) is used to describe the skeleton pattern by specifying the topology with respect to a virtual processor grid. The SDL can then be compiled into native C++ code, which can be used as any other skeleton. ===SBASCO=== '''SBASCO''' ('''Skeleton-BAsed Scientific COmponents''') is a programming environment oriented towards efficient development of parallel and distributed numerical applications <ref>''M. Diaz, B. Rubio, E. Soler, and J. M. Troya.'' "SBASCO: Skeleton-based scientific components." In PDP, pages 318–. IEEE Computer Society, 2004.</ref>. '''SBASCO''' aims at integrating two programming models: skeletons and components with a custom composition language. An application view of a component provides a description of its interfaces (input and output type); while a configuration view provides, in addition, a description of the component’s internal structure and processor layout. A component’s internal structure can be defined using three skeletons: farm, pipe and multi-block. '''SBASCO'''’s addresses domain decomposable applications through its multi-block skeleton. Domains are specified through arrays (mainly two dimensional), which are decomposed into sub-arrays with possible overlapping boundaries. The computation then takes place in an iterative BSP like fashion. The first stage consists of local computations, while the second stage performs boundary exchanges. A use case is presented for a reaction-diffusion problem in <ref>M. Diaz, S. Romero, B. Rubio, E. Soler, and J. M. Troya. "Using SBASCO to solve reaction-diffusion equations in two-dimensional irregular domains." In Practical Aspects of High-Level Parallel Programming (PAPP), affiliated to the International Conference on Computational Science (ICCS), volume 3992 of Lecture Notes in Computer Science, pages 912–919. Springer, 2006.</ref>. Two type of components are presented in <ref>''M. Diaz, S. Romero, B. Rubio, E. Soler, and J. M. Troya.'' "An aspect oriented framework for scientific component development." In PDP ’05: Proceedings of the 13th Euromicro Conference on Parallel, Distributed and Network-Based Processing, pages 290–296, Washington, DC, USA, 2005. IEEE Computer Society.</ref>. Scientific Components (SC) which provide the functional code; and Communication Aspect Components (CAC) which encapsulate non-functional behavior such as communication, distribution processor layout and replication. For example, SC components are connected to a CAC component which can act as a manager at runtime by dynamically re-mapping processors assigned to a SC. A use case showing improved performance when using CAC components is shown in <ref>''M. Diaz, S. Romero, B. Rubio, E. Soler, and J. M. Troya.'' "Dynamic reconfiguration of scientific components using aspect oriented programming: A case study." In R. Meersman And Z. Tari, editors, On the Move to Meaningful Internet Systems 2006: CoopIS, DOA, GADA, and ODBASE, volume 4276 of Lecture Notes in Computer Science, pages 1351–1360. Springer-Verlag, 2006.</ref>. ===SCL=== The '''Structured Coordination Language''' ('''SCL''') was one of the first languages introduced for skeleton programming <ref>''J. Darlington, A. J. Field, P. G. Harrison, P. H. J. Kelly, D. W. N. Sharp, and Q. Wu.'' "Parallel programming using skeleton functions." In PARLE ’93: Proceedings of the 5th International PARLE Conference on Parallel Architectures and 