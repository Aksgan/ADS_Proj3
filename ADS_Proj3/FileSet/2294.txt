it has to be implemented in floating or fix-point and causes round-off errors. # Reversible Color Transform (RCT) uses a modified YUV color space that does not introduce quantization errors, so it is fully reversible. Proper implementation of the RCT requires that numbers are rounded as specified that cannot be expressed exactly in matrix form. The transformation is: :<math> Y_r = \left\lfloor \frac{R+2G+B}{4} \right\rfloor ; C_b = B - G ; C_r = R - G ; </math> and <math> G = Y - \left\lfloor \frac{C_b + C_r}{4} \right\rfloor ; R = C_r + G ; B = C_b + G. </math> The [[chrominance]] components can be, but do not necessarily have to be, down-scaled in resolution; in fact, since the wavelet transformation already separates images into scales, downsampling is more effectively handled by dropping the finest wavelet scale. This step is called ''multiple component transformation'' in the JPEG 2000 language since its usage is not restricted to the [[RGB color model]]. ===Tiling=== After color transformation, the image is split into so-called ''tiles'', rectangular regions of the image that are transformed and encoded separately. Tiles can be any size, and it is also possible to consider the whole image as one single tile. Once the size is chosen, all the tiles will have the same size (except optionally those on the right and bottom borders). Dividing the image into tiles is advantageous in that the decoder will need less memory to decode the image and it can opt to decode only selected tiles to achieve a partial decoding of the image. The disadvantage of this approach is that the quality of the picture decreases due to a lower [[peak signal-to-noise ratio]]. Using many tiles can create a blocking effect similar to the older [[JPEG]] 1992 standard. ===Wavelet transform=== [[Image:Wavelet Bior2.2.svg|thumb|right|CDF 5/3 wavelet used for lossless compression.]] [[Image:Jpeg2000 2-level wavelet transform-lichtenstein.png|thumb|256px|An example of the wavelet transform that is used in JPEG 2000. This is a 2nd-level [[Cohen-Daubechies-Feauveau wavelet|CDF]] 9/7 [[wavelet transform]].]] These tiles are then [[wavelet transform]]ed to an arbitrary depth, in contrast to JPEG 1992 which uses an 8×8 block-size [[discrete cosine transform]]. JPEG 2000 uses two different wavelet transforms: #''irreversible'': the [[Cohen-Daubechies-Feauveau wavelet|CDF]] 9/7 [[wavelet transform]]. It is said to be "irreversible" because it introduces quantization noise that depends on the precision of the decoder. #''reversible'': a rounded version of the biorthogonal [[Cohen-Daubechies-Feauveau wavelet|CDF]] 5/3 [[wavelet]] transform. It uses only integer coefficients, so the output does not require rounding (quantization) and so it does not introduce any quantization noise. It is used in lossless coding. The wavelet transforms are implemented by the [[lifting scheme]] or by [[convolution]]. ===Quantization=== After the wavelet transform, the coefficients are scalar-[[Quantization (image processing)|quantized]] to reduce the amount of bits to represent them, at the expense of a loss of quality. The output is a set of integer numbers which have to be encoded bit-by-bit. The parameter that can be changed to set the final quality is the quantization step: the greater the step, the greater is the compression and the loss of quality. With a quantization step that equals 1, no quantization is performed (it is used in lossless compression). ===Coding=== The result of the previous process is a collection of ''sub-bands'' which represent several approximation scales. A sub-band is a set of ''coefficients''—[[real numbers]] which represent aspects of the image associated with a certain frequency range as well as a spatial area of the image. The quantized sub-bands are split further into ''precincts'', rectangular regions in the wavelet domain. They are typically selected in a way that the coefficients within them across the sub-bands form approximately spatial blocks in the (reconstructed) image domain, though this is not a requirement. Precincts are split further into ''code blocks''. Code blocks are located in a single sub-band and have equal sizes—except those located at the edges of the image. The encoder has to encode the bits of all quantized coefficients of a code block, starting with the most significant bits and progressing to less significant bits by a process called the ''EBCOT'' scheme. ''EBCOT'' here stands for ''Embedded Block Coding with Optimal Truncation''. In this encoding process, each [[bit plane]] of the code block gets encoded in three so-called ''coding passes'', first encoding bits (and signs) of insignificant coefficients with significant neighbors (i.e., with 1-bits in higher bit planes), then refinement bits of significant coefficients and finally coefficients without significant neighbors. The three passes are called ''Significance Propagation'', ''Magnitude Refinement'' and ''Cleanup'' pass, respectively. Clearly, in lossless mode all bit planes have to be encoded by the EBCOT, and no bit planes can be dropped. The bits selected by these coding passes then get encoded by a context-driven binary [[arithmetic coding|arithmetic coder]], namely the binary MQ-coder. The context of a coefficient is formed by the state of its nine neighbors in the code block. The result is a bit-stream that is split into ''packets'' where a ''packet'' groups selected passes of all code blocks from a precinct into one indivisible unit. Packets are the key to quality scalability (i.e., packets containing less significant bits can be discarded to achieve lower bit rates and higher distortion). Packets from all sub-bands are then collected in so-called ''layers''. The way the packets are built up from the code-block coding passes, and thus which packets a layer will contain, is not defined by the JPEG 2000 standard, but in general a codec will try to build layers in such a way that the image quality will increase monotonically with each layer, and the image distortion will shrink from layer to layer. Thus, layers define the progression by image quality within the code stream. The problem is now to find the optimal packet length for all code blocks which minimizes the overall distortion in a way that the generated target bitrate equals the demanded bit rate. While the standard does not define a procedure as to how to perform this form of [[rate–distortion optimization]], the general outline is given in one 