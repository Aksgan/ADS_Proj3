never accept the <tt>stop</tt> message from <tt>X</tt> (a phenomenon called [[Resource starvation|starvation]]) and consequently the above program might never print anything. In contrast consider, a simple Actor system that consists of Actors '''X''', '''Y''', '''Z''', and '''print''' where :the Actor '''X''' is created with the following behavior: :*If the message <tt>"start"</tt> is received, then send '''Z''' the message <tt>"stop"</tt> :the Actor '''Y''' is created with the following behavior: :*If the message <tt>"start"</tt> is received, then send '''Z''' the message <tt>"go"</tt> :*If the message '''true''' is received, then send '''Z''' the message <tt>"go"</tt> :*If the message '''false''' is received, then do nothing :the Actor '''Z''' is created with the following behavior that has a count <tt>n</tt> that is initially '''0''': :*If the message <tt>"start"</tt> is received, then do nothing. :*If the message <tt>"stop"</tt> is received, then send '''Y''' the message '''false''' and send '''print''' the message the count <tt>n</tt>. :*If the message <tt>"go"</tt> is received, then send '''Y''' the message '''true''' and process the next message received with count <tt>n</tt> being <tt>n+1</tt>. By the laws of Actor semantics, the above Actor system will always halt when the Actors '''X''', '''Y''', are '''Z''' are each sent a <tt>"start"</tt> message resulting in sending '''print''' a number that can be unbounded large. The difference between the CSP program and the Actor system is that the Actor '''Z''' does not get messages using a guarded choice command from multiple channels. Instead it processes messages in arrival ordering, and by the laws for Actor systems, the <tt>stop</tt> message is guaranteed to arrive. ===Livelock on getting from multiple channels=== Consider the following program written in CSP [Hoare 1978]: [Bidder1 :: b: bid; *[Bids1?b → process1!b; [] Bids2?b → process1!b;] || Bidder2 :: b: bid; *[Bids1?b → process2!b; [] Bids2?b → process2!b;] ] As pointed out in Knabe [1992], an issue with the above protocol ([[Actor model and process calculi#A simple distributed protocol|A simple distributed protocol]]) is that the process <tt>Bidder2</tt> might never accept a bid from <tt>Bid1</tt> or <tt>Bid2</tt> (a phenomenon called [[livelock]]) and consequently <tt>process2</tt> might never be sent anything. In each attempt to accept a message, <tt>Bidder2</tt> is thwarted because the bid that was offered by <tt>Bids1</tt> or <tt>Bids2</tt> is snatched away by <tt>Bidder1</tt> because it turns out that <tt>Bidder1</tt> has much faster access than <tt>Bidder2</tt> to <tt>Bids1</tt> and <tt>Bids2<tt>. Consequently <tt>Bidder1</tt> can accept a bid, process it and accept another bid before <tt>Bidder2</tt> can commit to accepting a bid. ===Efficiency=== As pointed out in Knabe [1992], an issue with the above protocol ([[Actor model and process calculi#A simple distributed protocol|A simple distributed protocol]]) is the large number of communications that must be sent in order to perform the handshaking in order to send a message through a synchronous channel. Indeed as shown in the previous section ([[Actor model and process calculi#Livelock on getting from multiple channels|Livelock]]), the number of communications can be unbounded. ===Summary of Issues=== The subsections above have articulated the following three issues concerned with the use of synchronous channels for process calculi: #''Starvation.'' The use of sychronous channels can cause starvation when a process attempts to get messages from multiple channels in a guarded choice command. #''Livelock.'' The use of synchronous channels can cause a process to be caught in livelock when it attempts to get messages from multiple channels in a guarded choice command. #''Efficiency.'' The use of synchronous channels can require a large number of communications in order to get messages from multiple channels in a guarded choice command. It is notable that in all of the above, issues arise from the use of a guarded choice command to get messages from multiple channels. ==Asynchronous channels== Asynchronous channels have the property that a sender putting a message in the channel need not wait for a receiver to get the message out of the channel. ===Simple asynchronous channels=== An asynchronous channel can be modeled by an Actor that receives <tt>put</tt> and <tt>get</tt> communications. The following is the behavior of an Actor for a simple asynchronous channel: *Each <tt>put</tt> communication has a message and an address to which an acknowledgment is sent immediately (without waiting for the message to be gotten by a <tt>get</tt> communication). *Each <tt>get</tt> communication has an address to which the gotten message is sent. ===Asynchronous channels in process calculi=== The Join-calculus programming language (published in 1996) implemented local and distributed concurrent computations. It incorporated asynchronous channels as well as a kind of synchronous channel that is used for procedure calls. Agha's Aπ Actor calculus {{harv|Agha and Thati|2004}} is based on a typed version of the asynchronous [[Pi-calculus|π-calculus]]. ==Algebras== The use of algebraic techniques was pioneered in the process calculi. Subsequently several different process calculi intended to provide algebraic reasoning about Actor systems have been developed in {{harv|Gaspari and Zavattaro|1997}}, {{harv|Gaspari and Zavattaro|1999}}, {{harv|Agha and Thati|2004}} ==Denotational Semantics== Will Clinger (building on the work of Irene Greif [1975], Gordon Plotkin [1976], [[Henry Baker (computer scientist)|Henry Baker]] [1978], Michael Smyth [1978], and Francez, [[Hoare]], Lehmann, and de Roever [1979]) published the first satisfactory mathematical [[Denotational semantics|denotational]] theory of the [[Actor model]] using [[domain theory]] in [[denotational semantics of the Actor model#Clinger's Model|his dissertation]] in 1981. His semantics contrasted the [[unbounded nondeterminism]] of the [[Actor model]] with the bounded nondeterminism of [[Communicating Sequential Processes|CSP]] [Hoare 1978] and Concurrent Processes [Milne and Milner 1979] (see [[denotational semantics]]). Roscoe [2005] has developed a denotational semantics with unbounded nondeterminism for a subsequent version of Communicating Sequential Processes Hoare [1985]. More recently [[Carl Hewitt]] [2006b] developed a denotational semantics for Actors based on [[Denotational semantics of the Actor model#The Timed Diagrams Model|timed diagrams]]. Ugo Montanari and Carolyn Talcott [1998] have contributed to attempting to reconcile Actors with process calculi. ==References== *Carl Hewitt, Peter Bishop and Richard Steiger. '''A Universal Modular Actor Formalism for Artificial Intelligence''' IJCAI 1973. *Robin Milner. '''Processes: A Mathematical Model of Computing Agents''' in Logic Colloquium 1973. *Irene Greif and Carl Hewitt. '''[http://www.ai.mit.edu/research/publications/publications Actor Semantics of PLANNER-73]''' Conference Record of ACM Symposium on Principles of Programming Languages. January 1975. *Irene Greif. 