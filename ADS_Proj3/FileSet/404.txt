those requirements will take to implement. The words Given, When and Then are often used to help drive out the scenarios, but are not mandated. These scenarios can also be automated, if an appropriate tool exists to allow automation at the UI level. If no such tool exists then it may be possible to automate at the next level in, i.e.: if an [[Model-view-controller|MVC]] design pattern has been used, the level of the Controller. ==Unit-level examples and behavior== The same principles of examples, using contexts, events and outcomes are used to drive development at a unit level. For instance, the following examples describe an aspect of behavior of a list: Example 1: New lists are empty * Given a new list * Then the list should be empty. Example 2: Lists with things in them are not empty. * Given a new list * When we add an object * Then the list should not be empty. Both these examples are required to describe the behavior of the <source lang="java">list.isEmpty()</source> method, and to derive the benefit of the method. These examples are usually automated using TDD frameworks. In BDD these examples are often encapsulated in a single method, with the name of the method being a complete description of the behavior. Both examples are required for the code to be valuable, and encapsulating them in this way makes it easy to question, remove or change the behaviour. For instance, using [[Java (programming language)|Java]] and [[JUnit]] 4, the above examples might become: <source lang="java"> public class ListTest { @Test public void shouldKnowWhetherItIsEmpty() { List list1 = new List(); assertTrue(list1.isEmpty()); List list2 = new List(); list2.add(new Object()); assertFalse(list2.isEmpty()); } } </source> Other practitioners, particularly in the Ruby community, prefer to split these into two separate examples, based on separate contexts for when the list is empty or has items in. This technique is based on Dave Astels' practice, "One assertion per test<ref name="oneassertion">D. Astels, [http://techblog.daveastels.com/tag/bdd/ One assertion per test]</ref>". Sometimes the difference between the context, events and outcomes is made more explicit. For instance: <source lang="java"> public class WindowControlBehavior { @Test public void shouldCloseWindows() { // Given WindowControl control = new WindowControl("My AFrame"); AFrame frame = new AFrame(); // When control.closeWindow(); // Then ensureThat(!frame.isShowing()); } } </source> However the example is phrased, the effect describes the behavior of the code in question. For instance, from the examples above one can derive: * List should know when it is empty * WindowControl should close windows The description is intended to be useful if the test fails, and to provide documentation of the code's behavior. Once the examples have been written they are then run and the code implemented to make them work in the same way as TDD. The examples then become part of the suite of regression tests. ==Using mocks== BDD proponents claim that the use of "should" and "ensureThat" in BDD examples encourages developers to question whether the responsibilities they're assigning to their classes are appropriate, or whether they can be delegated or moved to another class entirely. Practitioners use an object which is simpler than the collaborating code, and provides the same interface but more predictable behavior. This is [[Dependency Injection|injected]] into the code which needs it, and examples of that code's behavior are written using this object instead of the production version. These objects can either be created by hand, or created using a mocking framework such as [[Mockito]], [[Moq]], [[NMock]], [[Rhino Mocks]], [[JMock]] or [[EasyMock]]. Questioning responsibilities in this way, and using mocks to fulfill the required roles of collaborating classes, encourages the use of [[Role-based Interfaces]]. It also helps to keep the classes small and loosely coupled. ==References== {{Reflist}} ==External links== *[http://dannorth.net/introducing-bdd Dan North's article introducing BDD] *[http://behavior-driven.org/ Introduction to Behavior Driven Development] *[http://www.oreillynet.com/pub/a/ruby/2007/08/09/behavior-driven-development-using-ruby-part-1.html Behavior Driven Development Using Ruby (Part 1)] *[http://www.oreillynet.com/pub/a/ruby/2007/08/30/behavior-driven-development-using-ruby-part-2.html Behavior-Driven Development Using Ruby (Part 2)] *[http://www.ibm.com/developerworks/java/library/j-cq09187/index.html In pursuit of code quality: Adventures in behavior-driven development by Andrew Glover] *[http://www.pragprog.com/titles/achbd/the-rspec-book The RSpec Book: Behaviour Driven Development with RSpec, Cucumber, and Friends] [[Category:Software development philosophies]] [[Category:Software testing]] [[fr:Behavior Driven Development]] [[ja:ビヘイビア駆動開発]] [[pt:Behavior Driven Development]] [[zh:行为驱动开发]]</text> </page> <page> <id>3563</id> <title>Behavior of DEVS</title> <text>Behaviors of a given [[DEVS]] model is a set of sequences of timed events including null events, called [[Event Segment|event segments]] which make the model move one state to another within a set of legal states. To define this way, the concept of a set of illegal state as well a set of legal states are needed to be introduced. In addition, since the behaviors of a given DEVS model needs to define how the state transition change both when time is passed by and when an event occurs, it has been described by a much general formalism, called General System [[Behavior_of_DEVS#References|[ZPK00]]]. In this article, we use a sub-class of General System formalism, called [[Timed Event System]] instead. Depending on how to define the total state and its external state transition function of [[DEVS]], two ways to define the behavior of a [[DEVS]] model using [[Timed Event System]]. Since [[Behavior of Coupled DEVS|behavior of a Coupled DEVS]] model is defined as an [[DEVS#Atomic_DEVS|Atomic DEVS]] model, behavior of Coupled DEVS class is defined by [[Timed Event System]]. == View 1: Total States = States * Elapsed Times == Suppose that a [[DEVS]] model, <math>\mathcal{M}=<X,Y,S,s_0,ta,\delta_{ext},\delta_{int},\lambda></math> has # the total state set <math>Q=\{(s,t_e)| s \in S, t_e \in (\mathbb{T} \cap [0, ta(s)])\}</math> where <math> t_e </math> denotes elapsed time since last event and <math> \mathbb{T}=[0,\infty)</math> denotes the set of non-negative real numbers, and # the external state transition <math> \delta_{ext}:Q \times X \rightarrow S</math>. Then the [[DEVS]] model, <math>\mathcal{M} </math> is a [[Timed Event System]] <math>\mathcal{G}=<Z,Q,q_0,Q_A,\Delta> </math> where <blockquote> *The event set <math>Z=X \cup Y^\phi</math>. *The state set <math>Q=\mathcal{M}.Q \cup \{(illegal,t_e)| illegal \not \in S, t_e \in \mathbb{T} \}</math>. *The initial state <math> \,q_0 = (s_0,0)</math>. *The set of acceptance states <math> Q_A = \mathcal{M}.Q.</math> *The state trajectory function <math> \Delta: Q \times \Omega_{Z,[t_l,t_u]} \rightarrow Q</math> is defined for an total state <math> q=(s,t_e) \in Q</math> at time 