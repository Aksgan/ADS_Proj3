CPorts (potentially multiple hops apart) and aims to isolate connections from one another ("virtual wire" analogy). In contrast, L2 flow control is per-hop and avoids basic loss of data due to lack of receiver buffer space. ===L4 flow control applicability=== E2E FC is only possible for connection-oriented communication, but at present UniPro's L4 does not support alternative options. E2E FC is enabled by default but can, however, be disabled. This is not generally recommended. ===L4 safety net=== UniPro provides "safety net" mechanisms that mandate that a CPort absorbs all data sent to it without stalling. If a stall is detected anyway, the endpoint discards the incoming data arriving at that CPort in order to maintain data flow on the network. This can be seen as a form of graceful degradation at the system level: if one connection on the network cannot keep up with the speed of the received data, other devices and other connections are unaffected. ===L4 and Messages=== UniPro L4 allows a connection between a pair of CPorts to convey a stream of so-called messages (each consisting of a series of bytes) rather than a single stream of bytes. Message boundaries are triggered by the application-level protocol using UniPro and are signaled via a bit in the segment header. This End-of-Message bit indicates that the last byte in the L4 segment is the last byte of the application-level message. UniPro needs to be told by the application where or when to insert message boundaries into the byte stream: the boundaries have no special meaning for UniPro itself and are provided as a service to build higher-layer protocols on top of UniPro. Messages can be used to indicate (e.g. via an interrupt) to the application that a unit of data is complete and can thus be processed. Messages can also be useful as a robust and efficient mechanism to implement resynchronization points in some applications. ===L4 guarantees=== The mechanisms in L4 provide a number of guarantees to upper layer protocols: * A CPort cannot stall, in the sense that it will always continue to accept data as fast as the link or network can deliver the data. * If an application bound to CPort of a connection stalls and thus fails (for brief or longer periods) to absorb data, other connections to the same or different devices are unaffected. * A stream of data sent from one CPort to another will always arrive intact, in order, and with the correct message boundary information if the CPort is able to keep up with the incoming data stream. * In case the CPort cannot keep up with the incoming data stream, one or more messages may be corrupted (due to missing data) and the receiver is notified about this error condition. * It is safe for an application-level protocol to wait for a peer's response (e.g. an answer or acknowledgement) to a sent L4 message (e.g. a question or command). But it is unsafe for an application-level protocol to await a peer's response to a sent partial message. * The content of received short header packets/segments will always be correct. Although delivery at the long-header trap interface is not guaranteed, a future protocol extension plans to make the delivery of such packets reliable. This protocol extension could be implemented in software on top of the long-header trap. ==References== {{reflist}} ==See also== * [[UniPro]] * [[Mobile Industry Processor Interface|MIPI Alliance]] {{DEFAULTSORT:Unipro Protocol Stack}} [[Category:Embedded systems]] [[Category:Network protocols]] [[Category:UniPro]]</text> </page> <page> <id>38780</id> <title>Unicon (programming language)</title> <text>{{Refimprove|date=April 2010}} {{Infobox programming language | name = Unicon | logo = | caption = | file ext = | paradigm = [[object-oriented programming|object-oriented]], [[procedural programming|procedural]] | released = <!-- {{Start date|YYYY}} --> | designer = Clint Jeffery | developer = | latest release version = | latest release date = <!-- {{start date and age|YYYY|MM|DD}} --> | latest preview version = | latest preview date = <!-- {{start date and age|YYYY|MM|DD}} --> | typing = | implementations = | dialects = | influenced by = [[Icon programming language|Icon]] | influenced = | operating system = [[Cross-platform]]: [[Microsoft Windows|Windows]], [[Unix]] | license = [[GNU General Public License]] | website = http://unicon.sourceforge.net/ | wikibooks = }} '''Unicon''' is a [[programming language]] designed by American computer scientist Clint Jeffery. Unicon descended from [[Icon programming language|Icon]] and its preprocessor, [[IDOL]], that offers better access to the [[operating system]] as well as support for [[object-oriented programming]]. Unicon began life as a merger of three popular Icon extensions: an OO preprocessor named Idol, a [[POSIX]] filesystem and networking interface, and an [[Open Database Connectivity|ODBC]] facility. The name is shorthand for "Unified Extended Dialect of Icon." Compared with Icon, many of the new features of Unicon are extensions to the I/O and system interface, to complement Icon's core control and data structures. Rather than providing lower-level API's as-is from C, Unicon implements higher level and easier to use facilities, enabling rapid development of graphic- and network-intensive applications in addition to Icon's core strengths in text and file processing. * classes and packages *[[Exception handling|exceptions]] as a contributed class library - see mailing list * loadable child programs * monitoring of child programs * dynamic loading of C modules (some platforms) * multiple inheritance, with novel{{Citation needed|date=April 2010}} semantics * ODBC database access * dbm files can be used as associative arrays * posix system interface * 3D graphics When run as a graphical IDE, the Unicon program ui.exe continues to offer links to Icon help. The official [http://unicon.sourceforge.net/book/ub.pdf Unicon programming book in PDF format] is a popular way to learn Unicon. The book includes an introduction to object-oriented development as well as [[Unified_Modeling_Language|UML]]. It includes useful chapters on topics such as the use of Unicon for CGI. Recent additions to Unicon include [[XMLHttpRequest]] and [[SNOBOL]]-style pattern matching. Unicon is not yet [[Unicode]]-compliant and there are opportunities posted at a help-wanted page.<ref>http://unicon.sourceforge.net/helpwanted.html</ref> ==Example== <source lang="lua"> procedure main() w := open("test UNICON window", "g") write( w, "testing") write( w, "Any key will close this window") read(w) 