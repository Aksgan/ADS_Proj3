dynamic languages such as IronPython and IronRuby'' | accessdate = 2009-08-12}}</ref> [[IronScheme]], an upcoming [[Scheme (programming language)|Scheme]] implementation,<ref>http://www.codeplex.com/IronScheme</ref> was planning to build upon the DLR. This idea was abandoned because the DLR [[Branching (software)|branch]] the project used became out of sync with the [[Trunk (software)|trunk]], and also because (according to the project coordinator) the current version of the DLR at that time could not support the majority of Scheme's requirements.<ref>{{cite web | url = http://ironscheme.codeplex.com/Thread/View.aspx?ThreadId=55925 | title = Is there any silverlight sample? |quote=''Unfortunately, my DLR branch is very out of sync with the Silverlight one. I just thought about it, perhaps I do not need the DLR perse, will investigate. The problem is that the DLR as-is, is not good enough to support the majority of the Scheme's requirements'' | date=2009-05-11 | accessdate = 2009-07-26}}</ref> ==Architecture== The Dynamic Language Runtime is built on the idea that it is possible to implement language specificities on top of a generic language-agnostic [[abstract syntax tree]], whose nodes correspond to a specific functionality that is common to many dynamic languages.<ref>{{cite web | url = http://blogs.msdn.com/hugunin/archive/2007/05/15/dlr-trees-part-1.aspx | title = DLR Trees (Part 1) | last=Hugunin|first=Jim | quote=''The key implementation trick in the DLR is using these kinds of trees to pass code around as data and to keep code in an easily analyzable and mutable form as long as possible.'' | date = 2007-05-15 | accessdate = 2008-02-23}}</ref> This architecture is backed by the idea that the number of elementary language constructs that would have to be implemented on the generic stack should be inherently limited.<ref>{{cite web | url = http://headius.blogspot.com/2008/01/langnet-2008-day-1-thoughts.html | title = Lang.NET 2008: Day 1 Thoughts | last=Nutter|first=Charles | quote=''The idea is that there's a quickly-flattening asymptotic curve to the number of expression tree nodes required to implement each new language. Whether that's the case is yet to be seen.'' | date = 2008-01-28 | accessdate = 2008-02-23}}</ref> The DLR [[.NET metadata#Reflection|dynamically generates]] code corresponding to the functionality expressed by these nodes. The compiler for any dynamic language implemented on top of the DLR has to generate DLR abstract trees, and hand it over to the DLR libraries. The DLR provides dynamically-updated <code>DynamicSite</code> objects that cache the task of binding methods to objects. Since the type of an object—as well as the members it contains—in dynamic languages can change during a program lifetime, a method invocation must check the method list to see if the invocation is a valid one. <code>DynamicSite</code> objects represent and cache the state of the object and its methods; any update to the object is reflected in the <code>DynamicSite</code> objects as well. DLR routes all method invocations via the <code>DynamicSite</code> objects, which then performs a fast lookup and [[name binding|binding]] of the method with the actual implementation.<ref>{{cite web | url = http://msdn2.microsoft.com/en-us/magazine/cc163344.aspx | title = CLR Inside Out: IronPython and the Dynamic Language Runtime | publisher = [[MSDN]] Magazine | author = Bill Chiles | date = October 2007 | accessdate = 2007-08-10}}</ref> In contrast to other efforts like the [[Parrot virtual machine]] (with no dependencies) or [[Da Vinci Machine]] (built on Java's [[JVM]] by adding new bytecodes in the [[Java bytecode|JVM instruction set]]), the DLR is built on top of the existing [[Common Language Runtime]], the [[.NET Framework]] virtual machine.<ref>{{cite web | url = http://blogs.sun.com/jrose/entry/bravo_for_the_dynamic_runtime | title = Bravo for the dynamic runtime! | last=Rose|first=John | quote=''The differences between the CLR and JVM extensions are interesting to note. They work completely above the level of the CLR without significantly enhancing it, while we are developing the JVM and libraries at the same time.'' | date = 2008-02-02 | accessdate = 2008-02-23}}</ref> ==See also== *[[Da Vinci Machine]], an ongoing effort to bring support for dynamic languages on the [[Java Platform]] at the [[Java Virtual Machine]] level. == References == {{reflist|2}} {{refbegin}} *{{cite web | url = http://blogs.msdn.com/somasegar/archive/2007/04/30/mix-07-silverlight-shines-brighter.aspx | title = MIX 07 - Silverlight shines brighter! | accessdate = 2007-04-30}} *{{cite web | url = http://sessions.visitmix.com/default.asp?event=1011&session=2012&pid=DEV02&disc=&id=1511&year=2007&search=DEV02 | title = MIX 07 Video Presentation - DEV02 - Just Glue It! Ruby and the DLR in Silverlight | accessdate = 2007-05-04 |archiveurl = http://web.archive.org/web/20070508035633/http://sessions.visitmix.com/default.asp?event=1011&session=2012&pid=DEV02&disc=&id=1511&year=2007&search=DEV02 <!-- Bot retrieved archive --> |archivedate = 2007-05-08}} *{{cite web | url = http://blogs.msdn.com/hugunin/archive/2007/04/30/a-dynamic-language-runtime-dlr.aspx | title = Jim Hugunin's Thinking Dynamic | A Dynamic language runtime (DLR) | accessdate = 2008-02-06}} *{{cite web | url = http://packages.debian.org/source/squeeze/dlr-languages | title = Details of source package dlr-languages in squeeze | DLR in Debian | accessdate = 2010-07-06}} *{{cite web | url = http://packages.ubuntu.com/source/lucid/dlr-languages | title = Details of source package dlr-languages in lucid | DLR in Ubuntu | accessdate = 2010-07-06}} {{refend}} {{DotNET}} [[Category:Microsoft application programming interfaces]] [[Category:.NET framework]] [[fr:Dynamic Language Runtime]] [[ja:動的言語ランタイム]] [[pl:Dynamic Language Runtime]] [[sv:Dynamic Language Runtime]] [[zh:Dynamic Language Runtime]]</text> </page> <page> <id>11226</id> <title>Dynamic Logical Partitioning</title> <text>'''Dynamic Logical Partitioning''' ('''DLPAR'''), is the capability of a [[LPAR|logical partition]] (LPAR) to be reconfigured dynamically, without having to shut down the operating system that runs in the LPAR. DLPAR enables memory, CPU capacity, and I/O interfaces to be moved nondisruptively between LPARs within the same server. [[IBM]] introduced DLPAR on [[POWER4]]-based servers with the availability of [[AIX]] 5.2 in October 2002. DLPAR has been supported by the operating systems [[AIX operating system|AIX]] and [[i5/OS]] on almost all POWER4 and follow-on POWER systems since then. The [[Linux kernel]] for POWER also supported DLPAR, but its dynamic reconfiguration capabilities were limited to CPU capacity and [[Peripheral Component Interconnect|PCI]] devices, but not memory. In October 2009, seven years after the AIX announcement of DLPAR of memory, CPU and IO slots, Linux finally added the capability to DLPAR memory on POWER systems. The fundamentals of DLPAR are described in the IBM Systems Journal paper titled: "Dynamic reconfiguration: Basic building blocks for autonomic computing on IBM pSeries Servers" ( http://www.research.ibm.com/journal/sj/421/jann.html ) and written by the original inventor of DLPAR, Joefon Jann, and her team. Later on, the [[POWER5]] processor added enhanced DLPAR capabilities, including [[Micro-Partitioning|micro-partitioning]]: up to 10 LPARs can be configured per processor, with a single multiprocessor server supporting a maximum of 