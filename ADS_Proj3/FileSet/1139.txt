of nodes. The node is an [[Abstract type|abstract base class]], and derivatives can either be leaves (singular), or collections of other nodes (which in turn can contain leaves or collection-nodes). When an operation is performed on the parent, that operation is recursively passed down the hierarchy. ===Formatting=== Formatting differs from structure. Formatting is a method of constructing a particular instance of the document's physical structure. This includes breaking text into lines, using hyphens, adjusting for margin widths, etc. '''Problems and Constraints''' #Balance between (formatting) quality, speed and storage space #Keep formatting independent (uncoupled from) the document structure. '''Solution and Pattern''' A ''Compositor'' class will encapsulate the algorithm used to format a composition. Compositor is a subclass of the primitive object of the document's structure. A Compositor has an associated instance of a Composition object. When a Compositor runs its <code>Compose()</code>, it iterates through each element of its associated Composition, and rearranges the structure by inserting Row and Column objects as needed. The Compositor itself is an abstract class, allowing for derivative classes to use different formatting algorithms (such as double-spacing, wider margins, etc.) The [[Strategy pattern|Strategy Pattern]] is used to accomplish this goal. A Strategy is a method of encapsulating multiple algorithms to be used based on a changing context. In this case, formatting should be different, depending on whether text, graphics, simple elements, etc, are being formatted. ===Embellishing the User Interface=== The ability to change the graphical interface that the user uses to interact with the document. '''Problems and Constraints''' #Demarcate a page of text with a border around the editing area #Scroll bars that let the user view different parts of the page #User interface objects should not know about the embellishments #Avoid an "explosion of classes" that would be caused by subclassing for "every possible combination of embellishments" and elements (p44) '''Solution and Pattern''' The use of a ''transparent enclosure'' allows elements that augment the behaviour of composition to be added to a composition. These elements, such as Border and Scroller, are special subclasses of the singular element itself. This allows the composition to be augmented, effectively adding state-like elements. Since these augmentations are part of the structure, their appropriate <code>Operation()</code> will be called when the structure's <code>Operation()</code> is called. This means that the client does not need any special knowledge or interface with the structure in order to use the embellishments. This is a [[Decorator pattern]], one that adds responsibilities to an object without modifying the object itself. ===Supporting Multiple Look-And-Feel Standards=== [[Look and feel|Look-and-feel]] refers to [[Platform (computing)|platform]]-specific UI standards. These standards "define guidelines for how applications appear and react to the user" (pp47). '''Problems and Constraints''' #The editor must implement standards of multiple platforms so that it is [[porting|portable]] #Easily adapt to new and emergent standards #Allow for run-time changing of look-and-feel (ie: No [[hard coded|hard-coding]]) #Have a set of abstract elemental subclasses for each category of elements (ScrollBar, Buttons, etc) #Have a set of concrete subclasses for each abstract subclass that can have a different look-and-feel standard. (ScrollBar having MotifScrollBar and PresentationScrollBar for Motif and Presentation look-and-feels) '''Solution and Pattern''' Since object creation of different concrete objects cannot be done at runtime, the object creation process must be abstracted. This is done with an abstract guiFactory, which takes on the responsibility of creating UI elements. The abstract guiFactory has concrete implementations, such as MotifFactory, which creates concrete elements of the appropriate type (MotifScrollBar). In this way, the program need only ask for a ScrollBar and, at run-time, it will be given the correct concrete element. This is an [[Abstract factory pattern|Abstract Factory]]. A regular factory creates concrete objects of one type. An abstract factory creates concrete objects of varying types, depending on the concrete implementation of the factory itself. Its ability to focus on not just concrete objects, but entire ''families'' of concrete objects "distinguishes it from other creational patterns, which involve only one kind of product object" (pp51). ===Supporting Multiple Window Systems=== Just as look-and-feel is different across platforms, so is the method of handling [[window (computing)|windows]]. Each platform displays, lays out, handles input to and output from, and layers windows differently. '''Problems and Constraints''' #The document editor must run on as many of the "important and largely incompatible window systems" that exist (p. 52) #An Abstract Factory cannot be used. Due to differing standards, there will not be a common abstract class for each type of widget. #Do not create a new, nonstandard windowing system '''Solution and Pattern''' It is possible to develop "our own abstract and concrete product classes", because "all window systems do generally the same thing" (p. 52). Each window system provides operations for drawing primitive shapes, iconifying/de-iconfiying, resizing, and refreshing window contents. An abstract base <code>Window</code> class can be derived to the different types of existing windows, such as application, [[iconification|iconified]], dialog. These classes will contain operations that are associated with windows, such as reshaping, graphically refreshing, etc. Each window contains elements, whose <code>Draw()</code> functions are called upon by the <code>Window</code>'s own draw-related functions. In order to avoid having to create platform-specific Window subclasses for every possible platform, an interface will be used. The <code>Window</code> class will implement a <code>Window</code> implementation (<code>WindowImp</code>) abstract class. This class will then in turn be derived into multiple platform-specific implementations, each with platform-specific operations. Hence, only one set of <code>Window</code> classes are needed for each type of <code>Window</code>, and only one set of <code>WindowImp</code> classes are needed for each platform (rather than the [[Cartesian product]] of all available types and platforms). In addition, adding a new window type does not require any modification of platform implementation, or vice-versa. This is a [[Bridge pattern]]. <code>Window</code> and <code>WindowImp</code> are different, but related. <code>Window</code> deals with windowing in the program, and <code>WindowImp</code> deals with windowing on a platform. One of them can change without ever having to modify the other. The Bridge pattern allows these two "separate class hierarchies to work together even as they evolve independently" (p. 54). ===User Operations=== All actions the 