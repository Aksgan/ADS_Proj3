following Mythryl function "d" computes the numerical derivative of a given function "f" at a given point "x": fun d delta f x = (f (x + delta) - f (x - delta)) / (2.0 * delta); This function requires a small value "delta". A good choice for delta when using this algorithm is the cube root of the [[machine epsilon]].{{Citation needed|date=August 2008}} The function "d" maps a "Float" onto another function with the type "(Float -> Float) -> Float -> Float". This allows us to partially apply arguments. This functional style is known as [[currying]]. In this case, it is useful to partially apply the first argument "delta" to "d", to obtain a more specialised function: d = d 1E~8; We can compute a numerical approximation to the derivative of x^3-x-1 at x=3 with: eval: d (fn x = x*x*x - x - 1.0) 3.0; 25.9999996644 The correct answer is f'(x) = 3x^2-1 => f'(3) = 27-1 = 26. The function "d" is called a [[higher-order function]] because it accepts another function ("f") as an argument. [[Currying|Curried]] and higher-order functions can be used to eliminate redundant code. For example, a library may require functions of type <code>A -> B</code>, but it is more convenient to write functions of type <code>(A, C) -> B</code> where there is a fixed relationship between the objects of type <code>A</code> and <code>C</code>. A higher order function of type ((A, C) -> B) -> (A -> B) can factor out this commonality. This is an example of the [[adapter pattern]]. ==External links== * [http://mythryl.org Mythryl home page] ==References== <!--See http://en.wikipedia.org/wiki/Wikipedia:Footnotes for an explanation of how to generate footnotes using the <ref> and </ref> tags, and the template below--> {{reflist}} [[Category:Procedural programming languages]] [[Category:ML programming language family]] [[Category:Functional languages]] [[Category:Programming languages created in 2009]] [[Category:Free compilers and interpreters]] [[Category:Unix shells]] [[Category:Free development toolkits and libraries]]</text> </page> <page> <id>25539</id> <title>N-version programming</title> <text>{{DISPLAYTITLE:''N''-version programming}} '''''N''-version programming''' (NVP), also known as '''multiversion programming''', is a method or process in [[software engineering]] where multiple functionally equivalent programs are independently generated from the same initial specifications <ref name="avizienis-ieee">[http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=532621 N-Version Programming: A Fault-Tolerance Approach to Reliability of Software Operation], Liming Chen; Avizienis, A., Fault-Tolerant Computing, 1995, ' Highlights from Twenty-Five Years'., Twenty-Fifth International Symposium on, Vol., Iss., 27-30 Jun 1995, Pages:113-</ref>. The concept of ''N''-version programming was introduced in 1977 by Liming Chen and Algirdas Avizienis with the central conjecture that the "independence of programming efforts will greatly reduce the probability of identical software faults occurring in two or more versions of the program" <ref name="avizienis-ieee" /> <ref name="avizienis-redundancy" />. The aim of NVP is to improve the reliability of software operation by building in [[fault tolerance]] or [[Redundancy (engineering)|redundancy]] <ref name="avizienis-ieee" />. == NVP approach == The general steps of ''N''-version programming are: # An initial specification of the intended functionality of the software is developed. The specification should unambiguously define: functions, data formats (which include comparison vectors, c-vectors, and comparison status indicators, cs-indicators), cross-check points (cc-points), comparison algorithm, and responses to the comparison algorithm <ref name="avizienis-ieee" /> <ref name="avizienis-redundancy">A.A. Avizienis, “[http://se2c.uni.lu/tiki/se2c-bib_download.php?id=1146 The Methodology of N-version Programming]”, Software Fault Tolerance, edited by M. Lyu, John Wiley & Sons, 1995.</ref>. # From the specifications, two or more versions of the program are independently developed, each by a group that does not interact with the others <ref name="avizienis-ieee" />. The implementations of these functionally equivalent programs use different algorithms and programming languages <ref name="avizienis-ieee" />. At various points of the program, special mechanisms are built into the software which allow the program to be governed by the ''N''-version execution environment (NVX) <ref name="avizienis-redundancy" />. These special mechanisms include: comparison vectors (c-vectors, a data structure representing the program's state), comparison status indicators (cs-indicators), and synchronization mechanisms <ref name="avizienis-ieee" />. The resulting programs are called ''N''-version software (NVS) <ref name="avizienis-redundancy" />. # Some ''N''-version execution environment (NVX) is developed which runs the ''N''-version software and makes final decisions of the ''N''-version programs as a whole given the output of each individual ''N''-version program <ref name="avizienis-redundancy" />. The implementation of the decision algorithms can vary ranging from simple as accepting the most frequently occurring output (for instance, if a majority of versions agree on some output, then it is likely to be correct) to some more complex algorithm <ref name="liburd-mit">Liburd, Soyini. [http://hdl.handle.net/1721.1/28441 An ''N''-version electronic voting system (Thesis)]. Massachusetts Institute of Technology. Dept. of Electrical Engineering and Computer Science, 2004.</ref>. == Criticisms == * Researchers have argued that different programming teams can make similar mistakes <ref name="nvp-exploit">Lajos Nagy, Richard Ford, and William Allen. [https://cs.fit.edu/Projects/tech_reports/cs-2006-04.pdf N-Version Programming for the Detection of Zero-day Exploits]. The 2006 IEEE Topical Conference on Cybersecurity, Daytona Beach, Florida, April 2006.</ref>. In 1986, Knight & Leveson conducted an experiment to evaluate the assumption of independence in NVP, they found that the assumption of independence of failures in ''N''-version programs failed statistically <ref name="knight-leveson">Knight, J. C. and Leveson, N. G. 1986. [http://portal.acm.org/citation.cfm?coll=GUIDE&dl=GUIDE&id=10688# An experimental evaluation of the assumption of independence in multiversion programming]. IEEE Trans. Softw. Eng. 12, 1 (Jan. 1986), 96-109.</ref> <ref name="kl-response">Knight, J. C. and Leveson, N. G. 1990. [http://doi.acm.org/10.1145/382294.382710 A reply to the criticisms of the Knight & Leveson experiment]. SIGSOFT Softw. Eng. Notes 15, 1 (Jan. 1990), 24-35.</ref> <ref name="nvp-exploit" />. * The weakness of an NVP program lies in the decision algorithm. The question of correctness of an NVP program depends partially on the algorithm the NVX uses to determine what output is "correct" given the multitude of outputs by each individual ''N''-version program <ref name="liburd-mit" />. In theory, output from multiple independent versions is more likely to be correct than output from a single version <ref name="liburd-mit" />. However, there is debate whether or not the improvements of ''N''-version development is enough to warrant the time, additional requirements, and costs of using the NVP method <ref name="liburd-mit" />. == Applications == ''N''-version programming has been applied to software in switching trains, performing flight control computations on modern airliners, [[electronic voting]] (the SAVE System), and the detection of [[zero-day 