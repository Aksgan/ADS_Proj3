only recently proved by Andrew Wiles (1994). Previously in his book (p. 10, 11) Franzén describes what a [[Diophantine equation]] is and gives good examples (Fermat's last theorem has to do with a simple type of Diophantine equation recognizable to students as part of the conclusion of the [[Pythagorean theorem]] when the exponent is "2"). : Question: Does any arbitrary "Diophantine equation" have an integer solution? Answer: undecidable. : Fermat's last theorem: "No equation of the form :: ''x''<sup>''n''</sup> + ''y''<sup>''n''</sup> = ''z''<sup>''n''</sup> with ''n'' greater than 2 have any solution in positive integers" (Franzén p. 11) Franzén introduces "Hilbert's 10nth problem" and the [[Matiyasevich's theorem|MRDP theorem]] (Matiyasevich-Robinson-Davis-Putnam theorem) which states that ''no algorithm exists which can decide whether or not a Diophantine equation has ''any'' solution at all''. Franzén's treatment is a creditable job but relies on the reader's understanding of certain terminology with reference to Turing's theorem that he develops a few pages beforehand: MRDP uses the undecidability proof of Turing: "... the set of solvable Diophantine equations is an example of a computably enumerable but not decidable set, and the set of unsolvable Diophantine equations is not computably enumerable" (p. 71). Franzén also introduces a really fun ''unsolved'' problem, very easy to describe—even an elementary-algebra student in junior high could get the question: the [[Collatz conjecture]] (3''n'' + 1 conjecture, Ulam's problem). That something so easy to describe and fun to fiddle with is unsolved is rather shocking! (Franzén, p. 11). == Is this simple question impossible to prove? The Collatz (3''n'' + 1) conjecture == Also called Ulam's problem. The entries above have now equipped the reader with the tools to think about an unsolved problem. Here's a chance to become famous: : "No proof of the [[Collatz conjecture]] has been found in spite of intense efforts, and the problem is generally considered extremely difficult" (Franzen, p. 11). This is Franzen's description of the problem: : "... if we start with any positive natural number n and compute n/2 if n is even, or 3''n'' + 1 if ''n'' is odd, and continue applying the same rule to the new number, we will eventually reach 1" (Franzén, p. 11) Here are the first numbers. Clearly once certain numbers appear inside a string then they don't need to be "dealt with". But the ''lengths'' of the strings are interesting—they have a randomness to them that is "worrisome", per Chaitin's proof described above. This should lead us to believe that the question is "undecidable" (i.e. it's impossible to know whether the hypothesis is true or false): : 1, 4, 2, 1 : 2, 1 : 3, 10, 5, 16, 8, 4, 2, 1 : 4, 2, 1 : 5, 16, 8, 4, 2, 1 : 6, 3, 10, 5, 16, 8, 4, 2, 1 : 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1 : 8, 4, 2, 1 : 9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1 : 10, 5, 16, 8, 4, 2, 1 : 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1 : 12, 6, 3, 10, 5, 16, 8, 4, 2, 1 : 13, 40, 20, 10, 5, 16, 8, 4, 2, 1 : 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1 : 15, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1 : 80, 40, 20, 10, 5, 16, 8, 4, 2, 1 : 81, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1 : 82, 41, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1 But here's another clue that leads us to believe that the conjecture is true: algorithms that construct numbers are sometimes thought of as "[[Mathematical proof|proof]]s" in an [[axiom schema]]. For example, "proof" in number theory has a very precise meaning—that the next "provable formula" follows from either (i) an axiom, (ii) one prior "provable formula" or, (iii) two prior "provable formulas". In order to do these proofs in the framework of a tiny set of axioms, we might think of the numbers (and the formulas themselves) as strings of "unary", just "tally marks", separated by a "blank" symbol i.e. number "7" is | | | | | | |, i.e. 7 marks. If a proof is "true" then it is a [[Tautology (logic)|tautology]]. Thus the statement "3 + 4 = 7" is a tautology i.e. | | | + | | | | = | | | | | | |. (To do this we would have to express the "+" symbol and "=" symbols in a similar code, and provide adequate "formation rules" etc.) If we "check the proof" (as we used to do in geometry) by writing down all the steps that led us to the end of the proof, then the proof always ends in "True". If we assign the symbol "1" as equivalent to "True" then whenever we proof-check a tautology it always ends in 1, just as the Collatz sequence does above. Here's another clue that points to impossibility: we can describe a "machine" to do the computation as a "state machine". When the 