software product performed after delivery to keep a software product usable in a changed or changing environment; * ''Perfective maintenance'': Modification of a software product after delivery to improve performance or maintainability; * ''Preventive maintenance'': Modification of a software product after delivery to detect and correct latent faults in the software product before they become effective faults. All of the preceding take place when there is a known requirement for change. Although these categories were supplemented by many authors like Warren et al. (1999){{Citation needed|date=October 2009}} and Chapin (2001){{Citation needed|date=October 2009}}, the ISO/IEC 14764:2006 international standard has kept the basic four categories. More recently the description of software maintenance and evolution has been done using ontologies (Kitchemham et al. (1999),{{Citation needed|date=October 2009}} Derider (2002),{{Citation needed|date=October 2009}} Vizca√≠no 2003,{{Citation needed|date=October 2009}} Dias (2003),{{Citation needed|date=October 2009}} and Ruiz (2004)),{{Citation needed|date=October 2009}} which enrich the description of the many evolution activities. ==Lehman's Laws of Software Evolution== Prof. [[Meir M. Lehman]], who worked at [[Imperial College London]] from 1972 to 2002, and his colleagues have identified a set of behaviours in the evolution of proprietary software. These behaviours (or observations) are known as [[Lehman's laws of software evolution|''Lehman's Laws'']], and there are eight of them: # Continuing Change # Increasing Complexity # Large Program Evolution # Invariant Work-Rate # Conservation of Familiarity # Continuing Growth # Declining Quality # Feedback System It is worth mentioning that the laws are believed to apply mainly to monolithic, proprietary software. For example, some empirical observations coming from the study of [[open source software development]] appear to challenge some of the laws {{Vague|date=June 2010}}{{Citation needed|date=June 2010}}. The laws predict that change is inevitable and not a consequence of bad programming and that there are limits to what a software evolution team can achieve in terms of safely implementing changes and new functionality. Maturity Models specific to software evolution have been developed to help improve processes to ensure continuous rejuvenation of the software evolves iteratively. The "global process" that is made by the many stakeholders (e.g. developers, users, their managers) has many feedback loops. The evolution speed is a function of the feedback loop structure and other characteristics of the global system. Process simulation techniques, such as [[system dynamics]] can be useful in understanding and managing such global process. Software evolution is not likely to be [[Darwinian evolution|Darwinian]], [[Lamarckian evolution|Lamarckian]] or [[Baldwinian evolution|Baldwinian]], but an important phenomenon on its own. Giving the increasing dependence on software at all levels of society and economy, the successful evolution of software is becoming increasingly critical. This is an important topic of research that hasn't received much attention. The evolution of software, because of its rapid path in comparison to other man-made entities, was seen by Lehman as the "fruit fly" of the study of the evolution of artificial systems. ==See also== * [[Software entropy]] * [[Meir M. Lehman]] * [[Darwinian evolution]] * [[Lamarckian evolution]] * [[Baldwinian evolution]] * ''[[Journal of Software Maintenance and Evolution: Research and Practice]]'' ==References== {{Reflist}} [[Category:Software engineering]] [[Category:Software maintenance]] [[de:Software-Evolution]]</text> </page> <page> <id>34998</id> <title>Software framework</title> <text>In [[computer programming]], a '''software framework''' is an abstraction in which common code providing generic functionality can be selectively overridden or specialized by user code, thus providing specific functionality. Frameworks are a special case of [[software library|software libraries]] in that they are reusable abstractions of code wrapped in a well-defined [[application programming interface|Application programming interface (API)]], yet they contain some key distinguishing features that separate them from normal libraries. Software frameworks have these distinguishing features that separate them from libraries or normal user applications: # '''[[inversion of control]]''' - In a framework, unlike in libraries or normal user applications, the overall program's [[control flow|flow of control]] is not dictated by the caller, but by the framework.<ref>{{citation|url=http://www.riehle.org/computer-science/research/dissertation/diss-a4.pdf|first=Dirk|last=Riehle|title=Framework Design: A Role Modeling Approach|publisher=[[ETH Zurich|Swiss Federal Institute of Technology]]|year=2000|postscript=<!--none-->}}</ref> # '''default behavior''' - A framework has a default behavior. This default behavior must actually be some useful behavior and not a series of [[NOP|no-ops]]. # '''[[extensibility]]''' - A framework can be extended by the user usually by selective overriding or specialized by user code providing specific functionality. # '''non-modifiable framework code''' - The framework code, in general, is not allowed to be modified. Users can extend the framework, but not modify its code. There are different types of software frameworks: conceptual, application, domain, platform, component, service, development, etc.<ref>{{cite web|first = Tony|last = Shan|date = 2006|accessdate = 2010-10-10|url = http://portal.acm.org/citation.cfm?id=1190953|title = Taxonomy of Java Web Application Frameworks|publisher = Proceedings of 2006 IEEE International Conference on e-Business Engineering (ICEBE 2006)}}</ref> == Rationale == The designers of software frameworks aim to facilitate software development by allowing designers and programmers to devote their time to meeting software requirements rather than dealing with the more standard low-level details of providing a working system, thereby reducing overall development time.<ref>{{cite web |url=http://docforge.com/wiki/Framework |title=Framework |accessdate=15 December 2008 |work= DocForge}}</ref> For example, a team using a [[web application framework]] to develop a banking web-site can focus on the operations of account withdrawals rather than the mechanics of request handling and state management. By way of contrast, an in-house or purpose-built framework might be specified for the same project by a programming team as they begin working the overall job{{mdash}}specifying software needs based on first defining data types, structures and processing has long been taught as a successful strategy for top down design. Contrasting software data, its manipulation, and how a software system's various grades and kinds of users will need to either input, treat, or output the data are then used to specify the user interface(s) {{mdash}}some types of access being privileged and locked to other user types{{mdash}} all defining the overall user interfaces which to the users are the visible in-house Framework for the custom coded project. In such a case, each sort of operation, user interface code and so forth need written and separately integrated into the job at hand also more or less adding to necessary testing and validation. It can be argued that frameworks add to "[[code bloat]]", and that due 