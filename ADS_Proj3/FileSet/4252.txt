more bits of information per cell rather than just one, in an architecture called [[Multi-Level Cell]] (MLC). This is accomplished by storing intermediate voltage levels instead of using only the two levels ("0" = "discharged" and "1" = "charged") of traditional binary memories. The StrataFlash technology evolved out of Intel's ETOX flash memory products. Two bits per cell are achieved with four levels of voltage, while three bits per cell can be achieved with eight levels. Research of this technology began in 1992 and the first commercial products were released in 1997. Further developments allowed faster read speeds by offering synchronous burst mode and asynchronous page mode read operations. ==References== *[http://download.intel.com/technology/itj/q41997/pdf/overview.pdf Intel StrataFlash™ Memory Technology Overview] {{compu-storage-stub}} [[Category:Computer memory]] [[Category:Non-volatile memory]] [[Category:Solid-state computer storage media]] [[de:StrataFlash]]</text> </page> <page> <id>35878</id> <title>Strawberry Prolog</title> <text>'''Strawberry Prolog''' is a [[programming language dialect|dialect]] of the [[Prolog]] [[programming language]]. Its [[syntax of programming languages|syntax]] is very close to that of ISO-Prolog but it has many extensions which are not part of the standard. The main idea of Strawberry Prolog is to be very easy to use and that is why some [[university|universities]] use it for their Prolog courses. == History == Strawberry Prolog is produced by the [http://www.math.bas.bg/ Institute of Mathematics and Informatics] at [[Bulgarian Academy of Sciences]]. The first version was released in 1996. The leader of the Strawberry team is Dimiter Dobrev. == Some extensions == * Global variables * Arrays * Definition of functions and Built-in predicates * Prolog CGI Scripts * OLE Automation - COM and ActiveX * Strawberry Prolog as OLE server * Databases through ODBC == Download == The [[compiler]] can be downloaded from the Strawberry Prolog website. A restricted edition is available as [[freeware]]. == Sample programs == * '''Chess.spj''' — Chess Playing Program. You can play against the computer. This program is included in the standard installation of Strawberry Prolog. You will find it in the folder ''Games''. * '''Fractals.pro''' — You will see an infinite fractals field in which you can move and even get lost. The goal is to find the target place in the field. This is a clever program which uses the [[Pseudorandom number generator|pseudo-random numbers]] in order to generate infinite but constant fractals field where you can come back and to find there the same picture as before. This sample demonstrate the graphical power of Strawberry Prolog. You will find it in the folder ''Programs'' in the standard installation of the Light edition. == Debugger == Strawberry Prolog has a unique [[debugger]]. You can watch the execution of your program in the ''Proof Tree'' [[window (computing)|window]]. == See also == * [[Prolog]] ==External links== * [http://www.dobrev.com/ Strawberry Prolog website] * [http://www.dobrev.com/help/ Strawberry Prolog Help], online help [[Category:Prolog programming language family]] [[Category:Free compilers and interpreters]] [[Category:Integrated development environments]]</text> </page> <page> <id>35883</id> <title>Stream X-Machine</title> <text>The '''Stream X-machine''' ('''SXM''') is a model of computation introduced by Gilbert Laycock in his 1993 PhD thesis, ''The Theory and Practice of Specification Based Software Testing''.<ref name="Lay93">Gilbert Laycock (1993) ''The Theory and Practice of Specification Based Software Testing''. PhD Thesis, University of Sheffield, Dept of Computer Science. [http://www.mcs.le.ac.uk/people/gtl1/PhDabstract.html Abstract]</ref> Based on [[Samuel Eilenberg]]'s [[X-machine]], an extended [[finite state machine]] for processing data of the type ''X'',<ref name="Eil74">Samuel Eilenberg (1974) ''Automata, Languages and Machines, Vol. A''. London: Academic Press.</ref> the Stream X-Machine is a kind of [[X-machine]] for processing a memory data type ''Mem'' with associated input and output streams ''In''* and ''Out''*, that is, where ''X'' = ''Out''* × ''Mem'' × ''In''*. The transitions of a Stream X-Machine are labelled by functions of the form φ: ''Mem'' × ''In'' → ''Out'' × ''Mem'', that is, which compute an output value and update the memory, from the current memory and an input value. Although the general [[X-machine]] had been identified in the 1980s as a potentially useful formal model for specifying software systems,<ref name="Hol88"> M. Holcombe (1988) 'X-machines as a basis for dynamic system specification'. ''Software Engineering Journal'' '''3''' ''(2)'', pp. 69-76.</ref> it was not until the emergence of the Stream X-Machine that this idea could be fully exploited. Florentin Ipate and Mike Holcombe went on to develop a theory of ''complete'' [[functional testing]],<ref name="HolIp98">Mike Holcombe and Florentin Ipate (1998) ''Correct systems - building a business process solution''. Applied Computing Series. Berlin: Springer-Verlag.</ref> in which complex software systems with hundreds of thousands of states and millions of transitions could be decomposed into separate SXMs that could be tested exhaustively, with a guaranteed proof of correct integration.<ref name="IpHol97">F. Ipate and W. M. L. Holcombe (1997) 'An integration testing method which is proved to find all faults'. ''Int. J. Comp. Math.'', '''63''', pp. 159-178.</ref> Because of the intuitive interpretation of Stream X-Machines as "processing agents with inputs and outputs", they have attracted increasing interest, because of their utility in modelling real-world phenomena. The SXM model has important applications in fields as diverse as [[computational biology]], [[software testing]] and [[Computational economics|agent-based computational economics]]. == The Stream X-Machine == A Stream X-Machine (SXM) is an extended [[finite state machine]] with auxiliary memory, inputs and outputs. It is a variant of the general [[X-machine]], in which the fundamental data type ''X'' = ''Out''* × ''Mem'' × ''In''*, that is, a tuple consisting of an output stream, the memory and an input stream. A SXM separates the ''control flow'' of a system from the ''processing'' carried out by the system. The control is modelled by a [[finite state machine]] (known as the ''associated automaton'') whose transitions are labelled with processing functions chosen from a set Φ (known as the ''type'' of the machine), which act upon the fundamental data type. Each processing function in Φ is a partial function, and can be considered to have the type φ: ''Mem'' × ''In'' → ''Out'' × ''Mem'', where ''Mem'' is the memory type, and ''In'' and ''Out'' are respectively the input and output types. In any given state, a transition is ''enabled'' if the domain of the associated function φ<sub>i</sub> includes the next input value and the current memory 