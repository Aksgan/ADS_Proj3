==Proofs and type-theory== The presentation of natural deduction so far has concentrated on the nature of propositions without giving a formal definition of a ''proof''. To formalise the notion of proof, we alter the presentation of hypothetical derivations slightly. We label the antecedents with ''proof variables'' (from some countable set ''V'' of variables), and decorate the succedent with the actual proof. The antecedents or ''hypotheses'' are separated from the succedent by means of a ''[[Turnstile (symbol)|turnstile]]'' ({{Unicode|⊢}}). This modification sometimes goes under the name of ''localised hypotheses''. The following diagram summarises the change. <table style="margin-left: 2em;"><tr><td> ---- u<sub>1</sub> ---- u<sub>2</sub> ... ---- u<sub>n</sub> J<sub>1</sub> J<sub>2</sub> J<sub>n</sub> {{Unicode|⋮}} J </td><td width="10%" align="center">⇒</td><td> u<sub>1</sub>:J<sub>1</sub>, u<sub>2</sub>:J<sub>2</sub>, ..., u<sub>n</sub>:J<sub>n</sub> {{Unicode|⊢}} J </td></tr></table> The collection of hypotheses will be written as Γ when their exact composition is not relevant. To make proofs explicit, we move from the proof-less judgement "''A true''" to a judgement: "π ''is a proof of (A true)''", which is written symbolically as "π : ''A true''". Following the standard approach, proofs are specified with their own formation rules for the judgement "π ''proof''". The simplest possible proof is the use of a labelled hypothesis; in this case the evidence is the label itself. <table style="margin-left: 2em;"><tr><td> u ∈ V ------- proof-F u proof </td><td width="10%"></td><td> --------------------- hyp u:A true {{Unicode|⊢}} u : A true </td></tr></table> For brevity, we shall leave off the judgemental label ''true'' in the rest of this article, ''i.e.'', write "Γ {{Unicode|⊢}} π : ''A''". Let us re-examine some of the connectives with explicit proofs. For conjunction, we look at the introduction rule ∧I to discover the form of proofs of conjunction: they must be a pair of proofs of the two conjuncts. Thus: <table style="margin-left: 2em;"><tr><td> π<sub>1</sub> proof π<sub>2</sub> proof -------------------- pair-F (π<sub>1</sub>, π<sub>2</sub>) proof </td><td width="10%"></td><td> Γ {{Unicode|⊢}} π<sub>1</sub> : A Γ {{Unicode|⊢}} π<sub>2</sub> : B ------------------------ ∧I Γ {{Unicode|⊢}} (π<sub>1</sub>, π<sub>2</sub>) : A ∧ B </td></tr></table> The elimination rules ∧E<sub>1</sub> and ∧E<sub>2</sub> select either the left or the right conjunct; thus the proofs are a pair of projections &mdash; first ('''fst''') and second ('''snd'''). <table style="margin-left: 2em;"><tr><td> π proof ----------- '''fst'''-F '''fst''' π proof </td><td width="10%"></td><td> Γ {{Unicode|⊢}} π : A ∧ B ------------- ∧E<sub>1</sub> Γ {{Unicode|⊢}} '''fst''' π : A </td></tr><tr><td> π proof ----------- '''snd'''-F '''snd''' π proof </td><td width="10%"></td><td> Γ {{Unicode|⊢}} π : A ∧ B ------------- ∧E<sub>2</sub> Γ {{Unicode|⊢}} '''snd''' π : B </td></tr></table> For implication, the introduction form localises or ''binds'' the hypothesis, written using a λ; this corresponds to the discharged label. In the rule, "Γ, ''u'':''A''" stands for the collection of hypotheses Γ, together with the additional hypothesis ''u''. <table style="margin-left: 2em;"><tr><td> π proof ------------ λ-F λu. π proof </td><td width="10%"></td><td> Γ, u:A {{Unicode|⊢}} π : B ----------------- ⊃I Γ {{Unicode|⊢}} λu. π : A ⊃ B </td></tr><tr><td> π<sub>1</sub> proof π<sub>2</sub> proof ------------------- app-F π<sub>1</sub> π<sub>2</sub> proof </td><td width="10%"></td><td> Γ {{Unicode|⊢}} π<sub>1</sub> : A ⊃ B Γ {{Unicode|⊢}} π<sub>2</sub> : A ---------------------------- ⊃E Γ {{Unicode|⊢}} π<sub>1</sub> π<sub>2</sub> : B </td></tr></table> With proofs available explicitly, one can manipulate and reason about proofs. The key operation on proofs is the substitution of one proof for an assumption used in another proof. This is commonly known as a ''substitution theorem'', and can be proved by [[mathematical induction|induction]] on the depth (or structure) of the second judgement. ; Substitution theorem : ''If'' Γ {{Unicode|⊢}} π<sub>1</sub> : ''A'' ''and'' Γ, ''u'':''A'' {{Unicode|⊢}} π<sub>2</sub> : ''B'', ''then'' Γ {{Unicode|⊢}} [π<sub>1</sub>/''u''] π<sub>2</sub> : B. So far the judgement "Γ {{Unicode|⊢}} π : ''A''" has had a purely logical interpretation. In [[type theory]], the logical view is exchanged for a more computational view of objects. Propositions in the logical interpretation are now viewed as ''types'', and proofs as programs in the [[lambda calculus]]. Thus the interpretation of "π : ''A''" is "''the program'' π has type ''A''". The logical connectives are also given a different reading: conjunction is viewed as product (×), implication as the function arrow (→), etc. The differences are only cosmetic, however. Type theory has a natural deduction presentation in terms of formation, introduction and elimination rules; in fact, the reader can easily reconstruct what is known as ''simple type theory'' from the previous sections. The difference between logic and type theory is primarily a shift of focus from the types (propositions) to the programs (proofs). Type theory is chiefly interested in the convertibility or reducibility of programs. For every type, there are canonical programs of that type which are irreducible; these are known as ''canonical forms'' or ''values''. If every program can be reduced to a canonical form, then the type theory is said to be ''normalising'' (or ''weakly normalising''). If the canonical form is unique, then the theory is said to be ''strongly normalising''. Normalisability is a rare feature of most non-trivial type theories, which is a big departure from the logical world. (Recall that every logical derivation has an equivalent normal derivation.) To sketch the reason: in type theories that admit recursive definitions, it is possible to write programs that never reduce to a value; such looping programs can generally be given any type. In particular, the looping program has type ⊥, although there is no logical proof of "⊥ ''true''". For this reason, the ''propositions as types; proofs as programs'' paradigm only works in one direction, if at all: interpreting a type theory as a logic generally gives an inconsistent logic. Like logic, type theory has many extensions and variants, including first-order and higher-order versions. An interesting branch of type theory, known as [[dependent type theory]], allows quantifiers to range over programs themselves. These quantified types are written as Π and Σ instead of ∀ and ∃, and have the following formation rules: <table style="margin-left: 2em;"><tr><td> Γ {{Unicode|⊢}} A type Γ, x:A {{Unicode|⊢}} B type ----------------------------- Π-F Γ {{Unicode|⊢}} Πx:A. B type </td><td width="10%"></td><td> Γ {{Unicode|⊢}} A type Γ, x:A {{Unicode|⊢}} B type ---------------------------- Σ-F Γ {{Unicode|⊢}} Σx:A. B type </td></tr></table> These types are generalisations of the arrow and product 