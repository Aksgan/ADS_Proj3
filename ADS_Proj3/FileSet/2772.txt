'i' runs through all possible values, when values 'i' are outside the range it is simply moved back into the range by adding or subtracting appropriate multiples of m, as the magic hypercube resides in n-dimensional modular space. There can be multiple 'k' between bracket, these can't have the same value, though in undetermined order, which explains the equality of: [ <sub>1</sub>i, <sub>k</sub>j ] = [ <sub>k</sub>j, <sub>1</sub>i ] Of course given 'k' also one value 'i' is referred to.<br /> When a specific coordinate value is mentioned the other values can be taken as 0, which is especially the case when the amount of 'k's are limited using pe. #k=1 as in: [<sub>k</sub>1 ; #k=1] = [<sub>k</sub>1 <sub>j</sub>0 ; #k=1; #j=n-1] ("axial"-neighbor of [<sub>k</sub>0]) (#j=n-1 can be left unspecified) j now runs through all the values in [0..k-1,k+1..n-1]. Further: without restrictions specified 'k' as well as 'i' run through all possible values, in combinations same letters assume same values. Thus makes it possible to specify a particular line within the hypercube (see r-agonal in pathfinder section) Note: as far as I now this notation is not in general use yet(?), Hypercubes are not generally analyzed in this particular manner. Further: "'''perm(0..n-1)'''" specifies a [[permutation]] of the n numbers 0..n-1. ==Construction== Besides more specific constructions two more general construction method are noticeable: ===KnightJump construction=== This construction generalizes the movement of the chessboard horses (vectors <1,2>, <1,-2>, <-1,2>, <-1,-2>) to more general movements (vectors <<sub>k</sub>i>). The method starts at the position P<sub>0</sub> and further numbers are sequentially placed at positions V<sub>0</sub> further until (after m steps) a position is reached that is already occupied, a further vector is needed to find the next free position. Thus the method is specified by the n by n+1 matrix: [P<sub>0</sub>, V<sub>0</sub> .. V<sub>n-1</sub>] This positions the number 'k' at position: P<sub>k</sub> = P<sub>0</sub> + <sub>l=0</sub>∑<sup>n-1</sup>((k\m<sup>l</sup>)%m) V<sub>l</sub>; k = 0 .. m<sup>n</sup>-1. '''C. Planck''' gives in his 1905 article [http://www.magichypercubes.com/Encyclopedia/k/PathNasiks.zip "'''The theory of Path Nasiks'''"] conditions to create with this method "Path Nasik" (or modern {perfect}) hypercubes. ===Latin prescription construction=== (modular equations). This method is also specified by an n by n+1 matrix. However this time it multiplies the n+1 vector [x<sub>0</sub>,..,x<sub>n-1</sub>,1], After this multiplication the result is taken modulus m to achieve the n (Latin) hypercubes: LP<sub>k</sub> = ( <sub>l=0</sub>∑<sup>n-1</sup> LP<sub>k,l</sub> x<sub>l</sub> + LP<sub>k,n</sub> ) % m of radix m numbers (also called "'''digits'''"). On these LP<sub>k</sub>'s "'''digit changing'''" (?i.e. Basic manipulation) are generally applied before these LP<sub>k</sub>'s are combined into the hypercube: <sup>n</sup>H<sub>m</sub> = <sub>k=0</sub>∑<sup>n-1</sup> LP<sub>k</sub> m<sup>k</sup> '''J.R.Hendricks''' often uses modular equation, conditions to make hypercubes of various quality can be found on [http://www.magichypercubes.com/Encyclopedia http://www.magichypercubes.com/Encyclopedia] at several places (especially p-section) Both methods fill the hypercube with numbers, the knight-jump guarantees (given appropriate vectors) that every number is present. The Latin prescription only if the components are orthogonal (no two digits occupying the same position) ===Multiplication=== Amongst the various ways of compounding, the multiplication<ref>this is a n-dimensional version of (pe.): [http://mathforum.org/alejandre/magic.square/adler/product.html Alan Adler magic square multiplication]</ref> can be considered as the most basic of these methods. The '''basic multiplication''' is given by: <sup>n</sup>H<sub>m<sub>1</sub></sub> * <sup>n</sup>H<sub>m<sub>2</sub></sub> : <sup>n</sup>[<sub>k</sub>i]<sub>m<sub>1</sub>m<sub>2</sub></sub> = <sup>n</sup>[ [<nowiki>[</nowiki><sub>k</sub>i \ m<sub>2</sub>]<sub>m<sub>1</sub></sub></sub>m<sub>1</sub><sup>n</sup>]<sub>m<sub>2</sub></sub> + [<sub>k</sub>i % m<sub>2</sub>]<sub>m<sub>2</sub></sub>]<sub>m<sub>1</sub></sub><sub>m<sub>2</sub></sub> Most compounding methods can be viewed as variations of the above, As most qualfiers are invariant under multiplication one can for example place any aspectial variant of <sup>n</sup>H<sub>m<sub>2</sub></sub> in the above equation, besides that on the result one can apply a manipulation to improve quality. Thus one can specify pe the J. R. Hendricks / M. Trenklar doubling. These things go beyond the scope of this article. ==Aspects== A huper cube knows '''n! 2<sup>n</sup>''' Aspectial variants, which are obtained by coordinate reflection ([<sub>k</sub>i] --> [<sub>k</sub>(-i)]) and coordinate permutations ([<sub>k</sub>i] --> [<sub>perm[k]</sub>i]) effectively giving the Aspectial variant: <sup>n</sup>H<sub>m</sub><sup>~R perm(0..n-1)</sup>; R = <sub>k=0</sub>∑<sup>n-1</sup> ((reflect(k)) ? 2<sup>k</sup> : 0) ; perm(0..n-1) a permutation of 0..n-1 Where reflect(k) true iff coordinate k is being reflected, only then 2<sup>k</sup> is added to R. As is easy to see only n coordinates can be reflected explaining 2<sup>n</sup>, the n! permutation of n coordinates explains the other factor to the total amount of "Aspectial variants"! Aspectial variants are generally seen as being equal. Thus any hypercube can be represented shown in '''"normal position"''' by: [<sub>k</sub>0] = min([<sub>k</sub>θ ; θ ε {-1,0}]) (by reflection) [<sub>k</sub>1 ; #k=1] < [<sub>k+1</sub>1 ; #k=1] ; k = 0..n-2 (by coordinate permutation) (explicitely stated here: [<sub>k</sub>0] the minimum of all corner points. The axial neighbour sequentially based on axial number) ==Basic manipulations== Besides more specific manipulations, the following are of more general nature *'''#[perm(0..n-1)]''' : component permutation *'''^[perm(0..n-1)]''' : coordinate permutation (n == 2: transpose) *'''_2<sup>axis</sup>[perm(0..m-1)]''' : monagonal permutation (axis ε [0..n-1]) *'''=[perm(0..m-1)]''' : digit change Note: <nowiki>'#'</nowiki>, '^', '_' and '=' are essential part of the notation and used as manipulation selectors. ===Component permutation=== Defined as the exchange of components, thus varying the factor m<sup>'''k'''</sup> in m<sup>'''perm(k)'''</sup>, because there are n component hypercubes the permutation is over these n components ===Coordinate permutation=== The exchange of coordinate [<sub>'''k'''</sub>i] into [<sub>'''perm(k)'''</sub>i], because of n coordinates a permutation over these n directions is required.<br /> The term '''transpose''' (usually denoted by <sup>t</sup>) is used with two dimensional matrices, in general though perhaps "coordinate permutation" might be preferable. ===Monagonal permutation=== Defined as the change of [<sub>k</sub>'''i'''] into [<sub>k</sub>'''perm(i)'''] alongside the given "axial"-direction. Equal permutation along various axes can be combined by adding the factors 2<sup>axis</sup>. Thus defining all kinds of r-agonal permutations for any r. Easy to see that all possibilities are given by the corresponding permutation of m numbers. Noted be that '''reflection''' is the special case: ~R = _R[n-1,..,0] Further when all the axes undergo the same ;permutation (R = 2<sup>n</sup>-1) an '''n-agonal permutation''' is achieved, In this special case the 'R' is usually omitted so: _[perm(0..n-1)] = _(2<sup>n</sup>-1)[perm(0..n-1)] ===Digitchanging=== Usually being applied at component level and can be seen as given by '''[<sub>k</sub>i]''' in '''perm([<sub>k</sub>i]''') since a component is filled with radix m digits, a permutation over m numbers is 