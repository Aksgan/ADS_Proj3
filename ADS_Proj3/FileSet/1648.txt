[[daemon (computer software)|daemon]] for Gamin. == Origins == The word ''gamin'' in French (where it also has a female form ''[[gamine]]'') refers to a boy, especially an abandoned and homeless boy who roams the streets; an urchin. The Gamin project built on an earlier project called Marmot<ref>[http://www.gnome.org/~veillard/gamin/overview.html Overview<!-- Bot generated title -->]</ref> (which in French means "child" or "brat"). == How it works == Under [[Linux]], Gamin uses [[inotify]] or [[dnotify]] to monitor filesystem activity. Under [[FreeBSD]], Gamin uses [[kqueue]]/[[kevent]] as the native FreeBSD kernel event notification mechanism, but in this case kqueue has one major drawback as compared to inotify: inotify is the filename-based monitoring facility and kqueue uses [[file descriptor]]s for identification of monitored files, so, under FreeBSD, gam_server has to open each file in the monitored directory. This can be an issue when monitoring directories with many files stored, because system could easily reach its kernel limits on maximum file descriptor count (kern.maxfiles and kern.maxfilesperproc). == References == {{reflist}} == External links == * [http://www.gnome.org/~veillard/gamin/ The Gamin project page] [[Category:FreeBSD]] [[Category:Linux]] {{unix-stub}} [[pt:Gamin]] [[ru:Gamin]]</text> </page> <page> <id>14773</id> <title>Gang scheduling</title> <text>In [[Computer science]], '''Gang scheduling''' is a [[scheduling algorithm]] for parallel systems that schedules related [[thread (computer science)|thread]]s or [[process (computing)|process]]es to run simultaneously on different [[central processing unit|processor]]s. Usually these will be threads all belonging to the same process, but they may also be from different processes, for example when the processes have a producer-consumer relationship, or when they all come from the same [[Message Passing Interface|MPI]] program. Gang scheduling is used so that if two or more threads or processes communicate with each other, they will all be ready to communicate at the same time. If they were not gang-scheduled, then one could wait to send or receive a message to another while it is sleeping, and vice-versa. When processors are over-subscribed and gang scheduling is not used within a group of processes or threads which communicate with each other, it can lead to situations where each communication event suffers the overhead of a context switch. Technically, gang scheduling is based on a data structure called the Ousterhout matrix. In this matrix each row represents a time slice, and each column a processor. The threads or processes of each job are packed<ref>Dror G. Feitelson (1996). [http://dx.doi.org/10.1007/BFb0022289 ''Packing schemes for gang scheduling'']. In Job Scheduling Strategies for Parallel Processing, Springer-Verlag Lecture Notes in Computer Science Vol. 1162, pp. 89-110.</ref> into a single row of the matrix. During execution, coordinated context switching is performed across all nodes to switch from the processes in one row to those in the next row. Gang scheduling is stricter than [[Coscheduling]].<ref>Dror G. Feitelson, Larry Rudolph (1992). [http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.79.7070&rep=rep1&type=pdf ''Gang Scheduling Performance Benefits for Fine-Grain Synchronization'']. Journal of Parallel and Distributed Computing, volume 16, pages 306--318.</ref> It requires all threads of the same process to run concurrently, while Coscheduling allows for ''fragments'', which are sets of threads that do not run concurrently with the rest of the gang. Gang scheduling was implemented and used in production mode on several parallel machines, most notably the [[Connection Machine]] CM-5. == See also == * [[Coscheduling]] * [[Parallel computing]] == References == * [http://www.llnl.gov/asci/pse_trilab/sc98.summary.html Gang Scheduling, Timesharing on Parallel Computers, SC98, November 1998 (a summary)] * [http://www.llnl.gov/asci/pse_trilab/sc97.paper.html Performance Characteristics of Gang Scheduling in Multiprogrammed Environments, SC97, November 1997] {{reflist}} {{DEFAULTSORT:Gang Scheduling}} [[Category:Scheduling algorithms]] {{comp-sci-stub}}</text> </page> <page> <id>14782</id> <title>Garbage (computer science)</title> <text>'''Garbage''', in the context of [[computer science]], refers to [[object (computer science)|object]]s, [[data]], or other regions of the memory of a computer system (or other system resources), which will not be used in any future computation by the system, or by a program running on it. As computer systems all have finite amounts of memory, it is frequently necessary to ''deallocate'' garbage and return it to the heap, or memory pool, so the underlying memory can be reused. == Classification == Garbage is generally classified into two types: ; semantic garbage : Semantic garbage is any object or data which will never be accessed by a running program, for any combination of inputs to the program. ; syntactic garbage: Syntactic garbage refers to objects or data within a program's memory space that are ''unreachable'' from the program's [[root set]]. Note that syntactic garbage is a (usually strict) subset of semantic garbage as it is entirely possible for an object to hold a reference to another object without the latter object being used. Determination of the semantic garbage present in a program is generally [[undecidable]], but there are many algorithms for identifying syntactic garbage. Objects and/or data which is not garbage is said to be ''live''. ==Eliminating garbage== The problem of managing the deallocation of garbage is a well-known one in computer science. Several approaches are taken: * Many [[operating systems]] will reclaim the memory and resources used by a process or program when it terminates. Simple or short-lived programs which are designed to run in such environments can exit and allow the operating system to perform any necessary reclamation. * In systems or [[programming language]]s with [[manual memory management]], the programmer must explicitly arrange for memory to be deallocated when it is no longer used. [[C (programming language)|C]] and [[C++]] are two well-known languages which support this model. * [[Garbage collection (computer science)|Garbage collection]] uses various algorithms to automatically analyze the state of a program, identify garbage, and deallocate it without intervention by the programmer. Many modern programming languages such as [[Java (programming language)|Java]] and [[Haskell (programming language)|Haskell]] provide automated garbage collection. However, it is not a recent development, as it has also been used in older languages such as [[LISP]]. * There is ongoing research to [[type theory|type theoretic]] approaches (such as [[region inference]]) to identification and removal of garbage from a program. Note that no general type-theoretic solution to the problem has been developed. An example of the automatic removal of semantic garbage, by [[reference counting]] garbage collection, can be produced using the [[Python (programming language)|Python]] command-line [[Interpreter (computing)|interpreter]]: <source lang="python"> >>> class Foo(object): ... 