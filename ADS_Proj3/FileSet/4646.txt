place for files that may change often. ::* '''<tt>/var/log</tt>''' — contains system log files. ::* '''<tt>/var/mail</tt>''' — the place where all the incoming mails are stored. The user can access his/her own mail only, unless he/she has admin rights. ::* '''<tt>/var/spool</tt>''' — [[spooling|spool]] directory; contains print jobs, mail spools and other queued tasks. ::* '''<tt>/var/tmp</tt>''' — A place for temporary files preserved between system reboots. ==References== *{{Citizendium}} {{reflist}} {{DEFAULTSORT:Unix Directory Structure}} [[Category:Unix]] [[Category:File system management]]</text> </page> <page> <id>38965</id> <title>Unix philosophy</title> <text>The '''Unix philosophy''' is a set of cultural norms and philosophical approaches to developing [[computer software|software]] based on the experience of leading developers of the [[Unix]] [[operating system]]. ==McIlroy: A Quarter Century of Unix== [[Douglas McIlroy|Doug McIlroy]], the inventor of [[Pipeline (Unix)|Unix pipes]] and one of the founders of the Unix tradition, summarized the philosophy as follows:<ref>[http://www.faqs.org/docs/artu/ch01s06.html Basics of the Unix Philosophy]</ref> {{quote|This is the Unix philosophy: Write [[computer program|programs]] that do one thing and do it well. Write programs to work together. Write programs to handle [[standard streams|text stream]]s, because that is a universal interface.}} This is usually abridged to "Write programs that do one thing and do it well". ==Pike: Notes on Programming in C== [[Rob Pike]] offers the following five maxims of complexity in [[computer programming|programming]] in ''Notes on Programming in C'',<ref>{{cite web|title=Notes on Programming in C|url=http://www.lysator.liu.se/c/pikestyle.html|author=[[Rob Pike]]|accessdate=2008-07-08}}</ref> though they can be easily viewed as points of a Unix philosophy:{{Citation needed|date=December 2007}} #You cannot tell where a program is going to spend its time. Bottlenecks occur in surprising places, so do not try to second guess and put in a speed hack until you've proven that's where the bottleneck is. #Measure. Do not tune for speed until your [[performance analysis]] tool tells you which part of the code overwhelms the rest. #Fancy [[algorithm]]s tend to run more slowly on small data sets than simple algorithms. They tend to have a large constant factor in [[Big O notation|O(''n'') analysis]], and ''n'' is usually small. So don't get fancy unless Rule 2 indicates that ''n'' is big enough. #Simplify your algorithms and [[data structures]] wherever it makes sense because fancy algorithms are more difficult to implement without [[software bug|defects]]. The data structures in most programs can be built from [[array list]]s, [[linked list]]s, [[hash table]]s, and [[binary tree]]s. #Data dominates. If you have chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming. Pike's rules 1 and 2 restate [[Donald Knuth]]'s<ref>[[Donald Knuth|Knuth, Donald]]: [http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf Structured Programming with Goto Statements]. ''Computing Surveys'' '''6''':4 (1974), 261–301.</ref> famous maxim "Premature [[optimization (computer science)|optimization]] is the root of all evil." [[Ken Thompson (computer programmer)|Ken Thompson]] rephrased Pike's rules 3 and 4 as "When in doubt, use [[Brute-force search|brute force]]." Rules 3 and 4 are instances of the design philosophy [[KISS principle|KISS]]. Rule 5 was previously stated by [[Fred Brooks]] in ''[[The Mythical Man-Month]]''. [[Jon Bentley]]'s ''[[Programming Pearls]]'' also has a chapter on the same design principle. Rule 5 is often shortened to "write stupid code that uses smart data", and is an instance of the guideline "If your data structures are good enough, the algorithm to manipulate them should be trivial." ==Mike Gancarz: The UNIX Philosophy== In 1994 [[Mike Gancarz]] (a member of the team that designed the [[X Window System]]), drew on his own experience with Unix, as well as discussions with fellow programmers and people in other fields who depended on Unix, to produce ''The UNIX Philosophy'' which sums it up in 9 paramount precepts: #''Small is beautiful.'' #''Make each program do one thing well.'' #''Build a prototype as soon as possible.'' #''Choose portability over efficiency.'' #''Store data in flat [[text file]]s.'' #''Use software leverage to your advantage.'' #''Use [[shell script]]s to increase leverage and portability.'' #''Avoid captive user interfaces.'' #''Make every program a filter.'' The 10 lesser tenets are not universally agreed upon as part of the Unix philosophy and, in some cases, are hotly debated such as [[Kernel_(computer_science)#Monolithic_kernels_vs._microkernels|Monolithic Kernels vs. Microkernels]]: #''Allow the user to tailor the environment.'' #''Make operating system kernels small and lightweight.'' #''Use lowercase and keep it short.'' #''Save trees.'' #''Silence is golden.'' #''Think parallel.'' #''The sum of the parts is greater than the whole.'' #''Look for the 90-percent solution.'' #''[[Worse is better]].'' #''Think hierarchically.'' ==Worse is better== {{Main|Worse is better}} [[Richard P. Gabriel]] suggests that a key advantage of Unix was that it embodied a design philosophy he termed "worse is better", in which simplicity of both the interface ''and'' the implementation are more important than any other attribute of the system&mdash;including correctness, consistency and completeness. Gabriel argues that this design style has key evolutionary advantages, though he questions the quality of some results. For example, in the early days Unix was a [[monolithic kernel]] (which means that user processes carried out kernel system calls all on the user stack). If a signal was delivered to a process while it was blocked on a long-term [[Input/output|I/O]] in the kernel, then what should be done? Should the signal be delayed, possibly for a long time (maybe indefinitely) while the I/O completed? The signal handler could not be executed when the process was in kernel mode, with sensitive kernel data on the stack. Should the kernel back-out the system call, and store it, for replay and restart later, assuming that the signal handler completes successfully? In these cases [[Ken Thompson (computer programmer)|Ken Thompson]] and [[Dennis Ritchie]] favored simplicity over perfection. The Unix system would occasionally return early from a system call with an error stating that it had done nothing&mdash;the "Interrupted System Call", or an error number 4 (<code>EINTR</code>) in today's systems. Of course the call had been aborted in order to call the signal handler. This could only happen for a handful of long-running system calls, i.e. <code>read()</code>, <code>write()</code>, <code>open()</code>, <code>select()</code>, etc. On the plus side, this made the I/O system many times simpler to design and understand. The vast majority of user programs were never affected because they didn't handle or 