in functional graphs. [[Cycle detection]], the problem of following a path in a functional graph to find a cycle in it, has applications in [[cryptography]] and [[computational number theory]], as part of [[Pollard's rho algorithm]] for [[integer factorization]] and as a method for finding collisions in [[cryptographic hash function]]s. In these applications, &fnof; is expected to behave randomly; [[Philippe Flajolet|Flajolet]] and [[Andrew Odlyzko|Odlyzko]]<ref>{{harvtxt|Flajolet|Odlyzko|1990}}.</ref> study the graph-theoretic properties of the functional graphs arising from randomly chosen mappings. In particular, a form of the [[birthday paradox]] implies that, in a random functional graph with ''n'' vertices, the path starting from a randomly selected vertex will typically loop back on itself to form a cycle within O(&radic;''n'') steps. Martin, [[Andrew Odlyzko|Odlyzko]], and [[Stephen Wolfram|Wolfram]]<ref>{{harvtxt|Martin|Odlyzko|Wolfram|1984}}.</ref> investigate pseudoforests that model the dynamics of [[cellular automaton|cellular automata]]. These functional graphs, which they call ''state transition diagrams'', have one vertex for each possible configuration that the ensemble of cells of the automaton can be in, and an edge connecting each configuration to the configuration that follows it according to the automaton's rule. One can infer properties of the automaton from the structure of these diagrams, such as the number of components, length of limiting cycles, depth of the trees connecting non-limiting states to these cycles, or symmetries of the diagram. For instance, any vertex with no incoming edge corresponds to a [[Garden of Eden pattern]] and a vertex with a self-loop corresponds to a [[Still life (cellular automaton)|still life pattern]]. Another early application of functional graphs is in the ''trains'' used to study [[Steiner system|Steiner triple system]]s.<ref>{{harvtxt|White|1913}}; {{harvtxt|Colbourn|Colbourn|Rosenbaum|1982}}; {{harvtxt|Stinson|1983}}.</ref> The train of a triple system is a functional graph having a vertex for each possible triple of symbols; each triple ''pqr'' is mapped by &fnof; to ''stu'', where ''pqs'', ''prt'', and ''qru'' are the triples that belong to the triple system and contain the pairs ''pq'', ''pr'', and ''qr'' respectively. Trains have been shown to be a powerful invariant of triple systems although somewhat cumbersome to compute. ==Bicircular matroid== A [[matroid]] is a mathematical structure in which certain sets of elements are defined to be [[independence system|independent]], in such a way that the independent sets satisfy properties modeled after the properties of [[linear independence]] in a [[vector space]]. One of the standard examples of a matroid is the [[graphic matroid]] in which the independent sets are the sets of edges in forests of a graph; the matroid structure of forests is important in algorithms for computing the [[minimum spanning tree]] of the graph. Analogously, we may define matroids from pseudoforests. For any graph ''G'' = (''V'',''E''), we may define a matroid on the edges of ''G'', in which a set of edges is independent if and only if it forms a pseudoforest; this matroid is known as the '''[[bicircular matroid]]''' (or '''bicycle matroid''') of ''G''.<ref>{{harvtxt|Simoes-Pereira|1972}}.</ref><ref>{{harvtxt|Matthews|1977}}.</ref> The smallest dependent sets for this matroid are the minimal connected subgraphs of ''G'' that have more than one cycle, and these subgraphs are sometimes called bicycles. There are three possible types of bicycle: a [[theta graph]] has two vertices that are connected by three internally disjoint paths, a figure 8 graph consists of two cycles sharing a single vertex, and a handcuff graph is formed by two disjoint cycles connected by a path.<ref>[http://www.math.binghamton.edu/zaslav/Bsg/glossary.html Glossary of Signed and Gain Graphs and Allied Areas]</ref> A graph is a pseudoforest if and only if it does not contain a bicycle as a subgraph. <ref name="st"/> ==Forbidden minors== [[Image:Butterfly and diamond graphs.svg|thumb|The [[butterfly graph]] (left) and [[diamond graph]] (right), forbidden [[graph minor|minors]] for pseudoforests]] Forming a [[Minor (graph theory)|minor]] of a pseudoforest by contracting some of its edges and deleting others produces another pseudoforest. Therefore, the family of pseudoforests is [[Closure (mathematics)|closed]] under minors, and the [[Robertsonâ€“Seymour theorem]] implies that pseudoforests can be characterized in terms of a finite set of [[forbidden minor]]s, analogously to [[Wagner's theorem]] characterizing the [[planar graph]]s as the graphs having neither the [[complete graph]] K<sub>5</sub> nor the [[complete bipartite graph]] K<sub>3,3</sub> as minors. As discussed above, any non-pseudoforest graph contains as a subgraph a handcuff, figure 8, or theta graph; any handcuff or figure 8 graph may be contracted to form a ''[[butterfly graph]]'' (five-vertex figure 8), and any theta graph may be contracted to form a ''[[diamond graph]]'' (four-vertex theta graph),<ref>For this terminology, see the [http://wwwteo.informatik.uni-rostock.de/isgci/smallgraphs.html list of small graphs] from the Information System on Graph Class Inclusions. However, ''butterfly graph'' may also refer to a different family of graphs related to [[hypercube graph|hypercubes]], and the five-vertex figure 8 is sometimes instead called a ''bowtie graph''.</ref> so any non-pseudoforest contains either a butterfly or a diamond as a minor, and these are the only minor-minimal non-pseudoforest graphs. Thus, a graph is a pseudoforest if and only if it does not have the butterfly or the diamond as a minor. If one forbids only the diamond but not the butterfly, the resulting larger graph family consists of the [[cactus graph]]s and disjoint unions of multiple cactus graphs.<ref>{{harvtxt|El-Mallah|Colbourn|1988}}.</ref> More simply, if [[multigraph]]s with [[self-loop]]s are considered, there is only one forbidden minor, a vertex with two loops. ==Algorithms== An early algorithmic use of pseudoforests involves the ''network simplex'' algorithm and its application to generalized flow problems modeling the conversion between [[commodity|commodities]] of different types.<ref name="dantzig"/><ref name="amo">{{harvtxt|Ahuja|Magnanti|Orlin|1993}}.</ref> In these problems, one is given as input a [[flow network]] in which the vertices model each commodity and the edges model allowable conversions between one commodity and another. Each edge is marked with a ''capacity'' (how much of a commodity can be converted per unit time), a ''flow multiplier'' (the conversion rate between commodities), and a ''cost'' (how much loss or, if negative, profit is incurred per unit of conversion). The task is to determine how much of each commodity to convert via each edge of the flow network, in order to minimize cost or maximize profit, while obeying the capacity constraints and not allowing commodities of any type to accumulate unused. This type of problem can be formulated as a [[linear program]], and 