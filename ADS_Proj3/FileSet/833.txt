to set out the various similarities and differences between the various [[programming paradigm]]s as a summary in both graphical and tabular format with links to the separate discussions concerning these similarities and differences in existing Wikipedia articles == Main paradigm approaches == {{Original research|section|date=January 2010}} The following are considered {{By whom|date=January 2010}} the main programming paradigms. There is inevitably some overlap in these non mutually-exclusive paradigms but the main features or identifiable differences are summarized in the following table: * [[Imperative programming]] - describes computation in terms of [[statement (programming)|statement]]s that change a program [[state (computer science)|state]] * [[Functional programming]] - treats [[computation]] as the evaluation of [[function (mathematics)|mathematical function]]s and avoids [[program state|state]] and [[immutable object|mutable]] data. * [[Procedural programming]] / [[structured programming]] - specifying the steps the program must take to reach the desired state * [[Event-driven programming]] - the [[Program flow|flow of the program]] is determined by [[event (computing)|event]]s&mdash;i.e., [[sensor]] outputs or user actions ([[computer mouse|mouse]] clicks, key presses) or [[Message passing|messages]] from other programs or [[Thread (computer science)|threads]]. * [[Object oriented programming]] (OOP) - uses "[[Object (computer science)|objects]]" &ndash; [[data structures]] consisting of [[Field (computer science)|datafields]] and [[Method (computer science)|methods]] together with their interactions &ndash; to design applications and computer programs. * [[Declarative programming]] - expresses the logic of a [[computation]] without describing its [[control flow]] * [[Automata-based programming]] - in which the program or its part is thought of as a model of a finite state machine or any other formal automata. None of the main programming paradigms have a precise, globally unanimous definition, let alone an official international standard. Nor is there any agreement on which paradigm constitutes the best approach to developing software. The subroutines that actually implement OOP [[Method (computer science)|methods]] might be ultimately coded in an imperative, functional or procedural style that might, or might not, directly alter [[state (computer science)|state]] on behalf of the invoking program. {| class="wikitable sortable" |- ! [[Programming paradigm|Paradigm]] ! Description ! Main characteristics (examples) ! Related paradigm(s) ! Critics? |- ! [[Imperative programming|Imperative]] | Computation in terms of [[statement (programming)|statement]]s that ''directly'' change a program [[state (computer science)|state]] ([[Field (computer science)|datafields]]) | Direct [[Assignment (computer science)|assignment]]s, Common [[data structure]]s, [[Global variable]]s | | [[Edsger W. Dijkstra]], [[Michael A. Jackson]] |- ! [[structured programming|Structured]] | A style of [[Imperative programming]] with more logical program structure | [[Structogram]]s, [[Indent style|Indentation]], absence of [[GOTO]] statements | [[Imperative programming|Imperative]] | |- ! [[Functional programming|Functional]] | Treats [[computation]] as the evaluation of [[function (mathematics)|mathematical function]]s avoiding [[program state|state]] and [[immutable object|mutable]] data. | [[Lambda calculus]], [[Compositionality]], [[Formula]], [[Referential transparency (computer science)|Referential transparency]], no [[Side effect (computer science)|side effects]] | | |- ! [[Procedural programming|Procedural]] | Derived from [[structured programming]], based upon the concept of [[modular programming]] or the ''procedure call'' | [[Local variable]]s, sequence, selection, and [[iteration]] and [[Modular programming|modularization]] | [[structured programming|Structured]], [[imperative programming|Imperative]] | |- ! [[Event-driven programming|Event-driven]] including [[Time-driven programming|time driven]] | [[Program flow]] is mainly determined by [[event (computing)|event]]s (such as [[mouse click]]s or interrupts including timer) | [[Main loop]], [[Event handler]]s, [[Asynchronous programming|Asynchronous processes]] | [[Procedural programming|Procedural]] | |- ! [[Object oriented programming|Object-oriented]] | Treats [[Field (computer science)|datafields]] as "objects" manipulated only through pre-defined [[Method (computer science)|methods]] | [[Object (computer science)|Objects]], [[method (computer science)|Methods]], [[Message passing]], [[Information hiding]], [[Data abstraction]], [[Encapsulation (computer science)|Encapsulation]], [[Polymorphism in object-oriented programming|Polymorphism]], [[Inheritance (computer science)|Inheritance]] and [[Serialization|Serialization/Marshalling]] | | [[Object-oriented_programming#Criticism|See here]] and <ref>{{cite web|url=http://www.geocities.com/tablizer/oopbad.htm |title=Object Oriented Programming Oversold |last=Jacobs |first=B.|date=2006-08-27|archiveurl=http://web.archive.org/web/20061015181417/http://www.geocities.com/tablizer/oopbad.htm|archivedate=2006-10-15}}</ref><ref name="flaws"/><ref name="executioniKoN"/> |- ! [[Declarative programming|Declarative]] | Expresses the logic of a [[computation]] without describing its detailed [[control flow]] | ([[4GL]]s, [[Spreadsheet]]s, [[Report program generator]]s) | | |- ! [[Automata-based programming]] | The program is thought of as a model of a [[finite state machine]] or any other formal automata. | [[Enumeration|State enumeration]], [[Control variable]], Changes in [[state (computer science)|state]], [[Isomorphism]], [[State transition table]] | [[Imperative programming|Imperative]], [[Event-driven programming|Event-driven]] | |- |-class="sortbottom" ! [[Programming paradigm|Paradigm]] ! Description ! Main characteristics (examples) ! Related paradigm(s) ! Critics? |} == Differences in terminology == Despite multiple (types of) programming [[paradigm]]s existing in parallel (with sometimes apparently conflicting definitions), many of the underlying ''[[Essence|fundamental components]]'' remain more or less the same ([[Constant (programming)|constant]]s, [[Variable (programming)|variable]]s, [[Field (computer science)|datafield]]s, [[subroutine]]s, Calls etc.) and must somehow therefore inevitably be incorporated into each separate paradigm with equally similar attributes or functions. The table below is not intended as a guide to precise similarities, but more an index of where to look for more information - based on the different naming of these entities - within each paradigm. Non-standardized implementations of each paradigm in numerous [[programming language]]s further complicate the overall picture, especially those languages that support [[Multi-paradigm programming language|multiple paradigms]], each with its own [[jargon]]. == Support for new paradigms, supporting languages & syntactic sugar == {{Main|Syntactic sugar}} [[Syntactic sugar]] is a term used to describe the sweetening of program functionality by the introduction of "new features" together with its new terminology. One example of syntactic sugar may arguably be classes in [[C++]] (as well as in [[Java (programming language)|Java]], [[C Sharp (programming language)|C#]], etc.). The [[C programming language]] is fully capable of [[object-oriented programming]] using its powerful facilities of [[function pointer]]s, type casting, and structures. However, it is claimed {{Who|date=June 2010}} that languages such as [[C++]] make object-oriented programming more convenient by introducing syntax specific to this coding style. Moreover, the specialized syntax works to emphasize the object-oriented approach to new programmers. Another example of syntactic sugar may arguably be functions and looping syntax in [[C (programming language)|C]] (as well as other procedural and structured programming languages). [[Assembly language]] is fully capable of procedural or structured programming using its powerful facilities for modifying register values and branching execution depending on program state. However, it is claimed that languages such as C make procedural and structured programming more convenient by introducing syntax specific to these coding styles. Moreover, the specialized syntax works to emphasize the structured approach to new programmers. Features of the C# (C Sharp) programing language, such as properties and interfaces, similarly do not 