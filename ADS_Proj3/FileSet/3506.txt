of the <math>\pi</math>-calculus that make these encodings possible are name-passing and replication (or, equivalently, recursively defined agents). In the absence of replication/recursion, the <math>\pi</math>-calculus ceases to be [[Turing]]-powerful. This can be seen by the fact that [[bisimulation]] equivalence becomes decidable for the recursion-free calculus and even for the finite-control <math>\pi</math>-calculus where the number of parallel components in any process is bounded by a constant (Mads Dam: On the Decidability of Process Equivalences for the pi-Calculus. Theoretical Computer Science 183, 1997, pp. 215–228.) == Bisimulations in the <math>\pi</math>-calculus == {{See also|Bisimulation}} As for process calculi, the <math>\pi</math>-calculus allows for a definition of bisimulation equivalence. In the <math>\pi</math>-calculus, the definition of bisimulation equivalence (also known as bisimilarity) may be based on either the reduction semantics or on the labelled transition semantics. There are (at least) three different ways of defining ''labelled bisimulation equivalence'' in the <math>\pi</math>-calculus: Early, late and open bisimilarity. This stems from the fact that the <math>\pi</math>-calculus is a value-passing process calculus. In the remainder of this section, we let <math>p</math> and <math>q</math> denote processes and <math>R</math> denote binary relations over processes. ===Early and late bisimilarity=== Early and late bisimilarity were both discovered by Milner, Parrow and Walker in their original paper on the <math>\pi</math>-calculus.<ref>{{cite journal|last=Milner|first=R.|coauthors=J. Parrow and D. Walker|title=A calculus of mobile processes|journal=Information and Computation|issue=100|pages=1–40|year=1992|doi=10.1016/0890-5401(92)90008-4|volume=100}}</ref> A binary relation <math>R</math> over processes is an ''early bisimulation'' if for every pair of processes <math>(p, q) \in R</math>, * whenever <math> p \,\xrightarrow{a(x)}\,p' </math> then for every name <math>y</math> there exists some <math>q'</math> such that <math> q \,\xrightarrow{a(x)}\,q' </math> and <math>(p'[y/x],q'[y/x]) \in R</math>; * for any non-input action <math>\alpha</math>, if <math> p \xrightarrow\alpha p' </math> then there exists some <math>q'</math> such that <math> q \xrightarrow\alpha q' </math> and <math>(p',q') \in R</math>; * and symmetric requirements with <math>p</math> and <math>q</math> interchanged. Processes <math>p</math> and <math>q</math> are said to be early bisimilar, written <math>p \sim_e q</math> if the pair <math>(p,q) \in R</math> for some early bisimulation <math>R</math>. In late bisimilarity, the transition match must be independent of the name being transmitted. A binary relation <math>R</math> over processes is a ''late bisimulation'' if for every pair of processes <math>(p, q) \in R</math>, * whenever <math> p \xrightarrow{a(x)} p' </math> then for some <math>q'</math> it holds that <math> q \xrightarrow{a(x)} q' </math> and <math>(p'[y/x],q'[y/x]) \in R</math> ''for every name y''; *for any non-input action <math>\alpha</math>, if <math> p \xrightarrow\alpha p' </math> implies that there exists some <math>q'</math> such that <math> q \xrightarrow\alpha q' </math>and <math>(p',q') \in R</math>; * and symmetric requirements with <math>p</math> and <math>q</math> interchanged. Processes <math>p</math> and <math>q</math> are said to be late bisimilar, written <math>p \sim_l q</math> if the pair <math>(p,q) \in R</math> for some late bisimulation <math>R</math>. Both <math>\sim_e</math> and <math>\sim_l</math> suffer from the problem that they are not ''congruence relations'' in the sense that they are not preserved by all process constructs. More precisely, there exist processes <math>p</math> and <math>q</math> such that <math>p \sim_e q</math> but <math>a(x).p \not \sim_e a(x).q</math>. One may remedy this problem by considering the maximal congruence relations included in <math>\sim_e</math> and <math>\sim_l</math>, known as ''early congruence'' and ''late congruence'', respectively. ===Open bisimilarity=== Fortunately, a third definition is possible, which avoids this problem, namely that of ''open bisimilarity'', due to Sangiorgi <ref>{{cite journal|last=Sangiorgi|first=D.|title=A theory of bisimulation for the <math>\pi</math>-calculus|journal=Acta Informatica|volume=33|pages=69–97|year=1996|doi=10.1007/s002360050036}}</ref>. A binary relation <math>R</math> over processes is an ''open bisimulation'' if for every pair of elements <math>(p, q) \in R</math> and for every name substitution <math>\sigma</math> and every action <math>\alpha</math>, whenever <math> p\sigma \xrightarrow\alpha p'</math> then there exists some <math>q'</math> such that <math> q\sigma \xrightarrow\alpha q' </math> and <math>(p',q') \in R</math>. Processes <math>p</math> and <math>q</math> are said to be open bisimilar, written <math>p \sim_o q</math> if the pair <math>(p,q) \in R</math> for some open bisimulation <math>R</math>. <math>\sim_o</math> Early, late and open bisimilarity are in fact all distinct. The containments are proper, so <math>\sim_o \subsetneq \sim_l \subsetneq \sim_e</math>. In certain subcalculi such as the asynchronous pi-calculus, late, early and open bisimilarity are known to coincide. However, in this setting a more appropriate notion is that of ''asynchronous bisimilarity''. The reader should note that, in the literature, the term ''open bisimulation'' usually refers to a more sophisticated notion, where processes and relations are indexed by distinction relations; details are in Sangiorgi's paper cited above. === Barbed equivalence === Alternatively, one may define bisimulation equivalence directly from the reduction semantics. We write <math>p \Downarrow a</math> if process <math>p</math> immediately allows an input or an output on name <math>a</math>. A binary relation <math>R</math> over processes is a ''barbed bisimulation'' if it is a symmetric relation which satisfies that for every pair of elements <math>(p, q) \in R</math> we have that :(1) <math>p \Downarrow a</math> if and only if <math>q \Downarrow a</math> for every name <math>a</math> and :(2) for every reduction <math> p \rightarrow p'</math> there exists a reduction <math> q \rightarrow q' </math> such that <math>(p',q') \in R</math>. We say that <math>p</math> and <math>q</math> are ''barbed bisimilar'' if there exists a barbed bisimulation <math>R</math> where <math>(p,q) \in R</math>. Defining a context as a π term with a hole [] we say that two processes P and Q are ''barbed congruent'', written <math>P \sim_b Q\,\!</math> if for every context <math>C[] </math> we have that <math>C[P] \sim_b C[Q]\,\!</math>. It turns out that barbed congruence coincides with the congruence induced by early bisimilarity. == Applications ==<!-- This section is linked from [[SPI]] --> The <math>\pi</math>-calculus has been used to describe many different kinds of concurrent systems. In fact, some of the most recent applications lie outside the realm of computer science. In 1997, [[Martin Abadi]] and Andrew Gordon proposed an extension of the <math>\pi</math>-calculus, the [[Spi-calculus]], as a formal notation for describing and reasoning about cryptographic protocols. The spi-calculus extends the <math>\pi</math>-calculus with primitives for encryption and decryption. In 2001, [[Martin Abadi]] and Cedric Fournet generalised the handling of cryptographic protocols to produce the applied <math>\pi</math> calculus. There is now a large body of work devoted to variants of the applied <math>\pi</math> calculus, including a number of experimental verification tools. One example is the tool 