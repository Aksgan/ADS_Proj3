since commands can be abbreviated to a single letter, this routine could be made more compact: <source lang="text"> hello() w "Hello, World!",! q </source> The '<code>,!</code>' after the text generates a newline. The '<code>quit</code>' is not strictly necessary at the end of a function like this, but is good programming practice in case other functions are added below '<code>hello()</code>' later. ==Summary of key language features== {{Main|MUMPS Language Syntax}} The following summary seeks to give programmers familiar with other languages a feeling for what MUMPS is like. This is not a formal language specification, and many features and qualifiers have been omitted for brevity. ANSI X11.1-1995 gives a complete, formal description of the language; an annotated version of this standard is available online.<ref>[http://71.174.62.16/Demo/AnnoStd The Annotated MUMPS Standards] - Ed De Moel, [http://jacquardsystems.com/ Jacquard Systems Research]</ref> '''Data types''': There is one universal [[datatype]], which is implicitly [[Type conversion|coerced]] to string, integer, or floating-point datatypes as context requires. '''Booleans''' (called ''truthvalues'' in MUMPS): In IF commands and other syntax that has expressions evaluated as conditions, any string value is evaluated as a numeric value, and if that is a nonzero value, then it is interpreted as True. <code> a<b </code> yields 1 if a is less than b, 0 otherwise. '''Declarations''': None. All variables are dynamically created at the first time a value is assigned. '''Lines''': are important syntactic entities, unlike their status in languages patterned on C or Pascal. Multiple statements per line are allowed and are common. The scope of any IF, ELSE, and FOR command is "the remainder of current line." '''Case sensitivity''': Commands and intrinsic functions are case-insensitive. In contrast, variable names and labels are case-sensitive. There is no special meaning for upper vs. lower-case and few widely followed conventions. The percent sign (%) is legal as first character of variables and labels. '''Postconditionals''': execution of almost all commands can be controlled by following it with a colon and a truthvalue expression. <code>SET:N<10 A="FOO"</code> sets A to "FOO" if N is less than 10; <code>DO:N>100 PRINTERR,</code> performs PRINTERR if N is greater than 100. This construct provides a conditional whose scope is less than a full line. '''Abbreviation''': You can abbreviate nearly all commands and native functions to one, two, or three characters. '''Reserved words''': None. Since MUMPS interprets source code by context, there is no need for reserved words. You may use the names of language commands as variables. There has been no contest such as the [[International Obfuscated C Code Contest]] for MUMPS, despite the potential of examples such as the following, perfectly legal, MUMPS code: <source lang="text"> GREPTHIS() NEW SET,NEW,THEN,IF,KILL,QUIT SET IF="KILL",SET="11",KILL="l1",QUIT="RETURN",THEN="KILL" IF IF=THEN DO THEN QUIT:$QUIT QUIT QUIT ; (quit) THEN IF IF,SET&KILL SET SET=SET+KILL QUIT </source> MUMPS can be made more obfuscated by using the contracted operator syntax, as shown in this terse example derived from the example above: <source lang="text"> GREPTHIS() N S,N,T,I,K,Q S I="K",S="11",K="l1",Q="R",T="K" I I=T D T Q:$Q Q Q T I I,S&K S S=S+K Q </source> '''Arrays''': are created dynamically, stored as [[B-trees]], are sparse (i.e. use almost no space for missing nodes), can use any number of subscripts, and subscripts can be strings or numeric (including floating point). Arrays are always automatically stored in sorted order, so there is never any occasion to sort, pack, reorder, or otherwise reorganize the database. Built in functions such as $DATA, $ORDER, $NEXT(deprecated) and $QUERY functions provide efficient examination and traversal of the fundamental array structure, on disk or in memory. <source lang="text"> for i=10000:1:12345 set sqtable(i)=i*i set address("Smith","Daniel")="dpbsmith@world.std.com" </source> '''Local arrays''': variable names not beginning with caret (i.e. "^") are stored in memory by process, are private to the creating process, expire when the creating process terminates. The available storage depends on implementation. For those implementations using partitions, it is limited to the partition size, (A small patition might be 32K). For other implementations, it may be several megabytes. '''Global arrays''': <code>^abc, ^def</code>. These are stored on disk, are available to all processes, and are persistent when the creating process terminates. Very large globals (e.g., hundreds of gigabytes) are practical and efficient in most implementations. This is MUMPS' main "database" mechanism. It is used instead of calling on the operating system to create, write, and read files. '''Indirection''': in many contexts, <code>@VBL</code> can be used, and effectively substitutes the contents of VBL into another MUMPS statement. <code>SET XYZ="ABC" SET @XYZ=123</code> sets the variable ABC to 123. <code>SET SUBROU="REPORT" DO @SUBROU</code> performs the subroutine named REPORT. This substitution allows for lazy evaluation and late binding as well as effectively the operational equivalent of "pointers" in other languages. '''Piece function''': This breaks variables into segmented pieces guided by a user specified separator string (sometimes called a "delimiter"). Those who know [[awk]] will find this familiar. <code>$PIECE(STRINGVAR,"^",3)</code> means the "third caret-separated piece of STRINGVAR." The piece function can also appear as an assignment (SET command) target. After <source lang="text"> SET X="dpbsmith@world.std.com" </source> <code>$PIECE("world.std.com",".",2)</code> yields "std" <code>SET $P(X,"@",1)="office"</code> causes X to become "office@world.std.com" (note that $P is equivalent to $PIECE and could be written as such). '''Order function''' <source lang="text"> Set stuff(6)="xyz",stuff(10)=26,stuff(15)="" </source> $<code>Order(stuff(""))</code> yields 6, $<code>Order(stuff(6))</code> yields 10, $<code>Order(stuff(8))</code> yields 10, $<code>Order(stuff(10))</code> yields 15, $<code>Order(stuff(15))</code> yields "". <source lang="text"> Set i="" For Set i=$O(stuff(i)) Quit:i="" Write !,i,10,stuff(i) </source> Here, the argument-less ''For'' repeats until stopped by a terminating ''Quit''. This line prints a table of i and stuff(i) where i is successively 6, 10, and 15. '''Multi-User/Multi-Tasking/Multi-Processor''': MUMPS supports multiple simultaneous users and processes even when the underlying operating system does not (E.g. MS-DOS). Additionally, there is the ability to specify an environment for a variable, such as by specifying a machine name in a variable (as in <code>SET ^|"DENVER"|A(1000)="Foo"</code>), which can allow you to access data on remote machines. For a thorough listing of the rest of the MUMPS commands, operators, functions and special variables, see these online resources: *[http://71.174.62.16/Demo/AnnoStd?Frame=Main&Page=a100006 MUMPS by Example], or the (out of print) book of the same name by Ed de Moel. Much of the language syntax is detailed 