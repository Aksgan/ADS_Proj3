between opening <math>\{D_1,D_2,D_3\}</math> or <math>\{D_3,D_4,D_5\}</math> (this choice can be derived from the secret key or from a [[Random number generator|true random]] source, such as [[dice]]<ref>Arel Cordero, David Wagner, and David Dill. [http://www.cs.berkeley.edu/~daw/papers/dice-wote06.pdf The Role of Dice in Election Audits -- Extended Abstract].</ref> or the [[stock market]]<ref>Jeremy Clark, Aleks Essex, Carlisle Adams. [http://www.cs.uwaterloo.ca/~j5clark/papers/StockMarket.pdf Secure and Observable Auditing of Electronic Voting Systems using Stock Indices].</ref>). This procedure allows the voter to be confident that the set of all ballots were ''counted as cast''. If all ballots are ''counted as cast'' and ''cast as intended'', then all ballots are ''counted as intended''. Therefore the integrity of the election can be proven to a very high probability. == Additional security == To further increase the integrity of a Punchscan election, several further steps can be taken to protect against a completely corrupt election authority. === Multiple databases === Since <math>D_1</math>, <math>D_2</math>, and <math>D_5</math> in the database are all generated pseudorandomly, multiple databases can be created with different random values for these columns. Each database is independent of the others, allowing the first half of some of the databases to be opened and inspected and the second half of others. Each database must produce the same final tally. Thus if an election authority were to tamper with the database to skew the final tally, they would have to tamper with each of the databases. The probability of the tampering being uncovered in the audit increases exponentially with the number of independent databases. With even a modest number of databases, the integrity of the election is probabilistically certain. === Commitments === Prior to an election, the election authority prints the ballots and creates the database(s). Part of this creation process involves [[Commitment scheme|committing]] to the unique information contained on each ballot and in the databases. This is accomplished by applying a cryptographic [[one-way function]] to the information. Though the result of this function, the commitment, is made public, the actual information being committed to remains sealed. Because the function is one-way, it is computationally infeasible to determine the information on the sealed ballot given only its publicly posted commitment. === Ballot inspection === Prior to an election, twice as many ballots are produced than the number intended to use in the election. Half of these ballots are selected randomly (or each candidate could choose a fraction of the ballots) and opened. The rows in the database corresponding to these selected ballots can be checked to ensure the calculations are correct and not tampered with. Since the election authority does not know ''a priori'' which ballots will be selected, passing this audit means the database is well formed with a very high probability. Furthermore, the ballots can be checked against their commitments to ensure with high probability that the ballot commitments are correct. == See also == * [[Stream cipher]] * [[Commitment scheme]] * [[Zero-knowledge proof]] == References == {{refs|2}} == External links == * [http://www.punchscan.org/ Project home page] * [http://punchscan.org/vocomp/PunchscanVocompSubmission.pdf Vocomp Submission] &mdash; a comprehensive 80-page document explaining all aspects of the system * [http://punchscan.org/press/punchscan%20-%20digital%20planet.mp3 Electronic Democracy] &mdash; [[BBC World]]'s [[Digital Planet]] audio interview with [[David Chaum]]. * [http://www.spectrum.ieee.org/print/4817 Making Every E-vote Count] &mdash; [[IEEE Spectrum]]. * Transparent and Open Voting with Punchscan: [http://www.securitycatalyst.com/2006/11/29/security-catalyst-39-voting-security-series-transparent-and-open-voting-with-punchscan/ Part I] and [http://www.securitycatalyst.com/2006/12/31/security-catalyst-december-31-2006-in-depth-with-punch-scan/ Part II] * [http://www.publicradio.org/columns/futuretense/2006/11/07.shtml Future Tense] audio interview with [[David Chaum]]. [[Category:Electronic voting methods]] [[Category:Applications of cryptography]] [[Category:Electoral systems]] [[Category:Elections]] [[de:Punchscan]]</text> </page> <page> <id>30559</id> <title>PureXML</title> <text>{{lowercase}} '''pureXML''' is the native [[XML]] storage feature in the [[IBM DB2]] data server. pureXML provides [[query language]]s, storage technologies, indexing technologies, and other features to support XML data. The word ''pure'' in pureXML was chosen to indicate that DB2 natively stores and natively processes XML data in its inherent hierarchical structure, as opposed to treating XML data as plain text or converting it into a relational format.<ref>http://www.ibm.com/developerworks/blogs/page/datastudioteam?entry=purexml_and_purequery_what_s</ref> == Technical information == DB2 includes two distinct storage mechanisms: one for efficiently managing traditional SQL data types, and another for managing XML data. The underlying storage mechanism is transparent to users and applications; they simply use SQL (including SQL with XML extensions or SQL/XML) or [[XQuery]] to work with the data. XML data is stored in columns of DB2 tables that have the XML data type. XML data is stored in a parsed format that reflects the hierarchical nature of the original XML data. As such, pureXML uses trees and nodes as its model for storing and processing XML data. If you instruct DB2 to validate XML data against an XML schema prior to storage, DB2 annotates all nodes in the XML hierarchy with information about the schema types; otherwise, it will annotate the nodes with default type information. Upon storage, DB2 preserves the internal structure of XML data, converting its tag names and other information into integer values. Doing so helps conserve disk space and also improves the performance of queries that use navigational expressions. However, users aren't aware of this internal representation. Finally, DB2 automatically splits XML nodes across multiple database pages, as needed. XML schemas specify which XML elements are valid, in what order these elements should appear in XML data, which XML data types are associated with each element, and so on. pureXML allows you to validate the cells in a column of XML data against no schema, one schema, or multiple schemas. pureXML also provides tools to support evolving XML schemas. IBM has enhanced its [[programming language]] interfaces to support access to its XML data. These enhancements span [[Java (programming language)|Java]] ([[JDBC]]), [[C (programming language)|C]] (embedded SQL and call-level interface), [[COBOL]] (embedded SQL), [[PHP]], and [[Microsoft]]'s [[.NET Framework]] (through the DB2.NET provider). == History == pureXML was first included in the DB2 9 for [[Linux]], [[Unix]], and [[Microsoft Windows]] release, which was codenamed Viper, in June 2006.<ref>http://www-03.ibm.com/press/us/en/pressrelease/19781.wss</ref> It was available on DB2 9 for [[z/OS]] in March 2007.<ref>http://www-03.ibm.com/press/us/en/pressrelease/21189.wss</ref> In October 2007, IBM released DB2 9.5 with improved XML data transaction performance and improved storage savings.<ref>http://www-03.ibm.com/press/us/en/pressrelease/22455.wss</ref> In June 2009, IBM released DB2 9.7 with XML supported for database-partitioned, range-partitioned, and 