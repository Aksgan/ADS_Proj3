remanufacturing the hardware, especially if they are [[commodity items]]. == Bug management == It is common practice for software to be released with known bugs that are considered non-critical, that is, that do not affect most users' main experience with the product. While software products may, by definition, contain any number of unknown bugs, measurements during testing can provide an estimate of the number of likely bugs remaining; this becomes more reliable the longer a product is tested and developed ("if we had 200 bugs last week, we should have 100 this week"). Most big software projects maintain two lists of "known bugs"— those known to the software team, and those to be told to users. This is not dissimulation, but users are not concerned with the internal workings of the product. The second list informs users about bugs that are not fixed in the current release, or not fixed at all, and a workaround may be offered. There are various reasons for not fixing bugs: * The developers often don't have time or it is not economical to fix all non-severe bugs. * The bug could be fixed in a new version or [[Patch (computing)|patch]] that is not yet released. * The changes to the code required to fix the bug could be large, expensive, or delay finishing the project. * Even seemingly simple fixes bring the chance of introducing new unknown bugs into the system. At the end of a test/fix cycle some managers may only allow the most critical bugs to be fixed. * Users may be relying on the undocumented, buggy behavior, especially if scripts or macros rely on a behavior; it may introduce a [[wiktionary:breaking change|breaking change]]. * It's "not a bug". A misunderstanding has arisen between expected and provided behavior Given the above, it is often considered impossible to write completely bug-free software of any real complexity. So bugs are categorized by severity, and low-severity non-critical bugs are tolerated, as they do not affect the proper operation of the system for most users. NASA's [[Software Assurance Technology Center|SATC]] managed to reduce the number of errors to fewer than 0.1 per 1000 lines of code ([[Source lines of code|SLOC]]){{Citation needed|date=September 2009}} but this was not felt to be feasible for any real world projects. The severity of a bug is not the same as its importance for fixing, and the two should be measured and managed separately. On a [[Microsoft Windows]] system a [[blue screen of death]] is rather severe, but if it only occurs in extreme circumstances, especially if they are well diagnosed and avoidable, it may be less important to fix than an icon not representing its function well, which though purely aesthetic may confuse thousands of users every single day. This balance, of course, depends on many factors; expert users have different expectations from novices, a niche market is different from a general consumer market, and so on. To better achieve this balance, some software developers use a formalized ''bug triage'' process (borrowing the [[triage|medical term]]), in which each new bug is assigned a priority based on its severity, frequency, risk, and other predetermined factors.{{Citation needed|date=May 2010}} A school of thought popularized by [[Eric S. Raymond]] as [[Linus's Law]] says that popular [[open-source software]] has more chance of having few or no bugs than other software, because "given enough eyeballs, all bugs are shallow".<ref>[http://www.catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar/ar01s04.html "Release Early, Release Often"], [[Eric S. Raymond]], ''[[The Cathedral and the Bazaar]]''</ref> This assertion has been disputed, however: computer security specialist [[Elias Levy]] wrote that "it is easy to hide vulnerabilities in complex, little understood and undocumented source code," because, "even if people are reviewing the code, that doesn't mean they're qualified to do so."<ref>[http://www.securityfocus.com/news/19 "Wide Open Source"], [[Elias Levy]], ''SecurityFocus'', 17 April 2000</ref> Like any other part of engineering management, bug management must be conducted carefully and intelligently because "what gets measured gets done"<ref>{{cite |url=http://mspresso.wordpress.com/2008/03/31/what-gets-measured-gets-done/ |last=Smith|first=Mark |accessdate=8 April 2009 |title=What gets measured gets done |publisher=Cobalt Group }}</ref> <!-- this is a blog, I think, but is short and sums it up nicely --> and managing purely by bug counts can have [[Law of Unintended Consequences|unintended consequences]]. If, for example, developers are rewarded by the number of bugs they fix, they will naturally fix the easiest bugs first— leaving the hardest, and probably most risky or critical, to the last possible moment ("I only have one bug on my list but it says "Make sun rise in West"). If the management ethos is to reward the number of bugs fixed, then some developers may quickly write sloppy code knowing they can fix the bugs later and be rewarded for it, whereas careful, perhaps "slower" developers do not get rewarded for the bugs that were never there. ==Security vulnerabilities== [[Malware|Malicious software]] may attempt to exploit known vulnerabilities in a system — which may or may not be bugs. Viruses are not bugs in themselves — they are typically programs that are doing precisely what they were designed to do. However, viruses are occasionally referred to as such in the popular press.{{Citation needed|date=August 2010}} == Common types of computer bugs == * Conceptual error (code is syntactically correct, but the programmer or designer intended it to do something else) ===Arithmetic bugs=== * [[Division by zero#In computer arithmetic|Division by zero]] * [[Arithmetic overflow]] or [[Arithmetic underflow|underflow]] * Loss of [[arithmetic precision]] due to [[rounding]] or [[numerical stability|numerically unstable]] algorithms ===Logic bugs=== * [[Infinite loop]]s and infinite [[Recursion (computer science)|recursion]] * [[Off by one error]], counting one too many or too few when looping ===Syntax bugs=== * Use of the wrong operator, such as performing assignment instead of [[%3D%3D#Equality|equality test]]. In simple cases often warned by the compiler; in many languages, deliberately guarded against by language syntax ===Resource bugs=== * [[Pointer (computing)#Null pointer|Null pointer]] dereference * Using an [[uninitialized variable]] * Using an otherwise valid instruction on the wrong [[data type]] (see [[packed decimal]]/[[binary coded decimal]]) * [[Access violation]]s * Resource leaks, where a finite system resource such as [[memory leak|memory]] or 