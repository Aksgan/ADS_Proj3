for sequencing purposes, nodes are compared according to their '''keys''' rather than any part of their associated records. The major advantage of binary search trees over other data structures is that the related [[sorting algorithm]]s and [[search algorithm]]s such as [[in-order traversal]] can be very efficient. Binary search trees are a fundamental [[data structure]] used to construct more abstract data structures such as [[set (computer science)|sets]], [[multiset]]s, and [[associative array]]s. ==Operations== Operations on a binary tree require comparisons between nodes. These comparisons are made with calls to a [[comparator (computer science)|comparator]], which is a [[subroutine]] that computes the total order (linear order) on any two values. This comparator can be explicitly or implicitly defined, depending on the language in which the BST is implemented. ===Searching=== Searching a binary tree for a specific value can be a [[Recursion (computer science)|recursive]] or [[Iteration#Computing|iterative]] process. This explanation covers a recursive method. We begin by examining the [[Tree (data structure)#root nodes|root node]]. If the tree is null, the value we are searching for does not exist in the tree. Otherwise, if the value equals the root, the search is successful. If the value is less than the root, search the left subtree. Similarly, if it is greater than the root, search the right subtree. This process is repeated until the value is found or the indicated subtree is null. If the searched value is not found before a null subtree is reached, then the item must not be present in the tree. Here is the search algorithm in the [[Python (programming language)|Python programming language]]: <source lang="python"> # 'node' refers to the parent-node in this case def search_binary_tree(node, key): if node is None: return None # key not found if key < node.key: return search_binary_tree(node.leftChild, key) elif key > node.key: return search_binary_tree(node.rightChild, key) else: # key is equal to node key return node.value # found key </source> … or equivalent [[Haskell (programming language)|Haskell]]: <source lang="haskell"> searchBinaryTree _ NullNode = Nothing searchBinaryTree key (Node nodeKey nodeValue (leftChild, rightChild)) = case compare key nodeKey of LT -> searchBinaryTree key leftChild GT -> searchBinaryTree key rightChild EQ -> Just nodeValue </source> This operation requires [[Big O notation|O]](log ''n'') time in the average case, but needs [[Big O notation|O]](''n'') time in the worst case, when the unbalanced tree resembles a [[linked list]] ([[Binary Tree#Types of binary trees|degenerate tree]]). Assuming that BinarySearchTree is a class with a member function "search(int)" and a pointer to the root node, the algorithm is also easily implemented in terms of an iterative approach. The algorithm enters a loop, and decides whether to branch left or right depending on the value of the node at each parent node. <source lang="cpp"> bool BinarySearchTree::search(int val) { Node *next = this->root(); while (next != NULL) { if (val == next->value()) { return true; } else if (val < next->value()) { next = next->left(); } else { next = next->right(); } } //not found return false; }</source> ===Insertion===<!-- This section is linked from [[Red-black tree]] --> Insertion begins as a search would begin; if the root is not equal to the value, we search the left or right subtrees as before. Eventually, we will reach an external node and add the value as its right or left child, depending on the node's value. In other words, we examine the root and recursively insert the new node to the left subtree if the new value is less than the root, or the right subtree if the new value is greater than or equal to the root. Here's how a typical binary search tree insertion might be performed in [[C++ (programming language)|C++]]: <source lang="cpp"> /* Inserts the node pointed to by "newNode" into the subtree rooted at "treeNode" */ void InsertNode(Node* &treeNode, Node *newNode) { if (treeNode == NULL) treeNode = newNode; else if (newNode->key < treeNode->key) InsertNode(treeNode->left, newNode); else InsertNode(treeNode->right, newNode); } </source> The above "destructive" procedural variant modifies the tree in place. It uses only constant space, but the previous version of the tree is lost. Alternatively, as in the following [[Python (programming language)|Python]] example, we can reconstruct all ancestors of the inserted node; any reference to the original tree root remains valid, making the tree a [[persistent data structure]]: <source lang="python"> def binary_tree_insert(node, key, value): if node is None: return TreeNode(None, key, value, None) if key == node.key: return TreeNode(node.left, key, value, node.right) if key < node.key: return TreeNode(binary_tree_insert(node.left, key, value), node.key, node.value, node.right) else: return TreeNode(node.left, node.key, node.value, binary_tree_insert(node.right, key, value)) </source> The part that is rebuilt uses Θ(log ''n'') space in the average case and Ω(''n'') in the worst case (see [[big-O notation]]). In either version, this operation requires time proportional to the height of the tree in the worst case, which is [[Big O notation|O]](log ''n'') time in the average case over all trees, but Ω(''n'') time in the worst case. Another way to explain insertion is that in order to insert a new node in the tree, its value is first compared with the value of the root. If its value is less than the root's, it is then compared with the value of the root's left child. If its value is greater, it is compared with the root's right child. This process continues, until the new node is compared with a leaf node, and then it is added as this node's right or left child, depending on its value. There are other ways of inserting nodes into a binary tree, but this is the only way of inserting nodes at the leaves and at the same time preserving the BST structure. Here is an iterative approach to inserting into a binary search tree the in [[Java (programming language)|Java Programming Language]]: <source lang="java"> public static void insert(Node root, int data) { if (root == null) { root = new TreeNode(data, null, null); return; } while (root != null) { if (data < root.getData()) { // insert left if (root.getLeft() == null) { root.setLeft(new TreeNode(data, null, null)); return; } else { root = root.getLeft(); } 