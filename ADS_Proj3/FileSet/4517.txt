2.0 matures, [[Travel 3.0]] is beginning to emerge. In this case, rather than following the trends of the overall Web (Travel 2.0 built on Web 2.0), the travel element is leading, providing the proving grounds for Web 3.0. <!-- THIS IS NOT A PLACE TO ADVERTISE YOUR TRAVEL-RELATED SITE. SPAM LINKS WILL BE DELETED QUICKLY. --> == See also == * [[.travel]], top-level domain name for the travel industry on the internet * [[Enterprise 2.0]] * [[Learning 2.0]] * [[Library 2.0]] * [[Office 2.0]] * [[User-generated content]] * [[Web 2.0]] * [[The Hitchhiker's Guide to the Galaxy]] == References == {{Reflist|2}} {{Tourism}} [[Category:Buzzwords]] [[Category:World Wide Web]] [[Category:Social networks]] [[Category:Travel technology]] [[Category:Travel websites]] [[fr:Tourisme 2.0]]</text> </page> <page> <id>38174</id> <title>Travelling salesman</title> <text>{{wiktionary|travelling salesman}} A '''travelling salesman''' is a travelling [[vendor (supply chain)]] of goods. '''Travelling salesman''' may also refer to: * [[Traveling Salesman (film)|''Traveling Salesman'' (film)]], a 1921 comedy film * [[Traveling Salesmen (The Office)|"Traveling Salesmen" (The Office)]], the twelfth episode of the third season of the US version of ''The Office'' * [[Travelling salesman problem]], a problem in discrete or combinatorial optimization {{disambig}} [[fr:Voyageur représentant placier]] [[it:Commesso viaggiatore]] [[pt: Caixeiro-viajante]]</text> </page> <page> <id>38180</id> <title>Treap</title> <text>{{Probabilistic}} In [[computer science]], the '''treap''' and the '''randomized binary search tree''' are two closely-related forms of [[binary search tree]] [[data structure]]s that maintain a dynamic set of ordered keys and allow [[binary search]]es among the keys. After any sequence of insertions and deletions of keys, the shape of the tree is a [[random variable]] with the same probability distribution as a [[random binary tree]]; in particular, with high probability its height is proportional to the [[logarithm]] of the number of keys, so that each search, insertion, or deletion operation takes logarithmic time to perform. ==Treap== [[Image:TreapAlphaKey.svg|thumb|left|A treap with alphabetic key and numeric max heap order]] The treap was first described by [[Cecilia R. Aragon]] and [[Raimund Seidel]] in 1989;<ref name="paper89">{{Citation | contribution=Randomized Search Trees | first1=Cecilia R. | last1=Aragon | first2=Raimund | last2=Seidel | url=http://faculty.washington.edu/aragon/pubs/rst89.pdf | title=[[Symposium on Foundations of Computer Science|Proc. 30th Symp. Foundations of Computer Science (FOCS 1989)]] | pages=540–545 | year=1989 | doi=10.1109/SFCS.1989.63531 | isbn=0-8186-1982-1 | publisher=IEEE Computer Society Press | location=Washington, D.C.}} </ref><ref name="paper96"> {{Citation | title=Randomized Search Trees | first1=Raimund | last1=Seidel | first2=Cecilia R. | last2=Aragon | journal=Algorithmica | volume=16 | issue=4/5 | pages=464–497 | year=1996 | url=http://citeseer.ist.psu.edu/seidel96randomized.html | doi=10.1007/s004539900061}}.</ref> its name is a [[portmanteau word|portmanteau]] of [[Tree data structure|tree]] and [[heap (data structure)|heap]]. It is a [[Cartesian tree]]<ref>{{citation | last = Vuillemin | first = Jean | doi = 10.1145/358841.358852 | issue = 4 | journal = Commun. ACM | location = New York, NY, USA | pages = 229–239 | publisher = ACM | title = A unifying look at data structures | volume = 23 | year = 1980}}.</ref> in which each key is given a (randomly chosen) numeric priority. As with any binary search tree, the [[inorder traversal]] order of the nodes is the same as the sorted order of the keys. The structure of the tree is determined by the requirement that it be heap-ordered: that is, the priority number for any non-leaf node must be greater than or equal to the priority of its children. Thus, as with Cartesian trees more generally, the root node is the maximum-priority node, and its left and right subtrees are formed in the same manner from the subsequences of the sorted order to the left and right of that node. An equivalent way of describing the treap is that it could be formed by inserting the nodes highest-priority-first into a binary search tree without doing any rebalancing. Therefore, if the priorities are independent random numbers (from a distribution over a large enough space of possible priorities to ensure that two nodes are very unlikely to have the same priority) then the shape of a treap has the same probability distribution as the shape of a [[random binary search tree]], a search tree formed by inserting the nodes without rebalancing in a randomly chosen insertion order. Because random binary search trees are known to have logarithmic height with high probability, the same is true for treaps. Specifically, the treap supports the following operations: *To search for a given key value, apply a standard [[binary search]] algorithm in a binary search tree, ignoring the priorities. *To insert a new key ''x'' into the treap, generate a random priority ''y'' for ''x''. Binary search for ''x'' in the tree, and create a new node at the leaf position where the binary search determines a node for ''x'' should exist. Then, as long as ''x'' is not the root of the tree and has a larger priority number than its parent ''z'', perform a [[tree rotation]] that reverses the parent-child relation between ''x'' and ''z''. *To delete a node ''x'' from the heap, if ''x'' is a leaf of the tree, simply remove it. If ''x'' has a single child ''z'', remove ''x'' from the tree and make ''z'' be the child of the parent of ''x'' (or make ''z'' the root of the tree if ''x'' had no parent). Finally, if ''x'' has two children, swap its position in the tree with the position of its immediate successor ''z'' in the sorted order, resulting in one of the previous cases. In this final case, the swap may violate the heap-ordering property for ''z'', so additional rotations may need to be performed to restore this property. *To split a treap into two smaller treaps, those smaller than key ''x'', and those larger than key ''x'', insert ''x'' into the treap with maximum priority—larger than the priority of any node in the treap. After this insertion, ''x'' will be the root node of the treap, all values less than ''x'' will be found in the left subtreap, and all values greater than ''x'' will be found in the right subtreap. This costs as much as a single insertion into the treap. *Merging two treaps (assumed to be the product of a former split), 