may be defined using a voting protocol whose results depend only on the visible channels. The problem of voting for a ''single'' value by a group of independent entities is called [[Consensus (computer science)|'''Consensus''']]. By extension, a ''series'' of values may be chosen by a series of consensus instances. This problem becomes difficult when the participants or their communication medium may experience failures <ref name="lowerbounds"/>. Inputs may be ordered by their position in the series of consensus instances ('''Consensus Order''')<ref name=paxos/>. Consensus Order may be derived independently by each server. Inputs to the State Machine may be executed in Consensus Order, guaranteeing consistent State and Output for all non-faulty replicas. :'''Optimizing Causal & Consensus Ordering''' :In some cases additional information is available (such as real-time clocks). In these cases, it is possible to achieve more efficient causal or consensus ordering for the Inputs, with a reduced number of messages, fewer message rounds, or smaller message sizes. See references for details <ref name=schneider/><ref name=cheap/><ref name=time/><ref name=fast>{{cite web|curly=yes|last=Lamport|first=Leslie|year=2005|title=Fast Paxos|url=http://research.microsoft.com/users/lamport/pubs/pubs.html#fast-paxos}}</ref> :Further optimizations are available when the semantics of State Machine operations are accounted for (such as Read vs Write operations). See references [[Paxos_algorithm#Generalized Paxos|Generalized Paxos]]<ref name=reliable/><ref name=general>{{cite journal|curly=yes|last=Lamport|first=Leslie|year=2005|title=Generalized Consensus and Paxos|url=http://research.microsoft.com/users/lamport/pubs/pubs.html#generalized}}</ref>. ===Sending Outputs=== Client requests are interpreted as Inputs to the State Machine, and processed into Outputs in the appropriate order. Each replica will generate an Output independently. Non-faulty replicas will always produce the same Output. Before the client response can be sent, faulty Outputs must be filtered out. Typically, a majority of the Replicas will return the same Output, and this Output is sent as the response to the client. ===System Failure=== :If there is no majority of replicas with the same Output, or if less than a majority of replicas returns an Output, a system failure has occurred. The client response must be the unique Output: FAIL. ===Auditing and Failure Detection=== The permanent, unplanned compromise of a replica is called a '''Failure'''. Proof of failure is difficult to obtain, as the replica may simply be slow to respond <ref name=FLP>{{cite journal|curly=yes|last=Fischer|first=Michael|year=1985|title=Impossibility of Distributed Consensus with One Faulty Process|journal=Journal of the Association for Computing Machinery|volume=32|issue=2|pages=347–382|url=http://research.microsoft.com/users/lamport/pubs/pubs.html#using-time|accessdate=2008-03-13}}</ref>, or even lie about its status <ref name=byzantine/>. Non-faulty replicas will always contain the same State and produce the same Outputs. This invariant enables failure detection by comparing States and Outputs of all replicas. Typically, a replica with State or Output which differs from the majority of replicas is declared faulty. A common implementation is to pass checksums of the current replica State and recent Outputs among servers. An Audit process at each server restarts the local replica if a deviation is detected <ref name=live>{{cite journal|curly=yes|last=Chandra|first=Tushar|coauthors=Robert Griesemer, Joshua Redstone|year=2007|title=Paxos Made Live – An Engineering Perspective|journal=PODC '07: 26th ACM Symposium on Principles of Distributed Computing|url=http://labs.google.com/papers/paxos_made_live.html}}</ref>. Cryptographic security is not required for checksums. It is possible that the local server is compromised, or that the Audit process is faulty, and the replica continues to operate incorrectly. This case is handled safely by the Output filter described previously (see [[#Sending Outputs|Sending Outputs]]). ==Appendix: Extensions== ===Input Log=== In a system with no failures, the Inputs may be discarded after being processed by the State Machine. Realistic deployments must compensate for transient non-failure behaviors of the system such as message loss, network partitions, and slow processors <ref name=live/>. One technique is to store the series of Inputs in a log. During times of transient behavior, replicas may request copies of a log entry from another replica in order to fill in missing Inputs <ref name=paxos/>. In general the log is not required to be persistent (it may be held in memory). A persistent log may compensate for extended transient periods, or support additional system features such as [[#Checkpoints|Checkpoints]], and [[#Reconfiguration|Reconfiguration]]. ===Checkpoints=== If left unchecked a log will grow until it exhausts all available storage resources. For continued operation, it is necessary to forget log entries. In general a log entry may be forgotten when its contents are no longer relevant (for instance if all replicas have processed an Input, the knowledge of the Input is no longer needed). A common technique to control log size is store a duplicate State (called a '''Checkpoint'''), then discard any log entries which contributed to the checkpoint. This saves space when the duplicated State is smaller than the size of the log. Checkpoints may be added to any State Machine by supporting an additional Input called '''CHECKPOINT'''. Each replica maintains a checkpoint in addition to the current State value. When the log grows large, a replica submits the CHECKPOINT command just like a client request. The system will ensure non-faulty replicas process this command in the same order, after which all log entries before the checkpoint may be discarded. In a system with checkpoints, requests for log entries occurring before the checkpoint are ignored. Replicas which cannot locate copies of a needed log entry are faulty and must re-join the system (see [[#Reconfiguration|Reconfiguration]]). ===Reconfiguration=== Reconfiguration allows replicas to be added and removed from a system while client requests continue to be processed. Planned maintenance and replica failure are common examples of reconfiguration. Reconfiguration involves [[#Quitting|Quitting]] and [[#Joining|Joining]]. ===Quitting=== When a server detects its State or Output is faulty (see [[#Auditing and Failure Detection|Auditing and Failure Detection]]), it may selectively exit the system. Likewise, an administrator may manually execute a command to remove a replica for maintenance. A new Input is added to the State Machine called '''QUIT'''<ref name=reliable/><ref name=time/>. A replica submits this command to the system just like a client request. All non-faulty replicas remove the quitting replica from the system upon processing this Input. During this time, the replica may ignore all protocol messages. If a majority of non-faulty replicas remain, the quit is successful. If not, there is a [[#System Failure|System Failure]]. ===Joining=== After quitting, a failed server may selectively restart or re-join the system. Likewise, an administrator may add a new replica to the group for additional capacity. A new Input is added to the State Machine called '''JOIN'''. A replica submits 