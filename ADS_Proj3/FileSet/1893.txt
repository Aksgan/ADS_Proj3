of Service Counter-Measure", technical report, August 2002 [http://www.hashcash.org/papers/hashcash.pdf (PDF)]. * Ben Laurie and Richard Clayton, "'Proof-of-Work' Proves Not to Work", WEAS 04. [http://www.hashcash.org/papers/proof-work.pdf (PDF)]. * Dwork, C. and Naor, M. (1992) "Pricing via Processing or Combating Junk Mail", Crypto '92, pp. 139–147. [http://dsns.csie.nctu.edu.tw/research/crypto/HTML/PDF/C92/139.PDF (PDF)] <references /> ==External links== * http://hashcash.org — Hashcash homepage * [http://www-106.ibm.com/developerworks/linux/library/l-hashcash.html?ca=dgr-lnxw01HashCash Beat spam using hashcash] — David Mertz's article on hashcash, its applications and an implementation in [[Python (language)|Python]]. * [http://www.ietf.org/ietf/IPR/rsa-ipr-draft-jennings-sip-hashcash-00.txt RSA IPR note to the IETF about hashcash] (2004) [[Category:Cryptographic protocols]] [[Category:Spam filtering]] [[Category:Email authentication]] [[de:Hashcash]] [[fr:Hashcash]]</text> </page> <page> <id>16372</id> <title>Haskell 98 features</title> <text>This article describes the features in [[Haskell (programming language)|'''Haskell98''']]. == Examples == === Factorial === A simple example that is often used to demonstrate the syntax of [[functional language]]s is the [[factorial]] function for non-negative integers, shown in Haskell: <source lang="haskell"> factorial :: Integer -> Integer factorial 0 = 1 factorial n | n > 0 = n * factorial (n-1) </source> Or in one line: <source lang="haskell"> factorial n = if n > 0 then n * factorial (n-1) else 1 </source> This describes the factorial as a recursive function, with one terminating base case. It is similar to the descriptions of factorials found in mathematics textbooks. Much of Haskell code is similar to standard [[mathematical notation]] in facility and syntax. The first line of the factorial function describes the ''type'' of this function; while it is optional, it is considered to be good style<ref>HaskellWiki: [http://www.haskell.org/haskellwiki/Type_signatures_as_good_style Type signatures as good style]</ref> to include it. It can be read as ''the function factorial'' (<tt>factorial</tt>) ''has type'' (<tt>::</tt>) ''from integer to integer'' (<tt>Integer -> Integer</tt>). That is, it takes an integer as an argument, and returns another integer. The type of a definition is inferred automatically if the programmer didn't supply a type annotation. The second line relies on [[pattern matching]], an important feature of Haskell. Note that parameters of a function are not in parentheses but separated by spaces. When the function's argument is 0 (zero) it will return the integer 1 (one). For all other cases the third line is tried. This is the [[recursion]], and executes the function again until the base case is reached. A [[guard (computing)|guard]] protects the third line from negative numbers for which a factorial is undefined. Without the guard this function would, if called with a negative number, recurse through all negative numbers without ever reaching the base case of 0. As it is, the pattern matching is not complete: if a negative integer is passed to the factorial function as an argument, the program will fail with a runtime error. A final case could check for this error condition and print an appropriate error message instead. Using the <tt>product</tt> function from the Prelude, a number of small functions analogous to [[C (programming language)|C]]'s [[C standard library|standard library]], and using the Haskell syntax for arithmetic sequences, the factorial function can be expressed in Haskell as follows: <source lang="haskell"> factorial n = product [1..n] </source> Here <tt><nowiki>[1..n]</nowiki></tt> denotes the arithmetic sequence {{nowrap|1, 2, …, ''n''}} in list form. Using the Prelude function <tt>enumFromTo</tt>, the expression <tt><nowiki>[1..n]</nowiki></tt> can be written as <tt>enumFromTo 1 n</tt>, allowing the factorial function to be expressed as <source lang="haskell"> factorial n = product (enumFromTo 1 n) </source> which, using the [[function composition operator]] (expressed as a dot in Haskell) to compose the product function with the [[currying|curried]] enumeration function can be rewritten in [[point-free programming|point-free style]]:<ref>HaskellWiki: [http://haskell.org/haskellwiki/Pointfree Pointfree]</ref> <source lang="haskell"> factorial = product . enumFromTo 1 </source> In the Hugs interpreter, one often needs to define the function and use it on the same line separated by a <tt>where</tt> or <tt>let</tt>..<tt>in</tt>. For example, to test the above examples and see the output <tt>120</tt>: <source lang="haskell"> let { factorial n | n > 0 = n * factorial (n-1); factorial _ = 1 } in factorial 5 </source> or <source lang="haskell"> factorial 5 where factorial = product . enumFromTo 1 </source> The GHCi interpreter doesn't have this restriction and function definitions can be entered on one line and referenced later. === More complex examples === In the Haskell source immediately below, "::" can be read as "has type"; "a —> b" can be read as "is a function from a to b". (Thus the Haskell "calc :: String —> [Float]" can be read as "<tt>calc</tt> has type of function from Strings to lists of Floats".) In the second line "calc = ... " the equals sign can be read as "can be"; thus multiple lines with "calc = ... " can be read as multiple possible values for <tt>calc</tt>, depending on the circumstance detailed in each line. A simple [[Reverse Polish notation]] calculator expressed with the [[higher-order function]] <code>[[foldl]]</code> whose argument ''f'' is defined in a ''where'' clause using [[pattern matching]] and the [[type class]] ''Read'': <source lang="haskell"> calc :: String -> [Float] calc = foldl f [] . words where f (x:y:zs) "+" = (y + x):zs f (x:y:zs) "-" = (y - x):zs f (x:y:zs) "*" = (y * x):zs f (x:y:zs) "/" = (y / x):zs f xs y = read y : xs </source> The empty list is the initial state, and ''f'' [[Interpreter (computing)|interpret]]s one word at a time, either matching two numbers from the head of the list and pushing the result back in, or parsing the word as a [[floating-point number]] and prepending it to the list. The following definition produces the list of [[Fibonacci numbers]] in linear time: <source lang="haskell"> fibs = 0 : 1 : zipWith (+) fibs (tail fibs) </source> The infinite list is produced by [[corecursion]] — the latter values of the list are computed on demand starting from the initial two items 0 and 1. This kind of a definition relies on [[lazy evaluation]], an important feature of Haskell programming. For an example of how the evaluation evolves, the following illustrates the values of ''fibs'' and ''tail fibs'' after the computation of six items and shows how ''zipWith (+)'' has produced 