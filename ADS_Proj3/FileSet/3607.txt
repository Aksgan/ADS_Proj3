that if all roots of a polynomial have positive real part, then so do the roots of all derivatives of the polynomial. A related result is the [[Bernstein's inequality in mathematical analysis|Bernstein's inequality]]. It states that for a polynomial ''P'' of degree ''n'' with derivative ''P′'' we have :<math>\max_{|z| \leq 1} \big|P'(z)\big| \le n \max_{|z| \leq 1} \big|P(z)\big|.</math> == Polynomials with real roots== If <math>a_n x^n+a_{n-1}x^{n-1}+\ldots+a_1x+a_0</math> is a polynomial such that all of its roots are real, then they are located in the interval with endpoints :<math>x_\pm=-\frac{a_{n-1}}{n\cdot a_n} \pm \frac{n-1}{n\cdot a_n}\sqrt{a^2_{n-1} - \frac{2n}{n-1}a_n a_{n-2}}</math>. Example: The polynomial <math>x^4+5x^3+5x^2-5x-6</math> has four real roots -3, -2, -1 and 1. The formula gives :<math>x_\pm=-\frac{5}{4} \pm \frac{3}{4}\sqrt{\frac{35}{3}}</math>, its roots are contained in : I = [-3,812 ; 1,312]. ==See also== * [[Descartes' rule of signs]] * [[Abel–Ruffini theorem]] * [[Viète's formulas]] * [[Gauss–Lucas theorem]] * [[Content (algebra)]] * [[Rational root theorem]] * [[Halley's method]] * [[Laguerre's method]] * [[Jenkins-Traub method]] == Notes == <references/> ==References== * E.E. Tyrtyshnikov, ''A Brief Introduction to Numerical Analysis'', Birkhäuser Boston, 1997 [[Category:Mathematical analysis]] [[Category:Polynomials]] [[ar:خواص جذور كثيرة الحدود]] [[de:Polynom]]</text> </page> <page> <id>30379</id> <title>Protocol implementation conformance statement</title> <text>A '''Protocol Implementation Conformance Statement''' or most commonly ''PICS'' is a structured document which asserts which specific requirements are met by a given implementation of a [[communications protocol|protocol]] [[Technical standard|standard]]. It is often completed as a record of formal protocol [[conformance testing|conformance test]] results, and some [[automated test]] systems machine-author a PICS as output. A potential buyer or user of the implementation can consult the PICS to determine if it meets his or her requirements. [[ETSI]] publish [http://portal.etsi.org/mbs/Referenced%20Documents/ts_101_823_02.pdf an example proforma PICS] showing which information would be completed. {{Measurement-stub}} [[Category:Documents]] [[Category:Network protocols]] [[Category:Software testing]]</text> </page> <page> <id>30380</id> <title>Protocol overhead</title> <text>{{Multiple issues|technical = September 2010}} '''Protocol overhead''' refers to characteristics of computer communications schemes. An application which transfers data across a network can not expect to use the full [[Bandwidth (computing)|bandwidth]] of the communications medium, since some data is necessary for routing of the message, describing the information content of the message, and other protocol needs. This extra data is referred to as overhead, since it does not contribute to the information in the content of the message. Thus, protocol overhead, expressed as a percentage, is the number of non-application [[byte]]s (protocol and [[frame synchronization]]) divided by the total number of bytes in the message. ==References== * [http://msdn2.microsoft.com/en-us/library/ms997599.aspx Common Performance Issues in Network Applications Part 1: Interactive Applications], Windows XP Technical Articles, Microsoft * [http://www.sonic.net/support/docs/ip-atm.overhead.pdf Protocol Overhead in IP/ATM Networks], Minnesota Supercomputer Center {{DEFAULTSORT:Protocol Overhead}} [[Category:Computer networking]] {{Compu-network-stub}}</text> </page> <page> <id>30381</id> <title>Protocol stack</title> <text>{{Unreferenced|date=April 2008}} A '''protocol stack''' (sometimes '''communications stack''') is a particular software implementation of a [[computer network]]ing ''protocol suite''. The terms are often used interchangeably. Strictly speaking, the suite is the definition of the protocols, and the stack is the software implementation of them. Individual [[network protocol|protocols]] within a suite are often designed with a single purpose in mind. This [[modularity (programming)|modularization]] makes design and evaluation easier. Because each protocol module usually communicates with two others, they are commonly imagined as ''layers'' in a stack of protocols. The lowest protocol always deals with "low-level", physical interaction of the hardware. Every higher layer adds more features. User applications usually deal only with the topmost layers (see also [[OSI model]]). In practical implementation, protocol stacks are often divided into three major sections: media, transport, and applications. A particular [[operating system]] or platform will often have two well-defined software interfaces: one between the media and transport layers, and one between the transport layers and applications. The media-to-transport interface defines how transport protocol software makes use of particular media and hardware types ("card drivers"). For example, this interface level would define how [[Internet protocol suite|TCP/IP]] transport software would talk to [[Ethernet]] hardware. Examples of these interfaces include [[Open Data-Link Interface|ODI]] and [[Network Driver Interface Specification|NDIS]] in the [[Microsoft Windows]] and [[DOS]] environment. The application-to-transport interface defines how application programs make use of the transport layers. For example, this interface level would define how a [[web browser]] program would talk to TCP/IP transport software. Examples of these interfaces include [[Berkeley sockets]] and System V [[STREAMS]] in the [[Unix]] world, and [[Winsock]] in the Microsoft world. ==General protocol suite description== T ~ ~ ~ T [A] [B]_____[C] Imagine three computers: ''A'', ''B'', and ''C''. ''A'' and ''B'' both have radio equipment, and can communicate via the airwaves using a suitable network protocol (such as [[IEEE 802.11]].) ''B'' and ''C'' are connected via a cable, using it to exchange data (again, with the help of a protocol, for example Ethernet). However, neither of these two protocols will be able to transport information from ''A'' to ''C'', because these computers are conceptually on different networks. One, therefore, needs an inter-network protocol to "connect" them. One could combine the two protocols to form a powerful third, mastering both cable and wireless transmission, but a different super-protocol would be needed for each possible combination of protocols. It is easier to leave the base protocols alone, and design a protocol that can work on top of any of them (the [[Internet Protocol]] is an example.) This will make two stacks of two protocols each. The inter-network protocol will communicate with each of the base protocol in their simpler language; the base protocols will not talk directly to each other. A request on computer ''A'' to send a chunk of data to ''C'' is taken by the upper protocol, which (through whatever means) knows that ''C'' is reachable through ''B''. It, therefore, instructs the wireless protocol to transmit the data packet to ''B''. On this computer, the lower layer handlers will pass the packet up to the inter-network protocol, which, on recognizing that ''B'' is not the final destination, will again invoke lower-level functions. This time, the cable protocol is used to send the data to ''C''. There, the received packet is again passed to the upper protocol, which (with ''C'' being the destination) will pass it on to a higher protocol 