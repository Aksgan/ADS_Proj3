group is defined. *The codelet directive is inserted just before the function declaration. The syntax of the directive is: <font color="#0070C0">#pragma hmpp <</font>grp_label<font color="#0070C0">></font> codelet_label <font color="#0070C0">codelet</font> [<font color="#0070C0">, version</font> = major.minor[.micro]?]? [<font color="#0070C0">, args[</font>arg_items<font color="#0070C0">].io=</font>[[<font color="#0070C0">in</font>|<font color="#0070C0">out</font>|<font color="#0070C0">inout</font>]]* [<font color="#0070C0">, args[</font>arg_items<font color="#0070C0">].size={</font>dimsize[,dimsize]*<font color="#0070C0">}</font>]* [<font color="#0070C0">, args[</font>arg_items<font color="#0070C0">].const=true</font>]* [<font color="#0070C0">, cond =</font> "expr"] [<font color="#0070C0">, target=</font><font color="#990000">target_name</font>[:<font color="#990000">target_name</font>]*] More than one codelet directive can be added to a function in order to specify different uses or different execution contexts. However, there can be only one codelet directive for a given call site label. The <code>callsite</code> directive specifies how the use a codelet at a given point in the program. <br /> The syntax of the directive is: <font color="#0070C0">#pragma hmpp <</font>grp_label<font color="#0070C0">></font> codelet_label <font color="#0070C0">callsite</font> [<font color="#0070C0">, asynchronous</font>]? [<font color="#0070C0">, args[</font>arg_items<font color="#0070C0">].size={</font>dimsize[,dimsize]*<font color="#0070C0">}</font>]* [<font color="#0070C0">, args[</font>arg_items<font color="#0070C0">].advancedload=</font>[[<font color="#0070C0">true</font>|<font color="#0070C0">false</font>]]* [<font color="#0070C0">, args[</font>arg_items<font color="#0070C0">].addr="</font>expr<font color="#0070C0">"</font>]* [<font color="#0070C0">, args[</font>arg_items<font color="#0070C0">].noupdate=true</font>]* An example is shown here : /* declaration of the codelet */ #pragma hmpp simple1 codelet, args[outv].io=inout, target=CUDA static void matvec(int sn, int sm, loat inv[sm], float inm[sn][sm], float *outv){ int i, j; for (i = 0 ; i < sm ; i++) { float temp = outv[i]; for (j = 0 ; j < sn ; j++) { temp += inv[j] * inm[i][ j]; } outv[i] = temp; } int main(int argc, char **argv) { int n; ........ /* codelet use */ #pragma hmpp simple1 callsite, args[outv].size={n} matvec(n, m, myinc, inm, myoutv); ........ } In some cases, a specific management of the data throughout the application is required (CPU/GPU data movements optimization, shared variables...).<br /> The <code>group</code> directive allows the declaration of a group of codelets. The parameters defined in this directive are applied to all codelets belonging to the group. The syntax of the directive is: <font color="#0070C0">#pragma hmpp <</font>grp_label<font color="#0070C0">> group</font> [<font color="#0070C0">, version =</font> <major>.<minor>[.<micro>]?]? [<font color="#0070C0">, target =</font> <font color="#990000">target_name</font>[:<font color="#990000">target_name</font>]*]]? [<font color="#0070C0">, cond = “</font>expr<font color="#0070C0">”</font>]? === Data transfers directives to optimize communication overhead === When using a HWA, the main bottleneck is often the data transfers between the HWA and the main processor.<br /> To limit the communication overhead, data transfers can be overlapped with successive executions of the same codelet by using the asynchronous property of the HWA. * allocate directive The <code>allocate</code> directive locks the HWA and allocates the needed amount of memory. <font color="#0070C0">#pragma hmpp <</font>grp_label<font color="#0070C0">> allocate</font> [<font color="#0070C0">,args[</font>arg_items<font color="#0070C0">].size={</font>dimsize[,dimsize]*<font color="#0070C0">}</font>]* * release directive The <code>release</code> directive specifies when to release the HWA for a group or a stand-alone codelet. <font color="#0070C0">#pragma hmpp <</font>grp_label<font color="#0070C0">> release</font> * advancedload directive The <code>advancedload</code> directive prefetches data before the remote execution of the codelet.<br /> <font color="#0070C0">#pragma hmpp <</font>grp_label<font color="#0070C0">></font> [codelet_label]? <font color="#0070C0">advancedload</font> <font color="#0070C0">,args[</font>arg_items<font color="#0070C0">]</font> [<font color="#0070C0">,args[</font>arg_items<font color="#0070C0">].size={</font>dimsize[,dimsize]*<font color="#0070C0">}</font>]* [<font color="#0070C0">,args[</font>arg_items<font color="#0070C0">].addr="</font>expr<font color="#0070C0">"</font>]* [<font color="#0070C0">,args[</font>arg_items<font color="#0070C0">].section={</font>[<font color="#990000">subscript_triplet</font><font color="#0070C0">,</font>]+<font color="#0070C0">}</font>]* [<font color="#0070C0">,asynchronous</font>] * delegatedstore directive The <code>delegatedstore</code> directive is a synchronization barrier to wait for an asynchronous codelet execution to complete and to then download the results.<br /> <font color="#0070C0">#pragma hmpp <</font>grp_label<font color="#0070C0">></font> [codelet_label]? <font color="#0070C0">delegatedstore</font> <font color="#0070C0">,args[</font>arg_items<font color="#0070C0">]</font> [<font color="#0070C0">,args[</font>arg_items<font color="#0070C0">].addr="</font>expr<font color="#0070C0">"</font>]* [<font color="#0070C0">,args[</font>arg_items<font color="#0070C0">].section={</font>[<font color="#990000">subscript_triplet</font><font color="#0070C0">,</font>]+<font color="#0070C0">}</font>]* * Asynchronous Computations The <code>synchronize</code> directive specifies to wait until the completion of an asynchronous callsite execution. For the synchronize directive, the codelet label is always mandatory and the group label is required if the codelet belongs to a group. <font color="#0070C0">#pragma hmpp <</font>grp_label<font color="#0070C0">></font> codelet_label <font color="#0070C0">synchronize</font> * Example In the following example, the device initialization, memory allocation and upload of the input data are done only once outside the loop and not in each iteration of the loop.<br /> The <code>synchronize</code> directive allows to wait for the asynchronous execution of the codelet to complete before launching another iteration. Finally the <code>delegatedstore</code> directive outside the loop uploads the sgemm result. int main(int argc, char **argv) { #pragma hmpp sgemm allocate, args[vin1;vin2;vout].siez={size,size} #pragma hmpp sgemm advancedload, args[vin1;vin2;vout], args[m,n,k,alpha,beta] for ( j = 0 ; j < 2 ; j ++) { #pragma hmpp sgemm callsite, asynchronous, args[vin1;vin2;vout].advancedload=true, args[m,n,k,alpha,beta].advancedload=true sgemm (size, size, size, alpha, vin1, vin2, beta, vout); #pragma hmpp sgemm synchronize } #pragma hmpp sgemm delegatedstore, args[vout] #pragma hmpp sgemm release === Sharing Data Between Codelets === Those directives map together all the arguments sharing the given name for all the group.<br /> The types and dimensions of all mapped arguments must be identical. The <code>map</code> directive maps several arguments on the device. <font color="#0070C0">#pragma hmpp <</font>grp_label<font color="#0070C0">> map, args[</font>arg_items<font color="#0070C0">]</font> This directive is quite similar as the <code>map</code> directive except that the arguments to be mapped are directly specified by their name. The <code>mapbyname</code> directive is equivalent to multiple <code>map</code> directives. <font color="#0070C0">#pragma hmpp <</font>grp_label<font color="#0070C0">> mapbyname</font> [<font color="#0070C0">,</font>variableName]+ === Global Variable === The <code>resident</code> directive declares some variables as global within a group. Those variables can then be directly accessed from any codelet belonging to the group. This directive applies to the declaration statement just following it in the source code. The syntax of this directive is: <font color="#0070C0">#pragma hmpp <</font>grp_label<font color="#0070C0">> resident</font> [<font color="#0070C0">, args[::</font>var_name<font color="#0070C0">].io=</font>[[<font color="#0070C0">in</font>|<font color="#0070C0">out</font>|<font color="#0070C0">inout</font>]]* [<font color="#0070C0">, args[::</font>var_name<font color="#0070C0">].size={</font>dimsize[,dimsize]*<font color="#0070C0">}</font>]* [<font color="#0070C0">, args[::</font>var_name<font color="#0070C0">].addr="</font>expr<font color="#0070C0">"</font>]* [<font color="#0070C0">, args[::</font>var_name<font color="#0070C0">].const=true</font>]* The notation <code>::var_name</code> with the prefix <code>::</code>, indicates an application’s variable declared as resident. === Acceleration of Regions === A region is a merge of the codelet/callsite directives. The goal is to avoid code restructuration to build the codelet. Therefore, all the attributes available for <code>codelet</code> or <code>callsite</code> directives can be used on <code>regions</code> directives. In C language: <font color="#0070C0">#pragma hmpp [<</font>MyGroup<font color="#0070C0">>] [</font>label<font color="#0070C0">] region</font> [<font color="#0070C0">, args[</font>arg_items<font color="#0070C0">].io=</font>[[<font color="#0070C0">in</font>|<font color="#0070C0">out</font>|<font color="#0070C0">inout</font>]]* [<font color="#0070C0">, cond = "</font>expr<font color="#0070C0">"]</font>< [<font color="#0070C0">, args[</font>arg_items<font color="#0070C0">].const=true</font>]* [<font color="#0070C0">, target=</font><font color="#990000">target_name</font>[<font color="#0070C0">:</font><font color="#990000">target_name</font>]*] [<font color="#0070C0">, args[</font>arg_items<font color="#0070C0">].size={</font>dimsize[<font color="#0070C0">,</font>dimsize]*<font color="#0070C0">}</font>]* [<font color="#0070C0">, args[</font>arg_items<font color="#0070C0">].advancedload=</font>[[<font color="#0070C0">true</font>|<font color="#0070C0">false</font>]]* [<font color="#0070C0">, args[</font>arg_items<font color="#0070C0">].addr="</font>expr<font color="#0070C0">"</font>]* [<font color="#0070C0">, args[</font>arg_items<font color="#0070C0">].noupdate=true</font>]* [<font color="#0070C0">, asynchronous</font>]? [<font color="#0070C0">, private=[</font>arg_items<font color="#0070C0">]</font>]* { C BLOCK STATEMENTS } == Implementations == The HMPP Open Standard is based on HMPP Version 2.3 (May 2009, CAPS entreprise). The HMPP directive-based programming model is implemented in: *HMPP Workbench, 