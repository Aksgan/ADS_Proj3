not support. An ideal situation would allow the PC-based application to link to the older mainframe application and allow the mainframe and the PCs to share each other's [[data]]. Accessing the mainframe’s data offers two advantages: # new front-end PC applications can replace the old user-unfriendly mainframe terminals # PC-based systems can use the data from the mainframe in new ways — previously impractical due to the constraints of the mainframe’s software Up until the late 1980s [[system integrator]]s had no easy way to link these different applications together. [[Middleware Analysts|Developers]] faced several challenges: # the [[software developer|developer]]s would have to construct a separate software ‘adapter’ on both systems to translate data from source applications into a format that the destination system could understand (and ''vice versa''). # the processing speed of each system would constrain the other system. For example, if the mainframe ran slowly, the PC-based application would have to wait until the mainframe caught up, thereby slowing down the PC application. Conversely, processing that had been offloaded to distributed servers for cost reasons would run slowly and the mainframe would have to wait until the server caught up. # [[Middleware Analysts|communications programmers]] would need to install a network gateway system to form a bridge between the mainframe’s network and the PC network if the different systems used different network protocols. The gateway would translate the network packets from the source system and pass them on to the destination system using the destination system’s protocol. Such issues made integration between applications difficult. Much of such integration also required re-engineering every time two applications on disparate platforms needed linking together, as every situation differed to some extent. By devoting effort to linking together applications on different systems, IT departments started to spend an amount significantly greater than that spent on original development per sub-system. [[Middleware Analysts|Developers]] needed a separate piece of software that would sit in the middle of two or more applications and would handle all the ‘plumbing’ between the two systems. Such software needed the intelligence to handle different [[Platform (computing)|platform]]s, different [[programming language]]s, various [[network protocol]]s and diverse [[hardware]]. [[Middleware Analysts|Developers]] wanted to remove themselves from the complexities of the underlying computing [[infrastructure]] so that they could focus on functionality within actual applications. Towards the end of the 1980s middleware began to emerge that attempted to address these issues. Initial middleware offerings addressed specific handfuls of platforms or languages and thus had limited usefulness. Over time, however, middleware products have become more and more advanced, supporting multiple platforms, languages and protocols. The ability of middleware to link together disparate systems across a [[heterogeneous network]] environment offers only one example of the benefits of this dominant technology. Middleware {{As of|2006|lc=on}} provides a whole raft of new functionality that augments and enhances the existing applications that it interconnects. ==Advantages== The primary advantage of a message-based communications [[protocol (computing)|protocol]] lies in its ability to store, route or transform [[message]]s in the process of delivery. ==Communication properties== ===Synchronicity=== MOM comprises a category of inter-[[application software|application]] [[communication software]] that generally relies on [[asynchronous]] [[message passing|message-passing]], as opposed to a [[request-response]] metaphor. In asynchronous systems, [[message queue]]s provide temporary storage when the destination program is busy or not connected. In addition, most asynchronous MOM systems provide [[persistent storage]] to [[backup|back up]] the message queue. This means that the sender and receiver do not need to connect to the network at the same time ([[asynchrony|asynchronous delivery]]), and solves problems with intermittent connectivity. It also means that should the receiver application fail for any reason, the senders can continue unaffected, as the messages they send will simply accumulate in the [[message queue]] for later processing when the receiver restarts. ===Routing=== Many message-oriented [[middleware]] implementations depend on a [[message queue]] system. Some implementations permit routing logic to be provided by the messaging layer itself, whilst others depend on client applications to provide routing information or allow for a mix of both paradigms. Some implementations make use of [[Broadcasting (networks)|broadcast]] or [[multicast]] distribution paradigms. ====Transformation==== In a message-based middleware system, the recipient's message need not replicate the sender's message exactly. A MOM system with built-in intelligence can [[Data transformation|transform]] messages en-route to match the requirements of the sender or of the recipient. In conjunction with the routing and broadcast/multicast facilities, one application can send a message in its own native format, and two or more other applications may each receive a copy of the message in their own native format. Many modern MOM systems provide sophisticated message transformation (or mapping) tools which allow [[software developer|programmer]]s to specify transformation rules applicable to a simple [[graphical user interface|GUI]] [[drag-and-drop]] operation. ==Disadvantages== The primary disadvantage of many message oriented middleware systems is that they require an extra component in the [[software architecture|architecture]], the message transfer agent ([[message broker]]). As with any [[system]], adding another component can lead to reductions in [[computer performance|performance]] and reliability, and can also make the system as a whole more difficult and expensive to [[software maintenance|maintain]]. In addition, many inter-application communications have an intrinsically [[Synchronization (computer science)|synchronous]] aspect, with the sender specifically wanting to wait for a reply to a message before continuing (see [[real-time computing]] and [[near real time|near-real-time]] for extreme cases). Because message-based [[data communication|communication]] inherently functions [[asynchronous]]ly, it may not fit well in such situations. That said, most MOM systems have facilities to group a request and a response as a single pseudo-synchronous transaction. ===Lack of standards=== The lack of [[standardization|standards]] governing the use of message oriented middleware has caused problems. All the major vendors have their own implementations, each with its own [[application programming interface]] (API) and management tools. The [[Java EE]] programming environment provides a standard API called [[Java Message Service|JMS]] (Java Message Service), which is implemented by most MOM vendors and aims to hide the particular MOM API implementations; however, JMS does not define the format of the messages that are exchanged, so JMS systems are not interoperable. Microsoft's [[Microsoft Message Queuing|MSMQ]] doesn't support JMS, although there are third-party 