one can then send a message to <code>Bob's car</code>, telling it to ''deliver construction materials''. This example shows one of the problems with this approach: Bob's car, which happens to be a sports car, is not able to carry and deliver construction materials (in any meaningful sense), but this is a capability that <code>Vehicle</code>s are modelled to have. A more useful model arises from the use of [[subclassing]] to create specializations of <code>Vehicle</code>; for example <code>Sports Car</code> and <code>Flatbed Truck</code>. Only objects of the class <code>Flatbed Truck</code> need provide a mechanism to ''deliver construction materials''; sports cars, which are ill suited to that sort of work, need only drive fast. However, this deeper model requires more insight, which may only come as issues arise. This issue is one of the motivating factors behind '''prototypes'''. Unless one can predict with certainty what qualities a set of objects and classes will have in the distant future, one cannot design a class hierarchy properly. All too often the program would eventually need added behaviours, and sections of the system would need to be re-designed (or [[Refactoring|refactored]]) to break out the objects in a different way.{{Fact|date=February 2007}} Experience with early OO languages like [[Smalltalk]] showed that this sort of issue came up again and again. Systems would tend to grow to a point and then become very rigid, as the basic classes deep below the programmer's code grew to be simply "wrong". Without some way to easily change the original class, serious problems could arise.{{Fact|date=February 2007}} Dynamic languages such as Smalltalk allowed for this sort of change via well-known methods in the classes; by changing the class, the objects based on it would change their behaviour. However, such changes had to be done very carefully, as other objects based on the same class might be expecting this "wrong" behavior: "wrong" is often dependent on the context. (This is one form of the [[fragile base class problem]].) Further, in languages like [[C++]], where subclasses can be compiled separately from superclasses, a change to a superclass can actually break precompiled subclass methods. (This is another form of the fragile base class problem, and also one form of the [[fragile binary interface problem]].) In Self, and other prototype-based languages, the duality between classes and object instances is eliminated. Instead of having an "instance" of an object that is based on some "class", in Self one makes a copy of an existing object, and changes it. So <tt>Bob's car</tt> would be created by making a copy of an existing "Vehicle" object, and then adding the ''drive very fast'' method, modelling the fact that it happens to be a [[Porsche 911]]. Basic objects that are used primarily to make copies are known as ''prototypes''. This technique is claimed to greatly simplify dynamism. If an existing object (or set of objects) proves to be an inadequate model, a programmer may simply create a modified object with the correct behavior, and use that instead. Code which uses the existing objects is not changed. == Description of the language == Self objects are a collection of "slots". Slots are accessor methods that return values, and placing a colon after the name of a slot sets the value. For example, for a slot called "name", myPerson name returns the value in name, and myPerson name:'foo' sets it. Self, like Smalltalk, uses ''blocks'' for flow control and other duties. Methods are objects containing code in addition to slots (which they use for arguments and temporary values), and can be placed in a Self slot just like any other object: a number for example. The syntax remains the same in either case. Note that there is no distinction in Self between fields and methods: everything is a slot. Since accessing slots via messages forms the majority of the syntax in Self, many messages are sent to "self", and the "self" can be left off (hence the name). === Basic syntax === The syntax for accessing slots is similar to that of Smalltalk. Three kinds of messages are available: ;unary : <code>''receiver'' slot_name</code> ;binary : <code>''receiver'' + ''argument''</code> ;keyword : <code>''receiver'' keyword: ''arg1'' With: ''arg2''</code> All messages return results, so the receiver (if present) and arguments can be themselves the result of other messages. Following a message by a period means Self will discard the returned value. For example: 'Hello, World!' print. This is the Self version of the [[hello world]] program. The <code>'</code> syntax indicates a literal string object. Other literals include numbers, blocks and general objects. Grouping can be forced by using parentheses. In the absence of explicit grouping, the unary messages are considered to have the highest precedence followed by binary (grouping left to right) and the keywords having the lowest. The use of keywords for assignment would lead to some extra parenthesis where expressions also had keyword messages, so to avoid that Self requires that the first part of a keyword message selector start with a lowercase letter, and subsequent parts start with an uppercase letter. valid: base bottom between: ligature bottom + height and: base top / scale factor. can be parsed unambiguously, and means the same as: valid: ((base bottom) between: ((ligature bottom) + height) and: ((base top) / (scale factor))). In Smalltalk-80, the same expression would look written as: valid := self base bottom between: self ligature bottom + self height and: self base top / self scale factor. assuming <code>base</code>, <code>ligature</code>, <code>height</code> and <code>scale</code> were not instance variables of <code>self</code> but were, in fact, methods. === Making new objects === Consider a slightly more complex example: labelWidget copy label: 'Hello, World!'. makes a copy of the "labelWidget" object with the copy message (no shortcut this time), then sends it a message to put "Hello, World" into the slot called "label". Now to do something with it: (desktop activeWindow) draw: (labelWidget copy label: 'Hello, World!'). In this case the <code>(desktop activeWindow)</code> is performed first, returning the [[active window]] from the list of windows that the desktop object knows about. 