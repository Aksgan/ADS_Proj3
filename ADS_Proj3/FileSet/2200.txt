example, written in [[ChucK]] is available [http://wiki.cs.princeton.edu/index.php/FractalMelody here] *Live coding of graphics with [http://www.pawfal.org/Software/fluxus/ fluxus]: [http://www.pawfal.org/Software/fluxus/images/ribbon.png a screenshot] * [[Impromptu (programming environment)|impromptu]] *An example of livecoding in English with [http://netjam.org/quoth/demo Quoth] ==See also== * [[Live coding]] * [[Rapid application development]] [[Category:Programming paradigms]]</text> </page> <page> <id>18836</id> <title>Interactive theorem proving</title> <text>'''Interactive theorem proving''' is the field of [[computer science]] and [[mathematical logic]] concerned with tools to develop [[formal proof]]s by man-machine collaboration. This involves some sort of '''proof assistant''': an interactive proof editor, or other [[User interface|interface]], with which a human can guide the search for proofs, the details of which are stored in, and some steps provided by, a [[computer]]. Examples include: * [[HOL theorem prover]]s - A family of tools ultimately derived from the [[LCF theorem prover]]. In these systems the logical core is a library of their programming language. Theorems represent new elements of the language and can only be introduced via "strategies" which guarantee logical correctness. Strategy composition gives users the ability to produce significant proofs with relatively few interactions with the system. Members of the family include: **[http://hol.sourceforge.net/ HOL4] - The "primary descendant". [[Moscow ML]] based. **[[HOL Light]] - A thriving "minimalist fork". [[OCaml]] based. **[[Isabelle theorem prover|Isabelle]] - With a [[BSD license]]. Based on [[Standard ML]]. **[[ProofPower]] - Went proprietary, then returned to open source. Based on [[Standard ML]]. * [[Prototype Verification System]] (PVS) - a proof language and system based on higher-order logic. * [[ACL2]] - a programming language, a first-order logical theory, and a theorem prover (with both interactive and automatic modes) in the Boyer-Moore tradition. * [[Coq]] - Which allows the expression of mathematical assertions, mechanically checks proofs of these assertions, helps to find formal proofs, and extracts a certified program from the constructive proof of its formal specification. * [[Mizar_system|Mizar]] - A proof assistant based on first-order logic, in a natural deduction style, and [[Tarski-Grothendieck set theory]]. * [[PhoX]] - A proof assistant based on higher-order logic which is eXtensible. * [[MINLOG]] - A proof assistant based on first-order minimal logic. * [[Matita]] - A light system based on the Calculus of Inductive Constructions. * [[Jape_(software)|Jape]] - Java based. == See also == * [[Automated theorem proving]] * [[Computer-assisted proof]] * [[Proof verification]] [[Category:Automated theorem proving]] [[Category:Interactive theorem proving software| ]] {{math-stub}} [[es:Demostración interactiva de teoremas]] [[fr:Assistant de preuve]] [[de:Maschinengestütztes Beweisen]]</text> </page> <page> <id>18846</id> <title>Interceptor pattern</title> <text>In the field of [[software development]], an '''interceptor pattern''' is a software [[design pattern]] that is used when software systems or [[software framework|framework]]s want to offer a way to change, or augment, their usual processing cycle. For example, a (simplified) typical processing sequence for a web-server is to receive a URI from the browser, map it to a file on disk, open the file and send its contents to the browser. Any of these steps could be replaced or changed, i.e. by replacing the way URIs are mapped to filenames, or by inserting a new step which processes the files contents. Key aspects of the pattern are that the change is ''transparent'' and used ''automatically''. In essence, the rest of the systems does not have to know something has been added or changed and can keep working as before. To facilitate this, a ''predefined interface'' for extension has to be implemented, some kind of ''dispatching'' mechanism is required where interceptors are registered (this may be dynamic, at runtime, or static, e.g. through configuration files) and ''context objects'' are provided, which allow access to the frameworks internal state.<ref name="POSA2">[http://www.cs.wustl.edu/~schmidt/POSA/POSA2/ Schmidt, Stal, Rohnert & Buschmann: "Pattern-Oriented Software Architecture Vol.2: Patterns for Concurrent and Networked Objects", pp. 109--140, April 2001]</ref> == Uses & Context == Typical users of this pattern are web-servers<ref name="tomcat">[http://tomcat.apache.org/tomcat-6.0-doc/config/cluster-interceptor.html Apache Software Foundation: Tomcat 6.0 Channel Interceptor Reference, accessed 2009-Nov-24]</ref> (as mentioned above), object-<ref name="CORBA-PI">[http://www.omg.org/spec/CORBA/3.1/ OMG, "CORBA v3.1, Part I: Interfaces", Chapter 16 "Portable Interceptors", January 2008]</ref> and message-oriented middleware<ref name="MOM">[http://www.edwardcurry.org/web_publications/curry_DEBS_04.pdf E. Curry, D. Chambers, and G. Lyons, “Extending Message-Oriented Middleware using Interception”, presented at Third International Workshop on Distributed Event-Based Systems (DEBS '04), ICSE '04, Edinburgh, Scotland, UK, 2004.]</ref> An example of implementation of this pattern is the ''javax.servlet.Filter'' interface, which is part of [[Java Platform, Enterprise Edition]]. [[Aspect-oriented programming|Aspect-Oriented Programming (AOP)]] can also be used in some situations to provide the capability of an interceptor, although AOP doesn't use the elements typically defined for the interceptor pattern. == References == {{reflist}} {{DEFAULTSORT:Interceptor Pattern}} [[Category:Software design patterns]] [[Category:Concurrent computing]] [[de:Interceptor (Entwurfsmuster)]]</text> </page> <page> <id>18855</id> <title>Interconnection</title> <text>{{Wiktionary}} {{For|Interconnection in the [[electric grid]]|wide area synchronous grid}} In [[telecommunication]]s, '''interconnection''' is the physical linking of a [[common carrier|carrier]]'s [[telecommunications network|network]] with equipment or facilities not belonging to that network. The term may refer to a connection between a carrier's facilities and the equipment belonging to its customer, or to a connection between two (or more) carriers. In [[United States]] regulatory [[law]], interconnection is specifically defined (47 [[Code of Federal Regulations|C.F.R.]] 51.5) as "the linking of two networks for the mutual exchange of traffic." One of the primary tools used by regulators to introduce competition in telecommunications markets has been to impose interconnection requirements on dominant carriers. ==History== ===US=== Under the [[Bell System]] monopoly (post [[Communications Act of 1934]]), the Bell System owned the phones and did not allow interconnection, either of separate phones (or other [[terminal equipment]]) or of other networks; a popular saying was "Ma Bell has you by the calls". This began to change in the landmark case [[Hush-A-Phone v. United States]] [1956], which allowed some non-Bell owned equipment to be connected to the network, and was followed by a number of other cases, regulatory decisions, and legislation that led to the transformation of the American [[long distance calling|long distance]] [[telephone]] industry from a [[monopoly]] to a competitive business. This further changed in [[Federal Communications Commission|FCC]]'s ''[[Carterfone]]'' decision in 1968, which required the Bell System companies to permit interconnection by radio-telephone operators. Today the standard electrical connector for interconnection in the US, and much of the world, is the [[registered jack]] family of standards, especially [[RJ11]]. 