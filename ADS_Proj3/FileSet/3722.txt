array. Different metrics can be used to calculate the similarity. As long as the similarity exceeds some predefined threshold, replace the one in the accumulator with the average of both ellipses and add 1 to its score. Otherwise, initialize this ellipse to an empty position in the accumulator and assign a score of 1. ===Termination=== Once the score of one candidate ellipse exceeds the threshold, it is determined as existing in the image (in other words, this ellipse is detected), and should be removed from the image and accumulator array so that the algorithm can detect other potential ellipses faster. The algorithm terminates when the number of iterations reaches a maximum limit or all the ellipses have been detected. Pseudo code for RHT:<ref>S. Inverso, “Ellipse Detection Using Randomized Hough Transform”, www.saminverso.com/res/vision/EllipseDetectionOld.pdf, May 20, 2002</ref> <source lang="cpp"> while (we find ellipses OR not reached the maximum epoch) { for(a fixed number of iterations) { Find a potential ellipse. if(the ellipse is similar to an ellipse in the accumulator) Replace the one in the accumulator with the average of two ellipses and add 1 to the score; else Insert the ellipse into an empty position in the accumulator with a score of 1; } Select the ellipse with the best score and save it in a best ellipse table; Elliminate the pixels of the best ellipse from the image; Empty the accumulator; } </source> ==References== <references/> [[Category:Image processing]] [[Category:Computer vision]]</text> </page> <page> <id>31267</id> <title>Range criterion</title> <text>In [[quantum mechanics]], in particular [[quantum information]], the '''Range criterion''' is a necessary condition that a state must satisfy in order to be [[separable states|separable]]. In other words, it is a ''separability criterion''. == The result == Consider a quantum mechanical system composed of ''n'' subsystems. The state space ''H'' of such a system is the tensor product of those of the subsystems, i.e. <math>H = H_1 \otimes \cdots \otimes H_n</math>. For simplicity we will assume throughout that all relevant state spaces are finite dimensional. The criterion reads as follows: If ρ is a separable mixed state acting on ''H'', then the range of ρ is spanned by a set of product vectors. === Proof === In general, if a matrix ''M'' is of the form <math>M = \sum_i v_i v_i^*</math>, it is obvious that the range of ''M'', ''Ran(M)'', is contained in the linear span of <math>\; \{ v_i \}</math>. On the other hand, we can also show <math>v_i</math> lies in ''Ran(M)'', for all ''i''. Assume without loss of generality ''i = 1''. We can write <math>M = v_1 v_1 ^* + T</math>, where ''T'' is Hermitian and positive semidefinite. There are two possibilities: 1) ''span''<math>\{ v_1 \} \subset</math>''Ker(T)''. Clearly, in this case, <math>v_1 \in</math> ''Ran(M)''. 2) Notice 1) is true if and only if ''Ker(T)''<math>\;^{\perp} \subset</math> ''span''<math>\{ v_1 \}^{\perp}</math>, where <math>\perp</math> denotes orthogonal compliment. By Hermiticity of ''T'', this is the same as ''Ran(T)''<math>\subset</math> ''span''<math>\{ v_1 \}^{\perp}</math>. So if 1) does not hold, the intersection ''Ran(T)'' <math>\cap</math> ''span''<math>\{ v_1 \}</math> is nonempty, i.e. there exists some complex number α such that <math>\; T w = \alpha v_1</math>. So :<math>M w = \langle w, v_1 \rangle v_1 + T w = ( \langle w, v_1 \rangle + \alpha ) v_1.</math> Therefore <math>v_1</math> lies in ''Ran(M)''. Thus ''Ran(M)'' coincides with the linear span of <math>\; \{ v_i \}</math>. The range criterion is a special case of this fact. A density matrix ρ acting on ''H'' is separable if and only if it can be written as :<math>\rho = \sum_i \psi_{1,i} \psi_{1,i}^* \otimes \cdots \otimes \psi_{n,i} \psi_{n,i}^*</math> where <math>\psi_{j,i} \psi_{j,i}^*</math> is a (un-normalized) pure state on the ''j''-th subsystem. This is also :<math> \rho = \sum_i ( \psi_{1,i} \otimes \cdots \otimes \psi_{n,i} ) ( \psi_{1,i} ^* \otimes \cdots \otimes \psi_{n,i} ^* ). </math> But this is exactly the same form as ''M'' from above, with the vectorial product state <math>\psi_{1,i} \otimes \cdots \otimes \psi_{n,i}</math> replacing <math>v_i</math>. It then immediately follows that the range of ρ is the linear span of these product states. This proves the criterion. == References == * P. Horodecki, "Separability Criterion and Inseparable Mixed States with Positive Partial Transposition", ''Physics Letters'' '''A 232''', (1997). [[Category:Quantum information science]]</text> </page> <page> <id>31273</id> <title>Range tree</title> <text>In [[computer science]], a '''range tree''' is an [[ordered tree data structure|ordered tree]] [[data structure]] to hold a list of points. It allows all points within a given range to be efficiently retrieved, and is typically used in two or higher dimensions. It is similar to a [[kd-tree]] except with faster query times of [[Big O notation|O]](log<sub>''d''</sub> ''n'' + ''k'') but worse storage of O(''n'' log<sub>(''d''-1)</sub> ''n''), with ''d'' being the dimension of the space, ''n'' being the number of points in the tree, and ''k'' being the number of points retrieved for a given query. Range trees may be contrasted with [[interval tree]]s: instead of storing points and allowing points in a given range to be retrieved efficiently, an interval tree stores intervals and allows the intervals containing a given point to be retrieved efficiently. == External links == * [http://www.cgal.org/ CGAL : Computational Geometry Algorithms Library in C++] contains an implementation of Range Trees == References == * [[Mark de Berg]], [[Marc van Kreveld]], [[Mark Overmars]], and [[Otfried Schwarzkopf]]. ''Computational Geometry'', Second Revised Edition. Springer-Verlag 2000. Section 5.3: Range Trees, pp.105-110. * David M. Mount. ''[http://www.cs.umd.edu/class/fall2005/cmsc754/Lects/754lects.pdf Lecture Notes: CMSC 754 Computational Geometry]''. Lecture 23: Orthogonal Range Trees, pp. 102-104. {{CS-Trees}} [[Category:Trees (structure)]] [[de:Bereichsbaum]] {{datastructure-stub}}</text> </page> <page> <id>31275</id> <title>Rank (J programming language)</title> <text>'''Rank''' in the '''[[J programming language]]''' has several different meanings. ; Noun rank : The rank of a noun is a non-negative [[integer]]. ; Verb rank : The rank of a verb is a list of three integers. ; The rank conjunction : The rank conjunction (<tt>'''"'''</tt>) is used to derive a verb with a specific rank. == Noun rank == Nouns, in J, are [[array data type|arrays]]. The rank of a noun is the number of dimensions of that array. The derived verb <tt>#@$</tt> determines the rank of 