= [[Computer science]] | peer-reviewed = | language = | abbreviation = J. ACM | publisher = [[Association for Computing Machinery|ACM]] | country = [[United States]] | frequency = 6 times a year | history = [[1954]] to present | openaccess = | license = | impact = 2.717 | impact-year = 2009 | website = http://jacm.acm.org/ | link1 = http://portal.acm.org/toc.cfm?id=J401 | link1-name = Volumes in ACM digital library | link2 = | link2-name = | RSS = | atom = | JSTOR = | OCLC = | LCCN = | CODEN = | ISSN = 0004-5411 | eISSN = | boxwidth = }} The '''''Journal of the ACM''''' ('''JACM''') is the flagship [[scientific journal]] of the [[Association for Computing Machinery]] (ACM).<ref>{{citation|first=P.|last=Raghavan|title=Editorial: Preserving excellence through change|journal=J. ACM|volume=50|issue=4|url=http://jacm.acm.org/editorials/raghavan-2003-07|pages=427–428|year=2003|doi=10.1145/792538.792539}}.</ref> It is [[Peer review|peer-reviewed]] and covers computer science in general, especially theoretical aspects. Its current editor-in-chief is [[Victor Vianu]], from [[University of California, San Diego]]. The journal has been published since 1954.<ref>[http://portal.acm.org/citation.cfm?id=320764&coll=GUIDE&dl=GUIDE,ACM&CFID=46532899&CFTOKEN=76594460 Bibliographic record] at the [[ACM Portal]]</ref> As {{harvtxt|Lowry|Romans|Curtis|2004}} write, "computer scientists universally hold the Journal of the ACM (JACM) in high esteem".<ref>{{citation|first1=Paul Benjamin|last1=Lowry|first2=Denton|last2=Romans|first3=Aaron Mosiah|last3=Curtis|title=Global Journal Prestige and Supporting Disciplines: A Scientometric Study of Information Systems Journals|journal=Journal of the Association for Information Systems (JAIS)|volume=5|issue=2|pages=29–80|year=2004}}.</ref> == See also == * [[Communications of the ACM]] ==References== {{reflist}} == External links == *[http://jacm.acm.org/ Official website] *{{ISSN|0004-5411}} *[http://www.informatik.uni-trier.de/~ley/db/journals/jacm/ DBLP Bibliography] (1954 onwards) *[http://theory.lcs.mit.edu/~jacm/ JACM Bibliography] at [[MIT]] (1954–1998) *[http://doi.acm.org/10.1145/320764.320765 First article in the JACM on the ACM] (1954) {{DEFAULTSORT:Journal Of Acm}} [[Category:Publications established in 1954]] [[Category:Computer science journals]] [[Category:ACM publications]] {{sci-journal-stub}} [[de:Journal of the ACM]] [[pt:Journal of the ACM]] [[ru:Journal of the ACM]]</text> </page> <page> <id>20230</id> <title>Joy (programming language)</title> <text>{{Original research|date=May 2009}} {{Unreferenced|date=May 2009}} {{Infobox programming language |name = Joy |logo = |paradigm = [[multi-paradigm programming language|multi-paradigm]]: [[functional programming|functional]], [[Stack-oriented programming language|stack-oriented]] |year = 2001 |designer = [[Manfred von Thun]] |developer = Manfred von Thun, John Cowan |latest release version = March 17, 2003 |latest release date = March 17, 2003 |typing = [[strong typing|strong]], [[dynamic typing|dynamic]] |implementations = Joy0, Joy1, "Current Joy", "John Cowan's Joy", "JoyJ (Joy in jvmm)" |dialects = |influenced_by = [[Scheme (programming language)|Scheme]], [[C (programming language)|C]] |influenced = [[Factor (programming language)|Factor]], [[Cat (programming language)|Cat]], [[V (programming language)|V]], [[Trith (programming language)|Trith]] }} The '''Joy programming language''' is a purely [[functional programming language]] that was produced by Manfred von Thun of [[La Trobe University]] in [[Melbourne]], [[Australia]]. Joy is based on composition of functions rather than [[lambda calculus]]. It has turned out to have many similarities to [[Forth (programming language)|Forth]], due not to design but to a sort of parallel evolution and convergence. == How it works == Joy is unusual (except for [[function-level programming]] languages and some esoteric ones, such as [[unlambda]]) in its lack of a [[lambda calculus|lambda]] operator, and therefore lack of [[Parameter (computer science)|formal parameters]]. To illustrate this with a common example, here is how the square function might be defined in an [[imperative programming language]] ([[C (programming language)|C]]): int square(int x) { return x*x; } The variable x is a formal parameter which is replaced by the actual value to be squared when the function is called. Now here's how the same function would be defined in a [[functional programming|functional]] language ([[Scheme (programming language)|Scheme]]): <source lang="scheme"> (define square (lambda (x) (* x x))) </source> This is different in many ways, but it still uses the formal parameter x in the same way. Now here is how the square function would be defined in Joy: DEFINE square == dup * . To explain: In Joy, everything is a function that takes a [[stack (data structure)|stack]] as an argument and returns a stack as a result. For instance, the numeral '5' does not represent an integer constant, but instead a short program that pushes the number 5 onto the stack. * The '''dup''' operator simply duplicates the top element of the stack by pushing a copy of it. * The '''*''' operator pops two numbers off the stack and pushes their product. So this definition of the square function says to make a copy of the top element and then multiply the two top elements, leaving the square of the original top element on top of the stack. There is no need for a formal parameter at all. This design gives Joy conciseness and power, as illustrated by this definition of [[quicksort]]: <pre> <nowiki> DEFINE qsort == [small] [] [uncons [>] split] [[swap] dip cons concat] binrec . </nowiki> </pre> "binrec" is one of Joy's many [[recursion|recursive]] [[combinator]]s, implementing binary recursion. It expects four quoted programs on top of the stack which represent: * the termination condition (if a list is "small" (1 or 0 elements) it is already sorted), * what to do if the termination condition is met (in this case nothing), * what to do by default (split the list into two halves by comparing each element with the pivot), and finally * what to do at the end (insert the pivot between the two sorted halves). == Mathematical purity == In Joy, the [[meaning function]] is a [[homomorphism]] from the [[syntax|syntactic]] [[monoid]] onto the [[semantics|semantic]] [[monoid]]. That is, the syntactic relation of [[concatenation]] of [[symbol]]s maps directly onto the semantic relation of [[Function composition|composition]] of [[function (mathematics)|functions]]. It is a [[homomorphism]] instead of an [[isomorphism]] because it is [[onto]] but not [[one-to-one]], that is, some sequences of symbols have the same meaning (e.g. "dup +" and "2 *") but no symbol has more than one meaning. Its library routines mirror those of ISO [[C (programming language)|C]], though the current implementation is not easily extensible with functions written in C. ==External links== *[http://www.latrobe.edu.au/philosophy/phimvt/joy.html Joy homepage] *[http://appforge.apc.edu.ph/projects/joyj/ JoyJ project] [[Category:Concatenative programming languages]] [[Category:Stack-oriented programming languages]] [[Category:Functional languages]] [[de:Joy (Programmiersprache)]] [[es:Lenguaje de programación Joy]] [[fr:Joy (langage)]] [[pt:Joy (linguagem de programação)]]</text> </page> <page> <id>20239</id> <title>JsMath</title> <text>{{lowercase title}} {{Infobox software| name = jsMath | developer = Davide P. Cervone and others | latest_release_version = 3.6e | latest_release_date = March 21, 2010 | operating_system = [[Cross-platform]] | programming language = [[JavaScript]] | genre 