in a two-dimensional array <code>q[i, j]</code> rather than using a function. This avoids recomputation; before computing the cost of a path, we check the array <code>q[i, j]</code> to see if the path cost is already there. We also need to know what the actual shortest path is. To do this, we use another array <code>p[i, j]</code>, a ''predecessor array''. This array implicitly stores the path to any square ''s'' by storing the previous node on the shortest path to ''s'', i.e. the predecessor. To reconstruct the path, we lookup the predecessor of ''s'', then the predecessor of that square, then the predecessor of that square, and so on, until we reach the starting square. Consider the following code: '''function''' computeShortestPathArrays() '''for''' x '''from''' 1 '''to''' n q[1, x] := c(1, x) '''for''' y '''from''' 1 '''to''' n q[y, 0] := infinity q[y, n + 1] := infinity '''for''' y '''from''' 2 '''to''' n '''for''' x '''from''' 1 '''to''' n m := min(q[y-1, x-1], q[y-1, x], q[y-1, x+1]) q[y, x] := m + c(y, x) '''if''' m = q[y-1, x-1] p[y, x] := -1 '''else if''' m = q[y-1, x] p[y, x] := 0 '''else''' p[y, x] := 1 Now the rest is a simple matter of finding the minimum and printing it. '''function''' computeShortestPath() computeShortestPathArrays() minIndex := 1 min := q[n, 1] '''for''' i '''from''' 2 '''to''' n '''if''' q[n, i] < min minIndex := i min := q[n, i] printPath(n, minIndex) '''function''' printPath(y, x) '''print'''(x) '''print'''("<-") '''if''' y = 2 '''print'''(x + p[y, x]) '''else''' printPath(y-1, x + p[y, x]) === Sequence alignment === In [[genetics]], [[sequence alignment]] is an important application where dynamic programming is essential.<ref name="Eddy"/> Typically, the problem consists of transforming one sequence into another using edit operations that replace, insert, or remove an element. Each operation has an associated cost, and the goal is to find the [[edit distance|sequence of edits with the lowest total cost]]. The problem can be stated naturally as a recursion, a sequence A is optimally edited into a sequence B by either: # inserting the first character of B, and performing an optimal alignment of A and the tail of B # deleting the first character of A, and performing the optimal alignment of the tail of A and B # replacing the first character of A with the first character of B, and performing optimal alignments of the tails of A and B. The partial alignments can be tabulated in a matrix, where cell (i,j) contains the cost of the optimal alignment of A[1..i] to B[1..j]. The cost in cell (i,j) can be calculated by adding the cost of the relevant operations to the cost of its neighboring cells, and selecting the optimum. Different variants exist, see [[Smith-Waterman]] and [[Needleman-Wunsch]]. <br clear="all"> === Tower of Hanoi Puzzle === [[Image:Tower of Hanoi.jpeg|300px|thumb|A model set of the Towers of Hanoi (with 8 disks)]] [[Image:Tower of Hanoi 4.gif|300px|thumb|An animated solution of the '''Tower of Hanoi''' puzzle for ''T(4,3)''.]] The '''[[Tower of Hanoi]]''' or '''Towers of [[Hanoi]]''' is a [[mathematical game]] or [[puzzle]]. It consists of three rods, and a number of disks of different sizes which can slide onto any rod. The puzzle starts with the disks in a neat stack in ascending order of size on one rod, the smallest at the top, thus making a conical shape. The objective of the puzzle is to move the entire stack to another rod, obeying the following rules: * Only one disk may be moved at a time. * Each move consists of taking the upper disk from one of the rods and sliding it onto another rod, on top of the other disks that may already be present on that rod. * No disk may be placed on top of a smaller disk. The dynamic programming solution consists of solving the [[Bellman equation|functional equation]] : S(n,h,t) = S(n-1,h, not(h,t)) ; S(1,h,t) ; S(n-1,not(h,t),t) where n denotes the number of disks to be moved, h denotes the home rod, t denotes the target rod, not(h,t) denotes the third rod (neither h nor t), ";" denotes concatenation, and : S(n, h, t) := solution to a problem consisting of n disks that are to be moved from rod h to rod t. Note that for n=1 the problem is trivial, namely S(1,h,t) = "move a disk from rod h to rod t". The number of moves required by this solution is 2<sup>n</sup> -1. If the objective is to '''maximize''' the number of moves (without cycling) then the dynamic programming [[Bellman equation|functional equation]] is slightly more complicated and 3<sup>n</sup> -1 moves are required.<ref>{{cite journal |author=Moshe Sniedovich |title= "OR/MS Games: 2. The Towers of Hanoi Problem, |journal=INFORMS Transactions on Education |volume=3(1) |year=2002 |pages=34â€“51 |url=http://archive.ite.journal.informs.org/Vol3No1/Sniedovich/}}</ref> <br clear="all"> === Egg dropping puzzle === [[Image:Broken egg orange.jpg|300px|thumb|A broken egg, dropped from the H-th floor... ]] The following is a description of the instance of this famous [[puzzle]] involving n=2 eggs and a building with H=36 floors:<ref>Konhauser J.D.E., Velleman, D., and Wagon, S. (1996). [http://www.cambridge.org/uk/catalogue/catalogue.asp?isbn=9780883853252 Which way did the Bicycle Go?] Dolciani Mathematical Expositions -- No-18. [[The Mathematical Association of America]].</ref> :Suppose that we wish to know which windows in a 36-story building are safe to drop eggs from, and which will cause the eggs to break on landing. We make a few assumptions: :* An egg that survives a fall can be used again. :* A broken egg must be discarded. :* The effect of a fall is the same for all eggs. :* If an egg breaks when dropped, then it would break if dropped from a higher window. :* If an egg survives a fall then it would survive a shorter fall. :* It is not ruled out that the first-floor windows break eggs, nor is it ruled out that the 36th-floor windows do not cause an egg to break. : If only one egg is available and we wish to be sure of obtaining the right result, the experiment can be carried out in only one 