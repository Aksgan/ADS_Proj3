a series of standard types that exploit the extended ranges, including linteger for double range integers, cardinal for unsigned integers, and lcardinal for unsigned double range integers. Pascaline also defines new limits for these types, as maxlint, maxcrd, and maxlcrd. * Semaphores '''monitor''' test;<br/> '''var''' notempty, notfull: semaphore; '''procedure''' enterqueue; '''begin''' '''while''' nodata '''do''' wait(notempty); ... signalone(notfull) '''end'''; ... '''begin''' '''end'''. Semaphores implement task event queuing directly in the language, using the classical methods outlined by [[Per Brinch Hansen]]. * Overrides '''module''' test1; '''virtual''' '''procedure''' x; '''begin''' ... '''end'''; '''program''' test; '''joins''' test1; '''override''' '''procedure''' x; '''begin''' '''inherited''' x '''end'''; '''begin''' '''end'''. Overriding a procedure or function in another module effectively "hooks" that routine, replacing the definition for all callers of it, but makes the original definition available to the hooking module. This allows the overriding module to add new functionality to the old procedure or function. This can be implemented to any depth. * Overloads '''procedure''' x; '''begin''' '''end'''; '''overload''' '''procedure''' x(i: integer); '''begin''' '''end'''; '''overload''' '''function''' x: integer; '''begin''' x := 1 '''end'''; Overload "groups" allow a series of procedures and/or functions to be placed under the same name and accessed by their formal parameter or usage "signature". Unlike other languages that implement the concept, Pascaline will not accept overloads as belonging to the same group unless they are not ambiguous with each other. This means that there is no "priority" of overloads, nor any question as to which routine of an overload group will be executed for any given actual reference. * Objects '''program''' test; '''uses''' baseclass; '''class''' alpha; '''extends''' beta; '''type''' alpha_ref = '''reference''' '''to''' alpha; '''var''' a, b: integer; next: alpha_ref; '''virtual''' '''procedure''' x(d: integer); '''begin''' a := d; self := next '''end'''; '''private''' '''var''' q: integer; '''begin''' '''end'''. '''var''' r: alpha_ref; '''begin''' new(r); ... '''if''' r '''is''' alpha '''then''' r.a := 1; r.x(5); ... '''end'''. In Pascaline, classes are a dynamic instance of a module (and modules are a static instance of a class). Classes are a code construct (not a type) that exists between modules and procedures and functions. Because a class is a module, it can define any code construct, such as constants, types, variables, fixed, procedures and functions (which become "methods"), and make them public to clients of the class, or hide them with the "private" keyword. Since a class is a module, it can be accessed via a qualified identifier. Classes as modules have automatic access to their namespace as found in C# and C++ in that they do not require any qualification. Outside of the class, all members of the class can be accessed either by qualified identifier or by a reference. A reference is a pointer to the object that is created according to the class. Any number of instances of a class, known as "objects" can be created with the new() statement, and removed with the dispose() statement. Class members that have instance data associated with them, such as variables (or fields) and methods must be accessed via a reference. A reference is a type, and resembles a pointer, including the ability to have the value nil, and checking for equality with other reference types. It is not required to qualify the pointer access with "^". Pascaline implements the concept of "reference grace" to allow a reference to access any part of the object regardless of whether or not it is per-instance. This characteristic allows class members to be "promoted", that is moved from constants to variables, and then to "properties" (which are class fields whose read and write access are provided by "get" and "set" methods). Both overloads and overrides are provided for and object's methods. A method that will be overridden must be indicated as virtual. Object methods can change the reference used to access them with the "self" keyword. Single inheritance only is implemented. * Structured exception handling '''try''' ... '''except''' ... '''else''' ...; throw The "try" statement can guard a series of statements, and any exceptions flagged within the code are routined to the statement after "except". The try statement also features an else clause that allows a statement to be executed on normal termination of the try block. Exceptions are raised in the code via the throw() procedure. Try statements allow the program to bail out of any nested block, and serve as a better replacement for intra-procedure gotos (which are still supported under Pascaline). Since unhandled exceptions generate errors by default, the throw() procedure can serve as a general purpose error flagging system. * Asserts. assert(expression); The system procedure assert causes the program to terminate if the value tested is false. It is typically coupled to a runtime dump or diagnostic, and can be removed by compiler option. * Unicode. IP Pascal can generate either [[ISO 8859-1]] mode programs (8 bit characters) or [[Unicode]] mode programs by a simple switch at compile time (unlike many other languages, there is no source difference between Unicode and non-Unicode programs). The ASCII upward compatible [[UTF-8]] format is used in text files, and these files are read to and from 8 or 16 bit characters internal to the program (the upper 128 characters of ISO 8859-1 are converted to and from UTF-8 format in text files even in an 8 bit character encoded program). * Constant for character high limit. Similar to maxint, Pascaline has a maxchr, which is the maximum character that exists in the character set (and may not in fact have a graphical representation). The range of the type char is then defined as 0..maxchr. This is an important addition for dealing with types like "set of char", and aids when dealing with different character set options (such as ISO 8859-1 or Unicode). == Modular structure == IP Pascal uses a unique stacking concept for modules. Each module is stacked one atop the other in memory, and executed at the bottom. The bottom module calls the next module up, and that module calls the next module, and so on. wrapper serlib program 