''Global CO'' (using the condition in the theorem above). Then a ''voting-deadlock'' occurs [[if and only if]] a ''global cycle'' (spans two or more databases) exists in the ''Global augmented conflict graph'' (also blocking by a data-access lock is represented by an edge). If the cycle does not break by any abort, then all the ''global transactions'' on it are involved with the respective voting-deadlock, and eventually each has its vote blocked (either directly, or indirectly by a data-access lock); if a local transaction resides on the cycle, eventually it has its (local) commit blocked. :'''Comment:''' A rare situation of a voting deadlock (by missing blocked votes) can happen, with no voting for any transaction on the related cycle by any of the database systems involved with these transactions. This can occur when local sub-transactions are [[Thread (computer science)|multi-threaded]]. The highest probability instance of such rare event involves two transactions on two simultaneous opposite cycles. Such global cycles (deadlocks) overlap with local cycles which are resolved locally, and thus typically resolved by local mechanisms without involving atomic commitment. Formally it is also a global cycle, but practically it is local (portions of local cycles generate a global one; to see this, split each global transaction (node) to local sub-transactions (its portions confined each to a single database); a directed edge exists between transactions if an edge exists between any respective local sub-transactions; a cycle is local if all its edges originate from a cycle among sub-transactions of the same database, and global if not; global and local can overlap: a same cycle among transactions can result from several different cycles among sub-transactions, and be both local and global). Also the following locking based special case is concluded: *'''The CO Locking-based Global-Deadlock Theorem''' :In a CO compliant multidatabase system a locking-based global-deadlock, involving at least one data-access lock (non-materialized conflict), and two or more database systems, is a reflection of a global cycle in the ''Global augmented conflict graph'', which results in a voting-deadlock. Such cycle is not a cycle in the (regular) ''Global conflict graph'' (which reflects only materialized conflicts, and thus such cycle does not affect ''[[serializability]]''). :'''Comments:''' # Any blocking (edge) in the cycle that is not by a data-access lock is a direct blocking of either voting or local commit. All voting-deadlocks are resolved (almost all by ''Atomic commitment''; see comment above), including this locking-based type. # Locking-based global-deadlocks can be generated also in a completely-SS2PL based distributed environment (special case of CO based), where all the vote blocking (and voting-deadlocks) are caused by data-access locks. Many research articles have dealt for years with resolving such global deadlocks, but none (except the CO articles) is known (as of 2009) to notice that ''atomic commitment'' automatically resolves them. Such automatic resolutions are regularly occurring unnoticed in all existing SS2PL based multidatabase systems, often bypassing dedicated resolution mechanisms. Voting-deadlocks are the key for the operation of distributed CO. See [[Commitment ordering#Examples|Examples]] below. Global cycle elimination (here voting-deadlock resolution by ''atomic commitment'') and resulting aborted transactions' re-executions are time consuming, regardless of concurrency control used. If databases schedule transactions independently, global cycles are unavoidable (in a complete analogy to cycles/deadlocks generated in local SS2PL; with distribution, any transaction or operation scheduling coordination results in autonomy violation, and typically also in substantial performance penalty). However, in many cases their likelihood can be made very low by implementing database and transaction design guidelines that reduce the number of conflicts involving a global transaction. This, primarily by properly handling ''[[hot spot]]s'', and avoiding conflicts by [[Serializability#View and conflict serializability|using commutativity]] when possible (e.g., when extensively using counters, as in finances, and especially multi-transaction ''accumulation counters'', which are typically hot spots). Atomic commitment protocols are intended and designed to achieve [[atomicity]] without considering database concurrency control. They abort upon detecting or [[Heuristic algorithm|heuristically]] finding (e.g., by [[timeout (telecommunication)|timeout]]; sometimes mistakenly, unnecessarily) missing votes, and typically unaware of global cycles. These protocols can be specially enhanced for CO (including CO's variants below) both to prevent unnecessary aborts, and to accelerate aborts used for breaking global cycles in the global augmented conflict graph (for better performance by earlier release upon transaction-end of computing resources and typically locked data). For example, existing locking based global deadlock detection methods, other than timeout, can be generalized to consider also local commit and vote direct blocking, besides data access blocking. A possible compromise in such mechanisms is effectively detecting and breaking the most frequent and relatively simple to handle length-2 global cycles, and using timeout for undetected, much less frequent, longer cycles. ===Enforcing CO locally=== ''Commitment ordering'' can be enforced locally (in a single database) by a dedicated CO algorithm, or by any algorithm/protocol that provides any special case of CO. An important such protocol, being utilized extensively in database systems, which generates a CO schedule, is the ''strong [[Schedule (computer science)#Strict|strict]] [[two phase locking]]'' protocol (SS2PL: "release transaction's locks only after the transaction has been either committed or aborted"; see below). SS2PL is a [[proper subset]] of the intersection of [[2PL]] and [[Schedule (computer science)#Strict|strictness]]. ====A generic local CO algorithm==== A '''generic local CO algorithm''' is an algorithm independent of implementation details, that enforces exactly the CO property. It does not block data access (nonblocking), and consists of aborting transactions (only if needed) before committing a transaction. It aborts a (uniquely determined at any given time) minimal set of other undecided (neither committed, nor aborted) transactions that run locally and can cause serializability violation in the future (can later generate cycles of committed transactions in the conflict graph). This set consists of all undecided transactions with directed edges in the conflict graph to the transaction to be committed. The size of this set cannot increase when that transaction is waiting to be committed (in ready state: processing has ended), and typically decreases in time as its transactions are being decided. Thus, unless [[Real-time computing|real-time]] constraints exist to complete that transaction, it is preferred to wait with committing that transaction 