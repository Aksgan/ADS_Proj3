use of a [[mouse (computing)|mouse]] or other [[pointing device]]. Many console applications such as [[command line interpreter]]s are [[command line interface|command line]] tools, but numerous [[Text user interface|Text User Interface]] (TUI) programs also exist. As the speed and ease-of-use of GUI applications have improved over time, the use of console applications has greatly diminished, but not disappeared. Some users simply prefer console based applications, while some organizations still rely on existing console applications to handle key data processing tasks. ==Console based applications== The following list contains a small selection of console based applications: *[[Lynx (web browser)|Lynx]] — [[web browser]] *[[Irssi]] — [[IRC client]] *[[Alpine (e-mail client)|Alpine]] — [[e-mail client]] *[[Mutt (e-mail client)|Mutt]] — [[e-mail client]] *[[Midnight Commander]] — [[file manager]] *[[Nano (text editor)|nano]] — [[text editor]] *[[Music on Console]] — [[audio player]] *[[cmus]] — [[audio player]] ==See also== *[[Text-based (computing)]] *[[Box drawing characters]] *[[Shell (computing)]] {{DEFAULTSORT:Console Application}} [[Category:Terminal emulators]] [[Category:User interface]] [[Category:Windows software]] [[Category:Mac OS X software]] [[Category:Unix software]] [[Category:Console application| ]] {{Software-type-stub}} [[de:Konsolenanwendung]] [[ja:コンソールアプリケーション]]</text> </page> <page> <id>7830</id> <title>Consolidation ratio</title> <text>{{Wikify|date=April 2010}} {{Orphan|date=June 2008}} '''Consolidation ratio''' is the number of [[virtual server]]s you place on each of your physical hosts. Many companies arrive at that figure through trial and painful error by simply stacking virtual machines on top of each other until performance slows to a crawl. “It’s sort of capacity planning by bloody nose,” observes Bob aaaaaGill, managing director of server research for analyst firm TheInfoPro Inc. of New York,<ref>N.Y.http://www.accelerateresults.com/category/1/article/109-mastering-basic-virtualization-challenges-part-two-planning</ref> ==References== {{Reflist}} http://www.accelerateresults.com/category/1/article/109-mastering-basic-virtualization-challenges-part-two-planning {{DEFAULTSORT:Consolidation Ratio}} [[Category:Neologisms]] [[Category:Computer networking]]</text> </page> <page> <id>7840</id> <title>Constant interface</title> <text>In the [[Java programming language]], the constant interface [[Design pattern (computer science)|pattern]] describes the use of an [[interface (Java)|interface]] solely to define constants, and having [[Class (computer science)|classes]] implement that interface in order to achieve convenient syntactic access to those constants. However, since the usage of constants is an implementation detail, it is considered inappropriate to define an interface for this purpose.<ref>Bloch, Joshua, Effective Java, 2nd Edition, p. 98</ref><ref name="Sun">Sun Microsystems, Inc. (2004). [http://java.sun.com/j2se/1.5.0/docs/guide/language/static-import.html "Static Import"].</ref> In general, collecting system constants into classes independent of behaviour, might create a poor [[object-oriented]] design, because it is often a sign of low [[Cohesion (computer science)|cohesion]]. It is for these reasons that implementing constants interfaces is considered to be an [[anti-pattern]]. Use of this anti-pattern has a few other downsides: # It pollutes the class [[Namespace (computer science)|namespace]] with read-only variables that may not be of use. # Contrary to the [[compile-time]] tactical utility of implementing a constants interface, the incidental [[run-time]] artifacts have little practical purpose (cf. [[Marker interface pattern|marker interfaces]] which also have no methods but '''are''' useful at run-time). # If [[binary code compatibility]] is required in future releases, the constants interface must remain forever an interface (it cannot be converted into a class), even though it has not been used as an interface in the conventional sense. # Without an IDE that resolves where the constant are coming from, tracking it back to its containing class or interface can be time consuming. # A variable (representing an instance) of the interface is syntactically no more useful than the interface name itself (since it has no methods). ==Example== <source lang="java"> public interface Constants { public static final double PI = 3.14159; public static final double PLANCK_CONSTANT = 6.62606896e-34; } public class Calculations implements Constants { public double getReducedPlanckConstant() { return PLANCK_CONSTANT / (2 * PI); } } </source> ==Alternatives== Many of the pitfalls of the anti-pattern can be avoided by converting the constants interface to a proper class with no instances: <source lang="java"> public final class Constants { private Constants() { // restrict instantiation } public static final double PI = 3.14159; public static final double PLANCK_CONSTANT = 6.62606896e-34; } </source> This still leaves the original intent of the pattern mostly un-addressed (i.e. there is no syntax for accessing the constants unqualified). However, since [[Java 5]], consider using ''[[static import]]''<ref name="Sun"/> to achieve the same goal: <source lang="java"> import static Constants.PLANCK_CONSTANT; import static Constants.PI; public class Calculations { public double getReducedPlanckConstant() { return PLANCK_CONSTANT / (2 * PI); } } </source> To varying degrees, the issues listed above have now been addressed: # Because static members can be imported specifically, the class namespace need not be polluted with all members of the constants interface. # Run-time and compile-time semantics are more closely aligned when using static imports instead of constants interfaces. # The compiled code has one less binary compatibility constraint (that "class Calculations implements Constants"). # Because static imports apply only to the current file (and not the whole class hierarchy) it is easier to discover where each static member is declared. # There is less need to declare variables of the constants interface type, and it is potentially clearer that no concrete instances actually exist. Note however, the changes do nothing to improve the [[Cohesion (computer science)|cohesion]] of the Constants class, so static imports should not be considered to be a panacea. ==References== {{Reflist}} [[Category:Java programming language]] [[Category:Anti-patterns]]</text> </page> <page> <id>7845</id> <title>Constrained Delaunay triangulation</title> <text>In [[computational geometry]], a '''constrained Delaunay triangulation''' is a generalization of the [[Delaunay triangulation]] that forces certain required segments into the triangulation<ref>{{cite conference | first1=L. Paul| last1=Chew| title=Constrained Delaunay Triangulations | booktitle=Proceedings of the Third Annual Symposium on Computational Geometry | year=1987}}</ref>. == References == {{Reflist}} [[Category:Discrete geometry]] [[Category:Geometric algorithms]] [[Category:Triangles]] [[Category:Geometric graphs]] {{comp-sci-theory-stub}}</text> </page> <page> <id>7850</id> <title>Constraint (mathematics)</title> <text>In [[mathematics]], a '''constraint''' is a condition that a solution to an [[optimization (mathematics)|optimization]] problem must satisfy. There are two types of constraints: '''equality constraints''' and '''inequality constraints'''. The set of solutions that satisfy all constraints is called the [[candidate solution|feasible set]]. ==Example== The following is a simple optimization problem: :<math>\min f(\bold x) = x_1^2+x_2^4 </math> subject to :<math> x_1 \ge 1 </math> and :<math> x_2 = 1, \, </math> where <math>\bold x</math> denotes the [[Vectorization (mathematics)|vector]] (''x''<sub>1</sub>, ''x''<sub>2</sub>). In this example, the first line defines the function to be minimized (called the ''objective'' or ''cost function''). The second and third lines define two constraints, the first of which is an 