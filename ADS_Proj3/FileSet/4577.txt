concurrency control protocol of choice for most [[database system]]s and utilized since their early days in the 1970s. It is proven to be an effective mechanism in many situations, and provides besides [[Serializability]] also [[Schedule (computer science)#Strict|Strictness]] (a special case of cascadeless Recoverability), which is instrumental for efficient [[database]] [[data recovery|recovery]], and also [[Commitment ordering]] (CO) for participating in distributed environments where a CO based [[Serializability#Distributed serializability|distributed serializability]] and [[global serializability]] solutions are employed. Being a subset of CO, an efficient implementation of ''[[Commitment ordering#Distributed serializability and CO|distributed SS2PL]]'' exists without a [[distributed lock manager]] (DLM), while distributed deadlocks (see below) are resolved automatically. The fact that SS2PL employed in multi database systems ensures global serializability has been known for years before the discovery of CO, but only with CO came the understanding of the role of an [[atomic commitment]] protocol in maintaining global serializability, as well as the observation of automatic distributed deadlock resolution. As a matter of fact, SS2PL inheriting properties of Recoverability and CO is more significant than being a subset of 2PL, which by itself in its general form, besides comprising a simple serializability mechanism (however serializability is also implied by CO), in not known to provide SS2PL with any other significant qualities. 2PL in its general form, as well as when combined with Strictness, i.e., Strict 2PL (S2PL), are not known to be utilized in practice. The popular SS2PL does not require to mark "end of phase-1" as 2PL and S2PL do, and thus is simpler to implement. Also unlike the general 2PL, SS2PL provides, as mentioned above, the useful [[Schedule (computer science)#Strict|Strictness]] and [[Commitment ordering]] properties. Many variants of SS2PL exist that utilize various lock types with various semantics in different situations, including cases of lock-type change during a transaction. Notable are variants that use [[Multiple granularity locking]]. '''Comments:''' #SS2PL Vs. S2PL: Both provide Serializability and Strictness. Since S2PL is a super class of SS2PL it may, in principle, provide more concurrency. However no concurrency advantage is typically practically noticed (exactly same locking exists for both, with practically not much earlier lock release for S2PL), and the overhead of dealing with an end-of-phase-1 mechanism in S2PL, separate from transaction-end, is not justified. Also, while SS2PL provides [[Commitment ordering]], S2PL does not. This explains the preference of SS2PL over S2PL. # Especially before 1990, but also after, in many articles and books, e.g., ([[#Bern1987|Bernstein et al. 1987]], p. 59), the term "Strict 2PL" (S2PL) has been frequently defined by the locking protocol "Release all locks only after transaction end," which is the protocol of SS2PL. Thus, "Strict 2PL" could not be there the name of the intersection of Strictness and 2PL, which is larger than the class generated by the SS2PL protocol. This has caused confusion. With an explicit definition of S2PL as the intersection of Strictness and 2PL, a new name for SS2PL, and an explicit distinction between the classes S2PL and SS2PL, the articles ([[#Breit1991|Breitbart et al. 1991]]) and ([[#Raz1992|Raz 1992]]) have intended to clear the confusion: The first using the name "Rigorousness," and the second "SS2PL." # A more general property than SS2PL exists (a schedule super-class), [[Commitment ordering#Strict CO (SCO)|'''Strict commitment ordering''']] (Strict CO, or SCO), which as well provides both serializability, strictness, and CO, and has similar locking overhead. Unlike SS2PL, SCO does not block upon a read-write conflict (a read-lock does not block acquiring a write-lock; both SCO and SS2PL have the same behavior for write-read and write-write conflicts) at the cost of a possible delayed commit, and upon such conflict type SCO has shorter average transaction completion time and better performance than SS2PL. While SS2PL obeys the ''lock compatibility table'' above, SCO has the following table: ::{| class="wikitable" style="text-align:center;" |+Lock compatibility for SCO |- ! Lock type !! read-lock !! write-lock |- ! read-lock | || |- ! write-lock | '''X''' || '''X''' |} ::Note that though SCO releases all locks at transaction end and complies with the 2PL locking rules, SCO is not a subset of 2PL because of its different lock compatibility table. SCO allows materialized read-write conflicts between two transactions in their phases 1, which 2PL does not allow in phase-1 (see about materialized conflicts in [[Serializability]]). On the other hand 2PL allows other materialized conflict types in phase-2 that SCO does not allow at all. Together this implies that the schedule classes 2PL and SCO are incomparable (i.e., no class contains the other class). ===Summary - Relationships among classes=== [[Image:CO-ScheduleClasses.jpg|thumb|350px| '''Schedule classes containment:''' An arrow from class A to class B indicates that class A strictly contains B; a lack of a directed path between classes means that the classes are incomparable. A property is '''inherently-blocking''', if it can be enforced only by blocking transactionâ€™s data access operations until certain events occur in other transactions. ([[#Raz1992|Raz 1992]])]] Between any two schedule classes (define by their schedules' respective properties) that have common schedules, either one ''contains'' the other (''strictly contains'' if they are not equal), or they are ''incomparable''. The containment relationships among the 2PL classes and other major schedule classes are summarized in the following diagram. 2PL and its subclasses are ''inherently blocking'', which means that no optimistic implementations for them exist. ==Deadlocks in 2PL== Locks block data-access operations. Mutual blocking between transactions results in a ''[[deadlock]]'', where execution of these transactions is stalled, and no completion can be reached. Thus deadlocks need to be resolved to complete these transactions' executions and release related computing resources. A deadlock is a reflection of a potential cycle in the ''[[Serializability#Testing conflict serializability|precedence graph]]'', that would occur without the blocking. A deadlock is resolved by aborting a transaction involved with such potential cycle, and breaking the cycle. It is often detected using a ''[[wait-for graph]]'' (a graph of conflicts blocked by locks from being materialized; conflicts not materialized in the database due to blocked operations are not reflected in the precedence graph and do not affect ''[[serializability]]''), which indicates which transaction is "waiting for" lock release by 