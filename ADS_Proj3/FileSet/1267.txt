going through every column, subtracting one from the appropriate element of the pair for that column, depending on whether the assignment for the top row contained a zero or a one at that position. If any one of the results is negative, then the assignment is invalid and does not contribute to the set of solutions (recursion stops). Otherwise, we have an assignment for the top row of the {{math|<var>k</var> &times; <var>n</var>}} board and recursively compute the number of solutions to the remaining {{math|(<var>k</var> - 1) &times; <var>n</var>}} board, adding the numbers of solutions for every admissible assignment of the top row and returning the sum, which is being memoized. The base case is the trivial subproblem, which occurs for a {{math|1 &times; <var>n</var>}} board. The number of solutions for this board is either zero or one, depending on whether the vector is a permutation of {{math|<var>n</var> / 2}} <math>(0, 1)</math> and {{math|<var>n</var> / 2}} <math>(1, 0)</math> pairs or not. For example, in the two boards shown above the sequences of vectors would be <PRE WIDTH=80> ((2, 2) (2, 2) (2, 2) (2, 2)) ((2, 2) (2, 2) (2, 2) (2, 2)) k = 4 0 1 0 1 0 0 1 1 ((1, 2) (2, 1) (1, 2) (2, 1)) ((1, 2) (1, 2) (2, 1) (2, 1)) k = 3 1 0 1 0 0 0 1 1 ((1, 1) (1, 1) (1, 1) (1, 1)) ((0, 2) (0, 2) (2, 0) (2, 0)) k = 2 0 1 0 1 1 1 0 0 ((0, 1) (1, 0) (0, 1) (1, 0)) ((0, 1) (0, 1) (1, 0) (1, 0)) k = 1 1 0 1 0 1 1 0 0 ((0, 0) (0, 0) (0, 0) (0, 0)) ((0, 0) (0, 0), (0, 0) (0, 0)) </PRE> The number of solutions {{OEIS|id=A058527}} is :<math> 1,\, 2,\, 90,\, 297200,\, 116963796250,\, 6736218287430460752, \ldots </math> Links to the Perl source of the backtracking approach, as well as a MAPLE and a C implementation of the dynamic programming approach may be found among the [[Dynamic programming#External links|external links]]. === Checkerboard === Consider a [[checkerboard]] with ''n'' × ''n'' squares and a cost-function ''c''(''i'', ''j'') which returns a cost associated with square ''i'',''j'' (''i'' being the row, ''j'' being the column). For instance (on a 5 × 5 checkerboard), {| class="wikitable" style="text-align:center" |- ! 5 | 6 || 7 || 4 || 7 || 8 |- ! 4 | 7 || 6 || 1 || 1 || 4 |- ! 3 | 3 || 5 || 7 || 8 || 2 |- ! 2 | - || 6 || 7 || 0 || - |- ! 1 | - || - || *5* || - || - |- !width="15"| !! style="width:15px;"|1 !! style="width:15px;"|2 !! style="width:15px;"|3 !! style="width:15px;"|4 !! style="width:15px;"|5 |} Thus ''c''(1, 3) = 5 Let us say you had a checker that could start at any square on the first rank (i.e., row) and you wanted to know the shortest path (sum of the costs of the visited squares are at a minimum) to get to the last rank, assuming the checker could move only diagonally left forward, diagonally right forward, or straight forward. That is, a checker on (1,3) can move to (2,2), (2,3) or (2,4). {| class="wikitable" style="text-align:center" |- ! 5 | || || || || |- ! 4 | || || || || |- ! 3 | || || || || |- ! 2 | || x || x || x || |- ! 1 | || || o || || |- !width="15"| !! style="width:15px;"|1 !! style="width:15px;"|2 !! style="width:15px;"|3 !! style="width:15px;"|4 !! style="width:15px;"|5 |} This problem exhibits '''optimal substructure'''. That is, the solution to the entire problem relies on solutions to subproblems. Let us define a function ''q''(''i'', ''j'') as :''q''(''i'', ''j'') = the minimum cost to reach square (''i'', ''j'') If we can find the values of this function for all the squares at rank ''n'', we pick the minimum and follow that path backwards to get the shortest path. Note that ''q''(''i'', ''j'') is equal to the minimum cost to get to any of the three squares below it (since those are the only squares that can reach it) plus ''c''(''i'', ''j''). For instance: {| class="wikitable" style="text-align:center" |- ! 5 | || || || || |- ! 4 | || || A || || |- ! 3 | || B || C || D || |- ! 2 | || || || || |- ! 1 | || || || || |- !width="15"| !! style="width:15px;"|1 !! style="width:15px;"|2 !! style="width:15px;"|3 !! style="width:15px;"|4 !! style="width:15px;"|5 |} <math>q(A) = min(q(B),q(C),q(D))+c(A)</math> Now, let us define ''q''(''i'', ''j'') in somewhat more general terms: <math>q(i,j)=\begin{cases} \infty & j < 1 \mbox{ or }j > n \\ c(i, j) & i = n \\ \min(q(i-1, j-1), q(i-1, j), q(i-1, j+1)) + c(i,j) & \mbox{otherwise.}\end{cases}</math> The first line of this equation is there to make the recursive property simpler (when dealing with the edges, so we need only one recursion). The second line says what happens in the last rank, to provide a base case. The third line, the recursion, is the important part. It is similar to the A,B,C,D example. From this definition we can make a straightforward recursive code for ''q''(''i'', ''j''). In the following pseudocode, ''n'' is the size of the board, <code>c(i, j)</code> is the cost-function, and <code>min()</code> returns the minimum of a number of values: '''function''' minCost(i, j) '''if''' j < 1 '''or''' j > n '''return''' infinity '''else if''' i = n '''return''' c(i, j) '''else''' '''return''' '''min'''( minCost(i+1, j-1), minCost(i+1, j), minCost(i+1, j+1) ) + c(i, j) It should be noted that this function only computes the path-cost, not the actual path. We will get to the path soon. This, like the Fibonacci-numbers example, is horribly slow since it spends mountains of time recomputing the same shortest paths over and over. However, we can compute it much faster in a bottom-up fashion if we store path-costs 