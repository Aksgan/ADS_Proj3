call stack unwinds (assuming a recursive implementation of the search), it's easy to check the validity of the tree and perform any rotations as necessary. If a horizontal left link arises, a skew will be performed, and if two horizontal right links arise, a split will be performed, possibly incrementing the level of the new root node of the current subtree. Note, in the code as given above, the increment of level(T). This makes it necessary to continue checking the validity of the tree as the modifications bubble up from the leaves. '''function''' insert '''is''' '''input:''' X, the value to be inserted, and T, the root of the tree to insert it into. '''output:''' A balanced version T including X. ''Do the normal binary tree insertion procedure. Set the result of the'' ''recursive call to the correct child in case a new node was created or the'' ''root of the subtree changes.'' '''if''' nil(T) '''then''' ''Create a new leaf node with X.'' '''return''' node(X, 1, Nil, Nil) '''else if''' X < value(T) '''then''' left(T) := insert(X, left(T)) '''else if''' X > value(T) '''then''' right(T) := insert(X, right(T)) '''end if''' ''Note that the case of X == value(T) is unspecified. As given, an insert will have no effect. The implementor may desire different behavior.'' ''Perform skew and then split. The conditionals that determine whether or not a rotation will occur or not are inside of the procedures, as given above.'' T := skew(T) T := split(T) '''return T''' '''end function''' == Deletion == As in most balanced binary trees, the deletion of an internal node can be turned into the deletion of a leaf node by swapping the internal node with either its closest predecessor or successor, depending on which are in the tree or on the implementor's whims. Retrieving a predecessor is simply a matter of following one left link and then all of the remaining right links. Similarly, the successor can be found by going right once and left until a null pointer is found. Because of the AA property of all nodes of level greater than one having two children, the successor or predecessor node will be in level 1, making their removal trivial. To re-balance a tree, there are a few approaches. The one described by Andersson in his [http://user.it.uu.se/~arnea/abs/simp.html original paper] is the simplest, and it is described here, although actual implementations may opt for a more optimized approach. After a removal, the first step to maintaining tree validity is to lower the level of any nodes whose children are two levels below them, or who are missing children. Then, the entire level must be skewed and split. This approach was favored, because when laid down conceptually, it has three easily understood separate steps: # Decrease the level, if appropriate. # Skew the level. # Split the level. However, we have to skew and split the entire level this time instead of just a node, complicating our code. '''function''' delete '''is''' '''input:''' X, the value to delete, and T, the root of the tree from which it should be deleted. '''output:''' T, balanced, without the value X. '''if''' X > value(T) '''then''' right(T) := delete(X, right(T)) '''else if''' X < value(T) '''then''' left(T) := delete(X, left(T)) '''else''' ''If we're a leaf, easy, otherwise reduce to leaf case.'' '''if''' leaf(T) '''then''' return Nil '''else if''' nil(left(T)) '''then''' L := successor(T) right(T) := delete(L, right(T)) value(T) := L '''else''' L := predecessor(T) left(T) := delete(L, left(T)) value(T) := L '''end if''' '''end if''' ''Rebalance the tree. Decrease the level of all nodes in this level if necessary, and then skew and split all nodes in the new level.'' T := decrease_level(T) T := skew(T) right(T) := skew(right(T)) right(right(T)) := skew(right(right(T))) T := split(T) right(T) := split(right(T)) return T '''end function''' '''function''' decrease_level '''is''' '''input:''' T, a tree for which we want to remove links that skip levels. '''output:''' T with its level decreased. should_be = min(level(left(T)), level(right(T))) + 1 '''if''' should_be < level(T) '''then''' level(T) := should_be '''if''' should_be < level(right(T)) '''then''' level(right(T)) := should_be '''end if''' '''end if''' return T '''end function''' A good example of deletion by this algorithm is present in the [http://user.it.uu.se/~arnea/abs/simp.html Andersson paper]. == Performance == The performance of an AA tree is equivalent to the performance of a red-black tree. While an AA tree makes more rotations than a red-black tree, the simpler algorithms tend to be faster, and all of this balances out to result in similar performance. A red-black tree is more consistent in its performance than an AA tree, but an AA tree tends to be flatter, which results in slightly faster search times.{{Citation needed|date=February 2007}} == See also == * [[Red-black tree]] * [[B-tree]] * [[AVL tree]] ==References== *[http://user.it.uu.se/~arnea/abs/simp.html A. Andersson. Balanced search trees made simple] *[http://user.it.uu.se/~arnea/abs/searchproc.html A. Andersson. A note on searching in a binary search tree] ==External links== *[http://people.ksp.sk/~kuko/bak/index.html AA-Tree Applet] by Kubo Kovac *[http://bitbucket.org/trijezdci/bstlib/src/ BSTlib] - Open source AA tree library for C by trijezdci *[http://www.softpedia.com/get/Others/Home-Education/AA-Visual-2007.shtml AA Visual 2007 1.5 - OpenSource Delphi program for educating AA tree structures] *[http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_andersson.aspx Thorough tutorial] Julienne Walker with lots of code, including a practical implementation *[http://www.cs.fiu.edu/~weiss/dsaa_c++3/code/ Object Oriented implementation with tests] *[http://www.cepis.org/upgrade/files/full-2004-V.pdf A Disquisition on The Performance Behavior of Binary Search Tree Data Structures (pages 67-75)] - Comparison of AA trees, red-black trees, treaps, skip lists, and radix trees *[http://www.rational.co.za/aatree.c An example C implementation] {{CS-Trees}} {{DEFAULTSORT:Aa Tree}} [[Category:Trees (structure)]] [[cs:AA strom]] [[es:Árbol AA]] [[ja:AA木]]</text> </page> <page> <id>258</id> <title>ABINIT</title> <text>'''ABINIT''' is a [[free software|free]] [[Software package (installation)|software package]] for [[physicist]]s, distributed under the [[GNU General Public License]], whose main program allows the total [[energy]], [[Current density|charge density]], and [[Electron configuration|electronic structure]] of systems made of [[electron]]s and [[Atomic nucleus|nuclei]] ([[molecules]] and periodic/crystalline [[solid]]s) to be calculated within [[density functional theory]] (DFT), using [[pseudopotential]]s, and a [[plane wave]] basis.<ref>X. Gonze, J.-M. Beuken, R. Caracas, F. Detraux, M. Fuchs, G.-M. Rignanese, L. Sindic, M. Verstraete, G. Zerah, F. Jollet, M. Torrent, A. Roy, M. Mikami, P. Ghosez, J.-Y. Raty, and D.C. 