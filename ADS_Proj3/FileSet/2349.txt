watchpoint or breakpoint, or by issuing a BKPT (breakpoint) instruction from the software being debugged. When it is not being used for instruction tracing, the ETM can also trigger entry to debug mode; it supports complex triggers sensitive to state and history, as well as the simple address comparisons exposed by the debug module. Asynchronous transitions to debug mode are detected by polling the DSCR register. This is how single stepping is implemented: HALT the core, set a temporary breakpoint at the next instruction or next high-level statement, RESTART, poll DSCR until you detect asynchronous entry to debug state, remove that temporary breakpoint, repeat. ===Monitor Mode Debugging=== Modern software is often too complex to work well with such a single threaded model. For example, a processor used to control a motor (perhaps one driving a saw blade) may not be able to safely enter halt mode ... it may need to continue handling interrupts to ensure physical safety of people and/or machinery. Issuing a HALT instruction using JTAG might be dangerous. ARM processors support an alternative debug mode, called ''Monitor Mode'', to work with such situations. (This is distinct from the ''Secure Monitor Mode'' implemented as part of security extensions on newer ARM cores; it manages debug operations, not security transitions.) In those cases, breakpoints and watchpoints trigger a special kind of hardware exception, transferring control to a "debug monitor" running as part of the system software. This monitor will communicate with the debugger using the DCC, and could arrange for example to single step only a single process while other processes (and interrupt handlers) continue running. ==Common extensions== Microprocessor vendors have often defined their own core-specific debugging extensions. Such vendors include [[Infineon]], MIPS with EJTAG, and more. If the vendor does not adopt a standard (such as the ones used by ARM processors; or Nexus), they need to define their own solution. If they support boundary scan, they generally build debugging over JTAG. [[Freescale]] has COP and OnCE (On-Chip Emulation). OnCE includes a JTAG command which makes a TAP enter a special mode where the IR holds OnCE debugging commands<ref name="OnCE">AN1817/D, "MMC20xx Mâ€¢CORE OnCE Port Communication and Control Sequences"; Freescale Semiconductor, Inc.; 2004. Not all processors support the same OnCE module.</ref> for operations such as single stepping, breakpointing, and accessing registers or memory. It also defines EOnCE (Enhanced On-Chip Emulation)<ref name="EOnCE">AN2073 "Differences Between the EOnCE and OnCE Ports"; Freescale Semiconductor, Inc.; 2005.</ref> presented as addressing real time concerns. [[ARM architecture|ARM]] has an extensive processor core debug architecture (CoreSight) that started with EmbeddedICE (a debug facility available on most ARM cores), and now includes many additional components such as an ETM (Embedded Trace Macrocell), with a high speed trace port, supporting multi-core and multithread tracing. Note that tracing is non-invasive; systems do not need to stop operating to be traced. (However, trace data is too voluminous to use JTAG as more than a trace control channel.) [[Nexus (standard)|Nexus]] defines a processor debug infrastructure which is largely vendor-independent. One of its hardware interfaces is JTAG. It also defines a high speed auxiliary port interface, used for tracing and more. Nexus is used with some newer platforms, such as the [[Atmel]] AVR32 and Freescale MPC5500 series processors. ==Widespread uses== * Except for some of the very lowest end systems, essentially all [[embedded systems]] platforms have a JTAG port to support in-circuit debugging and firmware programming as well as for boundary scan testing: ** [[ARM Architecture]] processors come with JTAG support, sometimes supporting a two-wire "SWD" variant or high speed tracing of traffic on instruction or data busses. (This alone means most 32-bit processors in the world support JTAG.) ** Modern 8-bit and 16-bit [[Microcontroller]] chips, such as [[Atmel AVR]] and [[TI MSP430]] chips, support JTAG programming and debugging. However, the very smallest chips may not have enough pins to spare (and thus tend to rely on proprietary single-wire programming interfaces); if the pin count is over 32, there is probably a JTAG option. ** Almost all [[FPGA]]s and [[CPLD]]s used today can be programmed via a JTAG port. ** Many [[MIPS architecture|MIPS]] and [[PowerPC]] processors have JTAG support too *The [[Peripheral Component Interconnect|PCI]] bus connector standard contains optional JTAG signals on pins 1-5;<ref>[http://www.techfest.com/hardware/bus/pci.htm#4.10 PCI Local Bus Technical Summary, 4.10 JTAG/Boundary Scan Pins]</ref> PCI-Express contains JTAG signals on pins 5-9.<ref>[http://www.interfacebus.com/Design_PCI_Express_16x_PinOut.html PCI-Express 16x Connector Pin Out]</ref> A special JTAG card can be used to reflash a corrupt [[BIOS]]. * Boundary scan testing and in-system (device) programming applications are sometimes programmed using the [[Serial Vector Format]], a textual representation of JTAG operations using a simple syntax. Other programming formats include 'JAM' and STAPL plus more recently the IEEE Std. 1532 defined format 'ISC' (short for In-System Configuration). ISC format is used in conjunction with enhanced BSDL models for programmable logic devices (i.e. FPGAs and CPLDs) that include addition ISC_<operation> instructions in addition to the basic bare minimum IEEE 1149.1 instructions. FPGA programming tools from [[Xilinx]], Altera, Lattice, Cypress, Actel etc.. and will typically be able to export such files. * As mentioned, many boards include JTAG connectors, or just pads, to support manufacturing operations, where boundary scan testing helps verify board quality (identifying bad solder joints, etc.) and to initialize [[flash memory]] or FPGAs. * JTAG can also support field updates and troubleshooting. * Primarily of historical interest: Intel's [[Pentium]] processors supported a "probe mode"<ref name="pentium">[http://www.ddj.com/architect/184410327 ICE Mode and the Pentium Processor]</ref> supporting JTAG access for debuggers. For a long time, its documentation was withdrawn by Intel. Current x86 processors appear to use JTAG only for boundary scan. ==Client Support== The target's JTAG interface is accessed using some JTAG-enabled application and some JTAG adapter hardware. There is a wide range of such hardware, optimized for purposes such as production testing, debugging high speed systems, low cost microcontroller development, and so on. In the same way, the software used to drive such hardware can be quite varied. Software developers mostly use JTAG for debugging and updating firmware. If you want to acquire a JTAG adapter, you 