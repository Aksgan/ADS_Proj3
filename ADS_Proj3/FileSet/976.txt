website. Particularly in the case of social networking sites, the code would be further designed to self-propagate across accounts, creating a type of a client-side [[Computer worm|worm]].<ref>Viruses and worms in {{cite web|author=Alcorn, Wade|title=The Cross-site Scripting Virus|date=September 27, 2005|url=http://www.bindshell.net/papers/xssv|publisher=BindShell.net|accessdate=May 27, 2008}} and {{cite web|author=Grossman, Jeremiah|title=Cross-Site Scripting Worms and Viruses: The Impending Threat and the Best Defense|url=http://www.whitehatsec.com/downloads/WHXSSThreats.pdf|format=PDF|month=April | year=2006|publisher=WhiteHat Security|page=20|accessdate=June 6, 2008}} {{Dead link|date=September 2010|bot=H3llBot}}http://web.archive.org/web/*/http://www.whitehatsec.com/downloads/WHXSSThreats.pdf</ref> The methods of injection can vary a great deal; in some cases, the attacker may not even need to directly interact with the web functionality itself to exploit such a hole. Any data received by the web application (via email, system logs, etc.) that can be controlled by an attacker could become an injection vector. ===Traditional versus DOM-based vulnerabilities=== {| class=wikitable style="float:right; clear:right; width:30%; margin:0 0 1em 1em;" !| Example of DOM-based XSS |- | Before the bug was resolved, Bugzilla error pages were open to [[Document Object Model|DOM]]-based XSS attack in which arbitrary HTML and scripts could be injected using forced error messages.<ref>{{cite web|title=Bug 272620 â€“ XSS vulnerability in internal error messages|url=http://bugzilla.mozilla.org/show_bug.cgi?id=272620|year=2004|publisher=Bugzilla@Mozilla|accessdate=May 29, 2008}}</ref> |} Traditionally cross-site scripting vulnerabilities would occur in server-side code responsible for preparing the HTML response to be served to the user. With the advent of [[web 2.0]] applications a new class of XSS flaws emerged, ''DOM-based'' vulnerabilities. ''DOM-based'' vulnerabilities occur in the content processing stages performed by the client, typically in [[client-side JavaScript]]. The name refers to the standard model for representing HTML or XML contents which is called the [[Document Object Model]] (DOM). JavaScript programs manipulate the state of a web page and populate it with dynamically-computed data primarily by acting upon the DOM. A typical example is a piece of JavaScript accessing and extracting data from the URL via the <code>location.*</code> DOM, or receiving raw non-HTML data from the server via [[XMLHttpRequest]], and then using this information to write dynamic HTML without proper escaping, entirely on client side. ==Exploit scenarios== Attackers intending to exploit cross-site scripting vulnerabilities must approach each class of vulnerability differently. For each class, a specific attack vector is described here. The names below are technical terms, taken from the [[Alice and Bob|cast of characters]] commonly used in computer security. '''Non-persistent:''' # Alice often visits a particular website, which is hosted by Bob. Bob's website allows Alice to log in with a username/password pair and stores sensitive data, such as billing information. # Mallory observes that Bob's website contains a reflected XSS vulnerability. # Mallory crafts a URL to exploit the vulnerability, and sends Alice an email, enticing her to click on a link for the URL under false pretenses. This URL will point to Bob's website, but will contain Mallory's malicious code, which the website will reflect. # Alice visits the URL provided by Mallory while logged into Bob's website. # The malicious script embedded in the URL executes in Alice's browser, as if it came directly from Bob's server (this is the actual XSS vulnerability). The script can be used to send Alice's session cookie to Mallory. Mallory can then use the session cookie to steal sensitive information available to Alice (authentication credentials, billing info, etc.) without Alice's knowledge. '''Persistent attack:''' # Mallory posts a message with malicious payload to a social network. # When Bob reads the message, Mallory's XSS steals Bob's cookie. # Mallory can now [[session hijacking|hijack]] Bob's session and impersonate Bob.<ref>{{cite news|author=Brodkin, Jon|title=The top 10 reasons Web sites get hacked|url=http://www.networkworld.com/news/2007/100407-web-site-vulnerabilities.html|date=October 4, 2007|work=Network World|publisher=IDG|accessdate=June 8, 2008}}</ref> '''Framework:''' A [[BeEF (Browser Exploitation Framework)|Browser Exploitation Framework]] could be used to attack the web site and the user's local environment. ==Mitigation== ===Contextual Output Encoding/Escaping of String Input=== The primary defense mechanism to stop XSS is contextual output encoding/escaping. There are several different escaping schemes that must be used depending on where the untrusted string needs to be placed within an HTML document including HTML entity encoding, JavaScript escaping, CSS escaping, and [[Percent-encoding|URL (or percent) encoding]].<ref name=OWASP>{{cite web|author=Williams,Jeff|title=XSS (Cross SIte Scripting) Prevention Cheat Sheet|url=http://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet|publisher=OWASP|date=January 19, 2009|accessdate=February 4, 2009}}</ref> Most web applications that do not need to accept rich data can use escaping to largely eliminate the risk of XSS in a fairly straightforward manner. It is worth noting that although it is widely recommended, simply performing HTML entity encoding on the [[List of XML and HTML character entity references#Predefined entities in XML|five XML significant characters]] is not always sufficient to prevent many forms of XSS. Encoding can be tricky, and the use of a security encoding library is highly recommended.<ref name="OWASP"/> ===Safely Validating Untrusted HTML Input=== Many operators of particular web applications (e.g. forums and webmail) wish to allow users to utilize some of the features HTML provides, such as a limited subset of HTML markup. When accepting HTML input from users, output encoding will not suffice since the user input needs to be rendered as HTML by the browser. Stopping XSS when accepting HTML input from users is much more complex in this situation. Untrusted HTML input must be run through an HTML policy engine to ensure that it does not contain XSS. Tools such as OWASP AntiSamy <ref name=OWASP2>{{cite web|author=Dabirsiaghi,Arshan|title=OWASP AntiSamy Project|url=http://www.owasp.org/index.php/Category:OWASP_AntiSamy_Project|publisher=OWASP|date=November 3, 2010|accessdate=November 3, 2010}}</ref> and http://htmlpurifier.org/ accomplish this task. ===Cookie security=== Besides content filtering, other imperfect methods for cross-site scripting mitigation are also commonly used. One example is the use of additional security controls when handling [[HTTP cookie|cookie]]-based user authentication. Many web applications rely on session cookies for authentication between individual HTTP requests, and because client-side scripts generally have access to these cookies, simple XSS exploits can steal these cookies.<ref name=Sharma>{{cite web|author=Sharma, Anand|title=Prevent a cross-site scripting attack|url=http://www.ibm.com/developerworks/ibm/library/wa-secxss/|publisher=IBM|date=February 3, 2004|accessdate=May 29, 2008}}</ref> To mitigate this particular threat (though not the XSS problem in general), many web applications tie session cookies to the IP address of the user who originally logged in, and only permit that IP to use that cookie.<ref name=ModSecurity>{{cite web|title=ModSecurity: Features: PDF Universal XSS Protection|url=http://www.modsecurity.org/projects/modsecurity/apache/feature_universal_pdf_xss.html|publisher=Breach Security|accessdate=June 6, 2008}}</ref> This is effective in most situations (if an attacker is only after the cookie), but obviously breaks down in situations where an 