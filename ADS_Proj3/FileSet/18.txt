of bits. In C99, however, [[stdint.h]] provides names for integer types with certain numbers of bits where those types are available. ===Specific C-language data models=== In most programming environments on 32-bit machines, pointers, "int" (that is, integer) types, and "long" (that is, long integer) types are all 32 bits wide. However, in many programming environments on 64-bit machines, "int" variables are still 32 bits wide, but long integers and pointers are 64 bits wide. These are described as having an '''LP64''' [[data model]]. Another alternative is the '''ILP64''' data model in which all three data types are 64 bits wide, and even '''SILP64''' where "short" integers are also 64 bits wide{{Citation needed|date=February 2007}}. However, in most cases the modifications required are relatively minor and straightforward, and many well-written programs can simply be recompiled for the new environment without changes. Another alternative is the '''LLP64''' model, which maintains compatibility with 32-bit code by leaving both int and long as 32-bit. "LL" refers to the "long long integer" type, which is at least 64 bits on all platforms, including 32-bit environments. {|class="wikitable" |+64-bit data models |- ! Data model ! short (integer) ! int ! long (integer) ! long long ! pointers/size_t ! Sample operating systems |- ! LLP64/<br />IL32P64 | 16 | 32 | 32 | 64 | 64 | [[Microsoft Windows]] (X64/IA-64) |- ! LP64/<br />I32LP64 | 16 | 32 | 64 | 64 | 64 | Most [[Unix]] and [[Unix-like]] systems, e.g. [[Solaris (operating system)|Solaris]], [[Linux]], and [[Mac OS X]] |- ! ILP64 | 16 | 64 | 64 | 64 | 64 | [[HAL Computer Systems]] port of Solaris to [[SPARC64]] |- ! SILP64 | 64 | 64 | 64 | 64 | 64 | [[Unicos]] |} Many 64-bit compilers today use the '''LP64''' model (including Solaris, [[AIX]], [[HP-UX]], Linux, [[Mac OS X]], [[FreeBSD]], and IBM [[z/OS]] native compilers). Microsoft's [[Visual C++]] compiler uses the '''LLP64''' model. The disadvantage of the LP64 model is that storing a long into an int may overflow. On the other hand, casting a pointer to a long will work. In the LLP model, the reverse is true. These are not problems which affect fully standard-compliant code but code is often written with implicit assumptions about the widths of integer types. Note that a programming model is a choice made on a per-compiler basis, and several can coexist on the same OS. However, the programming model chosen as the primary model for the OS API typically dominates. Another consideration is the data model used for [[Device driver|driver]]s. Drivers make up the majority of the operating system code in most modern operating systems (although many may not be loaded when the operating system is running). Many drivers use pointers heavily to manipulate data, and in some cases have to load pointers of a certain size into the hardware they support for [[Direct memory access|DMA]]. As an example, a driver for a 32-bit PCI device asking the device to DMA data into upper areas of a 64-bit machine's memory could not satisfy requests from the operating system to load data from the device to memory above the 4 gigabyte barrier, because the pointers for those addresses would not fit into the DMA registers of the device. This problem is solved by having the OS take the memory restrictions of the device into account when generating requests to drivers for DMA, or by using an [[IOMMU]]. ==Current 64-bit microprocessor architectures== 64-bit [[processor architecture|microprocessor architectures]] ({{As of|2010|lc=on}}) include: * The 64-bit extension created by [[Advanced Micro Devices|AMD]] to Intel's [[x86]] architecture (later licensed by Intel); commonly known as "[[x86-64]]", "AMD64", or "x64": ** AMD's [[AMD64]] extensions (used in [[Athlon 64]], [[Opteron]], [[Sempron]], [[Turion 64]], [[Phenom (processor)|Phenom]], [[Athlon II]] and [[Phenom II]] processors) ** [[Intel]]'s [[Intel 64]] extensions (used in newer [[Celeron]], [[Pentium 4]], [[Pentium D]], [[Xeon]], [[Core 2]], [[Intel Core i3|Core i3]], [[Intel Core i5|Core i5]], [[Intel Core i7|Core i7]], and [[Intel Atom|Atom]] processors) ** [[VIA Technologies]]' 64-bit extensions, used in the [[VIA Nano]] processors * [[Power Architecture]]: ** IBM's [[POWER6]] processor ** IBM's [[PowerPC 970]] processor ** The [[Cell Broadband Engine]] used in the [[PlayStation 3]], designed by IBM, [[Toshiba]] and [[Sony]], combines a 64-bit Power architecture processor with seven or eight Synergistic Processing Elements. ** IBM's "[[Xenon (processor)|Xenon]]" processor used in the [[Microsoft]] [[Xbox 360]] comprises three 64-bit PowerPC cores. * [[SPARC]] V9 architecture: ** [[Sun Microsystems|Sun]]'s [[UltraSPARC]] processors ** [[Fujitsu]]'s [[SPARC64]] processors * IBM's [[z/Architecture]], used by IBM zSeries and [[System z9]] [[IBM mainframes|mainframes]], a 64-bit version of the [[ESA/390]] architecture * Intel's [[IA-64]] architecture (used in [[Itanium]] processors) * [[MIPS Technologies]]' [[MIPS architecture|MIPS64 architecture]] Most 64-bit processor architectures can execute code for the 32-bit version of the architecture natively without any performance penalty.{{Citation needed|date=September 2010}} This kind of support is commonly called ''bi-arch support'' or more generally ''multi-arch support''. ==Images== In digital imaging, 64-bit refers to [[Deep Color|48-bit images]] with a [[16-bit]] [[Alpha compositing|alpha channel]]. ==See also== * [[Computer memory]] ==References== {{Reflist}} ==External links== *Andrey Karpov. [http://software.intel.com/en-us/articles/collection-of-examples-of-64-bit-errors-in-real-programs/ A Collection of Examples of 64-bit Errors in Real Programs] *[http://software.intel.com/en-us/articles/lessons-on-development-of-64-bit-cc-applications/ Lessons on development of 64-bit C/C++ applications] *[http://www.unix.org/version2/whatsnew/lp64_wp.html 64-Bit Programming Models: Why LP64?] *[http://www.codeproject.com/KB/system/AMD64_EM64T_architectur.aspx AMD64 (EM64T) architecture] *[http://www.64bitdrivers.com/ Large list of 64 bit drivers for x64 operating systems] *[http://www.igorware.com/64bit-checker Detect if you have 64-bit operating system] {{FOLDOC}} {{CPU technologies}} [[ca:64 bits]] [[cs:64bitový]] [[de:64-Bit]] [[et:64-bitine protsessor]] [[es:64 bits]] [[fr:Processeur 64 bits]] [[ko:64비트]] [[it:64 bit]] [[lv:64 biti]] [[ms:64-bit]] [[ja:64ビット]] [[pl:Architektura 64-bitowa]] [[pt:64 bits]] [[zh:64位元]]</text> </page> <page> <id>189</id> <title>6in4</title> <text>{{IPv6 transition mechanisms}} '''6in4''' is an Internet [[IPv6#Transition mechanisms|transition mechanism]] for migrating from [[IPv4|Internet Protocol version 4]] (IPv4) to [[IPv6]]. 6in4 uses [[Tunneling protocol|tunneling]] to encapsulate IPv6 traffic over explicitly-configured IPv4 links as defined in RFC 4213 (obsoletes RFC 2893 and RFC 1933). The 6in4 traffic is sent over the IPv4 Internet inside IPv4 packets whose IP headers have the [[IP protocol number]] set to 41. This protocol number is specifically designated for ''IPv6 encapsulation''.<ref>{{cite web |url=http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xml |title=Protocol Numbers}}</ref> In 6in4, the IPv4 packet header is immediately followed by 