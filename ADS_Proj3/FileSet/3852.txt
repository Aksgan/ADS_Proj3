term in [[computer science]] which refers to a [[Run time (computing)|runtime]] [[search path]] hard-coded in an [[executable file]] or [[library (computer science)|library]], used during [[dynamic linking]] to find the libraries the executable or library requires. It is inserted in the executable or library at link time. Specifically it encodes a path to shared libraries into the header of an executable (or another shared library). This RPATH header value (so named in the [[Executable and Linkable Format]] header standards) may either override or supplement the system default dynamic linking search path (as defined in ''/etc/ld.so.conf'' on Linux systems, for example). It can be thought of as a compile-time alternative to the LD_LIBRARY_PATH environment setting. While LD_LIBRARY_PATH would have to be properly set in the environment of any process attempting to run a given program; the RPATH setting is compiled into that program's headers. The primary disadvantage of using RPATH is that it has higher priority than the LD_LIBRARY_PATH settings which makes things like running a precompiled binary out of a user's home directory or some other non-default location difficult or impossible. Use of RPATH also makes it difficult, if not impossible, to upgrade libraries without forcing a reinstallation of all the software dependent on (even the older versions of) the libraries. == External links == * [http://wiki.debian.org/RpathIssue Debian Wiki page about the use of RPATH] * [http://sourceware.org/autobook/autobook/autobook_88.html Autobook section containing brief discussion of rpath] * [http://packages.debian.org/stable/chrpath chrpath] - a tool to change the rpath of an executable * [http://nixos.org/patchelf.html patchELF] - a small utility to modify the dynamic linker and RPATH of [[Executable_and_Linkable_Format|ELF]] executables. {{DEFAULTSORT:Rpath (Linking)}} [[Category:Computer libraries]] [[Category:Operating system technology]] {{comp-sci-stub}}</text> </page> <page> <id>32530</id> <title>Rpmsg</title> <text>{{Orphan|date=April 2010}} {{Infobox file format | name = Restricted Permission Message | extension = <tt>.rpmsg</tt> | mime = <tt>unknown</tt> | owner = [[Microsoft]] | magic = <tt>76 E8 04 60 C4 11 E3 86 [http://msdn.microsoft.com/en-us/library/ee625343%28EXCHG.80%29.aspx]</tt> }} ==Usage== An '''rpmsg''' file is a restricted-permission message with an extension of rpmsg [http://msdn.microsoft.com/en-us/library/aa767786%28VS.85%29.aspx]. It is used to implement [[Information Rights Management|IRM]] for Outlook messages with the aim of restricting certain actions such as the ability to forwarded or copy [http://msdn.microsoft.com/en-us/library/aa767786%28VS.85%29.aspx][http://searchexchange.techtarget.com/news/article/0,,sid43_gci964022,00.html]. ==Implementation== The rpmsg file is created by writing body, attachments and images to a [[Compound File Binary Format|compound file]] and then compressing and encrypting it to create a [[Binary large object|BLOB]]: the rpmsg file [http://msdn.microsoft.com/en-us/library/cc463909%28EXCHG.80%29.aspx]. This resulting file is named message.rpmsg and is included as an attachment to a normal Outlook message. ==Rights Control== When a rights managed mail is created the author specifies what rights they wish to grant to the recipient and these rights are specified in the form of an [[XrML]] file called a 'Publishing License'. This file is included within the encrypted rpmsg file. When the rpmsg attachment is decrypted the enclosed 'Publishing License' is referenced by Outlook to determine what the recipient can and cannot do with the message (rights to forward, copy etc.).[http://msdn.microsoft.com/en-us/library/cc243194%28PROT.10%29.aspx][http://msdn.microsoft.com/en-us/library/cc463909%28EXCHG.80%29.aspx] ==External links== * [http://msdn.microsoft.com/en-us/library/aa767786%28VS.85%29.aspx Rights Management for E-Mail Messages] * [http://msdn.microsoft.com/en-us/library/cc463909%28EXCHG.80%29.aspx Rights-Managed E-Mail Object Protocol Specification] [[Category:Digital rights management]]</text> </page> <page> <id>32531</id> <title>Rprop</title> <text>'''Rprop''', short for resilient [[backpropagation]], is a learning [[heuristics|heuristic]] for [[supervised learning]] in [[Feedforward neural network|feedforward]] [[artificial neural network]]s. This is a [[First-order approximation|first-order]] [[optimization (mathematics)|optimization]] [[algorithm]]. This algorithm was created by Martin Riedmiller and Heinrich Braun in 1992. Similarly to the [[Manhattan update rule]], Rprop takes into account only the [[Sign (mathematics)|sign]] of the [[partial derivative]] over all patterns (not the magnitude), and acts independently on each "weight". For each weight, if there was a sign change of the partial derivative of the total error function compared to the last iteration, the update value for that weight is multiplied by a factor ''η''<sup>&minus;</sup>, where ''η''<sup>&minus;</sup> < 1. If the last iteration produced the same sign, the update value is multiplied by a factor of ''η''<sup>+</sup>, where ''η''<sup>+</sup> > 1. The update values are calculated for each weight in the above manner, and finally each weight is changed by its own update value, in the opposite direction of that weight's partial derivative , so as to minimise the total error function. ''η''<sup>+</sup> is empirically set to 1.2 and ''η''<sup>&minus;</sup> to 0.5. Next to the [[cascade correlation algorithm]] and the [[Levenberg&ndash;Marquardt algorithm]], Rprop is one of the fastest weight update mechanisms. RPROP is a batch update algorithm. ==Variations== Martin Riedmiller developed three algorithms, all named RPROP. Igel and Hüsken assigned a new name to them: [http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.1332 Improving the Rprop Learning Algorithm]. # RPROP+ is defined at [http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.21.1417 A Direct Adaptive Method for Faster Backpropagation Learning: The RPROP Algorithm]. # RPROP&minus; is defined at [http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.27.7876 Advanced Supervised Learning in Multi-layer Perceptrons &ndash; From Backpropagation to Adaptive Learning Algorithms]. Backtracking is removed from RPROP+. # iRPROP&minus; is defined at [http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.21.3428 Rprop &ndash; Description and Implementation Details]. This is reinvented by Igel and Hüsken. This is most popular, most simple, and in many cases most efficient. # iRPROP+ is defined at [http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.1332 Improving the Rprop Learning Algorithm]. == References == *[http://citeseer.ist.psu.edu/rd/2171473%2C711503%2C1%2C0.25%2CDownload/http://citeseer.ist.psu.edu/cache/papers/cs2/20/http:zSzzSzamy.informatik.uos.dezSzriedmillerzSzpublicationszSzrprop.details.pdf/riedmiller94rprop.pdf Rprop &ndash; Description and Implementation Details] Martin Riedmiller, 1994. Technical report. [[Category:Neural networks]] [[Category:Machine learning]] [[de:Resilient Propagation]]</text> </page> <page> <id>32538</id> <title>Rubber duck debugging</title> <text>[[File:Rubber Duck.jpg|thumb|A modern rubber duck.]] '''Rubber duck debugging''',<ref name="lorem">[http://pyre.third-bit.com/blog/archives/000106.html Essential Equipment - The Third Bit]</ref><ref name="so">[http://stackoverflow.com/questions/1106683/what-is-this-particular-type-of-revelation-called What is this particular type of revelation called? - Stack Overflow]</ref> '''Rubber Ducking''',<ref name="duckie1">[http://www.c2.com/cgi/wiki?RubberDucking Rubber Ducking - The Pragmatic Programmer]</ref> or the '''Rubber Duckie Test'''<ref name="duckie2">[http://lvtechspeak.blogspot.com/2009/03/rubber-duckie-test.html The Rubber Duckie Test - Technically Speaking]</ref> is an informal term used in software engineering to refer to a method of [[debugging]] code. The name is a reference to an [[apocryphal]] story in which an unnamed expert programmer would keep a [[rubber duck]] by his desk at all times, and debug his code by forcing himself to explain it, line-by-line, to the duck. The process is to meticulously explain code to an inanimate object, such as a rubber duck. It is expected that when the programmer comes across a piece of code that is incorrect, they will realize this<ref name="lorem" />. The method exploits [[cognitive dissonance]]; the programmer will be confronted with the fact 