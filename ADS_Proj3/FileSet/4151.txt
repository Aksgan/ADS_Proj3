arranging the data sequence in a two-dimensional array and then sorting the columns of the array using insertion sort. === Comb sort === {{Main|Comb sort}} '''Comb sort''' is a relatively simplistic sorting algorithm originally designed by [[Wlodzimierz Dobosiewicz]] in 1980. Later it was rediscovered and popularized by [[Stephen Lacey]] and [[Richard Box]] with a [[Byte Magazine]] article published in April 1991. Comb sort improves on [[bubble sort]], and rivals algorithms like [[Quicksort]]. The basic idea is to eliminate ''turtles'', or small values near the end of the list, since in a bubble sort these slow the sorting down tremendously. (''Rabbits'', large values around the beginning of the list, do not pose a problem in bubble sort.). === Merge sort === {{Main|Merge sort}} ''Merge sort'' takes advantage of the ease of merging already sorted lists into a new sorted list. It starts by comparing every two elements (i.e., 1 with 2, then 3 with 4...) and swapping them if the first should come after the second. It then merges each of the resulting lists of two into lists of four, then merges those lists of four, and so on; until at last two lists are merged into the final sorted list. Of the algorithms described here, this is the first that scales well to very large lists, because its worst-case running time is O(''n'' log ''n''). Merge sort has seen a relatively recent surge in popularity for practical implementations, being used for the standard sort routine in the programming languages [[Perl]],<ref>[http://perldoc.perl.org/functions/sort.html Perl sort documentation]</ref> [[Python (programming language)|Python]] (as [[timsort]]<ref>[http://svn.python.org/projects/python/trunk/Objects/listsort.txt Tim Peters's original description of timsort]</ref>), and [[Java (programming language)|Java]] (also uses timsort as of [[JDK7]]<ref>[http://hg.openjdk.java.net/jdk7/tl/jdk/rev/bfd7abda8f79]</ref>), among others. Merge sort has been used in Java at least since 2000 in JDK1.3.<ref name = "mergesort_in_jdk13">[http://java.sun.com/j2se/1.3/docs/api/java/util/Arrays.html#sort(java.lang.Object%5B%5D) Merge sort in Java 1.3], Sun.</ref><ref name = "jdk13_since_2000">[[Java version history#J2SE 1.3 (May 8, 2000)|Java 1.3 live since 2000]]</ref> === Heapsort=== {{Main|Heapsort}} ''Heapsort'' is a much more efficient version of [[selection sort]]. It also works by determining the largest (or smallest) element of the list, placing that at the end (or beginning) of the list, then continuing with the rest of the list, but accomplishes this task efficiently by using a data structure called a [[heap (data structure)|heap]], a special type of [[binary tree]]. Once the data list has been made into a heap, the root node is guaranteed to be the largest (or smallest) element. When it is removed and placed at the end of the list, the heap is rearranged so the largest element remaining moves to the root. Using the heap, finding the next largest element takes ''O(''log'' n)'' time, instead of ''O(n)'' for a linear scan as in simple selection sort. This allows Heapsort to run in ''O(n ''log'' n)'' time, and this is also the worst case complexity. === Quicksort === {{Main|Quicksort}} ''Quicksort'' is a [[divide and conquer algorithm|divide and conquer]] [[algorithm]] which relies on a ''partition'' operation: to partition an array, we choose an element, called a ''pivot'', move all smaller elements before the pivot, and move all greater elements after it. This can be done efficiently in linear time and [[in-place algorithm|in-place]]. We then recursively sort the lesser and greater sublists. Efficient implementations of quicksort (with in-place partitioning) are typically unstable sorts and somewhat complex, but are among the fastest sorting algorithms in practice. Together with its modest O(log ''n'') space usage, this makes quicksort one of the most popular sorting algorithms, available in many standard libraries. The most complex issue in quicksort is choosing a good pivot element; consistently poor choices of pivots can result in drastically slower O(''n''²) performance, but if at each step we choose the [[median]] as the pivot then it works in O(''n'' log ''n''). Finding the median, however, is an O(n) operation on unsorted lists, and therefore exacts its own penalty. === Counting Sort === {{Main|Counting sort}} Counting sort is applicable when each input is known to belong to a particular set, ''S'', of possibilities. The algorithm runs in O(|''S''| + ''n'') time and O(|''S''|) memory where ''n'' is the length of the input. It works by creating an integer array of size |''S''| and using the ''i''th bin to count the occurrences of the ''i''th member of ''S'' in the input. Each input is then counted by incrementing the value of its corresponding bin. Afterward, the counting array is looped through to arrange all of the inputs in order. This sorting algorithm cannot often be used because ''S'' needs to be reasonably small for it to be efficient, but the algorithm is extremely fast and demonstrates great asymptotic behavior as ''n'' increases. It also can be modified to provide stable behavior. ===Bucket sort=== {{Main|Bucket sort}} Bucket sort is a [[divide and conquer algorithm|divide and conquer]] sorting algorithm that generalizes [[Counting sort]] by partitioning an array into a finite number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm. A variation of this method called the single buffered count sort is faster than quicksort and takes about the same time to run on any set of data.{{Citation needed|date=October 2010}} Due to the fact that bucket sort must use a limited number of buckets it is best suited to be used on data sets of a limited scope. Bucket sort would be unsuitable for data such as social security numbers - which have a lot of variation. === Radix sort === {{Main|Radix sort}} ''Radix sort'' is an algorithm that sorts numbers by processing individual digits. ''n'' numbers consisting of ''k'' digits each are sorted in O(''n'' · ''k'') time. Radix sort can either process digits of each number starting from the [[least significant digit]] (LSD) or the [[most significant digit]] (MSD). The LSD algorithm first sorts the list by the least significant digit while preserving their relative order using a stable sort. Then it sorts them by the next digit, and so on from the least significant to the most significant, ending up 