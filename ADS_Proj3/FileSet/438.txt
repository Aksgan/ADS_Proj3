the ''sizes'' of the two heaps, from right-to-left. Whenever a carry occurs during addition, this corresponds to a merging of two binomial trees during the merge. Each tree has order at most log ''n'' and therefore the running time is ''O''(log ''n''). '''function''' merge(p, q) '''while''' '''not'''( p.end() '''and''' q.end() ) tree = mergeTree(p.currentTree(), q.currentTree()) '''if''' '''not''' heap.currentTree().empty() tree = mergeTree(tree, heap.currentTree()) heap.addTree(tree) '''else''' heap.addTree(tree) heap.next() p.next() q.next() [[Image:Binomial heap merge2.svg|right|thumb|300px|This shows the merger of two binomial heaps. This is accomplished by merging two binomial trees of the same order one by one. If the resulting merged tree has the same order as one binomial tree in one of the two heaps, then those two are merged again.]] ===Insert=== '''Inserting''' a new element to a heap can be done by simply creating a new heap containing only this element and then merging it with the original heap. Due to the merge, insert takes O(log ''n'') time,however it has an ''amortized'' time of O(1) (i.e. constant). ===Find minimum=== To find the '''minimum''' element of the heap, find the minimum among the roots of the binomial trees. This can again be done easily in ''O''(log ''n'') time, as there are just ''O''(log ''n'') trees and hence roots to examine. By using a pointer to the binomial tree that contains the minimum element, the time for this operation can be reduced to ''O''(1). The pointer must be updated when performing any operation other than Find minimum. This can be done in ''O''(log ''n'') without raising the running time of any operation. ===Delete minimum=== To '''delete the minimum element''' from the heap, first find this element, remove it from its binomial tree, and obtain a list of its subtrees. Then transform this list of subtrees into a separate binomial heap by reordering them from smallest to largest order. Then merge this heap with the original heap. Since each tree has at most log ''n'' children, creating this new heap is ''O''(log ''n''). Merging heaps is ''O''(log ''n''), so the entire delete minimum operation is ''O''(log ''n''). '''function''' deleteMin(heap) min = heap.trees().first() '''for each''' current '''in''' heap.trees() '''if''' current.root < min '''then''' min = current '''for each''' tree '''in''' min.subTrees() tmp.addTree(tree) heap.removeTree(min) merge(heap, tmp) ===Decrease key=== After '''decreasing''' the key of an element, it may become smaller than the key of its parent, violating the minimum-heap property. If this is the case, exchange the element with its parent, and possibly also with its grandparent, and so on, until the minimum-heap property is no longer violated. Each binomial tree has height at most log ''n'', so this takes ''O''(log ''n'') time. ===Delete=== To '''delete''' an element from the heap, decrease its key to negative infinity (that is, some value lower than any element in the heap) and then delete the minimum in the heap. ==Performance== All of the following operations work in [[Big O notation|O]](log ''n'') time on a binomial heap with ''n'' elements: * Insert a new element to the heap * Find the element with minimum key * Delete the element with minimum key from the heap * Decrease key of a given element * Delete given element from the heap * Merge two given heaps to one heap Finding the element with minimum key can also be done in ''O''(1) by using an additional pointer to the minimum. ==Applications== * [[Discrete event simulation]] * [[Priority queue]]s ==See also== * [[Fibonacci heap]] * [[Soft heap]] * [[Skew binomial heap]] ==References== * [[Thomas H. Cormen]], [[Charles E. Leiserson]], [[Ronald L. Rivest]], and [[Clifford Stein]]. ''[[Introduction to Algorithms]]'', Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Chapter 19: Binomial Heaps, pp.455&ndash;475. * Vuillemin, J. (1978). [http://portal.acm.org/citation.cfm?id=359478 A data structure for manipulating priority queues.] ''Communications of the ACM'' '''21''', 309–314. ==External links== * [http://www.cs.yorku.ca/~aaw/Sotirios/BinomialHeap.html Java applet simulation of binomial heap] * [http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/511508 Python implementation of binomial heap] * [http://www.cs.unc.edu/~bbb/#binomial_heaps Two C implementations of binomial heap] (a generic one and one optimized for integer keys) * [http://hackage.haskell.org/packages/archive/TreeStructures/latest/doc/html/src/Data-Heap-Binomial.html Haskell implementation of binomial heap] [[Category:Heaps (structure)]] {{Link GA|de}} [[cs:Binomiální halda]] [[de:Binomial-Heap]] [[fa:پشته‌های دوجمله‌ای]] [[fr:Tas binomial]] [[it:Heap binomiale]] [[he:עץ בינומי]] [[ja:二項ヒープ]] [[pl:Kopiec dwumianowy]] [[ru:Биномиальная куча]] [[uk:Біноміальна купа]] [[zh:二项堆]]</text> </page> <page> <id>3862</id> <title>BioCreative</title> <text>'''BioCreAtIvE''' (A critical assessment of text mining methods in [[molecular biology]]) consists in a community-wide effort for evaluating [[information extraction]] and [[text mining]] developments in the biological domain<ref>Lynette Hirschman, Alex Yeh, Christian Blaschke, and Alfonso Valencia (2005) Overview of BioCreative: Critical assessment of information extraction for biology. BMC Bioinformatics 6(Suppl. 1)</ref>. Three main tasks were posed at the first BioCreAtIvE challenge: the entity extraction task<ref>Alex Yeh, Alex Morgan, Marc Colosimo, and Lynette Hirschman (2005) BioCreative task 1A: Gene mention finding evaluation. BMC Bioinformatics 6(Suppl. 1)</ref>, the gene name normalization task<ref>Lynette Hirschman, Mark Colosimo, Alex Morgan, and Alex Yeh (2005) Overview of BioCreative task 1B: Normalized gene lists. BMC Bioinformatics 6(Suppl. 1)</ref><ref>Marc Colosimo, Alex Morgan, Alex Yeh, J. Colombe, and Lynette Hirschman (2005) Data preparation and interannotator agreement: BioCreative task 1B. BMC Bioinformatics 6(Suppl. 1)</ref>, and the functional annotation of gene products task<ref>Christian Blaschke, E. Leon, Martin Krallinger, and Alfonso Valencia (2005) Evaluation of BioCreative task 2. BMC Bioinformatics 6(Suppl. 1)</ref>. The data sets produced by this contest serve as a Gold Standard training and test set to evaluate and train Bio-NER tools and annotation extraction tools. The second BioCreAtIvE included three tasks organized by Lynette Hirschman and Alex Morgan of [[MITRE]]; Alfonso Valencia and Martin Krallinger of CNIO in Spain; and W. John Wilbur, Lorrie Tanabe and Larry Smith of [[NIH]]. ==External links== *[http://genomebiology.com/2008/9/S2/ BioCreAtIve 2, Genome Biology Special Issue] *[http://biocreative.sourceforge.net BioCreAtIve 2, 2006-2007] *[http://www.pdg.cnb.uam.es/BioLINK/workshop_BioCreative_04/ First BioCreAtIvE workshop, 2004] *[http://www.biomedcentral.com/1471-2105/6?issue=S1 BMC Bioinformatics special issue : BioCreAtIvE] *[http://www.pdg.cnb.uam.es/BioLINK/workshop_BioCreative_04/results/agreetment.html First BioCreAtIvE data download request] ==References== {{reflist}} {{DEFAULTSORT:Biocreative}} [[Category:Bioinformatics]] [[Category:Information science]] {{bioinformatics-stub}}</text> </page> <page> <id>3877</id> <title>BioSim</title> <text>{{Multiple issues|advert=June 2009|intromissing=June 2009|notability=June 2009|primarysources=June 2009}} '''''BioSim''''' is a project funded by the [[European Community]] under the 6th Framework program and was initiated on December 1, 2004. The main objective of the Network is to demonstrate how the use of modern [[simulation]] techniques through a 