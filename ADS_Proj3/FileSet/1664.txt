(in [[L-notation]]) for constant <math>c = \left(64/9\right)^\left(1/3\right)</math>.<ref>{{Cite news|last=Pomerance|first=Carl|author-link=Carl Pomerance|date=December 1996|title=A Tale of Two Sieves|periodical=Notices of the AMS|volume=43|issue=12|pages=1473–1485|url=http://www.ams.org/notices/199612/pomerance.pdf|format=PDF|postscript=<!--None-->}}</ref> It is a generalization of the [[special number field sieve]]: while the latter can only factor numbers of a certain special form, the general number field sieve can factor any number apart from [[prime power]]s (which are trivial to factor by taking roots). When the term ''number field sieve'' (NFS) is used without qualification, it refers to the general number field sieve. The principle of the number field sieve (both special and general) can be understood as an improvement to the simpler [[rational sieve]] or [[quadratic sieve]]. When using such algorithms to factor a large number ''n'', it is necessary to search for [[smooth number]]s (i.e. numbers with small prime factors) of order ''n''<sup>1/2</sup>. The size of these values is exponential in the size of ''n'' (see below). The general number field sieve, on the other hand, manages to search for smooth numbers that are subexponential in the size of ''n''. Since these numbers are smaller, they are more likely to be smooth than the numbers inspected in previous algorithms. This is the key to the efficiency of the number field sieve. In order to achieve this speed-up, the number field sieve has to perform computations and factorizations in [[number field]]s. This results in many rather complicated aspects of the algorithm, as compared to the simpler rational sieve. Note that log ''n'' is the number of digits in the binary representation of ''n'', that is the size of the input to the algorithm, so any element of the order ''n''<sup>''c''</sup> for a constant ''c'' is exponential in log ''n''. The running time of the number field sieve is super-polynomial but sub-exponential in the size of the input. == Number fields == Suppose ''f'' is an ''n''-degree polynomial over '''Q''' (the rational numbers), and ''r'' is a complex root of ''f''. Then, ''f''(''r'') = 0, which can be rearranged to express ''r''<sup>''n''</sup> as a linear combination of powers of ''r'' less than ''n''. This equation can be used to reduce away any powers of ''r'' ≥ ''n''. For example, if ''f''(''x'') = ''x''<sup>2</sup> + 1 and ''r'' is the imaginary unit ''i'', then ''i''<sup>2</sup> + 1=0, or ''i''<sup>2</sup> = −1. This allows us to define the complex product: :(''a''+''bi'')(''c''+''di'') = ''ac'' + (''ad''+''bc'')''i'' + (''bd'')''i''<sup>2</sup> = (''ac'' - ''bd'') + (''ad''+''bc'')''i''. In general, this leads directly to the [[algebraic number field]] '''Q'''[''r''], which can be defined as the set of real numbers given by: :''a''<sub>''n''-1</sub>''r''<sup>''n''-1</sup> + ... + ''a''<sub>''1''</sub>''r''<sup>1</sup> + ''a''<sub>''0''</sub>''r''<sup>0</sup>, where ''a''<sub>''0''</sub>,...,''a''<sub>''n''-1</sub> in '''Q'''. The product of any two such values can be computed by taking the product as polynomials, then reducing any powers of ''r'' ≥ ''n'' as described above, yielding a value in the same form. To ensure that this field is actually ''n''-dimensional and does not collapse to an even smaller field, it is sufficient that ''f'' is an [[irreducible polynomial]]. Similarly, one may define the number field ring '''Z'''[''r''] as the subset of '''Q'''[''r''] where ''a''<sub>''0''</sub>,...,''a''<sub>''n''-1</sub> are restricted to be integers. == Method == Two [[polynomial]]s ''f''(''x'') and ''g''(''x'') of small [[degree of a polynomial|degrees]] ''d'' and ''e'' are chosen, which have integer coefficients, which are [[irreducible polynomial|irreducible]] over the [[rational number|rationals]], and which, when interpreted [[modular arithmetic|mod ''n'']], have a common integer [[root of a function|root]] ''m''. An optimal strategy for choosing these polynomials is not known; one simple method is to pick a degree ''d'' for a polynomial, consider the expansion of ''n'' in [[radix|base ''m'']] (allowing digits between −''m'' and ''m'') for a number of different ''m'' of order ''n''<sup>1/''d''</sup>, and pick ''f''(''x'') as the polynomial with the smallest coefficients and ''g''(''x'') as ''x'' − ''m''. Consider the number field rings '''Z'''[''r''<sub>1</sub>] and '''Z'''[''r''<sub>2</sub>], where ''r''<sub>1</sub> and ''r''<sub>2</sub> are complex roots of the polynomials ''f'' and ''g''. Since ''f'' is of degree ''d'' with integer coefficients, if ''a'' and ''b'' are integers, then so will be ''b''<sup>''d''</sup>·''f''(''a''/''b''), which we call ''r''. Similarly, ''s'' = ''b''<sup>''e''</sup>·''g''(''a''/''b'') is an integer. The goal is to find integer values of ''a'' and ''b'' that simultaneously make ''r'' and ''s'' [[smooth number|smooth]] relative to the chosen basis of primes. If ''a'' and ''b'' are small, then ''r'' and ''s'' will be small too, about the size of ''m'', and we have a better chance for them to be smooth at the same time. The current best-known approach for this search is [[lattice sieving]]; to get acceptable yields, it is necessary to use a large factor base. Having enough such pairs, using [[Gaussian elimination]], one can get products of certain ''r'' and of the corresponding ''s'' to be squares at the same time. A slightly stronger condition is needed—that they are [[field norm|norms]] of squares in our number fields, but that condition can be achieved by this method too. Each ''r'' is a norm of ''a'' − ''r''<sub>1</sub>''b'' and hence that the product of the corresponding factors ''a'' − ''r''<sub>1</sub>''b'' is a square in '''Z'''[''r''<sub>1</sub>], with a "square root" which can be determined (as a product of known factors in '''Z'''[''r''<sub>1</sub>])—it will typically be represented as an irrational [[algebraic number]]. Similarly, the product of the factors ''a'' − ''r''<sub>2</sub>''b'' is a square in '''Z'''[''r''<sub>2</sub>], with a "square root" which also can be computed. It should be remarked that the use of Gaussian elimination does not give the optimal run time of the algorithm. Instead, sparse matrix solving algorithms such as [[Block Lanczos algorithm for nullspace of a matrix over a finite field|Block Lanczos]] or [[Block Wiedemann algorithm|Block Wiedemann]] are used. Since ''m'' is a root of both ''f'' and ''g'' mod ''n'', there are [[homomorphism]]s from the rings '''Z'''[''r''<sub>1</sub>] and '''Z'''[''r''<sub>2</sub>] to the ring '''Z/nZ''' (the integers [[Modular arithmetic|mod ''n'']]), which map ''r''<sub>1</sub> and ''r''<sub>2</sub> to ''m'', and these homomorphisms will map each "square root" (typically not represented as a rational number) into its integer representative. Now the product of the factors ''a'' − ''mb'' mod ''n'' can be obtained as a 