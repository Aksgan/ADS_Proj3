The [[C (programming language)|C programming language]] is typesafe in limited contexts; for example, a compile-time error is generated when an attempt is made to convert a pointer to one type of structure to a pointer to another type of structure, unless an explicit cast is used. However, a number of very common operations are non-typesafe; for example, the usual way to print an integer is something like <code>printf("%d", 12)</code>, where the <code>%d</code> tells <code>printf</code> at run-time to expect an integer argument. (Something like <code>printf("%s", 12)</code>, which erroneously tells the function to expect a pointer to a character-string, will be accepted by compilers, but will produce undefined results.) In addition, C, like Ada, provides unspecified or undefined explicit conversions; and unlike in Ada, idioms that use these conversions are very common, and have helped to give C a type-unsafe reputation. For example, the standard way to allocate memory on the heap is to invoke a memory allocation-function (<code>malloc</code>) with an argument indicating how many bytes are required. The function returns an untyped pointer (type <code>void *</code>), which the calling code must cast to the appropriate pointer type. Expressions such as <code>(struct foo *) malloc(sizeof(struct foo))</code> are therefore quite common. ===C++=== [[C++]] is more type-safe than C when used properly{{Citation needed|date=June 2010}} (avoiding the use of void pointers and casting between pointers of two types). Features of C++ that promote code that is less at risk of type errors include: * The [[new (C++)|new operator]] returns a pointer of a specific type based on the operand, versus the void pointer from C's [[malloc]]. * Certain code written in C that uses void pointers can be rewritten using [[Template (programming)|C++ templates]] to give a type to an argument whose type is variable. * Additional casting operators such as [[dynamic_cast]], which allow for more specific checks than a C [[static cast]]. ===C#=== [[C Sharp (programming language)|C#]] is type-safe. It has support for untyped pointers, but this must be accessed using the "unsafe" keyword which can be prohibited at the compiler level. It has inherent support for run-time cast validation. Casts can be validated by using the "as" keyword that will return a null reference if the cast is invalid, or by using a C-style cast that will throw an exception if the cast is invalid. See [[C_Sharp_Syntax#Conversion_operators|C Sharp Conversion Operators]]. Undue reliance on the [[C_Sharp_syntax#object class|object]] type (from which all other types are derived) runs the risk of defeating the purpose of the C# type system. It is usually better practice to abandon object references in favour of [[Generic programming#Generic programming in .NET|generics]], similar to templates in C++ and [[generics in Java]]. ===Cyclone=== [[Cyclone_(programming_language)| Cyclone]] is a type-safe language. It does not require a virtual machine or garbage collection to achieve type safety during runtime. The syntax is very similar to C. ===Standard ML=== {{Wikibooks|Standard ML Programming}} [[Standard ML|SML]] has rigorously defined semantics and is known to be type-safe. However, some implementations of SML, including [[Standard ML of New Jersey]] (SML/NJ), its syntactic variant [[Mythryl]] and [[Mlton]], provide libraries that offer certain unsafe operations. These facilities are often used in conjunction with those implementations' [[foreign function interface]]s to interact with non-ML code (such as C libraries) that may require data laid out in specific ways. Another example is the SML/NJ [[read-eval-print loop|interactive toplevel]] itself, which must use unsafe operations to execute ML code entered by the user. ===Pascal=== {{Wikibooks|Pascal Programming}} [[Pascal (programming language)|Pascal]] has had a number of type safety requirements, some of which are kept in some compilers. Where a Pascal compiler dictates "strict typing", two variables cannot be assigned to each other unless they are either compatible (such as conversion of integer to real) or assigned to the identical subtype. For example, if you have the following code fragment: <source lang="pascal"> type TwoTypes = record I: Integer; Q: Real; end; DualTypes = record I: Integer; Q: Real; end; var T1, T2: TwoTypes; D1, D2: DualTypes; </source> Under strict typing, a variable defined as <tt>TwoTypes</tt> is ''not compatible'' with <tt>DualTypes</tt> (because they are not identical, even though the components of that user defined type are identical) and an assignment of <tt> T1 := D2; </tt> is illegal. An assignment of <tt>T1 := T2; </tt> would be legal because the subtypes they are defined to ''are'' identical. However, an assignment such as <tt>T1.Q := D1.Q;</tt> would be legal. ==Examples== The following simple C++ program illustrates that C++ permits operations that are quite type-unsafe: <source lang="cpp"> #include <iostream> using namespace std; int main() { int ival = 5; // A four-byte integer (on most processors) void *pval = &ival; // Store the address of ival in an untyped pointer double dval = *((double*)pval); // Convert it to a double pointer and get the value at that address cout << dval << endl; // Output the double (this will be garbage and not 5!) return 0; } </source> Even though <tt>pval</tt> does contain the correct address of <tt>ival</tt>, when <tt>pval</tt> is cast from a <tt>void</tt> pointer to a <tt>double</tt> pointer the resulting double value is not 5, but an undefined garbage value. On the machine code level, this program has explicitly prevented the processor from performing the correct conversion from a four-byte integer to an eight-byte floating-point value. When the program is run it will output a garbage floating-point value and possibly raise a memory exception. Thus, C++ (and C) allow type-unsafe code. The next example shows a slightly more complex type safety issue in C++ involving object pointer conversion. <source lang="cpp"> #include <iostream> using namespace std; class Parent {}; class Child1 : public Parent { public: int a; }; class Child2 : public Parent { public: double b; }; int main() { Child1 c1; c1.a = 5; Child2 c2; c2.b = 2.4; Parent *p = &c1; // Down-conversion is safe Child1 *pc1 = (Child1*)p; // Up-conversion is not safe cout << pc1->a << endl; // ...but this time it's okay p = &c2; // Safe pc1 = (Child1*)p; // Not safe cout << pc1->a << 