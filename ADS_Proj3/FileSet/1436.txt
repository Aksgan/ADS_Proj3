[[Filmbox]] software. FiLMBOX was designed for users to capture motion data from [[motion capture]] devices. Prior to 1996, FiLMBOX 1.0 used .FLM as its file format. This format only supported motion data, users' preferences and a list of devices used in the capturing of the motion data. This data was a [[Serial communication|serialized]] version of the libraries (binary dump), containing read/write memory data. Because the data was written in this format, problems would eventually arise in supporting legacy files with upcoming FiLMBOX releases. Parallel to this issue, there was an immediate demand from the early-adopting users of FiLMBOX for Kaydara to implement a target character in a scene with the motion capture data, so as to enable the visualization of the data in a 3D view with display markers. In order to support this request, Kaydara had enough reasons to go ahead and change FiLMBOX' native file format. To separate itself from the FLM file extension name, Kaydara decided upon "FBX" (an abbreviation for the FiLMBOX product name). FBX was therefore born in 1996, with the release of FiLMBOX 1.5. This new file format was an [[object-based]] model, allowing for the storing of motion data along with 2D, 3D, audio, and video data. The support for other software packages started with SoftImage 3D, Alias|Wavefront [[PowerAnimator]], NewTek [[LightWave]], Kinetix [[3D Studio MAX]] and the Unity game engine. Years passed, more releases were supported by the format and FiLMBOX was renamed to MotionBuilder, with its 4.0 release in 2002. Kaydara launched FBX for Apple's [[QuickTime]] Viewer in 2003. [[Alias Systems Corporation|Alias]] announced its intention to acquire Kaydara on August 8, 2004, sealing the deal in September of the same year. A [[Software Development Kit]] was developed in 2005 to ensure that everyone used the same object model, in turn allowing other software developers to provide plug-ins of their own. Alias was then acquired by [[Autodesk]] on January 10, 2006. There have been numerous optimizations made to the FBX object model since then, most notably in 2005 in regards to how the data is stored and in 2006 to allow for properties support. As the demands and imagination of 3D artists change over time, the FBX file format continues to evolve. The goal of the FBX technology is to constantly and significantly improve [[interoperability]] between Autodesk products and other [[Digital content creation]] (DCC) software packages. ==Limitations== Autodesk provides a C++ FBX SDK that can read, write, and convert to/from FBX files. The FBX file format is proprietary, however, the format description is exposed in the FBX Extensions SDK which provides source code for the FBX readers and writers. Currently there are 2 FBX SDK bindings one for C++ and Python supplied by Autodesk. [[Blender (software)|Blender]] includes a Python export script for FBX<ref name="Blender">{{cite web | url = http://wiki.blender.org/index.php/Extensions:Py/Scripts/Manual/Export/FBX| title = FBX| accessdate = 2009-12-26 | first =Erwin Coumans| date = 2009-12-26 | publisher = Blender Foundation| quote = Export selected objects to Autodesks .FBX file format. }}</ref> and [[The_OpenEnded_Group| OpenEndedGroup's Field]] includes a Java based library for loading and extracting interesting parts from a FBX file <ref name="Field">{{cite web | url =http://openendedgroup.com/field/wiki/LoadingFBXFiles| title = Loading FBX files| accessdate = 2009-12-26 | first =Erwin Coumans| date = 2009-12-26 | publisher = OpenEndedGroup| quote = Field's comes with a Java-based library for loading, and hacking the interesting parts out of, FBX files. }}</ref>. FBX SDK is designed with interactive desktop applications in mind, and does not have much functionality useful in server (web, virtual worlds, etc) applications. In particular, there is no support for data streaming - the whole scene has to be loaded together. Current version of FBX SDK (2011.3.1) supports Microsoft Visual Studio 2010. ==External links== *http://www.autodesk.com/fbx ==See also== * [[COLLADA]] ==References== {{refs}} {{DEFAULTSORT:Fbx}} [[Category:3D graphics software]] {{graphics-software-stub}} [[fr:FBX]] [[ru:FBX]]</text> </page> <page> <id>13033</id> <title>FCMOV</title> <text>'''FCMOV''' is a '''f'''loating point '''c'''onditional '''mov'''e [[opcode]] of the [[Intel]] [[x86]] architecture, first introduced in [[Pentium Pro]] processors. It copies the contents of one of the floating point stack register, depending on the contents of [[FLAGS register (computing)|EFLAGS]] integer flag register, to the ST(0) (top of stack) register. There are 8 variants of the instruction selected by the condition codes that need be set for the instruction to perform the move. Similar to the [[CMOV]] instruction, FCMOV allows to perform some conditional operations without the usual [[Branch (computer science)|branching]] overhead.<ref name="x86ref">''Intel Architecture Software Developer Manual, Volume 2: Instruction Set Reference.'' Available for download at [http://www.intel.com/design/intarch/manuals/243191.htm]</ref> However, it has a higher [[Latency (engineering)|latency]] than conditional branch instructions.<ref name="assembly">Fog, A: ''Optimizing subroutines in assembly language. An optimization guide for x86 platforms.'' Available for download at [http://www.agner.org/optimize/]</ref> Therefore, it is most useful for simple yet unpredictable comparison or conditional operations, where it can provide substantial performance gains. The instruction is usually used with the [[FCOMI]] instruction or the [[FCOM]]-[[FSTSW]]-[[SAHF]] idiom to set the relevant condition codes based on the result of a floating point comparison. ==Variants== This table shows the variants of the FCMOV instructions.<ref name="x86ref"/> In the Opcode column, i denotes the number of the floating point stack register used as the second operand (the first is always the ST(o) register - the top of the stack). Add it to the given number to obtain the corresponding opcode. {| class="wikitable" !Opcode !Mnemonic !Meaning !Condition |--- |DA C0+i |FCMOVB |Move if below |[[Carry flag]] set |--- |DA C8+i |FCMOVE |Move if equal |Zero flag set |--- |DA D0+i |FCMOVBE |Move if below or equal |Carry flag or Zero flag set |--- |DA D8+i |FCMOVU |Move if unordered |[[Parity flag]] set |--- |DB C0+i |FCMOVNB |Move if not below |Carry flag cleared |--- |DB C8+i |FCMOVNE |Move if not equal |Zero flag cleared |--- |DB D0+i |FCMOVNBE |Move if not below or equal |Carry flag and Zero flag cleared |--- |DB D8+i |FCMOVNU |Move if not unordered |Parity flag cleared |--- |} ==References== {{reflist}} ==External links== * [http://www.x86.org/secrets/opcodes/fcmov.htm Free Dr. Dobb's Microprocessor Resources] * [http://www.agner.org/optimize/ Software Optimization Resources] * [http://www.intel.com/design/intarch/manuals/243191.htm Intel's official instruction set reference download page] [[Category:X86 instructions]]</text> </page> <page> <id>13078</id> 