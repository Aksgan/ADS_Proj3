sometimes called "lazy"<!-- e.g. X-Klaim language: http://music.dsi.unifi.it/download/xklaim.pdf -->. ==Controlling eagerness in lazy languages== In lazy programming languages such as Haskell, although the default is to evaluate expressions only when they are demanded, it is possible in some cases to make code more eager—or conversely, to make it more lazy again after it has been made more eager. This can be done by explicitly coding something which forces evaluation (which may make the code more eager) or avoiding such code (which may make the code more lazy). ''Strict'' evaluation usually implies eagerness, but they are technically different concepts. However, there is an optimisation implemented in some compilers called [[strictness analysis]], which, in some cases, allows the compiler to infer that a value will always be used. In such cases, this may render the programmer's choice of whether to force that particular value or not, irrelevant, because strictness analysis will force strict evaluation. In Haskell, marking constructor fields strict means that their values will always be demanded immediately. The <code>seq</code> function can also be used to demand a value immediately and then pass it on, which is useful if a constructor field should generally be lazy. However, neither of these techniques implements ''recursive'' strictness—for that, a function called <code>deepSeq</code> was invented. Also, pattern matching in Haskell 98 is strict by default, so the <code>~</code> qualifier has to be used to make it lazy. <!-- Please add an example here --> ==Other uses== In computer [[windowing system]]s, the painting of information to the screen is driven by "expose events" which drive the display code at the last possible moment. By doing this, they avoid the computation of unnecessary display content.<ref name="Lampson">[http://research.microsoft.com/en-us/um/people/blampson/slides/lazyandspeculative.ppt Lazy and Speculative Execution] [[Butler Lampson]] [[Microsoft Research]] OPODIS, Bordeaux, France 12 December 2006</ref> Another example of laziness in modern computer systems is [[copy-on-write]] page allocation or [[demand paging]], where memory is allocated only when a value stored in that memory is changed.<ref name="Lampson"/> Laziness can be useful for high performance scenarios. An example is the Unix [[mmap]] functionality. mmap provides "demand driven" loading of pages from disk, so that only those pages actually touched are loaded into memory, and unnecessary memory is not allocated. ==See also== * [[Combinatory logic]] * [[Currying]] * [[Dataflow]] * [[Eager evaluation]] * [[Functional programming]] * [[Futures and promises]] * [[Graph reduction]] * [[Incremental computing]] – a related concept whereby computations are only repeated if their inputs change. May be combined with lazy evaluation. * [[Lambda calculus]] * [[Lazy initialization]] * [[Lookahead]] * [[Short-circuit evaluation|Short-circuit (minimal) evaluation]] * [[Non-strict programming language]] * [[Evaluation strategy#Normal order|Normal order evaluation]] ==References== {{reflist|2}} ==External links== * [http://gnosis.cx/publish/programming/charming_python_b13.html Functional programming in Python becomes lazy] * [http://haskell.org/haskellwiki/Haskell/Lazy_evaluation Lazy evaluation in Haskell] * [http://www.digitalmars.com/d/lazy-evaluation.html Lazy function argument evaluation] in the [[D (programming language)|D programming language]] * [http://nemerle.org/Lazy_evaluation Lazy evaluation macros] in [[Nemerle]] * [http://www-128.ibm.com/developerworks/linux/library/l-lazyprog.html Lazy programming and lazy evaluation] in [[Scheme (programming language)|Scheme]] * [http://www.iolanguage.com/docs/talks/2005-10-OOPSLA/p003-dekorte.pdf Lazy argument evaluation] in [[Io (programming language)|Io programming language]] * [http://groups.google.com/group/comp.lang.c/browse_thread/thread/22211d03c3e0b5c9/f11f83cdbde4eee8 Lazy evaluation list/set processing] in [[C (programming language)|C programming language]] * [http://spirit.sourceforge.net/dl_docs/phoenix-2/libs/spirit/phoenix/doc/html/phoenix/introduction.html Lambda calculus in Boost Libraries] in [[C++ (programming language)|C++ programming language]] * [http://perldesignpatterns.com/?LazyEvaluation Lazy Evaluation] in [[Perl]] * [http://www.genworks.com/downloads/customer-documentation/usage.txt Lazy Evaluation] as implemented in Genworks GDL [[Category:Programming evaluation]] [[Category:Compiler optimizations]] [[Category:Articles with example Haskell code]] [[be:Адкладзеныя вылічэнні]] [[ca:Avaluació tardana]] [[de:Lazy Evaluation]] [[fr:Évaluation paresseuse]] [[it:Valutazione pigra]] [[ko:느긋한 계산법]] [[nl:Luie evaluatie]] [[ja:遅延評価]] [[pl:Wartościowanie leniwe]] [[pt:Avaliação preguiçosa]] [[ru:Отложенные вычисления]] [[fi:Laiska suoritus]] [[tr:Tembel değerlendirme]] [[zh:惰性求值]]</text> </page> <page> <id>21315</id> <title>Lazy inheritance</title> <text>'''Lazy inheritance''' is a [[design pattern (computer science)|design pattern]] used in [[JavaScript]] computer programming. It designates a postponed linking of an object with its [[Prototype-based programming|prototype (class)]] until it is needed. If used properly, such approach may increase efficiency, simplicity and flexibility of [[object-oriented programming|OOP-based]] code written using JavaScript. Since lazy inheritance called only once at the moment of first object instance creation, it seems logical to combine process of class prototype creation with resolving necessary dependencies of that class. The instances of objects in lazy inheritance are created in "mixed" mode — on first invocation, a factory is used to modify class prototype which is later is used for subsequent object instances creation. In other words, the process of prototype construction also allows loading scripts (if ones were not loaded before) which particular class depends on. Such approach to inheritance support has the following benefits: *Lazy inheritance has the same benefits as classical JavaScript prototype features; * It is not necessary to maintain proper order of script files declaration; * In most cases, [[HTML]] page which contains JavaScript is loaded faster since there are no objects created during page initialization and since some scripts could be loaded only at the moment in which they are actually necessary (they are necessary if the caller code during its execution really creates instances of corresponding classes); * Dependencies are declared in more explicit way and class depends only on concrete scripts; Moreover, it's not necessary to artificially group particular scripts into modules and define dependencies between such modules; * If lazy mode of scripts loading is used, only necessary scripts (which are actually required for application functionality) will be loaded. If, for example, some HTML page may operate in different modes, like "read-write" and "read-only", for every mode required scripts will be loaded and this will be performed automatically without manual script loading optimization. == See also == * [[Lazy loading]] * [[Lazy initialization]] == Implementation == * [http://www.soft-amis.org/jsiner JSINER' Lazy inheritance implementation] * [http://sourceforge.net/projects/jsiner JSINER' page on SourceForge] [[Category:Software design patterns]] {{compu-prog-stub}}</text> </page> <page> <id>21327</id> <title>Le Lisp</title> <text>{{Unreferenced|date=May 2009}} '''Le Lisp''' is a [[Lisp programming language|Lisp]] dialect close to [[Common Lisp]]; it is lexically [[scope (programming)|scope]]d, with a [[CLOS]]-like object system and using both packages and modules. It was designed by [[Jerome Chailloux]] and [[Emmanuel St James]] of [[INRIA]]. ==External links== * Current commercial implementation - http://christian.jullien.free.fr/lelisp/ {{FOLDOC}} [[Category:Lisp programming language family]] [[Category:Lisp programming language]] {{compu-lang-stub}}</text> </page> <page> <id>21329</id> <title>Le Ton beau de Marot</title> <text>{{Original research|date=June 2009}} [[Image:Le Ton beau de Marot.bookcover.amazon.jpg|thumb|Book cover]] '''''Le Ton beau de Marot: In Praise of 