are specified: -> Inprocserver32 = object is to be loaded into a process + Path to file/object and readable name HKCR\interface: example: ISTREAM, IRPCSTUB, IMESSAGEFILTER connects to a CLSID. You can specify NUMMETHODS and PROXYSTUB(if web-object) HKCR\typelib One or more CLSID can be grouped into type library. it contains parameters for linking in COM. The rest of the info in the COM parts of the REGISTRY, is to give an application/object a CLSID. ===Reference counting=== The most fundamental COM interface of all, IUnknown (from which all COM interfaces must be derived), supports two main concepts: feature exploration through the '''QueryInterface''' method, and object lifetime management by including '''AddRef()''' and '''Release()'''. Reference counts and feature exploration apply to objects (not to each interface on an object) and thus must have a centralized implementation. The COM specifications require a technique called [[reference counting]] to ensure that individual objects remain alive as long as there are clients which have acquired access to one or more of its interfaces and, conversely, that the same object is properly disposed of when all code that used the object have finished with it and no longer require it. A COM object is responsible for freeing its own memory once its reference count drops to zero. For its implementation, a COM Object usually maintains an integer value that is used for reference counting. When AddRef() is called via any of object's interfaces, this integer value is incremented. When Release() is called, this integer is decremented. AddRef() and Release() are the only means by which a client of a COM object is able to influence its lifetime. The internal integer value remains a private member of the COM object and will never be directly accessible. The purpose of AddRef() is to indicate to the COM object that an additional reference to itself has been affected and hence it is necessary to remain alive as long as this reference is still valid. Conversely, the purpose of Release() is to indicate to the COM object that a client (or a part of the client's code) has no further need for it and hence if this reference count has dropped to zero, it may be time to destroy itself. Certain languages (e.g. Visual Basic) provide automatic reference counting so that COM object developers need not explicitly maintain any internal reference counter in their source codes. Using COM in C, explicit reference counting is needed. In C++, a coder may write the reference counting code or use a [[smart pointer]] that will manage all the reference counting. The following is a general guideline calling AddRef() and Release() to facilitate proper reference counting in COM object:<!--applies to list as well--> *Functions (whether object methods or global functions) that return interface references (via return value or via "out" parameter) should increment the reference count of the underlying object before returning. Hence internally within the function or method, AddRef() is called on the interface reference (to be returned). An example of this is the QueryInterface() method of the IUnknown interface. Hence it is imperative that developers be aware that the returned interface reference has already been reference count incremented and not call AddRef() on the returned interface reference yet another time. *Release() must be called on an interface reference before that interface's pointer is overwritten or goes out of scope. *If a copy is made on an interface reference pointer, AddRef() should be called on that pointer. After all, in this case, we are actually creating another reference on the underlying object. *AddRef() and Release() must be called on the specific interface which is being referenced since an object may implement per-interface reference counts in order to allocate internal resources only for the interfaces which are being referenced. *Extra calls to these functions are not sent out to remote objects over the wire; a proxy keeps only one reference on the remote object and maintains its own local reference count. To facilitate and promote COM development, Microsoft introduced [[Active Template Library|ATL (Active Template Library)]] for C++ developers. ATL provides for a higher-level COM development paradigm. It also shields COM client application developers from the need to directly maintain reference counting, by providing [[smart pointer]] objects. Other libraries and languages that are COM-aware include the [[Microsoft Foundation Classes]], the [[Visual C++|VC]] Compiler COM Support, [[VBScript]], [[Visual Basic]], [[ECMAScript]] ([[JavaScript]]) and [[Borland Delphi]]. ===Instantiation=== COM standardizes the instantiation (i.e. creation) process of COM objects by requiring the use of '''Class Factories'''. In order for a COM object to be created, two associated items must exist:<!--applies to list as well--> * A Class ID. * A Class Factory. Each COM Class or '''CoClass''' must be associated with a unique Class ID (a GUID). It must also be associated with its own Class Factory (that is achieved by using a centralized registry). A Class Factory is itself a COM object. It is an object that must expose the IClassFactory or IClassFactory2 (the latter with licensing support) interface. The responsibility of such an object is to create other objects. A class factory object is usually contained within the same executable code (i.e. the '''server code''') as the COM object itself. When a class factory is called upon to create a target object, this target object's class id must be provided. This is how the class factory knows which class of object to instantiate. A single class factory object may create objects of more than one class. That is, two objects of different class ids may be created by the same class factory object. However, this is transparent to the COM system. By delegating the responsibility of object creation into a separate object, a greater level of abstraction is promoted, and the developer is given greater flexibility. For example, implementation of the '''Singleton''' and other creation patterns is facilitated. Also, the calling application is shielded from the COM object's memory allocation semantics by the factory object. In order for client applications to be able to acquire class factory objects, COM servers must 