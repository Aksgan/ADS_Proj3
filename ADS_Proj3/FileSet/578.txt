exception, execution of the block is discontinued and the exception is handled by the <code>catch</code> block. There may be multiple <code>catch</code> blocks, in which case the first block with an exception variable whose type matches the type of the thrown exception is executed. If no <code>catch</code> block matches the type of the thrown exception, the execution of the outer block (or method) containing the <code>try</code> ... <code>catch</code> statement is discontinued, and the exception is passed up and outside the containing block (or method). The exception is propagated upwards through the [[call stack]] until a matching <code>catch</code> block is found within one of the currently active methods. If the exception propagates all the way up to the top-most <code>Main()</code> method without a matching <code>catch</code> block being found, the entire program is terminated and a textual description of the exception is written to the standard output stream. The statements within the <code>finally</code> block are always executed after the <code>try</code> and <code>catch</code> blocks, whether or not an exception was thrown. Such blocks are useful for providing clean-up code that is guaranteed to always be executed. The <code>catch</code> and <code>finally</code> blocks are optional, but at least one or the other must be present following the <code>try</code> block. ==Types== C# is a strongly-typed language like C++. That means that every variable and constant get a fixed type when they are being declared. There are two kinds of types: ''value types'' and ''reference types''. ===Value types=== Instances of value types reside on the stack, i.e. they are bound to their variables. If you declare a variable for a value type the memory gets allocated directly. If the variable gets out of scope the object is destroyed with it. ====Structures==== Structures are more commonly known as ''structs''. Structs are user-defined value types that are declared using the <code>struct</code> keyword. They are very similar to classes but are more suitable for lightweight types. Some important syntactical differences between a <code>class</code> and a <code>struct</code> are presented later in this article. <source lang="csharp"> struct Foo { ... } </source> The primitive data types are all structs. =====Pre-defined types===== These are the primitive datatypes. {| class="wikitable" |- !colspan="6"|Primitive Types |- ! Type Name ! [[Base Class Library|BCL]] Equivalent ! Value ! Range ! Size ! Default Value |- | <code>sbyte</code> | <code>System.SByte</code> | integer | −128 through +127 | 8-bit (1-byte) | <code>0</code> |- | <code>short</code> | <code>System.Int16</code> | integer | −32,768 through +32,767 | 16-bit (2-byte) | <code>0</code> |- | <code>int</code> | <code>System.Int32</code> | integer | −2,147,483,648 through +2,147,483,647 | 32-bit (4-byte) | <code>0</code> |- | <code>long</code> | <code>System.Int64</code> | integer | −9,223,372,036,854,775,808 through<br/> +9,223,372,036,854,775,807 | 64-bit (8-byte) | <code>0</code> |- | <code>byte</code> | <code>System.Byte</code> | unsigned integer | 0 through 255 | 8-bit (1-byte) | <code>0</code> |- | <code>ushort</code> | <code>System.UInt16</code> | unsigned integer | 0 through 65,535 | 16-bit (2-byte) | <code>0</code> |- | <code>uint</code> | <code>System.UInt32</code> | unsigned integer | 0 through 4,294,967,295 | 32-bit (4-byte) | <code>0</code> |- | <code>ulong</code> | <code>System.UInt64</code> | unsigned integer | 0 through 18,446,744,073,709,551,615 | 64-bit (8-byte) | <code>0</code> |- | <code>decimal</code> | <code>System.Decimal</code> | signed decimal number | −7.9228162514264337593543950335 through<br/> +7.9228162514264337593543950335 <!--IS THIS CORRECT?--> | 128-bit (16-byte) | <code>0.0</code> |- | <code>float</code> | <code>System.Single</code> | floating point number | ±1.401298E−45 through ±3.402823E+38 | 32-bit (4-byte) | <code>0.0</code> |- | <code>double</code> | <code>System.Double</code> | floating point number | ±4.94065645841246E−324 through<br/> ±1.79769313486232E+308 | 64-bit (8-byte) | <code>0.0</code> |- | <code>bool</code> | <code>System.Boolean</code> | Boolean | <code>true</code> or <code>false</code> | 8-bit (1-byte) | <code>false</code> |- | <code>char</code> | <code>System.Char</code> | single Unicode character | <code>'\u0000'</code> through <code>'\uFFFF'</code> | 16-bit (2-byte) | <code>'\u0000'</code> |} '''Note:''' <code>string</code> (<code>System.String</code>) is not a struct and is not a primitive type. ====Enumerations==== Enumerated types (<code>enums</code>) are named values representing integer values. <source lang="csharp"> enum Season { Winter = 0, Spring = 1, Summer = 2, Autumn = 3, Fall = Autumn //Autumn is called Fall in American English. } </source> <code>enum</code> instances are declared as ordinary variables and are initialized by default to zero. They can be assigned or initialized to the named values defined by the enumeration type. <source lang="csharp"> Season season; season = Season.Spring; </source> <code>enum</code> types variables are basically integer values. That means that addition and subtraction between variables of the same type is allowed without any specific cast but multiplication and division is somewhat more risky and requires it explicitly. Casts are also required to and from integer types. It will however throw an exception if the value is not allowed. <source lang="csharp"> season = (Season)2; //2 to an enum-value of type Season. season = season + 1; //Adds 1 to the value. season = season + season2; //Adding the values of two variables. int value = (int)season; //Casting enum-value to integer value. season++; //Season.Spring (1) becomes Season.Summer (2). season--; //Season.Summer (2) becomes Season.Spring (1). </source> Values can be combined using the bitwise-OR operator, ''|''. <source lang="csharp"> Color myColors = Color.Green | Color.Yellow | Color.Blue; </source> '''See also''' * [[Enumeration (programming)]] ===Reference types=== Variables created for reference types are typed managed references. When the constructor is called an object is created on the heap and a reference is assigned to the variable. When a variable of an object gets out of scope the reference is broken and when there are no references left the object gets marked as garbage. The garbage collector will then soon collect and destroy it. A reference variable is <code>null</code> when it does not reference any object. ====Arrays==== An [[array (programming)|array]] type is a reference type that refers to a space containing one or more elements of a certain type. All array types derive from a common base class, <code>System.Array</code>. Each element is referenced by its index just like in C++ and Java. An array in C# is what would be called a [[dynamic array]] in C++. <source lang="csharp"> int[] numbers = new int[5]; numbers[0] = 2; numbers[1] = 5; int x = numbers[0]; </source> =====Initializers===== Array initializers provide convenient syntax for initialization of arrays. <source lang="csharp"> //Long syntax int[] 