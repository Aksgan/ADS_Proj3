Next (read inner to outer, left to right) the code we examined earlier returns the labelWidget. Finally the widget is sent into the draw slot of the [[active window]]. === Inheritance/Delegation === {{main|delegation (computer science)}} In theory, every Self object is a stand-alone entity. Self has neither classes nor meta-classes. Changes to a particular object don't affect any other, but in some cases it is desirable if they did. Normally an object can understand only messages corresponding to its local slots, but by having one or more slots indicating ''parent'' objects, an object can '''delegate''' any message it doesn't understand itself to the parent object. Any slot can be made a parent pointer by adding an asterisk as a suffix. In this way Self handles duties that would use [[inheritance (computer science)|inheritance]] in class-based languages. Delegation can also be used to implement features such as [[namespace (computer science)|namespace]]s and [[lexical scoping]]. For example, suppose an object is defined called "bank account", that is used in a simple book keeping application. Usually, this object would be created with the methods inside, perhaps "deposit" and "withdraw", and any data slots needed by them. This is a prototype, which is only special in the way it is used since it also happens to be a fully functional bank account. ===Traits=== Making a clone of this object for "Bob's account" will create a new object which starts out exactly like the prototype. In this case we have copied the slots including the methods and any data. However a more common solution is to first make a more simple object called a [[trait (abstract data type)|traits object]] which contains the items that one would normally associate with a class. In this example the "bank account" object would not have the deposit and withdraw method, but would have as a parent an object that did. In this way many copies of the bank account object can be made, but we can still change the behaviour of them all by changing the slots in that root object. How is this any different from a traditional class? Well consider the meaning of: myObject parent: someOtherObject. This excerpt changes the "class" of myObject at runtime by changing the value associated with the 'parent*' slot (the asterisk is part of the slot name, but not the corresponding messages). Unlike with inheritance or lexical scoping, the delegate object can be modified at runtime. === Adding slots === Objects in Self can be modified to include additional slots. This can be done using the graphical programming environment, or with the primitive '_AddSlots:'. A '''primitive''' has the same syntax as a normal keyword message, but its name starts with the underscore character. The _AddSlots primitive should be avoided because it is a left over from early implementations. However, we will show it in the example below because it makes the code shorter. An earlier example was about refactoring a simple class called Vehicle in order to be able to differentiate the behaviour between cars and trucks. In Self one would accomplish this with something like this: _AddSlots: (| vehicle <- (|parent* = traits clonable|) |). Since the receiver of the '_AddSlots:' primitive isn't indicated, it is "self". In the case of expressions typed at the prompt, that is an object called the "lobby". The argument for '_AddSlots:' is the object whose slots will be copied over to the receiver. In this case it is a literal object with exactly one slot. The slot's name is 'vehicle' and its value is another literal object. The "<-" notation implies a second slot called 'vehicle:' which can be used to change the first slot's value. The "=" indicates a constant slot, so there is no corresponding 'parent:'. The literal object that is the initial value of 'vehicle' includes a single slot so it can understand messages related to cloning. A truly empty object, indicated as (| |) or more simply as (), cannot receive any messages at all. vehicle _AddSlots: (| name <- 'automobile'|). Here the receiver is the previous object, which now will include 'name' and 'name:' slots in addition to 'parent*'. _AddSlots: (| sportsCar <- vehicle copy |). sportsCar _AddSlots: (| driveToWork = (''some code, this is a method'') |). Though previously 'vehicle' and 'sportsCar' were exactly alike, now the latter includes a new slot with a method that the original doesn't have. Methods can only be included in constant slots. _AddSlots: (| porsche911 <- sportsCar copy |). porsche911 name:'Bobs Porsche'. The new object 'porsche911' started out exactly like 'sportsCar', but the last message changed the value of its 'name' slot. Note that both still have exactly the same slots even though one of them has a different value. == The environment == One feature of Self is that it is based on the same sort of [[virtual machine]] system that earlier Smalltalk systems used. That is, programs are not [[standalone software|stand-alone]] entities as they are in languages such as [[C (programming language)|C]], but need their entire memory environment in order to run. This requires that applications be shipped in chunks of saved memory known as ''snapshots'' which tend to be large and unwieldy. {{Fact|date=February 2007}} However, due to this, the Self environment can provide powerful debugging tools. One can stop programs at any point, change values and code, and continue running where one left off. This sort of "on the fly" development delivers greater productivity. {{Fact|date=February 2007}} In addition, the environment is tailored to the rapid and continual change of the objects in the system. Refactoring a "class" design is as simple as dragging methods out of the existing ancestors into new ones. Simple tasks like test methods can be handled by making a copy, dragging the method into the copy, then changing it. Unlike traditional systems, only the changed object has the new code, and nothing has to be rebuilt in order to test it. If the method works, it can simply be dragged back into the ancestor. ===Performance=== Self VMs achieved 