''DYRC'' and the entry number is 01.]] The entry is then shown with a [[video projector]] and [[Public address|PA system]]; in case of music, through its specific replayer with the compo slide staying on screen (although some parties prefer to show the module patterns in case of [[tracking|tracked music]]); and in case of graphics, through an image viewer program ([[Breakpoint demo party|Breakpoint]] expanded this tradition by also zooming inside the picture to reveal technical details for the trained eye). [[Applause]] is always awarded for an entry after it was shown, even if it was a below-average quality entry by someone who never created a production before; it is usually the actual effort behind the production that's awarded. It is not uncommon to hear applause during the display of a demo or intro when a remarkable effect is shown; this type of display of respect is generally considered a huge achievement and is highly regarded by the creators. After the compo, visitors are given the opportunity to vote. Voting methods are versatile, and often vary between parties: some parties prefer the "oldskool" paper votesheets, others only allow voting through the party-LAN, using votekeys handed out to the audience. To avoid mass-votes by individuals, a votesheet or votekey is usually only handed out to a visitor in exchange of a mark on the ticket, such as tickmark or the removal of the wristband. Votes, usually done via either [[preferential voting]] or [[range voting]], are calculated after the voting deadline, which is usually some hours after the last compo. ([[Assembly demo party|Assembly]] is a curiosity in this case; due to the amount of compos at the party, ASM traditionally holds two voting deadlines and two prizegivings.) After the votes have been counted, a prizegiving ceremony is issued where the prizes are awarded to the winners; prizes usually consist of hardware and software, rarely cash and often some sort of [[memorabilia]] of the party, such as medals, trophies or printed diplomas. [[Fastcompo]]s are a common form of entertainment at demoparties. Unlike regular compos, fastcompos are announced at the party, usually only a few hours to a day before the deadline, and often have some design or theme limitations. Fastcompos may be held for music, graphics, demos and anything else regular compos are. [[Category:Demoscene]] [[fi:Kompo]] [[sv:Compo]]</text> </page> <page> <id>7319</id> <title>Component-Integrated ACE ORB</title> <text>The '''Component-Integrated ACE ORB''' ('''CIAO''') is a [[CORBA]] Component Model (CCM) implementation built on top of [[TAO (software)|TAO]]. CIAO is currently aiming to provide component-oriented paradigm to the distributed, real-time, embedded (DRE) system developers by abstracting DRE-critical systemic aspects, such as [[Quality of Service|QoS]] requirements, [[Real-time computing|RT]] policies, as installable/configurable units supported by the component framework. Promoting these DRE-critical aspects as first-class metadata disentangles code for controlling these non-function aspects from application logic and makes DRE system development more flexible. Since mechanisms to support various DRE-critical non-functional aspects can be easily verified, CIAO will also make configuring and managing these aspects easier. ==See also== *[[TAO (software)|TAO]] ==External links== *[http://www.cs.wustl.edu/~schmidt/CIAO.html CIAO Homepage] *[http://download.dre.vanderbilt.edu Download CIAO] [[Category:Application programming interfaces]] {{compu-prog-stub}}</text> </page> <page> <id>7321</id> <title>Component-based software engineering</title> <text>{{Cleanup-rewrite|date=September 2009}} {{Merge to|modular programming|discuss=Talk:object (computer science)#Merge section into modular programming|date=September 2009}}<!-- this article should be merged with modular programming which is what it is essentially about with perhaps a redirection from component-based_software engineering --> [[Image:Component-based Software Engineering (CBSE) - example 1.svg|thumb|0|A simple example of two components expressed in [[Unified Modeling Language|UML]] 2.0. The checkout component, responsible for facilitating the customer's order, ''requires'' the card processing component to charge the customer's credit/debit card (functionality which the latter ''provides'').]] {{Programming paradigms}} '''Component-based software engineering (CBSE)''' (also known as '''component-based development (CBD)''') is a branch of [[software engineering]] which emphasizes the [[separation of concerns]] in respect of the wide-ranging functionality available throughout a given software system. This practice aims to bring about an equally wide-ranging degree of benefits in both the short-term and the long-term for the software itself and for organizations that sponsor such software. Software engineers regard components as part of the starting platform for [[service-orientation]]. Components play this role, for example, in [[Web Services]], and more recently, in [[Service-oriented architecture|Service-Oriented Architecture (SOA)]] - whereby a component is converted{{By whom|date=February 2010}} into a ''service'' and subsequently inherits further characteristics beyond that of an ordinary component. Components can produce events or consume events and can be used for [[event driven architecture]] (EDA). == Definition and characteristics of components == An individual component is a software package, a [[web service]], or a [[Modular programming|module]] that encapsulates a set of related functions (or data). All system processes are placed into separate components so that all of the data and functions inside each component are semantically related (just as with the contents of classes). Because of this principle, it is often said that components are ''modular'' and ''cohesive''. With regard to system-wide co-ordination, components communicate with each other via ''interfaces''. When a component offers services to the rest of the system, it adopts a ''provided'' interface which specifies the services that other components can utilize, and how they can do so. This interface can be seen as a signature of the component - the client does not need to know about the inner workings of the component (implementation) in order to make use of it. This principle results in components referred to as ''encapsulated''. The [[Unified Modeling Language|UML]] illustrations within this article represent provided interfaces by a lollipop-symbol attached to the outer edge of the component. However when a component needs to use another component in order to function, it adopts a ''used'' interface which specifies the services that it needs. In the UML illustrations in this article, ''used interfaces'' are represented by an open socket symbol attached to the outer edge of the component. [[Image:Component-based Software Engineering (CBSE) - example 2.gif|thumb|350px|left|A simple example of several software components - pictured within a hypothetical holiday-reservation system represented in [[Unified Modeling Language|UML]] 2.0.]] Another important attribute of components is that they are ''substitutable'', so that a component can replace another (at design time or run-time), 