EAX register.<br /> '''movzx eax, BYTE PTR [esi]''' ; this is the correct notation if the programmer wishes to zero extend a BYTE into a 32 bit register. ===Limited Type Checking=== From at least version 6.0, ML.EXE has supported a pseudo high level notation for creating procedures that perform argument size and count checking. It is part of a system using the '''PROC ENDP PROTO''' and '''INVOKE''' operators. The '''PROTO''' operator is used to define a function prototype that has a matching '''PROC''' that is terminated with the '''ENDP''' operator. The prototyped procedure can then be called with the '''INVOKE''' operator which is protected by the limited size and argument count checking. There is additional notation at a more advanced level for turning off the automatically generated stack frame for the procedure where stack overhead in the procedure call may have an effect with very small procedures. ML.EXE is also capable of being written completely free of the pseudo high level notation using only bare Intel mnemonics. Using an example prototype from the 32 bit [[Windows API]] function set, SendMessage '''PROTO''' STDCALL :DWORD,:DWORD,:DWORD,:DWORD SendMessage equ <SendMessageA> The code to call this function using the '''INVOKE''' notation is as follows. '''invoke SendMessage,hWin,WM_COMMAND,wParam,lParam''' Which is translated exactly to, '''push lParam''' '''push wParam''' '''push WM_COMMAND''' '''push hWin''' '''call SendMessage''' The advantage of the '''INVOKE''' method is that it tests the size of the data types and the argument count and generates an assembly time error if the arguments do not match the prototype. Note that ML64.EXE does not currently support the '''INVOKE''' notation and may not in the future. Based on Microsoft's history of updating earlier versions of ML.EXE on a needs basis for their own internal usage, this feature set may not be developed unless they have a need to add it. ===Calling Conventions=== ML.EXE supports a number of different calling conventions on both the 16 bit real mode DOS operating system, the 16 bit Windows versions and the later 32 bit versions. ML.EXE supports the '''C''', '''SYSCALL''', '''STDCALL''', '''BASIC''', '''FORTRAN''' and '''PASCAL''' [[x86 calling conventions|calling conventions]].<ref>ALANG.HLP standard installation Masm 6.11d</ref> ===Pseudo High Level Emulation=== ML.EXE provides a notation to emulate a variety of high level control and loop structures.<br /> It supports the '''.IF''' block structure, '''.if''' - '''.elseif''' - '''.else''' - '''.endif''' It also supports the '''.WHILE''' loop structure, '''.while eax > 0''' '''sub eax, 1''' '''.endw''' And the '''.REPEAT''' loop structure. '''.repeat''' '''sub eax, 1''' '''.until eax''' < 1 The high level emulation also supports C runtime comparison operators that work according to the same rules as Intel mnemonic comparisons.<ref>http://www.intel.com/products/processor/manuals/</ref> For the .IF block notation the distinction between SIGNED and UNSIGNED data is handled with a minor data type notation variation; the storage size DWORD, (which is by default UNSIGNED) can also be specified as SDWORD for SIGNED comparison. This data type distinction is only appropriate for the pseudo high level notation. It is unused at the mnemonic level of code where the distinction is determined by the range of conditional evaluation techniques available in the Intel mnemonics. The combined pseudo high level emulation allows MASM to more easily interface with the later current operating systems that use a C style application programming interface.<ref>http://msdn.microsoft.com/en-us/library/default.aspx</ref> Generally the pseudo high level interface is used for non-speed critical code where clarity and readability are the most important factors, speed critical code is usually written in directly in mnemonics. Note that ML64.EXE does not support all of the earlier pseudo high level notation and may not in the future. Based on Microsoft's history of updating earlier versions of ML.EXE on a needs basis for their own internal usage, this feature set may not be developed unless they have a need to add it. ===Pre-Processor=== The Microsoft assembler has a very powerful pre-processor that has considerably more functionality than modern C compilers which is consistent with its designation as a '''macro assembler''' and it has been designed from the introduction of ML.EXE version 6.0 with C style pseudo high level functionality for programmers who prefer to use this style of notation for code that is not speed critical. On the down side the pre-processor is an old design that is known to be quirky in its operation and reasonably difficult to use without a lot of experience when writing macros that are of a more complex nature. At their simplest macros written for the ML.EXE pre-processor are useful for automating many different simple tasks. ; ---------------------------- ; memory to memory assignment ; ---------------------------- m2m MACRO M1, M2 push M2 pop M1 ENDM ; -------------------------------------------------- ; memory to memory assignment using the EAX register ; -------------------------------------------------- mrm MACRO m1, m2 mov eax, m2 mov m1, eax ENDM Using the '''EXITM <return item>''' notation a macro can return a value or register in a way that can used similar to a high level function call. Using a very simple example, addregs32 MACRO reg1, reg2 add reg1, reg2 EXITM <reg1> ENDM In the '''.CODE''' section. mov ecx, 16 mov edx, 8 mov eax, addregs32(ecx, edx) Which disassembles exactly to the following mnemonics. 0040102B B910000000 mov ecx,10h 00401030 BA08000000 mov edx,8 00401035 03CA add ecx,edx 00401037 8BC1 mov eax,ecx At a slightly more complex level the pre-processor can be used to emulate higher level languages which allows non-critical code to be simplified for higher programming throughput. '''fn''' MessageBox,0,'''str$'''(eax),"Title",MB_OK<ref>MASM32 Main macro file '''MACROS.ASM'''</ref> In this working example '''fn''' is a macro that encapsulates the INVOKE notation and adds functionality so that quoted text can be inserted directly into the API function call in much the same way as a high level language. The '''str$()''' macro is an emulation of traditional basic for converting numeric data as either a memory operand or a register into string data for display. ==Object Module Compatibility== The 32 bit versions of ML.EXE introduced with the patches for the last commercial version onwards produce object modules in both the older OMF format and the Microsoft version of the '''Portable Executable'''<ref>http://download.microsoft.com/download/e/b/a/eba1050f-a31d-436b-9281-92cdfeae4b45/pecoff.doc</ref><ref>http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx</ref> specification [[COFF]] format. The object 