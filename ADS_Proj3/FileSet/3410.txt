new system for allocating RAM and defragmenting physical memory. It still uses flat shared address space that can not be defragmented. It is based on [[Slab allocation|slab allocation method]] and paging memory that allows swapping.<ref>{{cite web |url=http://os4.hyperion-entertainment.biz/index.php%3Foption=content&task=view&id=22&Itemid=.html |title=AmigaOS4.0 Memory Allocation |author=Frieden brothers |publisher=[[Hyperion Entertainment]] |date=[[2007]] |accessdate=2008-11-02 }} {{Dead link|date=September 2010|bot=H3llBot}}</ref> <ref>{{cite web |url=http://os4.hyperion-entertainment.biz/index.php%3Foption=content&task=view&id=23&Itemid=.html |title=AmigaOS 4.0 new memory system revisited |author=Frieden brothers |publisher=[[Hyperion Entertainment]] |date=[[2007]] |accessdate=2008-11-02 }} {{Dead link|date=September 2010|bot=H3llBot}}</ref> Paging was finally implemented in [[AmigaOS 4.1]]. Swap memory could be activated and deactivated any moment allowing the user to choose to use only physical RAM. ==Performance== The backing store for a virtual memory operating system is typically many orders of [[magnitude (mathematics)|magnitude]] slower than [[random access memory|RAM]]. Additionally, using mechanical storage devices introduces [[Access time|delay]], several milliseconds for a harddisk. Therefore it is desirable to reduce or eliminate swapping, where practical. Some operating systems offer settings to influence the kernel's decisions. # Linux offers the <code>/proc/sys/vm/swappiness</code> parameter, which changes the balance between swapping out runtime memory, as opposed to dropping pages from the system [[page cache]]. # Windows 2000, XP, and Vista offer the <code>DisablePagingExecutive</code> registry setting, which controls whether kernel-mode code and data can be eligible for paging out. # Mainframe computers frequently used head-per-track disk drives or drums for swap storage to eliminate [[rotational delay]]. # Flash memory has a finite number of erase-write cycles, (see [[Flash memory#Limitations|Limitations of flash memory]]), and the smallest amount of data that can be erased at once might be very large (128 KiB for an Intel X25-M SSD <ref>{{cite web|url=http://thunk.org/tytso/blog/2009/02/20/aligning-filesystems-to-an-ssds-erase-block-size |title=Aligning filesystems to an SSD’s erase block size &#124; Thoughts by Ted |publisher=Thunk.org |date=2009-02-20 |accessdate=2010-10-28}}</ref>), seldom coinciding with pagesize. Therefore, flash memory may wear out quickly if used as swap space under tight memory conditions. On the attractive side, flash memory is practically delayless compared to harddisks, and not [[Volatile memory|volatile]] as RAM chips. Schemes like [[ReadyBoost]] and [[Intel Turbo Memory]] are made to exploit these characteristics. Many [[Unix-like]] operating systems (for example [[AIX]], [[Linux]] and [[Solaris (operating system)|Solaris]]) allow using multiple storage devices for swap space in parallel, to increase performance. == Tuning swap space size == In some older virtual memory operating systems, space in swap backing store is reserved when programs allocate memory for runtime data. OS vendors typically issue guidelines about how much swap space should be allocated. == Reliability == Swapping can decrease system reliability by some amount. If swapped data gets corrupted on the disk (or at any other location during transfer), the memory will also have incorrect contents after the data has later been returned. == Addressing limits on 32 bit hardware == It is not uncommon to find 32 bit computers with 4 GB of RAM, the maximum amount addressable without the use of, e.g., [[Physical Address Extension|PAE]]. For some machines, e.g., the IBM [[IBM System/370|S/370]] in XA mode, the upper bit was not part of the address and only 2 GB could be addressed. Paging and swap space can be used beyond this 4 GB limit, due to it being addressed in terms of pages rather than individual bytes. While 32 bit programs on machines with linear address spaces will continue to be limited to the 4 GB they're capable of addressing, because they each exist in their own [[virtual address space]], a group of programs can together grow beyond this limit and into any available space. Most of the time. On machines with segment registers, e.g., the access registers on an [[IBM System/370]] in [[IBM ESA/390|ESA]] mode,<ref>{{cite manual | author = IBM | title = IBM System/370 Extended Architecture Principles of Operation | id = SA22-7085-1 | version = Second Edition | date = January 1987 | separator = , }}</ref> the address space size is limited only by OS constraints, e.g., the need to fit the mapping tables into the available storage. == See also == * [[Physical memory]], a subject of paging * [[Virtual memory]], an abstraction that paging may create * [[Demand paging]], a "lazy" paging scheme * [[Page cache]], a disk cache that utilizes virtual memory mechanism * [[Page replacement algorithm]] * [[Segmentation (memory)]] * [[Page size]] * [[Page table]] * [[Memory allocation]] == Notes == {{Reflist|2|group=NB}} == References == {{Reflist|2}} == External links == *[http://it.toolbox.com/blogs/microsoft-infrastructure/moving-the-pagefilesys-to-another-partition-or-disk-35772 Windows Server - Moving Pagefile to another partition or disk] by [[David Nudelman]] *[http://computer.howstuffworks.com/virtual-memory.htm How Virtual Memory Works] from HowStuffWorks.com (in fact explains only swapping concept, and not virtual memory concept) *[http://www.faqs.org/docs/linux_admin/x1762.html Linux swap space management] (outdated, as the author admits) *[http://www.techarp.com/showarticle.aspx?artno=143 Guide On Optimizing Virtual Memory Speed] (outdated, and contradicts section 1.4 of this wiki page, and (at least) references 8, 9, and 11.) *[http://people.msoe.edu/~mccrawt/resume/papers/CS384/mccrawt_cs384_virtual.pdf Virtual Memory Page Replacement Algorithms] *[http://support.microsoft.com/kb/308417/ Windows XP. How to manually change the size of the virtual memory paging file] *[http://support.microsoft.com/?id=312362 Windows XP. Factors that may deplete the supply of paged pool memory] *[http://www.acc.umu.se/~bosse/ SwapFs] driver that can be used to save the paging file of Windows on a swap partition of Linux. {{Operating System}} [[Category:Virtual memory]] [[Category:Memory management]] [[ca:Paginació de memòria]] [[cs:Stránkování paměti]] [[de:Paging]] [[et:Lehekülgede saalimine]] [[es:Paginación de memoria]] [[eu:Orrikatze]] [[fr:Mémoire virtuelle#Mémoire virtuelle paginée]] [[ko:페이징]] [[it:Paging]] [[he:דפדוף (זיכרון)]] [[lt:Puslapiavimas]] [[ms:Penghalaman]] [[ja:ページング方式]] [[pl:Stronicowanie pamięci]] [[pt:Memória paginada]] [[ru:Свопинг]] [[sk:Stránkovanie]] [[sl:Ostranjevanje]] [[uk:Підкачка сторінок]]</text> </page> <page> <id>28317</id> <title>Paleochiton</title> <text>{{automatic taxobox | fossil_range = {{geo range|Ordovician|ref=<ref name=vanBelle1981/>}} | authority = A. G. Smith, 1964 }} '''Paleochiton''' is an extinct {{taxon rank}} of [[chiton|polyplacophoran]] mollusc.<ref name=vanBelle1981>{{Fossil chiton catalogue}}</ref> == References == {{reflist}} [[Category:Paleontology]] [[Category:Chitons]] [[Category:Taxonomy]] {{paleo-mollusc-stub}} {{chiton-stub}}</text> </page> <page> <id>28327</id> <title>Palm OS Emulator</title> <text>{{Unreferenced|date=May 2008}} Descended from Copilot, '''Palm OS Emulator''' is used for writing, testing, and debugging Palm OS applications. Palm OS Emulator emulates [[Motorola 68000|Motorola 68000-class]] devices and has intimate knowledge of [[Palm OS]]'s inner working, allowing for the close monitoring of correct application operation. Unlike [[Xcopilot]] (another descendent of Copilot), Palm OS Emulator will not boot [[uClinux]]. All versions of Palm OS Emulator require a file containing the ROM image to boot. ROM image files can be obtained from PalmSource (now part of [[Access Co.]], Ltd), or downloaded 