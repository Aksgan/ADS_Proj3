as many symbols as necessary. As a consequence no step is defined when the stack is empty. Computations of the pushdown automaton are sequences of steps. The computation starts in the initial state <math>q_{0}</math> with the initial stack symbol <math>Z</math> on the stack, and a string <math>w</math> on the input tape, thus with initial description <math>(q_{0},w,Z)</math>. There are two modes of accepting. The pushdown automaton either accepts by final state, which means after reading its input the automaton reaches an accepting state (in <math>F</math>), or it accepts by empty stack (<math>\varepsilon</math>), which means after reading its input the automaton empties its stack. The first acceptance mode uses the internal memory (state), the second the external memory (stack). Formally one defines # <math>L(M) = \{ w\in\Sigma^* | (q_{0},w,Z) \vdash_M^* (f,\varepsilon,\gamma)</math> with <math>f \in F</math> and <math>\gamma \in \Gamma^* \}</math> (final state) # <math>N(M) = \{ w\in\Sigma^* | (q_{0},w,Z) \vdash_M^* (q,\varepsilon,\varepsilon)</math> with <math>q \in Q \}</math> (empty stack) Here <math>\vdash_M^*</math> represents the reflexive and transitive closure of the step relation <math>\vdash_M</math> meaning any number of consecutive steps (zero, one or more). For each single pushdown automaton these two languages need to have no relation: they may be equal but usually this is not the case. A specification of the automaton should also include the intended mode of acceptance. Taken over all pushdown automata both acceptance conditions define the same family of languages. '''Theorem.''' For each pushdown automaton <math>M</math> one may construct a pushdown automaton <math>M'</math> such that <math>L(M)=N(M')</math>, and vice versa, for each pushdown automaton <math>M</math> one may construct a pushdown automaton <math>M'</math> such that <math>N(M)=L(M')</math> == Example == The following is the formal description of the PDA which recognizes the language <math>\{0^n1^n \mid n \ge 0 \}</math> by final state: [[Image:Pda-example.svg|thumb|250px|PDA for <math>\{0^n1^n \mid n \ge 0\}</math> (by final state)]] <math>M=(Q,\ \Sigma,\ \Gamma,\ \delta, \ p,\ Z, \ F)</math>, where <math>Q = \{ p,q,r \}</math> <math>\Sigma = \{0, 1\}</math> <math>\Gamma = \{A, Z\}</math> <math>F = \{r\}</math> <math>\delta</math> consists of the following six instructions: <math>(p,0,Z,p,AZ)</math>, <math>(p,0,A,p,AA)</math>, <math>(p,\epsilon,Z,q,Z)</math>, <math>(p,\epsilon,A,q,A)</math>, <math>(q,1,A,q,\epsilon)</math>, and <math>(q,\epsilon,Z,r,Z)</math>. In words, in state <math>p</math> for each symbol <math>0</math> read, one <math>A</math> is pushed onto the stack. Pushing symbol <math>A</math> on top of another <math>A</math> is formalized as replacing top <math>A</math> by <math>AA</math>. In state <math>q</math> for each symbol <math>1</math> read one <math>A</math> is popped. At any moment the automaton may move from state <math>p</math> to state <math>q</math>, while it may move from state <math>q</math> to accepting state <math>r</math> only when the stack consists of a single <math>Z</math>. There seems to be no generally used representation for PDA. Here we have depicted the instruction <math>(p,a,A,q,\alpha)</math> by an edge from state <math>p</math> to state <math>q</math> labelled by <math>a; A/\alpha</math> (read <math>a</math>; replace <math>A</math> by <math>\alpha</math>). ==Understanding the computation process== [[Image:Pda-steps.svg|thumb|340px|accepting computation for <math>0011</math>]] The following illustrates how the above PDA computes on different input strings. The subscript <math>M</math> from the step symbol <math>\vdash</math> is here omitted. (a) Input string = 0011. There are various computations, depending on the moment the move from state <math>p</math> to state <math>q</math> is made. Only one of these is accepting. : (i) <math>(p,0011,Z) \vdash (q,0011,Z) \vdash (r,0011,Z)</math>. The final state is accepting, but the input is not accepted this way as it has not been read. : (ii) <math>(p,0011,Z) \vdash (p,011,AZ) \vdash (q,011,AZ)</math>. No further steps possible. : (iii) <math>(p,0011,Z) \vdash (p,011,AZ) \vdash (p,11,AAZ) \vdash (q,11,AAZ)</math> <math> \vdash (q,1,AZ) \vdash (q,\epsilon,Z)</math> <math> \vdash (r,\epsilon,Z)</math>. Accepting computation: ends in accepting state, while complete input has been read. (b) Input string = 00111. Again there are various computations. None of these is accepting. : (i) <math>(p,00111,Z) \vdash (q,00111,Z) \vdash (r,00111,Z)</math>. The final state is accepting, but the input is not accepted this way as it has not been read. : (ii) <math>(p,00111,Z) \vdash (p,0111,AZ) \vdash (q,0111,AZ)</math>. No further steps possible. : (iii) <math>(p,00111,Z) \vdash (p,0111,AZ) \vdash (p,111,AAZ) \vdash (q,111,AAZ)</math> <math> \vdash (q,11,AZ) \vdash (q,1,Z)</math> <math> \vdash (r,1,Z)</math>. The final state is accepting, but the input is not accepted this way as it has not been (completely) read. ==PDA and Context-free Languages== Every context-free grammar can be transformed into an equivalent pushdown automaton. The derivation process of the grammar is simulated in a leftmost way. Where the grammar rewrites a nonterminal, the PDA takes the topmost nonterminal from its stack and replaces it by the right-hand part of a grammatical rule (expand). Where the grammar generates a terminal symbol, the PDA reads a symbol from input when it is the topmost symbol on the stack (match). In a sense the stack of the PDA contains the unprocessed data of the grammar, corresponding to a pre-order traversal of a derivation tree. Technically, given a context-free grammar, the PDA is constructed as follows. # <math>(1,\varepsilon,A,1,\alpha)</math> for each rule <math>A\to\alpha</math> (<em>expand</em>) # <math>(1,a,a,1,\varepsilon)</math> for each terminal symbol <math>a</math> (<em>match</em>) As a result we obtain a single state pushdown automaton, the state here is <math>1</math>, accepting the context-free language by empty stack. Its initial stack symbol equals the axiom of the context-free grammar. The converse, finding a grammar for a given PDA, is not that easy. The trick is to code two states of the PDA into the nonterminals of the grammar. '''Theorem.''' For each pushdown automaton <math>M</math> one may construct a context-free grammar <math>G</math> such that <math>N(M)=L(G)</math>. ==Generalized Pushdown Automaton (GPDA)== A GPDA is a PDA which writes an entire string of some known length to the stack or removes an entire string from the stack in one step. A GPDA is formally defined as a 6-tuple: :<math>M=(Q,\ \Sigma,\ \Gamma,\ \delta, \ q_{0}, \ F)</math> where Q, <math>\Sigma\,</math>, <math>\Gamma\,</math>, q<sub>0</sub> and F are defined the same way as a PDA. :<math>\,\delta</math>: <math>Q \times \Sigma_{\epsilon} \times \Gamma^{*} \longrightarrow P( Q \times \Gamma^{*} )</math> is the transition function. Computation rules for a GPDA are the same as a PDA except that the a<sub>i+1</sub>'s and b<sub>i+1</sub>'s are now strings instead of symbols. GPDA's and PDA's are equivalent in that if a language is recognized by a PDA, it is also recognized by a GPDA and vice 