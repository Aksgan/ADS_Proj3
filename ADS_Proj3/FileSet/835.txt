or, Lambda: The Ultimate GOTO". MIT AI Lab. AI Lab Memo AIM-443. October 1977. [http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AIM-443.pdf][http://dspace.mit.edu/handle/1721.1/5753][http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.4404&rep=rep1&type=pdf]</ref>. The extent to which different paradigms utilize subroutines (and their consequent memory requirements) influences the overall performance of the complete algorithm, although as [[Guy Steele]] pointed out in a 1977 paper, a well-designed programming language implementation ''can'' have very low overheads for procedural abstraction (but laments, in most implementations, that they seldom achieve this in practice - being "rather thoughtless or careless in this regard"). In the same paper, Steele also makes a considered case for [[automata-based programming]] (utilizing procedure calls with [[tail recursion]]) and concludes that "we should have a healthy respect for procedure calls" (because they are powerful) but suggested "use them sparingly"<ref name="steele1997"/> In terms of the frequency of subroutine calls:- * for procedural programming, the [[Granularity#Data_granularity|granularity]] of the code is largely determined by the number of discrete procedures or [[modular programming|module]]s. * for functional programming, frequent calls to [[library (computing)|library]] subroutines are commonplace{{Citation needed|date=March 2010}} (but may be frequently inlined by the optimizing compiler) * for object oriented programming, the number of method calls invoked is also partly determined by the granularity of the data structures and may therefore include many "read-only" accesses to low level objects that are encapsulated (and therefore accessible in no other, more direct, way). Since increased granularity is a prerequisite for greater [[code reuse]], the tendency is towards fine-grained data structures, and a corresponding increase in the number of discrete objects (and their methods) and, consequently, subroutine calls. The creation of "[[god object]]s" is actively discouraged. [[Constructor (object-oriented programming)|Constructor]]s also add to the count as they are also subroutine calls (unless they are inlined). Performance problems caused by excessive granularity may not become apparent until [[scalability]] becomes an issue. * for other paradigms, where a mixture of the above paradigms may be employed, subroutine usage is less predictable. ====Allocation of dynamic memory for Message storage and object storage==== Uniquely, the object oriented paradigm involves dynamic allocation of memory from [[Dynamic memory allocation|heap storage]] for both object creation and message passing. A 1994 benchmark - "Memory Allocation Costs in Large C and C++ Programs" conducted by [[Digital Equipment Corporation]] on a variety of software, using an instruction-level profiling tool, measured how many instructions were required per dynamic storage allocation. The results showed that the lowest absolute number of instructions executed averaged around 50 but others reached as high as 611<ref>{{cite journal |journal=SOFTWARE—PRACTICE AND EXPERIENCE |title=Memory Allocation Costs in Large C and C++ Programs; Page 532 |author=David Detlefs and Al Dosser and Benjamin Zorn |volume=24|issue=6 |pages= 527–542 |date=1994-06 |format=PDF|url=http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/vol24/issue6/spe895.pdf }})</ref>. See also "Heap:Pleasures and pains" by Murali R. Krishnan<ref>{{cite web|url=http://msdn.microsoft.com/en-us/library/ms810466%28v=MSDN.10%29.aspx|publisher=microsoft.com|title=Heap: Pleasures and pains|last=Krishnan|first=Murali R.|date=1999-02 }}</ref> that states "Heap implementations tend to stay general for all platforms, and hence have heavy overhead". The above pseudocode example does not include a realistic estimate of this memory allocation pathlength or the memory prefix overheads involved and the subsequent associated garbage collection overheads (To gain some appreciation that heap allocation is not a "trivial" task, this <ref>http://microallocator.googlecode.com/svn/trunk/MicroAllocator.cpp</ref> is an example of one [[open source]] microallocator by games developer, [[John W. Ratcliff]], consisting of nearly 1,000 lines of code). ==== Dynamically dispatched Message calls v. Direct procedure Call overheads ==== In their Abstract "''Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis''"<ref>{{cite paper|title=Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis|author=Jeffrey Dean, David Grove, and Craig Chambers |publisher=University of Washington |DOI=10.1.1.117.2420 |url=http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.117.2420&rep=rep1&type=pdf}}</ref>, Jeffrey Dean, David Grove, and Craig Chambers of the Department of Computer Science and Engineering, at the [[University of Washington]], claim that "Heavy use of inheritance and dynamically-bound messages is likely to make code more extensible and reusable, but it also imposes a significant performance overhead, compared to an equivalent but non-extensible program written in a non-object-oriented manner. In some domains, such as structured graphics packages, the performance cost of the extra flexibility provided by using a heavily object-oriented style is acceptable. However, in other domains, such as basic data structure libraries, numerical computing packages, rendering libraries, and trace-driven simulation frameworks, the cost of message passing can be too great, forcing the programmer to avoid object-oriented programming in the “hot spots” of their application." === Serialization of objects === {{Main|Serialization}} [[Serialization]] imposes quite considerable overheads when passing [[Object (computer science)|object]]s from one system to another, especially when the transfer is in human-readable formats such as [[XML]] and [[JSON]]. This contrasts with compact binary formats for non object oriented data. Both encoding and decoding of the objects data value and its attributes are involved in the serialization process (that also includes awareness of complex issues such as inheritance, encapsulation and data hiding). ==See also== * [[Comparison of programming languages]] * [[Comparison of programming languages (basic instructions)]] * [[Granularity#In_computing|Granularity]] * [[Message passing]] * [[Subroutine]] ==References== {{Reflist|refs=<ref name="flaws">{{cite web| first = Asaf| last= Shelly |title = Flaws of Object Oriented Modeling| date=2008-08-22|accessdate=2010-07-04| publisher = Intel® Software Network| url=http://software.intel.com/en-us/blogs/2008/08/22/flaws-of-object-oriented-modeling/}}</ref><ref name="executioniKoN">{{cite web| first = Steve| last=Yegge | title = Execution in the Kingdom of Nouns| date=2006-03-30|accessdate=2010-07-03| publisher = steve-yegge.blogspot.com| url=http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html}}</ref>}} ==Further reading== * [http://g.oswego.edu/dl/html/malloc.html "A Memory Allocator"] by Doug Lea * [http://www.sqa.org.uk/e-learning/LinkedDS01CD/page_01.htm "Dynamic Memory Allocation and Linked Data Structures"] by ([[Scottish Qualifications Authority]]) * [http://www.flounder.com/inside_storage_allocation.htm "Inside A Storage Allocator"] by Dr. Newcomer Ph.D ==External links== * [http://users.ecs.soton.ac.uk/mrd/research/prog.html Comparing Programming Paradigms] by Dr Rachel Harrison and Mr Lins Samaraweera * [http://eprints.ecs.soton.ac.uk/597/ Comparing Programming Paradigms: an Evaluation of Functional and Object-Oriented Programs] by Harrison, R., Samaraweera, L. G., Dobie, M. R. and Lewis, P. H. (1996) pp. 247–254. ISSN 0268-6961 * [http://www.info.ucl.ac.be/~pvr/paradigmsDIAGRAMeng101.pdf "The principal programming paradigms"] By Peter Van Roy * [http://www.info.ucl.ac.be/~pvr/book.html "Concepts, Techniques, and Models of Computer Programming" ](2004) by Peter Van Roy & Seif Haridi, ISBN 0-262-22069-5 * [http://hbfs.wordpress.com/2008/12/30/the-true-cost-of-calls/ The True Cost of Calls ]- from "Harder, Better, Faster, Stronger" blog by computer scientist [http://www.stevenpigeon.org/Publications/ Steven Pigeon] {{DEFAULTSORT:Comparison Of Programming Paradigms}} [[Category:Programming paradigms|!]]</text> </page> <page> <id>7237</id> <title>Comparison sort</title> <text>[[Image:Balance à tabac 1850.JPG|thumb|right|300px|Sorting a set of unlabelled weights by weight using only a balance scale requires a comparison sort algorithm]] A '''comparison sort''' is a type of 