CO locally|Enforcing CO locally]] below) and enforcing the ''voting strategy'' in the theorem above (for global transactions). ====Exact characterization of voting-deadlocks by global cycles==== The above global cycle elimination process by a '''voting deadlock''' can be explained in detail by the following observation: First it is assumed, for simplicity, that every transaction reaches the ready-to-commit state and is voted on by at least one database (this implies that no blocking by locks occurs). Define a ''"wait for vote to commit" graph'' as a directed graph with transactions as nodes, and a directed edge from any first transaction to a second transaction if the first transaction blocks the vote to commit of the second transaction (opposite to conventional edge direction in a [[wait-for graph]]). Such blocking happens only if the second transaction is in a conflict with the first transaction (see above). Thus this "wait for vote to commit" graph is identical to the global conflict graph (has exactly the same definition - see [[serializability#Testing conflict serializability|in Serializability]]). A cycle in the "wait for vote to commit" graph means a deadlock in voting. Hence there is a deadlock in voting if and only if there is a cycle in the conflict graph. Local cycles (confined to a single database) are eliminated by the local serializability mechanisms. Consequently only global cycles are left, which are then eliminated by the atomic commitment protocol when it aborts deadlocked transactions with missing (blocked) respective votes. Secondly, also local commits are dealt with: Note that when enforcing CO also waiting for a regular local commit of a local transaction can block local commits and votes of other transactions upon conflicts, and the situation for global transactions does not change also without the simplifying assumption above: The final result is the same also with local commitment for local transactions, without voting in atomic commitment for them. Finally, blocking by a lock (which has been excluded so far) needs to be considered: A lock blocks a conflicting operation and prevents a conflict from being materialized. If the lock is released only after transaction end, it may block indirectly either a vote or a local commit of another transaction (which now cannot get to ready state), with the same effect as of a direct blocking of a vote or a local commit. In this case a cycle is generated in the conflict graph only if such a blocking by a lock is also represented by an edge. With such added edges representing events of blocking-by-a-lock, the conflict graph is becoming an ''augmented conflict graph''. *'''Definition - Augmented conflict graph''' :An '''augmented conflict graph''' is a [[serializability#Testing conflict serializability|conflict graph]] with added edges: In addition to the original edges a directed edge exists from transaction <math>T_{1}</math> to transaction <math>T_{2}</math> if two conditions are met: # <math>T_{2}</math> is blocked by a data-access lock applied by <math>T_{1}</math> (the blocking prevents the conflict of <math>T_{2}</math> with <math>T_{1}</math> from being materialized and have an edge in the regular conflict graph), and # This blocking will not stop before <math>T_{1}</math> ends (commits or aborts; true for any locking-based CO) :The graph can also be defined as the [[Union (set theory)|union]] of the (regular) ''conflict graph'' with the (reversed edge, regular) ''wait-for graph'' :'''Comments:''' # Here, unlike the regular conflict graph, which has edges only for materialized conflicts, all conflicts, both materialized and non-materialized, are represented by edges. # Note that all the new edges are all the (reversed to the conventional) edges of the ''[[wait-for graph]]''. The ''wait-for graph'' can be defined also as the graph of non-materialized conflicts. By the common conventions edge direction in a ''conflict graph'' defines time order between conflicting operations which is opposite to the time order defined by an edge in a ''wait-for graph''. # Note that such global graph contains (has [[Embedding|embedded]]) all the (reversed edge) regular local ''wait-for'' graphs, and also may include locking based global cycles (which cannot exist in the local graphs). For example, if all the databases on a global cycle are SS2PL based, then all the related vote blocking situations are caused by locks (this is the classical, and probably the only global deadlock situation dealt with in the database research literature). This is a global deadlock case where each related database creates a portion of the cycle, but the complete cycle does not reside in any local wait-for graph. In the presence of CO the ''augmented conflict graph'' is in fact a (reversed edge) ''local-commit and voting wait-for graph'': An edge exists from a first transaction, either local or global, to a second, if the second is waiting for the first to end in order to be either voted on (if global), or locally committed (if local). All ''global cycles'' (across two or more databases) in this graph generate voting-deadlocks. The graph's global cycles provide complete characterization for voting deadlocks and may include any combination of materialized and non-materialized conflicts. Only cycles of (only) materialized conflicts are also cycles of the regular conflict graph and affect serializability. One or more (lock related) non-materialized conflicts on a cycle prevent it from being a cycle in the regular conflict graph, and make it a locking related deadlock. All the global cycles (voting-deadlocks) need to be broken (resolved) to both maintain global serializability and resolve global deadlocks involving data access locking, and indeed they are all broken by the atomic commitment protocol due to missing votes upon a voting deadlock. '''Comment:''' This observation also explains the correctness of ''[[Commitment ordering#Extended CO (ECO)|Extended CO (ECO)]]'' below: Global transactions' voting order must follow the conflict graph order with vote blocking when order relation (graph path) exists between two global transactions. Local transactions are not voted on, and their (local) commits are not blocked upon conflicts. This results in same voting-deadlock situations and resulting global cycle elimination process for ECO. The ''voting-deadlock'' situation can be summarized as follows: *'''The CO Voting-Deadlock Theorem''' :Let a multidatabase environment comprise CO compliant (which eliminates ''local cycles'') database systems that enforce, each, 