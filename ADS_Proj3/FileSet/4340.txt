stored in memory and are referred to through a hard register called the Workspace Pointer. The concept behind the workspace is that main memory was based on the new semiconductor RAM chips that TI had developed and ran at the same speed as the CPU. This meant that it didn't matter if the "registers" were real registers in the CPU or represented in memory. When the Workspace Pointer is loaded with a memory address, that address is the origin of the "registers". There are three hard registers in the 990; the Workspace Pointer (WP), the Program Counter (PC) and the Status register (ST). A context switch entailed the saving and restoring of only the hard registers. ===Extended Operation=== The TI-990 had a facility to allow extended operations through the use of plug in hardware. If the hardware is not present the CPU traps to allow software to perform the function. The operation code (XOP) allowed for 15 attached devices on a system. Although, device 15 is reserved, by convention, to be used as the systems call entry for user programs to request systems services. ===Instruction set=== Programmers liked the TI-990 design because it had a fairly [[orthogonal instruction set]] which allowed a programmer to separately memorize all of the operations and the methods of accessing [[operand]]s. The basic instruction formats allowed for one, two and three word instructions. The model 990/12 CPU allowed for a four word instruction with the extended mode operations. ==Architectural details== === General register [[addressing mode]]s === (R is a general register, 0 to 15.) :0. Register - the value is to or from a register: OPR R ; R contains operand :1. Indirect register - register is used as a memory address to read or write: OPR *R ; R contains address :2. Indexed: OPR @MEM(R); R contains index value, R0 is not used in indexing and allows direct memory addressing :3. Autoincrement: OPR *R+ ; R contains address of address, then increment R by the length of the operand type Several registers had special usages that reserve their use, the register and their usages are: *R0 - shift counter, extended mode counter, floating point AC-0 *R1 - floating point AC-1 *R2 - floating point AC-2 *R3 - floating point AC-3 *R11 - XOP pointer (kernel mode), return linkage *R12 - CRU base address (kernel mode) *R13 - Saved Workspace pointer *R14 - Saved Program counter *R15 - Saved Status === TI-990 instructions === The 990/4, 990/5, 990/9 instruction sets consisted of 69 instructions, the 990/10 had 72 instructions, the 990/10A had 77 instructions and the 990/12 had 144 instructions. The instructions are divided into types that have similar characteristics. <div style="font-size:116%;font-weight:bold;">Type 1 instructions</div> The first part of the word specifies the operation to be performed, the remaining two parts provide information for locating the operands. *MOV (move word) *MOVB (move byte) *A (add word) *AB (add byte) *S (subtract word) *SB (subtract byte) *C (compare word) *CB (compare byte) *SZC (set zeros corresponding word) *SZCB (set zeros corresponding byte) *SOC (set ones corresponding word) *SOCB (set ones corresponding byte) <div style="font-size:116%;font-weight:bold;">Type 2 instructions</div> The first part of the word specifies the operation to be performed, the second part is a relative offset to where to go, for JMP instructions, or the relative offset for CRU bit addressing. *JMP (jump unconditionally) *JLT (jump if less than zero) *JLE (jump if less than or equal to zero) *JEQ (jump if zero) *JHE (jump if logically greater than or equal to zero) *JGT (jump if greater than zero) *JNE (jump if not equal zero) *JNC (jump if carry clear) *JOC (jump if carry set) *JNO (jump if overflow clear) *JL (jump if logically less than zero) *JH (jump if logically greater than zero) *SBO (set CRU bit to one) *SBZ (set CRU bit to zero) *TB (test CRU bit) <div style="font-size:116%;font-weight:bold;">Type 3 instructions</div> One part of the word specifies the operation, the second part provides the register, the third part provides information for locating the second operand. *COC (compare ones corresponding) *CZC (compare zeros corresponding) *XOR (exclusive or) *XOP (extended operation) <div style="font-size:116%;font-weight:bold;">Type 4 instructions</div> The first part of the word specifies the operation to be performed, the second part is the bit width of the operation, the third part provides information for locating the second operand. *LDCR (load CRU) *STCR (store CRU) <div style="font-size:116%;font-weight:bold;">Type 5 instructions</div> The first part of the word specifies the operation to be performed, the second part is the shift count, the third part specifies the register to shift. *SRA (shift right arithmetic) *SRL (shift right logical) *SLA (shift left arithmetic) *SRC (shift right circular) <div style="font-size:116%;font-weight:bold;">Type 6 instructions</div> The first part specifies the operation to be performed, the second part provides information for locating the second operand. *BLWP (brach and load workspace pointer) *B (branch) *X (execute) *CLR (clear word) *NEG (twos complement negate) *INV (ones complement) *INC (increment) *INCT (increment by two) *DEC (decrement) *DECT (decrement by two) *BL (branch and link) *ABS (absolute value) *SWPB (swap bytes) *SETO (set word to ones) *LDS (long distance source, 990/10, 990/10A, 990/12) *LDD (long distance destination, 990/10, 990/10A, 990/12) *BIND (branch indirect, 990/10A, 990/12) *MPYS (multiply signed, 990/10A, 990/12) *DIVS (divide signed, 990/10A, 990/12) *AR (add real, 990/12) *CIR (convert integer to real, 990/12) *SR (subtract real, 990/12) *MR (multiply real, 990/12) *DR (divide real, 990/12) *LR (load real, 990/12) *STR (store real, 990/12) *AD (add double, 990/12) *CID (convert integer to double, 990/12) *SD (subtract double, 990/12) *MD (multiply double, 990/12) *DD (divide double, 990/12) *LD (load double, 990/12) *STD (store double, 990/12) <div style="font-size:116%;font-weight:bold;">Type 7 instructions</div> The word specified the operation to be performed. *IDLE (cpu idle) *RSET (cpu reset) *RTWP (return workspace pointer) *CKON (clock on) *CKOF (clock off) *LREX (load ROM and execute) *EMD (execute micro diagnostic, 990/12) *EINT (enable interrupt, 990/12) *DINT (disable interrupt, 990/12) *CRI (convert real to integer, 990/12) *CDI (convert double to integer, 990/12) *NEGR (negate real, 990/12) *NEGD (negate double, 990/12) *CRE (convert 