can be split up in two parts, [[CAD]] tools for reconfigurable array and compilation tools for CPU. The front-end compiler is an integrated tool, and will generate a structural hardware representation that is input of hardware design flow. Hardware design flow for reconfigurable architecture can be classified by the approach adopted by three main stages of design process: technology mapping, placement algorithm and routing algorithm. The software frameworks differ in the level of the programming language. Some types of reconfigurable computers are microcoded processors where the [[microcode]] is stored in [[random-access memory|RAM]] or [[EEPROM]], and changeable on [[hard reboot|reboot]] or on the fly. This could be done with the [[Advanced Micro Devices|AMD]] 2900 series [[bit slicing|bit slice processor]]s (on reboot) and later with [[Field-programmable gate array|FPGA]]s (on the fly). Some{{Which?|date=April 2010}} [[dataflow]] processors are implemented using reconfigurable computing. A new method of application development for reconfigurable computing is being developed by MNB Technologies, Inc,[http://www.mnbtech.com] under contract to the United States Air Force Office of Scientific Research (AFOSR). This approach uses a national repository of generic algorithms, similar to the [[BLAS]] and [[LAPACK]] libraries found at netlib.org. In addition to the repository, the project is developing a tightly integrated suite of expert system based tools that largely eliminate the need for an application developer to have any in-depth knowledge of the underlying hardware or how to use the specialized Verilog and VHDL hardware description languages. The results of this research will be available without charge to individuals and organizations based in the United States. To compare the effect of various ways to implement an algorithm on the runtime and energy used, some tools allow compiling the same piece of C code for a fixed CPU, a [[soft processor]], or compiling directly to FPGA [http://www.fpgajournal.com/articles/impulseC.htm]. ==Reconfigurable computing as a paradigm shift: using the Anti Machine == {|class="wikitable" | align="right" |+ ''Table 1: Nick Tredennick’s Paradigm Classification Scheme'' |- |{{highlight1}} colspan="2" | '''Early Historic Computers:''' |- |{{highlight1}} | ! Programming Source |- | Resources fixed | none |- | Algorithms fixed | none |- |{{highlight2}} colspan=2 | '''von Neumann Computer:''' |- |{{highlight2}} | ! Programming Source |- | Resources fixed | none |- | Algorithms variable | Software (instruction streams) |- |{{highlight3}} colspan="2"| '''Reconfigurable Computing Systems:''' |- |{{highlight3}}| ! Programming Source |- | Resources variable | [[Configware]] (configuration) |- | Algorithms variable | [[Flowware]] (data streams) |} Computer scientist [[Reiner Hartenstein]] describes reconfigurable computing in terms of an ''[[anti machine]]'' that, according to him, represents a fundamental paradigm shift away from the more conventional [[von Neumann machine]]. <ref> Hartenstein, R. 2001. A decade of reconfigurable computing: a visionary retrospective. In ''Proceedings of the Conference on Design, Automation and Test in Europe (DATE 2001)'' (Munich, Germany). W. Nebel and A. Jerraya, Eds. Design, Automation, and Test in Europe. IEEE Press, Piscataway, NJ, 642–649. </ref> Hartenstein calls it '''Reconfigurable Computing Paradox,''' that software-to-[[configware]] migration (software-to-[[FPGA]] migration) results in reported speed-up factors of up to more than four orders of magnitude, as well as a reduction in electricity consumption by up to almost foure orders of magnitude—although the technological parameters of FPGAs are behind the Gordon Moore curve by about four orders of magnitude, and the clock frequency is substantially lower than that of microprocessors. This paradox is due to a paradigm shift, and is also partly explained by the [[Von Neumann syndrome]]. The fundamental model of the reconfigurable computing machine paradigm, the data-stream-based anti machine is well illustrated by the differences to other machine paradigms that were introduced earlier, as shown by [[Nick Tredennick]]'s following classification scheme of computing paradigms (see "Table 1: Nick Tredennick’s Paradigm Classification Scheme"). <ref> N. Tredennick: The Case for Reconfigurable Computing; Microprocessor Report, Vol. 10 No. 10, 5 August 1996, pp 25–27.</ref> The fundamental model of a [[Anti machine|Reconfigurable Computing Machine]], the data-stream-based anti machine (also called Xputer), is the counterpart of the instruction-stream-based von Neumann machine paradigm. This is illustrated by a simple reconfigurable system (not [[dynamically reconfigurable|''dynamically'' reconfigurable]]), which has no instruction fetch at run time. The reconfiguration (before run time) can be considered as a kind of ''super instruction fetch''. An anti machine does not have a program counter. The anti machine has data counters instead, since it is data-stream-driven. Here the definition of the term ''data streams'' is adopted from the [[systolic array]] scene, which defines, at which time which data item has to enter or leave which port, here of the reconfigurable system, which may be fine-grained (e. g. using FPGAs) or coarse-grained, or a mixture of both. The systolic array scene, originally (early 1980s) mainly mathematicians, only defined one half of the anti machine: the data path: the systolic array (also see [[Super systolic array]]). But they did not define nor model the data sequencer methodology, considering that this is not their job to take care where the data streams come from or end up. The data sequencing part of the anti machine is modeled as distributed memory, preferably on chip, which consists of [[auto-sequencing memory]] (ASM) blocks. Each ASM block has a sequencer including a data counter. An example is the [[Generic Address Generator]] (GAG), which is a generalization of the [[Direct memory access|DMA]]. ==See also== * [[Reconfigurable computing terminology]] * [[Partial re-configuration]] * [[Sprinter (computer)|Sprinter]] * [[1chipMSX]] * [[PSoC]] * [[PipeRench]] * [[Computing with Memory]] * [[High-Performance Reconfigurable Computing]] == References == {{Reflist|2}} == Further reading == * S. Hauck and A. DeHon, ''Reconfigurable Computing: The Theory and Practice of FPGA-Based Computing'', [[Morgan Kaufmann]], 2008. * J. Henkel, S. Parameswaran (editors): Designing Embedded Processors. A Low Power Perspective; Springer Verlag, March 2007 * J. Teich (editor) et al.: Reconfigurable Computing Systems. Special Topic Issue of Journal ''it — Information Technology'', Oldenbourg Verlag, Munich. [http://www.atypon-link.com/OLD/toc/itit/49/3 Vol. 49(2007) Issue 3] * T.J. Todman, G.A. Constantinides, S.J.E. Wilton, O. Mencer, W. Luk and P.Y.K. Cheung, "Reconfigurable Computing: Architectures and Design Methods", IEE Proceedings: Computer & Digital Techniques, Vol. 152, No. 2, March 2005, pp. 193–208. * A. Zomaya (editor): Handbook of Nature-Inspired and Innovative Computing: 