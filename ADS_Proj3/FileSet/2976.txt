therefore necessary.<ref name="lulu"/> 1. Abstraction <br> The [[abstraction]] level of decisions is raised to model level. This only makes sense if a corresponding abstraction on the model level can be identified.<br> 2. Tagging the model<br> This involves moving code-level decisions into the model without raising the abstraction level. This procedure is called 'tagging'the model with [[implementation]] decisions.<br> 3. Separation of code classses <br> This involves the adaptation of the [[target architecture]] in such a way that manually-created code must be written into classes specifically created for this purpose.<br> 4. Tagging the code <br> This consists of the introduction of [[protected region]]s to the code, and is accomplished through the use of special tags that protect the code placed between them from [[overwriting]] during regeneration. This list reflects the various solution's elegance in strictly descending order. Tagging the model still allows a clear separation of responsibilities and enables a fully-automated regeneration without further manual treatment. == References == {{reflist}} <!--- Categories ---> [[Category:Articles created via the Article Wizard]] [[Category:Software engineering]]</text> </page> <page> <id>24874</id> <title>Model elimination</title> <text>'''Model Elimination''' is the name attached to a pair of [[proof procedure]]s invented by Donald W. Loveland, the first of which was published in 1968 in the Journal of the ACM. Their primary purpose is to carry out [[automated theorem proving]], though they can readily be extended to [[logic programming]], including the more general [[disjunctive logic programming]]. Model Elimination is closely related to [[Resolution (logic)|resolution]] while also bearing characteristics of a [[Method of analytic tableaux|Tableaux]] method. It is a progenitor of the [[SLD resolution]] procedure used in the [[Prolog]] logic programming language. While somewhat eclipsed by attention to and progress in Resolution theorem provers, Model Elimination has continued to attract the attention of researchers and software developers. Today there are several theorem provers under active development that are based on the Model Elimination procedure. == References == * Loveland, D. W. (1968) Mechanical theorem-proving by model elimination. Journal of the ACM, 15, 236--251. [[Category: Automated theorem proving]] [[Category: Logical calculi]] [[Category: Logic in computer science]]</text> </page> <page> <id>24892</id> <title>Modelur</title> <text>{{Orphan|date=September 2010}} {{Infobox software | name = Modelur | screenshot = [[Image:Modelur.png|thumb]] | caption = A [[screenshot]] of Modelur in action: a warning is issued if buildings are placed too close together. | developer = URBS | released = {{Start date|2009|apr}} | latest release version = 0.2.4 (Windows) / 0.2.4 (Mac OS X) | latest release date = {{Start date and age|2010|02|16}} | operating system = [[Windows 2000]], [[Windows XP]]{{-}}[[Windows Vista]]{{-}}[[Windows 7]]{{-}}[[Mac OS X Tiger]] ([[Universal Binary]]){{-}}[[Mac OS X Leopard]] ([[Universal Binary]]) | language = Chinese, Dutch, English, French, German, Polish, Portuguese, Slovenian, Spanish | genre = [[3D computer graphics]] | license = Available in Pre-beta Partner Program free of charge. | website = [http://www.modelur.com/ www.modelur.com] }} '''Modelur''' is a [[3D computer graphics|3D]] parametric [[urban design]] [[software]], implemented as a [[Google SketchUp]] plugin. In contrast to common [[CAD]] applications, where the user designs buildings with usual dimensions such as width, depth and height, Modelur offers design of [[built environment]] through key urban parameters such as number of storeys and gross floor area of a building. In addition, urban control values (i.e. [[Floor Space Index]], Built Area, etc ) and requirements (i.e. number of parking lots or green areas) based on [[land use]] normatives are calculated in real-time. ==Sources== * [http://sketchup.google.com/ Google SketchUp] * [http://modelur.com/about About Modelur] * [http://www.youtube.com/modelur Modelur on YouTube] * [http://modelur.blogspot.com/ Blog] <!--- See [[Wikipedia:Footnotes]] on how to create references using <ref></ref> tags which will then appear here automatically --> {{Reflist}} ==External links== * [http://www.modelur.com/ Modelur Homepage] * [http://groups.google.com/group/modelur Modelur Support Forum] * [http://sketchup.google.com/download/plugins.html#modelur Google SketchUp plugins list] [[Category:Computer-aided design software]]</text> </page> <page> <id>24910</id> <title>Modified due date scheduling heuristic</title> <text>{{Context|date=October 2009}} {{Unreferenced|date=October 2007}} The '''modified due date''' [[heuristic]] is used in [[Scheduling (computing)|scheduling]] tasks to resources (for example, to answer the question "What order should we make sandwiches in, so as to please our customers?"). It assumes that the objective of the scheduling process is to minimise the total lateness of completing tasks. It is therefore only relevant when there are more tasks than the time available. Assuming that you have a range of tasks, with a range of due dates (d<sub>j</sub>), and a range of times it takes to complete the tasks (p<sub>j</sub>), then in each period (t) you should do the task that has the smallest modified due date (measured in time periods from now). The modified due date is the highest of either the due date, or the completion date if you started the task now: :mdd<sub>j</sub> = max( d<sub>j</sub>, t+p<sub>j</sub> ). ==See also== * [[Scheduling (computing)]] [[Category:Scheduling algorithms]] {{compsci-stub}}</text> </page> <page> <id>24917</id> <title>Modular Audio Recognition Framework</title> <text>{{Infobox Software | name = Modular Audio Recognition Framework (MARF) | screenshot = | caption = MARF | developer = Serguei A. Mokhov, Stephen Sinclair, Ian Clement, Dimitrios Nicolacopoulos, [[The MARF Research and Development Group]] | latest release version = snapshot-0.3.0-devel-20070108 | latest release date = {{release date|2007|01|08}} | operating system = Any with the [[JVM]] installed | genre = [[Pattern recognition]], [[Artificial intelligence]], [[Signal processing]], [[Software framework]]s | license = [[BSD license|BSD]] | website = http://marf.sourceforge.net }} '''Modular Audio Recognition Framework''' (MARF) is an open-source research platform and a collection of [[Voice message|voice]], [[sound]], [[Speech communication|speech]], [[writing|text]] and [[natural language processing]] (NLP) [[algorithm]]s written in [[Java (programming language)|Java]] and arranged into a [[Modularity (programming)|modular]] and extensible [[Software framework|framework]] that attempts to facilitate addition of new [[algorithm]]s. MARF may act as a [[Library (computer science)|library]] in [[application software|applications]] or be used as a source for [[learning]] and [[extension (computing)|extension]]. A few example applications are provided to show how to use the [[Software framework|framework]]. There is also a detailed manual<ref>{{cite web |url=http://marf.sourceforge.net/docs/marf/0.3.0.6/report.pdf |title=MARF, The Modular Audio Recognition Framework, and its Applications: Programmer's Manual|accessdate=2007-08-26 |format=PDF |work= }}</ref> and the [[API]] reference<ref>{{cite web |url=http://marf.sourceforge.net/api-dev/ |title=MARF Developers' API |accessdate=2007-08-10 |format=HTML |work= }}</ref> in the [[javadoc]] format as the project tends to be well-documented. MARF, its applications, and the corresponding source code and documentation are released under the [[BSD license|BSD-style 