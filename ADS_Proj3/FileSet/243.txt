two independent properties that characterize all human language grammars. ==References and footnotes== <references /> [[Category:Generative linguistics]] [[Category:Grammar frameworks]] [[Category:Syntactic relationships]] [[ca:Antisim√®tric]] [[sv:Antisymmetri]]</text> </page> <page> <id>2025</id> <title>Antithetic variates</title> <text>The '''antithetic variates''' method is a [[variance reduction]] technique used in [[Monte Carlo methods]]. Considering that the error reduction in the simulated signal (using [[Monte Carlo methods]]) has a [[square root]] [[limit of a sequence|convergence]] ([[standard deviation]] of the solution), a very large number of [[sample]] paths is required to obtain an accurate result. ==Underlying principle== The antithetic variates technique consists, for every [[sample]] path obtained, in taking its antithetic path &mdash; that is given a path <math>\{\varepsilon_1,\dots,\varepsilon_M\}</math> to also take <math>\{-\varepsilon_1,\dots,-\varepsilon_M\}</math>. The advantage of this technique is twofold: it reduces the number of [[normal]] samples to be taken to generate ''N'' paths, and it reduces the [[variance]] of the sample paths, improving the accuracy. Suppose that we would like to estimate :<math>\theta = \mathrm{E}( h(X) ) = \mathrm{E}( Y ) \, </math> For that we have generated two samples :<math>Y_1\text{ and }Y_2 \, </math> An unbiased estimate of <math>{\theta}</math> is given by :<math>\hat \theta = \frac{Y_1 + Y_2}{2}. </math> And :<math>\text{Var}(\hat \theta) = \frac{\text{Var}(Y_1) + \text{Var}(Y_2) + 2\text{Cov}(Y_1,Y_2)}{4} </math> In the case where ''Y''<sub>1</sub> and ''Y''<sub>2</sub> are [[iid]], [[covariance]] self-cancels and <math>\text{Var}(Y_1) = \text{Var}(Y_2) </math>, therefore : <math>\text{Var}(\hat \theta) = \frac{\text{Var}(Y_1) }{2} = \frac{\text{Var}(Y_2) }{2}. </math> The antithetic variates technique consists in this case of choosing the second sample in such a way that <math>Y_1</math> and <math>Y_2</math> are not [[iid]] anymore and <math> Cov(Y_1,Y_2)</math> is negative. As a result, <math>\text{Var}(\hat \theta)</math> is reduced and is smaller than the previous normal [[variance]] <math>\frac{\text{Var}(Y_1) }{2} = \frac{\text{Var}(Y_2) }{2} </math>. ==Example 1== If the law of the variable ''X'' follows a [[uniform distribution (continuous)|uniform distribution]] along [0, 1], the first sample will be <math>u_1, \ldots, u_n</math>, where, for any given ''i'', <math>u_i</math> is obtained from ''U''(0, 1). The second sample is built from <math>u'_1, \ldots, u'_n</math>, where, for any given ''i'': <math>u'_i = 1-u_i</math>. If the set <math>u_1</math> is uniform along [0, 1], so are <math>u'_i</math>. Furthermore, covariance is negative, allowing for initial variance reduction. ==Example 2: integral calculation== We would like to estimate :<math>I = \int_0^1 \frac{1}{1+x} \, \mathrm{d}x.</math> The exact result is <math>I=\ln 2 \approx 0.69314718</math>. This integral can be seen as the expected value of <math>f(U)</math>, where :<math>f(x) = \frac{1}{1+x}</math> And ''U'' follows a [[uniform distribution (continuous)|uniform distribution]] [0, 1]. The following table compares the classical Monte Carlo estimate (sample size: 2''n'', where ''n'' = 1500) to the antithetic variates estimate (sample size: ''n'', completed with the transformed sample 1 &minus; ''u''<sub>''i''): {| cellspacing="1" border="1" | | align="right" | '''Estimate''' | align="right" | '''Variance''' |- | ''Classical Estimate'' | align="right" | 0,69365 | align="right" | 0,02005 |- | ''Antithetic Variates '' | align="right" | 0,69399 | align="right" | 0,00063 |} The use of the antithetic variates method to estimate the result shows an important variance reduction. [[Category:Computational statistics]] [[Category:Monte Carlo methods]] {{unreferenced|date=November 2010}}</text> </page> <page> <id>2038</id> <title>Any-angle path planning</title> <text>{{Graph search algorithm}} '''Any-angle path planning''' algorithms search for paths on a cell decomposition of a continuous [[configuration space]] (such as a two-dimensional terrain). Consider, for example, a uniform grid with blocked and unblocked cells. Searching the corresponding [[visibility graph]] finds a shortest path from a given start vertex to a given goal vertex but is typically very slow since the number of edges can grow quadratically in the number of vertices. Searching the corresponding [[grid graph]] typically finds suboptimal paths (since, for example, the heading changes of the resulting path are constrained to multiples of 45 degrees on an eight-neighbor grid graph) but is fast since the number of edges grows no faster than linearly in the number of vertices. Optimizing the path after the search typically shortens the path but does not change the topology of the path. It does not find a shortest path, for example, if the path found by the search algorithm passes a blocked cell on the left but the shortest path passes the same blocked cell on the right. Thus, there is an advantage to interleaving the search and the optimization. '''Any-angle path planning''' algorithms propagate information along grid edges (to search fast) without constraining their paths to grid edges (to find short paths). Thus, the heading changes of their paths are not constrained to specific angles, which explains their name.<ref name="A. Nash, K. Daniel 1183">A. Nash, K. Daniel, S. Koenig and A. Felner. Theta*: Any-Angle Path Planning on Grids. In Proceedings of the AAAI Conference on Artificial Intelligence, pages 1177-1183, 2007.</ref> So far, two main any-angle path planning algorithms have been developed, both based on the heuristic search algorithm [[A*]] <ref>P. Hart, N. Nilsson and B. Raphael, A Formal Basis for the Heuristic Determination of Minimum Cost Paths, IEEE Trans. Syst. Science and Cybernetics, SSC-4(2), 100-107, 1968.</ref>. '''Field D*''' uses interpolation during each vertex expansion,<ref>D. Ferguson and A. Stentz. Field D*: An Interpolation-Based Path Planner and Replanner. Proceedings of the International Symposium on Robotics Research, 2005.</ref> and '''Theta*''' checks for shortcuts during each vertex expansion.<ref name="A. Nash, K. Daniel 1183"/> Both of them find short paths but neither one of them is guaranteed to find shortest paths. ==Applications== * [[Robot navigation]] * [[Real-time strategy]] games ==References== {{reflist}} ==See also== * [[Path planning]] {{DEFAULTSORT:Any-Angle Path Planning}} [[Category:Search algorithms]] [[Category:Robotics]] [[Category:Artificial intelligence]]</text> </page> <page> <id>2042</id> <title>AnyLogic</title> <text>{{Infobox Software | name = AnyLogic | logo = | screenshot = | caption = | collapsible = yes | author = | developer = XJ Technologies | released = | latest release version = Advanced 6 <ref>The release news on [http://www.xjtek.com/company/news/ the official web-site].</ref> | latest release date = | latest preview version = | latest preview date = | frequently updated = | programming language = [[Java (programming language)|Java SE]] | operating system = [[Cross-platform]] | platform = | size = | language = | status = | genre = [[Simulation software]] | license = [[Proprietary software|Proprietary]] | website = [http://www.anylogic.com www.anylogic.com] }} '''AnyLogic''' is a multi-method [[simulation]] modeling 