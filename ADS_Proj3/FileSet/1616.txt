architecture|ARM]] * [[Atmel AVR]] * [[Blackfin]] * [[HC12]] * [[Hitachi H8|H8/300]] * [[IA-32]] ([[X86 architecture|x86]]) * [[x86-64]] * [[IA-64]] * [[Motorola 68000]] * [[MIPS architecture|MIPS]] * [[PA-RISC]] * [[PDP-11]] * [[PowerPC]] * [[R8C]]/[[M16C]]/[[M32C]] * [[Synergistic Processing Unit|SPU]] * [[System/390]]/[[zSeries]] * [[SuperH]] * [[SPARC]] * [[VAX]] {{Refend}} Lesser-known target processors supported in the standard release have included: {{div col|colwidth=15em|small=no}} * [[AMD Am29000|A29K]] * [[ARC International|ARC]] * [[ETRAX CRIS]] * [[D30V]] * [[DSP16xx]] * [[FR-30]] * [[FR-V]] * [[Intel i960]] * [[IP2000]] * [[M32R]] * [[Freescale 68HC11|68HC11]] * [[MCORE]] * [[MIL-STD-1750A]] * [[MMIX]] * [[MN10200]] * [[MN10300]] * [[Motorola 88000]] * [[NS320xx|NS32K]] * [[ROMP]] * [[Stormy16]] * [[V850]] * [[Xtensa]] * [[AVR32]] {{Refend}} Additional processors have been supported by GCC versions maintained separately from the FSF version: {{div col|colwidth=15em|small=no}} * [[Cortus APS3]] * [[D10V]] * [[eSi-RISC]] * [[LatticeMico32]] * [[LatticeMico8]] * [[MeP]] * [[6809|Motorola 6809]] * [[MicroBlaze]] * [[TI MSP430|MSP430]] * [[Nios II]] and [[Nios embedded processor|Nios]] * [[OpenRISC 1200]] * [[PDP-10]] * [[TIGCC]] ([[Motorola 68000|m68k]] variant) * [[System/370]] * [[Zilog Z8000|Z8000]] * [[PIC30#PIC24 and dsPIC 16-bit microcontrollers|PIC24/dsPIC]] * [[NEC SX architecture]]<ref>{{cite web|title=sx-gcc: port gcc to nec sx vector cpu|url=http://code.google.com/p/sx-gcc/}}</ref> {{Refend}} The [[gcj]] Java compiler can target either a native machine language architecture or the [[Java Virtual Machine]]'s [[Java bytecode]].<ref>{{cite web | url = http://gcc.gnu.org/java/ | title = The GNU Compiler for the Java Programming Language | accessdate = 2010-04-22}}</ref> When [[retargetable compiler|retargeting]] GCC to a new platform, [[bootstrapping (compilers)|bootstrapping]] is often used. ==Structure== GCC's external interface is generally standard for a [[UNIX]] compiler. Users invoke a driver program named <code>gcc</code>, which interprets [[Command-line argument|command arguments]], decides which language compilers to use for each input file, runs the [[Assembly language#Assembler|assembler]] on their output, and then possibly runs the [[Linker (computing)|linker]] to produce a complete [[executable]] binary. Each of the language compilers is a separate program that inputs source code and outputs assembly code. All have a common internal structure. A per-language front end [[parsing|parses]] the source code in that language and produces an [[abstract syntax tree]] ("tree" for short). These are, if necessary, converted to the middle-end's input representation, called ''GENERIC'' form; the middle-end then gradually transforms the program towards its final form. [[Compiler optimization]]s and [[static code analysis]] techniques (such as FORTIFY_SOURCE,<ref>{{cite web|url=http://fedoraproject.org/wiki/Security/Features |title=Security Features: Compile Time Buffer Checks (FORTIFY_SOURCE) |publisher=fedoraproject.org |accessdate=2009-03-11}}</ref> a compiler directive which attempts to discover some [[buffer overflow]]s) are applied to the code. These work on multiple representations, mostly the architecture-independent GIMPLE representation and the architecture-dependent [[Register Transfer Language|RTL]] representation. Finally, assembly language is produced using architecture-specific [[pattern matching]] originally based on an algorithm of [[Jack Davidson]] and [[Chris Fraser]]. GCC is written primarily in [[C (programming language)|C]] except for parts of the [[Ada (programming language)|Ada]] front end. The distribution includes the standard libraries for Ada, [[C++]], and [[Java (programming language)|Java]] whose code is mostly written in those languages.<ref>{{cite web | url = http://www.ohloh.net/projects/gcc/analyses/latest | title = languages used to make GCC }}</ref><!-- primary source --> On some platforms, the distribution also includes a low-level runtime library, '''libgcc''', written in a combination of machine-independent C and processor-specific assembly language, designed primarily to handle arithmetic operations that the target processor cannot perform directly.<ref>[http://gcc.gnu.org/onlinedocs/gccint/Libgcc.html GCC Internals], GCC.org, Retrieved March 01, 2010.</ref> In May 2010, the GCC steering committee decided to allow use of a C++ compiler to compile GCC.<ref> {{cite news |title=GCC allows C++ â€“ to some degree |url=http://www.h-online.com/open/news/item/GCC-allows-C-to-some-degree-1012611.html |publisher=[[Heinz Heise|The H]] |date=1 June 2010}}</ref> The compiler will be written in C plus a subset of features from C++. In particular, this was decided so that GCC's developers could use the "[[Destructor (computer science)|destructors]]" and "[[Generic programming|generics]]" features of C++.<ref>{{cite web|url=http://lists.gnu.org/archive/html/emacs-devel/2010-07/msg00518.html|title=An email by Richard Stallman on emacs-devel|quote=The reason the GCC developers wanted to use it is for destructors and generics. These aren't much use in Emacs, which has GC and in which data types are handled at the Lisp level.}}</ref> ===Front-ends=== Frontends vary internally, having to produce trees that can be handled by the backend. Currently, the parsers are all hand-coded [[recursive descent parser]]s, though there is no reason why a [[parser generator]] could not be used for new front-ends in the future (version 2 of the C compiler used a [[GNU bison|bison]] based grammar). Until recently, the tree representation of the program was not fully independent of the processor being targeted. The meaning of a tree was somewhat different for different language front-ends, and front-ends could provide their own tree codes. This was simplified with the introduction of GENERIC and GIMPLE, two new forms of language-independent trees that were introduced with the advent of GCC 4.0. GENERIC is more complex, based on the GCC 3.x Java front-end's intermediate representation. GIMPLE is a simplified GENERIC, in which various constructs are ''lowered'' to multiple GIMPLE instructions. The [[C (Programming Language)|C]], [[C++]] and [[Java (programming language)|Java]] front ends produce GENERIC directly in the front end. Other front ends instead have different intermediate representations after parsing and convert these to GENERIC. In either case, the so-called "gimplifier" then lowers this more complex form into the simpler [[Static single assignment form|SSA]]-based GIMPLE form which is the common language for a large number of new powerful language- and architecture-independent global (function scope) optimizations. ===GENERIC and GIMPLE=== ''GENERIC'' is an [[intermediate representation]] language used as a "middle-end" while compiling source code into executable binaries. A subset, called ''GIMPLE'', is targeted by all the front-ends of GCC. The middle stage of GCC does all the code analysis and optimization, working independently of both the compiled language and the target architecture, starting from the GENERIC representation and expanding it to [[Register Transfer Language]]. The GENERIC representation contains only the subset of the imperative [[computer programming|programming]] constructs optimised by the middle-end. In transforming the source code to GIMPLE, complex [[Expression (programming)|expressions]] are split into a [[three address code]] using [[temporary variable]]s. This representation was inspired by the SIMPLE representation proposed in the McCAT [[compiler]]<ref>[http://web.archive.org/web/20040812030043/www-acaps.cs.mcgill.ca/info/McCAT/McCAT.html McCAT]</ref> by Laurie J. Hendren<ref>[http://www.sable.mcgill.ca/~hendren/ Laurie J. Hendren]</ref> for simplifying the analysis and [[Optimization (computer science)|optimization]] of [[Imperative programming|imperative programs]]. ===Optimization=== Optimization can occur 