to customer-demand driven applications needs both competing and complementary frameworks sometimes end up in a product. Further, some cognoscenti argue, because of the complexity of their APIs, the intended reduction in overall development time may not be achieved due to the need to spend additional time learning to use the framework{{mdash}}which criticism is certainly valid when a special or new framework is first encountered by a development staff. If such a framework is not utilized in subsequent job taskings, the time invested ascending the framework's learning curve might be more expensive than purpose written code familiar to the project's staff{{mdash}}many programmers keep aside useful boilerplate for common needs. {{bull}}However, it could be argued that once the framework is learned, future projects might be quicker and easier to complete{{mdash}}the concept of a framework is to make a one-size-fits-all solution set, and with familiarity, code production should logically be increased. There are no such claims made about the size of the code eventually bundled with the output product, nor its relative efficiency and conciseness. Using any library solution necessarily pulls in extras and unused extraneous assets unless the software is a compiler-object linker making a tight (small, wholly controlled, and specified) executable module. {{bull}}The issue continues, but a decade-plus of industry experience has shown that the most effective frameworks turn out to be those that evolve from re-factoring the common code of the enterprise, as opposed to using a generic "one-size-fits-all" framework developed by third-parties for general purposes. An example of that would be how the user interface in such an application package as an Office suite grows to have common look, see, feel and data sharing attributes and methods as the once disparate bundled applications become unified{{mdash}}hopefully a suite which is tighter and smaller as the newer evolved one can be a product sharing integral utility libraries and user interfaces. This trend in the controversy brings up an important issue about frameworks. Creating a framework that is elegant, as opposed to one that merely solves a problem, is still an art rather than a science. "[[elegance|Software elegance]]" implies clarity, conciseness, and little waste (extra or extraneous functionality{{mdash}}much of which is user defined). For those frameworks that generate code, for example, "elegance" would imply the creation of code that is clean and comprehensible to a reasonably knowledgeable programmer (and which is therefore readily modifiable), as opposed to one that merely generates correct code. The elegance issue is why relatively few software frameworks have stood the test of time: the best frameworks have been able to evolve gracefully as the underlying technology on which they were built advanced. Even there, having evolved, many such packages will retain legacy capabilities bloating the final software as otherwise replaced methods have been retained in parallel with the newer methods. == Examples == Software frameworks typically contain considerable housekeeping and utility code in order to help bootstrap user applications, but generally focus on specific problem domains, such as: * Artistic drawing, music composition, and mechanical [[CAD]]<ref>{{citation|doi = 10.1145/98188.98197|last1 = Vlissides|first1 = J M|last2 = Linton|first2 = M A|year = 1990|title = Unidraw: a framework for building domain-specific graphical editors|journal = ACM Transactions of Information Systems|volume = 8|issue = 3|pages =237–268|postscript = <!--none-->}}</ref><ref>{{citation|last = Johnson|first = R E|year = 1992|title = Documenting frameworks using patterns|publisher = ACM Press|journal = Proceedings of the Conference on Object Oriented Programming Systems Languages and Applications|pages = 63–76|postscript = <!--none-->}}</ref> * [[Compiler]]s for different [[programming language]]s and target machines.<ref>{{citation|last1 = Johnson|first1 = R E|first2 = C|last2 = McConnell|first3 = M J|last3 = Lake|year = 1992|title = The RTL system: a framework for code optimization|editor-first = R|editor-last = Giegerich|editor2-first = S L|editor2-last = Graham|publisher = [[Springer-Verlag]]|journal = Proceedings of the International workshop on code generation|pages = 255–274|postscript = <!--none-->}}</ref> * Financial modeling applications<ref>{{citation|last1 = Birrer|first1 = A|first2 = T|last2 = Eggenschwiler|year = 1993|title = Frameworks in the financial engineering domain: an experience report|publisher = [[Springer-Verlag]]|DUPLICATE DATA: title = Proceedings of the European conference on object-oriented programming|pages = 21–35|postscript = <!--none-->}}</ref> * Earth system modeling applications<ref>{{citation|last1 = Hill|first1 = C|first2 = C|last2 = DeLuca|first3 = V|last3 = Balaji|first4 = M|last4 = Suarez|first5 = A|last5 = da Silva|title = Architecture of the Earth System Modeling Framework ([[ESMF]])|journal = Computing in Science and Engineering|year = 2004|pages = 18–28|postscript = <!--none-->}}</ref> * [[Decision support systems]]<ref>{{citation|last = Gachet|first = A|year = 2003|title = Software Frameworks for Developing Decision Support Systems - A New Component in the Classification of DSS Development Tools|journal = Journal of Decision Systems|volume = 12|issue = 3|pages = 271–281|postscript = <!--none-->}}</ref> * [[Multimedia framework|Media playback and authoring]] * [[Web application framework|Web applications]] * [[Middleware]] == Architecture == According to Pree,<ref>{{citation|title = Meta Patterns-A Means For Capturing the Essentials of Reusable Object-Oriented Design|author = Pree, W|journal = Proceedings of the 8th European Conference on Object-Oriented Programming|pages = 150–162|year = 1994|publisher = [[Springer-Verlag]]|postscript = <!--none-->}}</ref> software frameworks consist of ''frozen spots'' and ''hot spots''. ''Frozen spots'' define the overall architecture of a software system, that is to say its basic components and the relationships between them. These remain unchanged (frozen) in any instantiation of the application framework. ''Hot spots'' represent those parts where the programmers using the framework add their own code to add the functionality specific to their own project. Software frameworks define the places in the [[software architecture|architecture]] where application programmers may make adaptations for specific functionality—the hot spots. In an [[Object-oriented programming|object-oriented]] environment, a framework consists of [[Abstract class|abstract]] and [[Class_(computer_science)#Concrete_classes|concrete]] [[Class (computer science)|classes]]. [[Instantiation]] of such a framework consists of [[Object composition|composing]] and [[subclass (computer science)|subclassing]] the existing classes.<ref>{{citation|last = Buschmann|first = F|year = 1996|title = Pattern-Oriented Software Architecture Volume 1: A System of Patterns. Chichester|publisher = [[John Wiley & Sons|Wiley]]|isbn = 0471958697|postscript = <!--none-->}}</ref> When developing a concrete software system with a software framework, developers utilize the hot spots according to the specific needs and requirements of the system. Software frameworks rely on the [[Hollywood Principle]]: "Don't call us, we'll call you."<ref>{{citation|last = Larman|first = C|year = 2001|title = Applying UML and Patterns: 