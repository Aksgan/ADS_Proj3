[[Task (computers)|task]]. The sole task is typically realized as an infinite loop in main(), e.g. in C/C++. The basic scheme is to cycle through a repeating sequence of activities, at a set frequency. For example, let us consider the example of an [[embedded system]] designed to monitor a [[temperature sensor]] and update an [[LCD]] display. The LCD may need to be written ten times a second (i.e., every 100 ms). If the temperature sensor must be read every 50 ms for other reasons, we might construct a loop of the following appearance: <pre> main() { // initialization code here while (1) { currTemp = tempRead(); lcdWrite(currTemp); // waste CPU cycles until 50 ms currTemp = tempRead(); // do other stuff // waste CPU cycles until 100 ms } } </pre> The outer 100 ms cycle is called the major cycle. In this case, there is also an inner minor cycle of 50 ms. == See also == * [[Preemption (computing)]] * [[Real-Time Operating System]] [[Category:Operating system technology]] [[Category:Concurrent computing]]</text> </page> <page> <id>8843</id> <title>Cyclone (programming language)</title> <text>{{Infobox programming language | name = Cyclone | logo = | caption = | file ext = | paradigm = | released = {{start date|2006}} | designer = AT&T Labs | developer = | latest release version = 1.0 | latest release date = {{start date and age|2006|05|08}} | latest preview version = | latest preview date = <!-- {{start date and age|YYYY|MM|DD}} --> | typing = | implementations = | dialects = | influenced by = [[C (programming language)|C]] | influenced = | programming language = | operating system = | license = | website = {{URL|http://cyclone.thelanguage.org}} | wikibooks = }} The '''Cyclone''' [[programming language]] is intended to be a safe dialect of the [[C (programming language)|C language]]. Cyclone is designed to avoid [[buffer overflow]]s and other vulnerabilities that are endemic in C programs, without losing the power and convenience of C as a tool for [[system programming]]. Cyclone development was started as a joint project of AT&T Labs Research and [[Greg Morrisett]]'s group at Cornell in 2001. Version 1.0 was released on May 8, 2006. ==Language features== Cyclone attempts to avoid some of the common pitfalls of [[C (programming language)|C]], while still maintaining its look and performance. To this end, Cyclone places the following limits on programs: * <code>[[NULL]]</code> checks are inserted to prevent [[segmentation fault]]s * [[Pointer arithmetic]] is limited * Pointers must be initialized before use (this is enforced by [[definite assignment analysis]]) * [[Dangling pointer]]s are prevented through region analysis and limits on [[Malloc|<code>free()</code>]] * Only "safe" casts and unions are allowed * [[Control flow|<code>goto</code>]] into scopes is disallowed * [[Control flow|<code>switch</code>]] labels in different scopes are disallowed * Pointer-returning functions must execute <code>return</code> * [[Setjmp/longjmp|<code>setjmp</code>]] and [[Setjmp/longjmp|<code>longjmp</code>]] are not supported To maintain the tool set that C programmers are used to, Cyclone provides the following extensions: * '''Never-<code>NULL</code> pointers''' do not require <code>NULL</code> checks * '''"Fat" pointers''' support pointer arithmetic with run-time [[bounds checking]] * '''Growable regions''' support a form of safe manual memory management * '''[[Garbage collection (computer science)|Garbage collection]]''' for heap-allocated values * '''[[Tagged union]]s''' support type-varying arguments * '''Injections''' help automate the use of tagged unions for programmers * '''[[Polymorphism (computer science)|Polymorphism]]''' replaces some uses of [[void pointer|<code>void *</code>]] * '''varargs''' are implemented as fat pointers * '''[[Exception handling|Exceptions]]''' replace some uses of <code>setjmp</code> and <code>longjmp</code> For a better high-level introduction to Cyclone, the reasoning behind Cyclone and the source of these lists, see [http://www.research.att.com/projects/cyclone/papers/cyclone-safety.pdf]. Cyclone looks, in general, much like [[C (programming language)|C]], but it should be viewed as a C-like language. ===Pointer/reference types=== Cyclone implements three kinds of [[reference (computer science)|reference]] (following C terminology these are called pointers): * <code>*</code> (the normal type) * <code>@</code> (the never-<code>NULL</code> pointer), and * <code>?</code> (the only type with [[pointer arithmetic]] allowed, "fat" pointers). The purpose of introducing these new pointer types is to avoid common problems when using pointers. Take for instance a function, called <code>foo</code> that takes a pointer to an int: <source lang="C"> int foo(int *); </source> Although the person who wrote the function <code>foo</code> could have inserted <code>NULL</code> checks, let us assume that for performance reasons they did not. Calling <code>foo(NULL);</code> will result in [[undefined behavior]] (typically, although not necessarily, a '''SIGSEGV''' being sent to the application). To avoid such problems, Cyclone introduces the <code>@</code> pointer type, which can never be <code>NULL</code>. Thus, the "safe" version of <code>foo</code> would be: <source lang="C"> int foo(int @); </source> This tells the Cyclone compiler that the argument to <code>foo</code> should never be <code>NULL</code>, avoiding the aforementioned undefined behavior. The simple change of <code>*</code> to <code>@</code> saves the programmer from having to write <code>NULL</code> checks and the operating system from having to trap <code>NULL</code> pointer dereferences. This extra limit, however, can be a rather large stumbling block for most C programmers, who are used to being able to manipulate their pointers directly with arithmetic. Although this is desirable, it can lead to [[buffer overflow]]s and other "off-by-one"-style mistakes. To avoid this, the <code>?</code> pointer type is delimited by a known bound, the size of the array. Although this adds overhead due to the extra information stored about the pointer, it improves safety and security. Take for instance a simple (and na√Øve) <code>strlen</code> function, written in C: <source lang="C"> int strlen(const char *s) { int iter = 0; if (s == NULL) return 0; while (s[iter] != '\0') { iter++; } return iter; } </source> This function assumes that the string being passed in is terminated by NUL (<code>'\0'</code>). However, what would happen if <code>char buf[] = {'h','e','l','l','o','!'};</code> were passed to this string? This is perfectly legal in C, yet would cause <code>strlen</code> to iterate through memory not necessarily associated with the string <code>s</code>. There are functions, such as <code>strnlen</code> which can be used to avoid such problems, but these functions are not standard with every implementation of [[ANSI C]]. The Cyclone version of <code>strlen</code> is not so different from the C version: <source lang="C"> int strlen(const char ? 