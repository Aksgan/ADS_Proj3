of the IEEE Third International Workshop on Research Issues on Data Engineering - Interoperability in Multidatabase Systems; Vienna, Austria; IEEE Computer Society Press, California, USA; April 19–20, 1993; pp. 42–49; ISBN 0-8186-3710-2. * Interoperability Using APPC; ACM SIGMOD International Conference on Management of Data Proceedings; Washington D.C., USA; ACM Press, New York, USA; May 1993; pp. 479–482; ISBN 0-89791-592-5. * Managing Interoperability Using APPC; IEEE First International Workshop on Systems Management Proceedings; Los Angeles, California, USA; IEEE Computer Society Press, California, USA; April 14–16, 1993; pp. 54–62; ISBN 0-8186-3820-6. == References == {{reflist}} == External links == * [http://www.inderscience.com/browse/index.php?journalID=209#board ''International Journal of Intelligent Information and Database Systems''] * [http://www.inderscience.com/browse/index.php?journalID=284#board ''International Journal of Knowledge and Web Intelligence''] * [http://www.hindawi.com/journals/aai/editors.html ''International Journal of Advances in Artificial Intelligence''] * [http://www.actapress.com/Content_of_Journal.aspx?journalID=111#editors-3 ''International Journal of Computers and Applications''] * [http://d_mukhopadhyay.tripod.com ''Dr. Debajyoti Mukhopadhyay'' - Home Page] * [http://genealogy.math.ndsu.nodak.edu/id.php?id=86920 ''Mathematics Genealogy Project, North Dakota State University''] * [http://twitter.com/DrDebM ''Dr. Debajyoti Mukhopadhyay'' on Twitter] {{Persondata <!-- Metadata: see [[Wikipedia:Persondata]]. --> | NAME = Mukhopadhyay, Debajyoti | ALTERNATIVE NAMES = | SHORT DESCRIPTION = | DATE OF BIRTH = October 5, 1955 | PLACE OF BIRTH = | DATE OF DEATH = | PLACE OF DEATH = }} {{DEFAULTSORT:Mukhopadhyay, Debajyoti}} [[Category:Indian academics]] [[Category:University of Calcutta alumni]] [[Category:Stevens Institute of Technology alumni]] [[Category:Alumni of Queen's University Belfast]] [[Category:1955 births]] [[Category:Living people]] [[Category:Indian computer scientists]] [[Category:Senior Members of the IEEE]] [[Category:Bengali people]] [[Category:People from Kolkata]] [[Category:Database researchers]] [[Category:Software engineers]]</text> </page> <page> <id>9740</id> <title>Decision rules</title> <text>A set of '''decision rules''' is the verbal equivalent of a graphical [[decision tree]], which specifies class membership based on a hierarchical sequence of (contingent) decisions. Each rule in a set of decision rules therefore generally takes the form of a [[Horn clause]] wherein class membership is implied by a conjunction of contingent observations. :'''IF''' <math>condition_1</math> '''AND''' <math>condition_2</math> '''AND''' ... '''AND''' <math>condition_n</math> '''THEN''' CLASS = <math>class_i</math> where <math>condition_j</math> is in general contingent on the choice of <math>condition_{j-1}</math>. Decision rules can be transcribed from the corresponding decision tree, or can be induced directly from observations. Decision rules are commonly used in the medical field. For example, the Ottawa Ankle Rules guide obtaining radiographs for traumatic ankle pain. == See also == [[Category:Decision trees]] [[Category:Machine learning]] {{comp-sci-stub}}</text> </page> <page> <id>9751</id> <title>Declarative programming</title> <text>{{Programming paradigms}} In [[computer science]], '''declarative programming''' is a [[programming paradigm]] that expresses the logic of a [[computation]] without describing its [[control flow]].<ref>{{citation|last=Lloyd|first=J.W.|title=Practical Advantages of Declarative Programming}}</ref> Many languages applying this style attempt to minimize or eliminate [[side effect (computer science)|side effects]] by describing ''what'' the program should accomplish, rather than describing ''how'' to go about accomplishing it.<ref>[http://foldoc.org/index.cgi?query=declarative+language Declarative language] in The Free On-line Dictionary of Computing, Editor Denis Howe.</ref> This is in contrast with [[imperative programming]], which requires an explicitly provided [[algorithm]]. Declarative programming often considers [[Program (machine)|programs]] as theories of a [[formal logic]], and computations as deductions in that logic space. Declarative programming has become of particular interest recently, as it may greatly simplify writing [[parallel computing|parallel programs]].<ref>http://www.cse.unsw.edu.au/~pls/damp09/</ref> Common declarative languages include those of [[regular expression]]s, [[logic programming]], and [[functional programming]]. == Definition == Declarative programming is often defined as any style of programming that is not [[imperative programming|imperative]]. A number of other common definitions exist that attempt to give the term a definition other than simply contrasting it with imperative programming. For example: * A program that describes ''what'' computation should be performed and not ''how'' to compute it * Any programming language that lacks [[Side effect (computer science)|side effects]] (or more specifically, is [[Referential transparency (computer science)|referentially transparent]]) * A language with a clear correspondence to [[mathematical logic]]. [http://www.cse.unsw.edu.au/~chak/papers/diss.ps.gz] <!-- this citation is just for this bullet point --> These definitions overlap substantially. ==Subparadigms== Declarative programming is an umbrella term that includes a number of better-known [[programming paradigm]]s. ===Functional programming=== {{Main|Functional programming}} Functional programming, and in particular [[purely functional]] programming, attempts to minimize or eliminate side effects, and is therefore considered declarative. Most functional languages, such as [[Scheme (programming language)|Scheme]], [[Objective Caml]] and [[Unlambda]], however, do permit side effects in practice. While functional languages typically do appear to specify "how", a compiler for a purely functional programming language is free to extensively rewrite the operational behavior of a function, so long as the same result is returned for the same inputs. This can be used to, for example, make a function compute its result in [[parallel computing|parallel]], or to perform substantial optimizations (such as [[Deforestation (computer science)|deforestation]]) that a compiler may not be able to safely apply to a language with side effects. ===Logic programming=== {{Main|Logic programming}} Logic programming languages such as [[Prolog]] state and query relations. The specifics of ''how'' these queries are answered is up to the implementation and its theorem prover, but typically take the form of some sort of [[unification (computing)|unification]]. Like functional programming, many logic programming languages permit side effects, and as a result are not strictly declarative. ===Constraint programming=== {{Main|Constraint programming}} In Constraint programming relations between variables are stated in the form of constraints, specifying the properties of a solution to be found. The set of constraints is then [[Solver (computer science)|solved]] by giving a value to each variable so that the solution is consistent with the maximum number of constraints. Constraint programming is often used as a complement to other paradigms: functional, logical or even imperative programming. ===Domain-specific languages=== {{Main|Domain-specific language}} Some well-known examples of declarative domain specific languages (DSLs) include [[regular expression]]s, [[CSS]], and a subset of [[SQL]] (SELECT queries, for example). DSLs have the advantage of being useful while not necessarily needing to be [[Turing-complete]], which makes it easier for a language to be purely declarative. Many markup languages such as [[HTML]], [[MXML]], [[XAML]], [[XSLT]], [[SVG]] or other [[user interface markup language]]s are often declarative. HTML, for example, only describes what should appear on a webpage and doesn't specify the possible [[interaction]]s with it. Some software systems now combine traditional user interface markup languages such as HTML with declarative markup that defines what (but not how) the back-end server systems should do to 