operate on [[ASCII]] characters. The LC-3 has no native support for [[floating-point]] numbers. The hardware implementation given in the Patt and Patel text is not pipelined or otherwise optimized, but it is certainly possible to create a fast implementation using more advanced concepts in computer architecture. == Instruction set == The LC-3 instruction set implements fifteen types of instructions, with a sixteenth opcode reserved for later use. The architecture is a load-store architecture; values in memory must be brought into the register file before they can be operated upon. Arithmetic instructions available include addition, bitwise AND, and bitwise NOT, with the first two of these able to use both registers and sign-extended immediate values as operands. These operations are sufficient to implement a number of basic arithmetic operations, including subtraction (by negating values) and bitwise left shift (by using the addition instruction to multiply values by two). The LC-3 can also implement any bitwise logical function, because NOT and AND together are [[functional completeness|logically complete]]. Memory accesses can be performed by computing addresses based on the current value of the [[program counter]] (PC) or a register in the register file; additionally, the LC-3 provides indirect loads and stores, which use a piece of data in memory as an address to load data from or store data to. Values in memory must be brought into the register file before they can be used as part of an arithmetic or logical operation. The LC-3 provides both conditional and unconditional control flow instructions. Conditional branches are based on the arithmetic sign (negative, zero, or positive) of the last piece of data written into the register file. Unconditional branches may move execution to a location given by a register value or a PC-relative offset. Three instructions (JSR, JSRR, and TRAP) support the notion of subroutine calls by storing the address of the code calling the subroutine into a register before changing the value of the program counter. The LC-3 does not support the direct arithmetic comparison of two values; comparing two register values arithmetically requires subtracting one from the other and evaluating the result. == Programming language support == While it has not been implemented on a physical chip, the LC-3 can be used in simulation on Linux/Unix, Mac OS X and Windows environments. The simulation tools include an assembler with support for computerized offset computation with labels and the insertion of constants, strings, and blank memory locations into a block of assembly code. There is also a convention for using the C language on the LC-3. A sample assembler, compiler, and simulator are provided by McGraw-Hill.<ref name="CompSysBook" /> === C and the LC-3 === The calling convention for C functions on the LC-3 is similar to that implemented by other systems, such as the x86 ISA. When running C programs, the architecture maintains a memory model that includes space for a [[call stack]] and [[dynamic memory allocation]]. In this model, four of the processor's eight general purpose registers take on special roles: R4 is used as a base register for loading and storing global data, R5 is used to point to the current function's area on the call stack, and R6 is used as a stack pointer. Additionally, R7 is usually reserved for storage of return addresses from function calls; the JSR, JSRR, and TRAP instructions automatically store return addresses in this register during their execution. When a C function is called under this model, the function's parameters are pushed onto the stack right to left. Space is then made on the stack for the return value of the function being called, the address of the instruction in the caller to return to, and the caller's value of R5. Local variables in the function being called are pushed onto the stack in the order that they are declared. Note that the LC-3 does not have native PUSH and POP instructions, so addition and memory storage instructions must be used separately to implement the stack. == The LC-3b == The [http://users.ece.utexas.edu/~patt/07s.360N/handouts/360n.appC.pdf LC-3b ISA] describes a modified version of the LC-3 that includes the following changes: * The machine's word size remains 16 bits, but its memory is now byte-addressable with the same address space. * The LD and ST instructions (load and store data using PC-relative addressing) have been removed. * The LDI and STI instructions (indirect loads and stores) use register-based addressing instead of PC-relative addressing. * Two instructions, LDB and STB, have been added to manipulate individual bytes of memory; the other load and store instructions continue to act on entire words. * The reserved opcode has been converted into a shift instruction, SHF, that supports [[arithmetic shift|arithmetic]] and [[logical shift]]s of arbitrary size in both directions. These changes make the hardware of the LC-3b slightly more complex than that of the LC-3. For example, the LC-3b needs a shifter (the LC-3 does not) and extra logic in its memory unit to properly handle loading and storing data of various sizes. Ashley Wise maintains a set of [http://www.crhc.uiuc.edu/~awise/ tools] for simulating and working with the LC-3b. == See also == * [[Educational programming language]] *[[DLX]] *[[Little man computer]] *[[MIX]], [[MMIX]] *[[MikroSim]] == References == <references /> {{prog-lang-stub}} [[Category:Assembly languages]] [[Category:Educational programming languages]]</text> </page> <page> <id>20920</id> <title>LCF notation</title> <text>{{For|other uses|LCF (disambiguation){{!}}LCF}} [[Image:Nauru graph.svg|thumb|220px|The [[Nauru graph]]<ref name="DE1">[[David Eppstein|Eppstein, D.]], [http://11011110.livejournal.com/124705.html The many faces of the Nauru graph] on LiveJournal, 2007.</ref> has LCF notation [5, &minus;9, 7, &minus;7, 9, &minus;5]<sup>4</sup>.]] In [[combinatorics|combinatorial]] mathematics, '''LCF notation''' or '''LCF code''' is a notation devised by [[Joshua Lederberg]], and extended by [[Harold Scott MacDonald Coxeter|Coxeter]] and [[Robert Frucht|Frucht]], for the representation of [[cubic graph]]s that are [[Hamiltonian path|Hamiltonian]].<ref>Weisstein, Eric W. "[http://mathworld.wolfram.com/LCFNotation.html LCF Notation]." From MathWorld--A Wolfram Web Resource.</ref><ref>{{citation|last=Frucht|first=R.|title=A canonical representation of trivalent Hamiltonian graphs|journal=Journal of Graph Theory|volume=1|pages=45â€“60|year=1976|issue=1|doi=10.1002/jgt.3190010111}}.</ref> Since the graphs are Hamiltonian, the vertices can be arranged in a cycle, which accounts for two edges per vertex. The third edge from each vertex can then be described by how many positions clockwise (positive) or counter-clockwise (negative) it leads. 