computation games”<ref>H. Ma, R. Chandrasekar, C. Quirk, A. Gupta: “Page Hunt: Improving search engines using human computation games”. Proceedings of the 32nd international ACM SIGIR conference on Research and development in information retrieval, 2009.</ref>): about 27% of the pages in test database had 100% findability (it means that all the person who were shown this page could bring it to the 5 best results), while almost the same number of pages (26%) was found by nobody. Thereby, a relation between the length URL and a webpage findability could be postulated: The longer is an URL of the webpage, the harder was to "hunt" it. Also the winning search queries were analyzed and classified. The queries that contain: # Spelling or punctuation alterations # Sitename to site alterations # Acronym/Initialism-Expansion alterations # Conceptual alterations ==See also== *[[Google Image Labeler]] *[[Foldit]] *[[ESP Game]] ==External links== * [http://www.cs.cmu.edu/~biglou/ieee-gwap.pdf L. von Ahn: “Games with a purpose”. Computer, vol. 29(6), pp. 92–94, 2006.] * [http://appsrv.cse.cuhk.edu.hk/~hma/Poster_SigIR09_Hao.pdf H. Ma, R. Chandrasekar, C. Quirk, A. Gupta: “Page Hunt: Improving search engines using human computation games”. Proceedings of the 32nd international ACM SIGIR conference on Research and development in information retrieval, 2009.] * [http://internetwidgets.blogspot.com/2009/11/gwap-from-bing-page-hunt.html Blog entry about Page Hunt] ==References== {{Reflist}} [[Category:Human-based computation]]</text> </page> <page> <id>28296</id> <title>Paging</title> <text>{{Dablink|This article is about computer virtual memory. For the wireless communication devices, see "[[Pager]]". [[Bank switching]] is also called ''paging''. [[Page flipping]] is also called ''paging''.}} In [[computer]] [[operating system]]s, '''paging''' is one of the [[Memory management|memory-management]] schemes by which a computer can store and retrieve data from secondary storage for use in main memory. In the paging memory-management scheme, the operating system retrieves data from secondary storage in same-size blocks called ''pages''. The main advantage of paging is that it allows the physical address space of a process to be [[Contiguous#Computer science|noncontiguous]]. Before the time paging was used, systems had to fit whole programs into storage [[contiguously]], which caused various [[Computer data storage|storage]] and [[Fragmentation (computer)|fragmentation]] problems.<ref>{{Cite book | contribution = Virtual memory systems | title = Encyclopedia of computer science and technology | editor1-last = Belzer | editor1-first = Jack | editor2-last = Holzman | editor2-first = Albert G. | editor3-last = Kent | editor3-first = Allen | publisher = CRC Press | volume=14 | page = 32 | year = 1981 | url = http://books.google.com/?id=KUgNGCJB4agC&printsec=frontcover | isbn = 0824722140 | postscript = <!--None--> }}</ref> Paging is an important part of [[virtual memory]] implementation in most contemporary general-purpose operating systems, allowing them to use disk storage for data that does not fit into physical [[random-access memory]] (RAM). ==Overview== The main functions of paging are performed when a program tries to access pages that are not currently mapped to physical memory (RAM). This situation is known as a [[page fault]]. The operating system must then take control and handle the page fault, in a manner invisible to the program. Therefore, the operating system must: # Determine the location of the data in auxiliary storage. # Obtain an empty [[page frame]] in RAM to use as a container for the data. # Load the requested data into the available page frame. # Update the [[page table]] to show the new data. # Return control to the program, transparently retrying the [[Instruction (computer science)|instruction]] that caused the page fault. Because RAM is faster than auxiliary storage, paging is avoided until there is not enough RAM to store all the data needed. When this occurs, a page in RAM is moved to auxiliary storage, freeing up space in RAM for use. Thereafter, whenever the page in secondary storage is needed, a page in RAM is saved to auxiliary storage so that the requested page can then be loaded into the space left behind by the old page. Efficient paging systems must determine the page to swap by choosing one that is least likely to be needed within a short time. There are various [[page replacement algorithm]]s that try to do this. Most operating systems use some approximation of the [[least recently used]] (LRU) page replacement algorithm (the LRU itself cannot be implemented on the current hardware) or [[working set]] based algorithm. If a page in RAM is modified (i.e. if the page becomes ''dirty'') and then chosen to be swapped, it must either be written to auxiliary storage, or simply discarded. To further increase responsiveness, paging systems may employ various strategies to predict what pages will be needed soon so that it can preemptively load them. === Demand paging === {{Main|Demand paging}} When demand paging is used, no preemptive loading takes place. Paging only occurs at the time of the data request, and not before. In particular, when a demand pager is used, a program usually begins execution with none of its pages pre-loaded in RAM. Pages are copied from the executable file into RAM the first time the executing code references them, usually in response to [[page fault]]s. As such, much of the executable file might never be loaded into memory if pages of the program are never executed during that run. === Anticipatory paging === This technique preloads a process's non-resident pages that are likely to be referenced in the near future (taking advantage of [[locality of reference]]). Such strategies attempt to reduce the number of page faults a process experiences. === Free page queue === The free page queue is a list of page frames that are available for assignment after a page fault. Some operating systems<ref group=NB>E.g., [[MVS]]</ref> support page reclamation; if a page fault occurs for a page that had been stolen and the page frame was never reassigned, then the operating system avoids the necessity of reading the page back in by assigning the unmodified page frame. === Page stealing === Some operating systems periodically look for pages that have not been recently referenced and add them to the Free page queue, after paging them out if they have been modified. === Swap prefetch === A few operating systems use anticipatory paging, also called swap prefetch. These operating 