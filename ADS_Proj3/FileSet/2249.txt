for the benefit of students by including more detail and explanations had an adverse effect on the faculty, who then had to sift through the added material to outline and prepare their lectures" (Hopcroft 1989). Still, the most cited edition of the book is apparently the 1979 edition: According to the website [[CiteSeerX]], over 3000 scientific papers freely available online cite this edition of the book (CiteSeerX, 2009). ==References== * {{cite web|url=http://citeseerx.ist.psu.edu/stats/citations|title=CiteSeerX Most Cited Computer Science Citations|accessdate=May 20, 2009}} * Entry [http://catb.org/~esr/jargon/html/C/Cinderella-Book.html "Cinderella book".] In: [[The Jargon file]] (version 4.4.7, December 29, 2003). * {{cite journal| last = Hopcroft | first = John E. | title=The emergence of computer science - A citation classic commentary on 'Formal Languages and their Relation to Automata' | url=http://garfield.library.upenn.edu/classics1989/classics1989.html | journal=[[Current Contents|Current Contents Engineering, Technology, and Applied Sciences]] | volume=31 | pages=12–12 | year=1989 }} [http://garfield.library.upenn.edu/classics1989/A1989AF70300001.pdf available online (pdf)] *{{cite book | last = Shallit | first = Jeffrey O. | authorlink = Jeffrey Shallit | title = A Second Course in Formal Languages and Automata Theory | publisher = Cambridge University Press | date = 2008 | page = ix | isbn = 978-0-521-86572-2 }} ==See also== *[[Introduction to the Theory of Computation]] by [[Michael Sipser]], another standard textbook in the field *[[List of important publications in theoretical computer science]] ==External links== *[http://infolab.stanford.edu/~ullman/ialc.html Book homepage] [[Category:Computer science books]] [[Category:Formal languages]] [[Category:Automata theory]] [[Category:1979 books]] [[Category:2000 books]] [[Category:2006 books]] [[hr:Introduction to Automata Theory, Languages, and Computation]]</text> </page> <page> <id>19244</id> <title>IntruShield</title> <text>The [[McAfee]] '''IntruShield''' is a network-based intrusion prevention sensor appliance that is used in prevention of zero-day, DoS ([[Denial of Service]]) attacks, [[spyware]], [[malware]], botnets and [[VoIP]] threats.[http://www.mcafee.com/us/local_content/datasheets/ds_intrushield_ips_app_ent.pdf] Its now called McAfee Network Security Platform. {| class="wikitable" |- ! Sensor hardware components ! I-4010 ! I-4000 ! I-3000 ! I-2700 ! I-1400 ! I-1200 |- | Performance | Up to 2 Gbit/s | Up to 2 Gbit/s | Up to 1 Gbit/s | Up to 600 Mbit/s | Up to 200 Mbit/s | Up to 100 Mbit/s |- | Dedicated Gigabit Ports | 12 | 4 | 12 | 2 | n/a | n/a |- | Dedicated Fast Ethernet Ports | n/a | n/a | n/a | 6 | 4 | 2 |- | Dedicated Fast Ethernet Response Ports | 2 | 2 | 2 | 3 | 1 | 1 |} {{primarysources|date=May 2007}} [[Category:Computer network security]]</text> </page> <page> <id>19250</id> <title>Intrusion tolerance</title> <text>'''Intrusion tolerance''' is a [[Fault-tolerant design]] approach to defending information systems against malicious attack. Abandoning the conventional aim of preventing all intrusions, intrusion tolerance instead calls for triggering mechanisms that prevent intrusions from leading to a system security failure. Projects in this area include the MAFTIA project (Malicious- and Accidental-Fault Tolerance for Internet Applications), which developed concepts and prototyped architectures, and the [http://www.tolerantsystems.org/ OASIS] program, which implemented several intrusion-tolerant systems. == See also == *[[Byzantine fault tolerance]] == External links == *Article "[http://hdl.handle.net/10455/2988 Intrusion Tolerance: Concepts and Design Principles. A Tutorial.]" by [http://www.di.fc.ul.pt/~pjv/ Paulo Veríssimo] [[Category:Fault tolerance]]</text> </page> <page> <id>19261</id> <title>Invariant-based programming</title> <text>'''Invariant based programming'''<ref>Back, Ralph-Johan: Invariant Based Programming: Basic approach and Teaching Experience, Formal Aspects of Computing, 14 February 2008, ISSN 0934-5043 (Print) 1433-299X (Online)</ref> is a programming methodology where [[Formal specification|specifications]] and [[Invariant (computer science)|invariants]] are written before the actual program statements. Writing down the invariants during the programming process has a number of advantages: it requires the programmer to make his intentions about the program behavior explicit before actually implementing it, and invariants can be evaluated dynamically during execution to catch common programming errors. Furthermore, if strong enough, invariants can be used to prove the [[Formal verification|correctness]] of the program based on the [[Formal semantics of programming languages|formal semantics]] of program statements. A combined programming and specification language, connected to a powerful formal proof system, will generally be required for full verification of non-trivial programs. In this case a high degree of automation of proofs is also possible. In most existing programming languages the main organizing structures are control flow blocks such as [[For loop|<tt>for</tt> loops]], [[While loop|<tt>while</tt> loops]] and [[If statement|<tt>if</tt> statements]]. Such languages may not be ideal for invariants-first programming, since they force the programmer to make decisions about control flow before writing the invariants. Furthermore, most programming languages do not have good support for writing specifications and invariants, since they lack quantifier operators and one can typically not express higher order properties. The idea of developing the program together with its proof originated from [[Edsger Dijkstra|E.W. Dijkstra]]. Actually writing invariants before program statements has been considered in a number of different forms by M.H. van Emden, [[John C. Reynolds|J.C. Reynolds]] and [[Ralph-Johan Back|R-J Back]]. == See also == [[Eiffel (programming language)]] == Notes == <references/> [[Category:Formal methods]] [[Category:Programming paradigms]]</text> </page> <page> <id>19265</id> <title>Invariant subspace problem</title> <text>In the field of [[mathematics]] known as [[functional analysis]], the '''invariant subspace problem''' for a complex [[Banach space]] ''H'' of [[dimension (vector space)|dimension]] > 1 is the question whether every [[bounded operator|bounded linear operator]] ''T'' : ''H'' → ''H'' has a non-trivial [[closed set|closed]] [[invariant subspace|''T''-invariant subspace]] (a closed [[linear subspace]] ''W'' of ''H'' which is different from {0} and ''H'' such that ''T''(''W'') ⊆ ''W''). To find a "counterexample" to the invariant subspace problem, means to answer affirmatively the following equivalent question: does there exist a bounded linear operator ''T'' : ''H'' → ''H'' such that for every non-zero vector ''x'', the vector space generated by the sequence {''T''<sup> ''n''</sup>(''x'') : ''n'' ≥ 0} is norm [[dense set|dense]] in ''H''? Such an operator is sometimes called transitive. For the most important case of Hilbert spaces ''H'' this is still open (as of 2010), though [[Per Enflo]] showed that the invariant subspace problem is false for some Banach spaces. ==Known special cases== While the general case of the invariant subspace problem is still open, several special cases have been settled: *For non-zero finite-dimensional vector spaces every operator has an eigenvector, so has a 1-dimensional invariant subspace. * The conjecture is true if the Hilbert space ''H'' is not [[separable space|separable]] (i.e. 