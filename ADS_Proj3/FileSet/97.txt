[[Adaptive heap sort|Adaptive Heap-Sort]] and [[Adaptive Merge-Sort]]. Dijkstra’s [[Smoothsort]] algorithm is a variation on heap-sort that is also considered an adaptive sorting algorithm. [[Timsort]], used as the generic sorting algorithm for several programming languages including Python, is adaptive.<ref>{{Cite web |last=Peters |first=Tim |authorlink=Tim Peters (programmer) |title=listsort.txt |url=http://svn.python.org/projects/python/trunk/Objects/listsort.txt |accessdate=2009-03-31 }}</ref> == See also == * [[Sorting algorithms]] * [[Smoothsort]] == References == * {{cite book | last = Hagerup | first = Torben | coauthors = Jyrki Katjainen | title = Algorithm Theory – SWAT 2004 | publisher = Springer-Verlag | year = 2004 | location = Berlin Heidelberg | pages = 221–222 | url = http://books.google.com/?id=2E-KNhKl3gEC&pg=PA221&lpg=PA221&dq=adaptive+sort | isbn = 3-540-22339-8}} * {{cite book | last = Mehta | first = Dinesh P. | coauthors = Sartaj Sahni | title = Data Structures and Applications | publisher = Chapman & Hall/CRC | year = 2005 | location = USA | pages = 11‑8–11‑9 | url = http://books.google.com/?id=fQVZy1zcpJkC&pg=PT230&lpg=PT230&dq=adaptive+sort | isbn = 1-58488-435-5}} * {{cite journal | doi = 10.1145/146370.146381 | last = Estivill-Castro | first = Vladmir | coauthors = Derick Wood | title = A survey of adaptive sorting algorithms | journal = ACM | volume = 24 | issue = 4 | pages = 441–476 | publisher = ACM | location = New York, NY, USA | date = December 1992 | url = http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=D302DA5A589E5D23ED76279C88DCCCEB?doi=10.1.1.45.8017&rep=rep1&type=pdf | issn = 0360-0300 | accessdate = February 22, 2009}} * {{cite journal | last = Petersson | first = Ola | coauthors = Alistair Moffat | title = A framework for adaptive sorting | journal = Lecture Notes in Computer Science | volume = 621 | pages = 422–433 | publisher = Springer Berlin / Heidelberg | location = Berlin | year = 1992 | url = http://www.springerlink.com/content/yv85w0u75777j021/ | issn = 1611-3349 | doi = 10.1007/3-540-55706-7_38 | accessdate = February 23, 2009}} <references /> {{sorting}} [[Category:Sorting algorithms]] [[it:Algoritmi di ordinamento adattivi]] [[pt:Ordenação adaptativa]]</text> </page> <page> <id>1007</id> <title>Address Range Registers</title> <text>{{About|computer hardware|other uses|ARR (disambiguation)}} '''Address Range Registers''' (ARRs) are [[control register]]s of the [[Cyrix]] [[6x86]], [[6x86MX]] and [[Cyrix MII|MII]] processors that are used as a control mechanism which provides system software with control of how accesses to memory ranges by the CPU are cached, similar to what [[Memory Type Range Registers]] (MTRRs) provide on other implementations of the [[x86 architecture]]<ref name="Linux Kernel">{{cite web |url = http://cateee.net/lkddb/web-lkddb/MTRR.html |title = Linux Kernel Driver Database |accessdate = 2009-09-27 |work = Linux Kernel Driver DataBase |publisher = Linux Kernel Driver DataBase }} </ref>. == See also == * [[Write barrier]] * [[Page Attribute Table]] * [[Memory Type Range Registers]] == References == {{reflist}} [[Category:Digital registers]] {{compu-hardware-stub}}</text> </page> <page> <id>1009</id> <title>Address bus</title> <text>{{Unreferenced|date=June 2009}} An '''address bus''' is a [[computer bus]] (a series of lines connecting two or more devices) that is used to specify a [[memory address|physical address]]. When a [[central processing unit|processor]] or [[direct memory access|DMA]]-enabled device needs to read or write to a memory location, it specifies that memory location on the address bus (the value to be read or written is sent on the [[data bus]]). The width of the address bus determines the amount of memory a system can address. For example, a system with a 32-bit address bus can address 2<sup>32</sup> (4,294,967,296) memory locations. If each memory address holds one bit, the addressable memory space is 4 GB. ==Implementation== Early processors used a wire for each bit of the address width. For example, a 16-bit address bus had 16 physical wires making up the bus. As the buses became wider, this approach became expensive in terms of the number of chip pins and board traces. Beginning with the [[Mostek]] 4096 DRAM, multiplexed addressing became common. In a multiplexed address scheme, the address is sent in two equal parts. This halves the number of address bus signals required to connect to the memory. For example a 32-bit address bus can be implemented by using 16 wires and sending the first half of the memory address, immediately followed by the second half. ==Interesting examples== Accessing an individual byte frequently requires reading or writing the full bus width (a ''[[word (computing)|word]]'') at once. In these instances the least significant bits of the address bus may not even be implemented - it is instead the responsibility of the controlling device to isolate the individual byte required from the complete word transmitted. This is the case, for instance, with the [[VESA Local Bus]] which lacks the two least significant bits, limiting this bus to [[Data structure alignment|aligned]] 32-bit transfers. Historically, there were also some examples of computers which were only able to address words. == See also == * [[Memory address]] {{Computer-bus}} [[Category:Computer buses|*Address bus]] [[bg:Адресна шина]] [[de:Bus (Datenverarbeitung)#Adressbus]] [[et:Aadressisiin]] [[es:Bus de direcciones]] [[fr:Bus d'adresse]] [[nl:Adresbus]] [[ja:アドレスバス]] [[pl:Szyna adresowa]] [[pt:Barramento de endereços]] [[ru:Шина адреса]] [[sv:Adressbuss]] [[ta:முகவரிப் பாட்டை]] [[zh:位址匯流排]]</text> </page> <page> <id>1015</id> <title>Address space layout randomization</title> <text>{{Original research|date=October 2008}} {{Refimprove|date=October 2008}} '''Address space layout randomization''' ('''ASLR''') is a [[Computer insecurity|computer security]] technique which involves randomly arranging the positions of key data areas, usually including the base of the [[executable]] and position of [[Library (computer science)|libraries]], [[Dynamic memory allocation|heap]], and [[Stack-based memory allocation|stack]], in a [[Process (computer science)|process]]'s [[address space]]. == Benefits == Address space randomization hinders some types of security attacks by making it more difficult for an attacker to predict target addresses. For example, attackers trying to execute [[return-to-libc attack]]s must locate the code to be executed, while other attackers trying to execute [[shellcode]] injected on the stack have to find the stack first. In both cases, the related memory addresses are obscured from the attackers. These values have to be guessed, and a mistaken guess is not usually recoverable due to the application crashing. === Effectiveness === Address space layout randomization relies on the low chance of an attacker guessing where randomly-placed areas are located. Security is increased by increasing the search space. Thus, address space randomization is more effective when more [[Information entropy|entropy]] is present in the random offsets. Entropy is increased by either raising the amount of 