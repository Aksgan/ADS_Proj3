and let this set decrease in size. If another serializability mechanism exists locally (which eliminates cycles in the local conflict graph), or if no cycle involving that transaction exists, the set will be empty eventually, and no abort of set member is needed. Otherwise the set will stabilize with transactions on local cycles, and aborting set members will have to occur to break the cycles. Since in the case of CO conflicts generate blocking on commit, local cycles in the ''augments conflict graph'' (see above) indicate local commit-deadlocks, and deadlock resolution techniques as in [[Serializability#Common mechanism - SS2PL|SS2PL]] can be used (e.g., like ''timeout'' and ''wait-for graph''). Local cycles in the ''augmented conflict graph'' reflect deadlocks by blocking caused by either materialized or non-materialized conflicts. The local algorithm above, applied to the local augmented conflict graph rather than the regular local conflict graph, comprises the '''generic enhanced local CO algorithm''', a single local cycle elimination mechanism, for both guaranteeing local serializability and handling locking based (with at least one lock) local deadlocks. Practically an additional concurrency control mechanism is always utilized, even solely to enforce [[serializability#Correctness - recoverability|recoverability]]. The generic CO algorithm does not affect local data access scheduling strategy, when it runs alongside of any other local concurrency control mechanism. It affects only the commit order, and for this reason it does not need to abort more transactions than those needed to be aborted for serializability violation prevention by any combined local concurrency control mechanism. The net effect of CO may be, at most, a delay of commit events (or voting in a distributed environment), to comply with the needed commit order (but not more delay than its special cases, for example, SS2PL, and on the average significantly less). The following theorem is concluded: *'''The Generic Local CO Algorithm Theorem''' :When running alone or alongside any concurrency control mechanism in a database system then #The ''Generic local CO algorithm'' guarantees (local) CO (a CO compliant schedule). #The ''Generic enhanced local CO algorithm'' guarantees both (local) CO and (local) locking based deadlock resolution. : and (when not using ''timeout'', and no ''real-time'' transaction completion constraints are applied) neither algorithm aborts more transactions than the minimum needed (which is determined by the transactions' operations scheduling, out of the scope of the algorithms). ====Implementation considerations - The Commitment Order Coordinator (COCO)==== A database system in a multidatabase environment is assumed. From a [[software architecture]] point of view a CO component that implements the generic CO algorithm locally, the ''Commitment Order Coordinator'' (COCO), can be designed in a straightforward way as a [[mediator pattern|mediator]] between a (single) database system and an atomic commitment protocol component ([[#Raz1991b|Raz 1991b]]). However, the COCO is typically an integral part of the database system. The COCO's functions are to vote to commit on ready global transactions (processing has ended) according to the local commitment order, to vote to abort on transactions for which the database system has initiated an abort (the database system can initiate abort for any transaction, for many reasons), and to pass the atomic commitment decision to the database system. For local transactions (when can be identified) no voting is needed. For determining the commitment order the COCO maintains an updated representation of the local conflict graph (or local augmented conflict graph for capturing also locking deadlocks) of the undecided (neither committed nor aborted) transactions as a data structure (e.g., utilizing mechanisms similar to [[lock (computer science)|locking]] for capturing conflicts, but with no data-access blocking). The COCO component has an [[interface (computer science)|interface]] with its database system to receive "conflict," "ready" (processing has ended; readiness to vote on a global transaction or commit a local one), and "abort" notifications from the database system. It also interfaces with the atomic commitment protocol to vote and to receive the atomic commitment protocol's decision on each global transaction. The decisions are delivered from the COCO to the database system through their interface, as well as local transactions' commit notifications, at a proper commit order. The COCO, including its interfaces, can be enhanced, if it implements another variant of CO (see below), or plays a role in the database's concurrency control mechanism beyond voting in atomic commitment. The COCO also guarantees CO locally in a single, isolated database system with no interface with an atomic commitment protocol. ===CO is a necessary condition for global serializability across autonomous database systems=== If the databases that participate in distributed transactions (i.e., transactions that span more than a single database) do not use any shared concurrency control information and use unmodified atomic commitment protocol messages (for reaching atomicity), then maintaining (local) ''commitment ordering'' is a [[necessary condition]] for guaranteeing global serializability (a proof can be found in ([[#Raz1992|Raz 1992]]), and a different proof method for this in ([[#Raz1993a|Raz 1993a]])); obviously it is also a [[sufficient condition]]. This is a mathematical fact derived from the definitions of ''[[serializability]]'' and a ''[[Database transaction|transaction]]''. It means that if not complying with CO, then global serializability cannot be guaranteed under this condition (the condition of no concurrency control information sharing between databases beyond atomic commit protocol messages). Atomic commitment is a minimal requirement for a distributed transaction since it is always needed, which is implied by the definition of transaction. Thus, defining ''database autonomy'' and ''independence'' as complying with this requirement is probably the broadest such definition possible in the context of database concurrency control. *'''Definition - ''' (Concurrency control based) '''Autonomous Database System''' :A database system is '''Autonomous''', if it does not share with any other entity any concurrency control information beyond unmodified [[atomic commitment]] protocol messages. Using this definition the following is concluded: *'''The CO and Global serializability Theorem''' #CO compliance of every ''autonomous'' database system (or transactional object) in a multidatabase environment is a ''necessary condition'' for guaranteeing Global serializability (without CO Global serializability may be violated). #CO compliance of every database system is a ''sufficient condition'' for guaranteeing Global serializability. '''Comment:''' The definition of autonomy above implies that transactions are scheduled in a 