[] Y?go() → n := n+1; Y!true] ] According to Clinger [1981], this program illustrates global nondeterminism, since the nondeterminism arises from incomplete specification of the timing of signals between the three processes <tt>X</tt>, <tt>Y</tt>, and <tt>Z</tt>. The repetitive guarded command in the definition of <tt>Z</tt> has two alternatives: #the <tt>stop</tt> message is accepted from <tt>X</tt>, in which case <tt>Y</tt> is sent the value '''false''' and <tt>print</tt> is sent the value <tt>n</tt> #a <tt>go</tt> message is accepted from <tt>Y</tt>, in which case <tt>n</tt> is incremented and <tt>Y</tt> is sent the value '''true'''. If <tt>Z</tt> ever accepts the <tt>stop</tt> message from <tt>X</tt>, then <tt>X</tt> terminates. Accepting the <tt>stop</tt> causes <tt>Y</tt> to be sent '''false''' which when input as the value of its guard will cause <tt>Y</tt> to terminate. When both <tt>X</tt> and <tt>Y</tt> have terminated, <tt>Z</tt> terminates because it no longer has live processes providing input. In the above program, there are synchronous channels from <tt>X</tt> to <tt>Z</tt>, <tt>Y</tt> to <tt>Z</tt>, and <tt>Z</tt> to <tt>Y</tt>. ===Analogy with the committee coordination problem=== According to Knabe [1992], Chandy and Misra [1988] characterized this as analogous to the committee coordination problem: :Professors in a university are assigned to various committees. Occasionally a professor will decide to attend a meeting of any of her committees, and will wait until that is possible. Meetings may begin only if there is full attendance. The task is to ensure that if all the members of a committee are waiting, then at least one of them will attend some meeting. :The crux of this problem is that two or more committees might share a professor. When that professor becomes available, she can only choose one of the meetings, while the others continue to wait. ===A simple distributed protocol=== This section presents a simple distributed protocol for channels in synchronous process calculi. The protocol has some problems that are addressed in the sections below. The behavior of a guarded choice command is as follows: *The command sends a message to each of its guards to <tt>prepare</tt>. *When it receives the first response from one of its guards that it is prepared, then it sends a message to that guard to <tt>prepare to commit</tt> and sends messages to all of the other guards to <tt>abort</tt>. **When it receives a message from the guard that it is <tt>prepared to commit</tt>, then it sends the guard a <tt>commit</tt> message. However, if the guard throws an exception that it cannot <tt>prepare to commit</tt>, then guarded choice command starts the whole process all over again. *If all of its guards respond that they cannot <tt>prepare</tt>, then the guarded command does nothing. The behavior of a guard is as follows: *When a message to <tt>prepare</tt> is received, then the guard sends a <tt>prepare</tt> message to each of the channels with which it is offering to communicate. If the guard has booleans such that it cannot <tt>prepare<tt> or if any of the channels respond that they cannot <tt>prepare</tt>, then it sends <tt>abort</tt> messages to the other channels and then responds that it cannot <tt>prepare</tt>. :*When a message to <tt>prepare to commit</tt> is received, then the guard sends a <tt>prepare to commit</tt> message to each of the channels. If any of the channels respond that they cannot <tt>prepare to commit</tt>, then it sends <tt>abort</tt> messages to the other channels and then throws an exception that it cannot <tt>prepare to commit</tt>. :*When a message to <tt>commit</tt> is received, then the guard sends an <tt>commit</tt> message to each of the channels. :*When a message to <tt>abort</tt> is received, then the guard sends an <tt>abort</tt> message to each of the channels. The behavior of a channel is as follows: *When a <tt>prepare to put</tt> communication is received, then respond that it is prepared if there is a <tt>prepare to get<tt> communication pending unless a <tt>terminate</tt> communication has been received, in which case throw an exception that it cannot <tt>prepare to put</tt>. *When a <tt>prepare to get</tt> communication is received, then respond that it is prepared if there is a <tt>prepare to put<tt> communication pending unless a <tt>terminate</tt> communication has been received, in which case throw an exception that it cannot <tt>prepare to get</tt>. :*When a <tt>prepare to commit to put</tt> communication is received, then respond that it is prepared if there is a <tt>prepare to commit to get<tt> communication pending unless a <tt>terminate</tt> communication has been received, in which case throw an exception that it cannot <tt>prepare to commit to put</tt>. :*When a <tt>prepare to commit to get</tt> communication is received, then respond that it is prepared if there is a <tt>prepare to commit to put<tt> communication pending unless a <tt>terminate</tt> communication has been received, in which case throw an exception that it cannot <tt>prepare to commit to get</tt>. ::*When a <tt>commit put<tt> communication is received, then depending on which of the following is received: ::**When a <tt>commit get<tt> communication is received, then if not already done perform the <tt>put</tt> and <tt>get</tt> and clean up the preparations. ::**When an <tt>abort get<tt> communication is received, then cancel the preparations ::*When a <tt>commit get<tt> communication is received, then depending on which of the following is received: ::**When a <tt>commit put<tt> communication is received, then if not already done perform the <tt>get</tt> and <tt>put</tt> and clean up the preparations. ::**When an <tt>abort put<tt> communication is received, then cancel the preparations. ::*When an <tt>abort put<tt> communication is received, then cancel the preparations. ::*When an <tt>abort get<tt> communication is received, then cancel the preparations. ===Starvation on getting from multiple channels=== Again consider the program written in CSP (discussed in [[Actor model and process calculi#Synchronous channels in process calculi|Synchronous channels in process calculi]] above): [X :: Z!stop() || Y :: guard: boolean; guard := true; *[guard → Z!go(); Z?guard] || Z :: n: integer; n:= 0; *[X?stop() → Y!false; print!n; [] Y?go() → n := n+1; Y!true] ] As pointed out in Knabe [1992], a problem with the above protocol ([[Actor model and process calculi#A simple distributed protocol|A simple distributed protocol]]) is that the process <tt>Z</tt> might 