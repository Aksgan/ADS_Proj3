(moving) object can reach a given position is [[Decidability (logic)|undecidable]] under the rules of the Newtonian dynamics.{{ref|adam}} The '''billiard ball model''' was proposed in 1982 in a seminal paper{{ref|bb}} of [[Edward Fredkin]] and [[Tommaso Toffoli]]. The work on this and similar models was continued by the MIT Information Mechanics group and has strong relations with the present Amorphous computing group at MIT or the Quantum Mechanical Hamiltonian Model of Paul Beniof. Presently there are a few research lines related to these kind of models in what it is known as [[unconventional computing]]. When the number of objects (such as billiard balls) in a system becomes large, we need new principles like the entropy or temperature{{ref|unc}} relations. And when the multitude of particles are able to react and change (not only in position and momentum) then new behaviours arise. The [[Amorphous computing]] paradigm prepares the engineering principles to observe, control, organize, and exploit the coherent and cooperative behaviour of programmable multitudes. The unconventional{{ref|unc}}{{ref|im}} and [[biologically-inspired computing]] paradigms use asynchronous and decentralized agents and include the model of cellular automata. Recent works related to the billiard ball model are the particle-based model{{ref|part}}{{ref|partb}}{{ref|partc}} and the reaction and diffusion of chemical species.{{ref|gray}} == See also == * [[Analog computer]] * [[Biologically inspired computing]] * [[Chemical computer]] * [[Mechanical computer]] * [[Quantum computing]] * [[Reversible computing]] * [[Unconventional computing]] == References == # {{note|whew}} Whewell, William. [http://books.google.com/books?id=j6lAAAAAIAAJ&pg=PA274 "The Philosophy of the Inductive Sciences"], vol 2. London: John W. Parker. 1847, pp. 274–295 # {{note|adam}} Adamatzky, Andrew (Ed.) [http://books.google.com/books?isbn=1852335408 "Collision-based Computing"]. Springer. 2002 # {{note|bb}} Fredkin, Edward and Toffoli, Tomasso, "[http://calculemus.org/logsoc03/materialy/ConservativeLogic.pdf Conservative Logic]", Int. J. Theor. Phys. 21 (1982), 219–253. Describes the Billiard-Ball model. # {{note|unc}} Unconventional computation Conference 2007 , http://cnls.lanl.gov/uc07/ # {{note|im}} Information Mechanics and Unconventional computating, http://www.interquanta.biz/im/ # {{note|part}} "Particle-based Methodology for Representing Mobile Ad-Hoc Networks", InterSense 2006 Conference Nice [http://portal.acm.org/ft_gateway.cfm?id=1142685&type=pdf&coll=GUIDE&dl=&CFID=15151515&CFTOKEN=6184618 ACM Press New York] # {{note|partb}} "Special issue on particle based modelling methods applied in biology", [http://portal.acm.org/toc.cfm?id=379912&coll=GUIDE&dl=,acm&type=issue&CFID=15151515&CFTOKEN=6184618 Issue 7 May 2001, ACM] # {{note|partc}} "Physics-Based Models to Support Test and Evaluation, S. Blankenship & F. Mello, High Performance Computing Workshop 1998" http://www.dtc.army.mil/hpcw/1998/blanken/blanken.html # {{note|gray}} the Gray-Scott model of a chemical reaction. http://www-swiss.ai.mit.edu/projects/amorphous/GrayScott/ [[Category:Computational models]] [[Category:Mechanical computers]] [[ja:ビリヤードボール・コンピュータ]]</text> </page> <page> <id>3799</id> <title>Bin (computational geometry)</title> <text>{{Context|date=October 2009}} {{Unreferenced|date=October 2007}} [[Image:bin computational geometry.png|thumb|right|400px|The bin data structure]] In [[computational geometry]], the '''bin''' [[data structure]] allows efficient region queries, i.e., if there are some [[Cartesian Coordinate System|axis]]-aligned rectangles on a 2D [[Plane (geometry)|plane]], answer the question ''Given a query rectangle, return all rectangles intersecting it''. [[kd-tree]] is another data structure that can answer this question efficiently. In the example in the figure, ''A, B, C, D, E'', and ''F'' are existing rectangles, the query with the rectangle ''Q'' should return ''C, D, E'' and ''F'', if we define all rectangles as [[closed interval]]s. The data structure partitions a region of the 2D plane into uniform-sized ''bins''. The bounding box of the bins encloses all ''candidate'' rectangles to be queried. All the bins are arranged in a 2D array. All the candidates are represented also as 2D arrays. The size of a candidate's array is the number of bins it intersects. For example, in the figure, candidate ''B'' has 6 elements arranged in a 3 row by 2 column array because it intersects 6 bins in such an arrangement. Each bin contains the head of a [[singly-linked list]]. If a candidate intersects a bin, it is chained to the bin's linked list. Each element in a candidate's array is a link node in the corresponding bin's linked list. == Operations == === Query === From the query rectangle ''Q'', we can find out which bin its lower-left corner intersects efficiently by simply subtracting the bin's bounding box's lower-left corner from the lower-left corner of ''Q'' and dividing the result by the width and height of a bin respectively. We then iterate the bins ''Q'' intersects and examine all the candidates in the linked-lists of these bins. For each candidate we check if it does indeed intersect ''Q''. If so and it is not previously reported, then we report it. We can use the convention that we only report a candidate the first time we find it. This can be done easily by clipping the candidate against the query rectangle and comparing its lower-left corner against the current location. If it is a match then we report, otherwise we skip. === Insertion and deletion === Insertion is linear to the number of bins a candidate intersects because inserting a candidate into 1 bin is constant time. Deletion is more expensive because we need to search the singly-linked list of each bin the candidate intersects. In a multithread environment, insert, delete and query are mutually exclusive. However, instead of locking the whole data structure, a sub-range of bins may be locked. Detailed performance analysis should be done to justify the overhead. == Efficiency and tuning == The analysis is similar to a [[hash table]]. The worst-case scenario is that all candidates are concentrated in one bin. Then query is O(''n''), delete is O(''n''), and insert is O(1), where ''n'' is the number of candidates. If the candidates are evenly spaced so that each bin has a constant number of candidates, The query is O(''k'') where ''k'' is the number of bins the query rectangle intersects. Insert and delete are O(''m'') where ''m'' is the number of bins the inserting candidate intersects. In practice delete is much slower than insert. Like a hash table, bin's efficiency depends a lot on the distribution of both location and size of candidates and queries. In general, the smaller the query rectangle, the more efficient the query. The bin's size should be such that it contains as few candidates as possible but large enough so that candidates do not span too many bins. If a candidate span many bins, a query has to skip this candidate over and over again after it is reported at the first bin of intersection. For example, in the figure, 