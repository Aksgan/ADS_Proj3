of support from several big licensees, including [[Atari]], [[Activision]], [[Capcom]], [[Disney Interactive Studios|Disney]], [[Konami]], [[Koei]], [[2K Games]], [[Midway Games]], [[THQ]], [[Ubisoft]], [[Sega]], [[Sony]], [[Electronic Arts]], [[Square Enix]], [[3D Realms]], and more. ==Updates== [[Epic Games]] announced at [[Game Developers Conference|GDC]] 2009 some improvements made to the Unreal Engine 3. These included:<ref>{{cite web|url=http://news.bigdownload.com/2009/03/16/epic-games-to-show-off-new-unreal-engine-3-features-at-gdc|title=Epic Games to show off new Unreal Engine 3 features at GDC}}</ref> *High-quality static lighting with next-generation effects, such as soft shadows with accurate [[Umbra#Penumbra|penumbrae]], [[Diffuse reflection|diffuse]], [[Specular reflection|specular]] inter-reflection and [[Color bleeding (computer graphics)|color bleeding]] *The ability to add fracture effects to [[Static mesh|static meshes]] to simulate destructible environments *[[Soft body dynamics|Soft-body physics]] *Simulation of large crowds In March 2010, [[Steam (software)#Steamworks|Steamworks]] was integrated into the software, and is offered to licensees.<ref name="ue3_steamworks">{{cite web|url=http://epicgames.com/press_releases/steamworks.html|title=Steamworks Integration Now Available to Unreal Engine 3 Licensees|publisher=[[Epic Games]]|date=March 11, 2010}}</ref> In June 2010, Apple showed up Epic Citadel, the first Unreal Engine 3 mobile in iOS4 developed by Epic Games in Apple WWDC 2010 and released it to AppStore. Epic Citadel require iPhone 3GS/iPhone 4/iPod Touch 3rd Generation/iPod Touch 4th Generation and iPad with iOS 3.1.3 or later. ==Non-gaming use== In addition to the game industry, UE3 has also seen adoption by many non-gaming projects including [[Computer-aided technologies|construction simulation and design]], driving simulation, virtual reality shopping malls and film storyboards.{{Citation needed| reason=The previous author had put this here, I'm assuming he/she can provide the needed citation|date=January 2010}} In December 2009, Epic demoed UE3 running on [[Apple Inc.|Apple]]'s 3rd generation [[iPod Touch]]. They said that this will also support [[iPhone]] 3GS, and also an unknown mobile platform set to be unveiled at CES 2010,<ref>http://anandtech.com/gadgets/showdoc.aspx?i=3695</ref> which was later revealed to be [[Nvidia|NVidia]]'s [[Nvidia Tegra|Tegra 2]] platform.<ref>http://www.engadget.com/2010/01/07/live-from-nvidias-ces-press-event/</ref> On December 16th, 2010, Epic released for free the Unreal Engine 3 with other gaming development tools as the "Unreal Developers Kit" on Apple's mobile devices.<ref>{{cite web|First=Oliver|last=Chiang|date=2010-12-15|title=Hit Game Engine Launches On iPhone Thursday, Android Later|url=http://blogs.forbes.com/oliverchiang/2010/12/15/hit-game-engine-launches-on-iphone-thursday-android-later/?boxes=Homepagechannels|publisher=Forbes|accessdate=2010-12-21}}</ref> The Unreal 3 engine also powers the animation software "[[Muvizu]] 3D" which is currently in beta stage.<ref>[http://www.muvizu.com/Info/About Muvizu 3D Web Site]</ref> ==Games using Unreal Engine 3== {{Main|List of Unreal Engine games#Unreal Engine 3}} ==See also== *[[First-person shooter engine]] *[[List of game engines]] *[[Unreal Engine]] ==References== {{reflist|1}} ==External links== *[http://www.udk.com/ Unreal Developer Kit] *[http://www.unrealtechnology.com/technology.php Unreal Technology page] {{Epic}} {{Unreal series}} [[Category:Unreal]] [[Category:Video game engines]] [[Category:Virtual reality]]</text> </page> <page> <id>38995</id> <title>Unrolled linked list</title> <text>{{Unreferenced|date=March 2009}} In computer programming, an '''unrolled linked list''' is a variation on the [[linked list]] which stores multiple elements in each node. It can drastically increase [[CPU cache|cache]] performance, while decreasing the memory overhead associated with storing list metadata such as [[reference]]s. It is related to the [[B-tree]]. ==Overview== A typical unrolled linked list node looks like this: '''[[record (computer science)|record]]''' node { ''node'' next ''// reference to next node in list'' ''int'' numElements ''// number of elements in this node, up to maxElements'' ''array'' elements ''// an array of numElements elements, with space allocated for maxElements elements'' } Each node holds up to a certain maximum number of elements, typically just large enough so that the node fills a single [[cache line]] or a small multiple thereof. A position in the list is indicated by both a reference to the node and a position in the elements array. It's also possible to include a ''previous'' pointer for an unrolled doubly-linked list. To insert a new element, we simply find the node the element should be in and insert the element into the <code>elements</code> array, incrementing <code>numElements</code>. If the array is already full, we first insert a new node either preceding or following the current one and move half of the elements in the current node into it. To remove an element, similarly, we simply find the node it is in and delete it from the <code>elements</code> array, decrementing <code>numElements</code>. If numElements falls below <code>maxElements &divide; 2</code> then we pull elements from adjacent nodes to fill it back up to this level. If both adjacent nodes are too low, we combine it with one adjacent node and then move some values into the other. This is necessary to avoid wasting space. ==Performance== One of the primary benefits of unrolled linked lists is decreased storage requirements. All nodes (except at most one) are at least half-full. If many random inserts and deletes are done, the average node will be about three-quarters full, and if inserts and deletes are only done at the beginning and end, almost all nodes will be full. Assume that: * ''m'' = <code>maxElements</code>, the maximum number of elements in each <code>elements</code> array; * ''v'' = the overhead per node for references and element counts; * ''s'' = the size of a single element. Then, the space used for ''n'' elements varies between <math>(v + sm)\lceil n/m \rceil</math>, roughly <math>(v/m + s)n</math>, and twice this value. For comparison, ordinary linked lists require <math>(v + s)n</math> space, although ''v'' may be smaller, and [[array data structure|array]]s, one of the most compact data structures, require <math>sn</math> space. Unrolled linked lists effectively spread the overhead ''v'' over a number of elements of the list. Thus, we see the most significant space gain when overhead is large, <code>maxElements</code> is large, or elements are small. If the elements are particularly small, such as bits, the overhead can be as much as 64 times larger than the data on many machines. Moreover, many popular memory allocators will keep a small amount of metadata for each node allocated, increasing the effective overhead ''v''. Both these make unrolled linked lists more attractive. Because unrolled linked list nodes each store a count next to the ''next'' field, retrieving the ''k''th element of an unrolled linked list (indexing) can be done in ''n''/''m'' + 1 cache misses, up to a factor of ''m'' better than ordinary linked lists. Additionally, if the size of each element is small compared to the cache line size, the list can be iterated over in order with fewer cache misses than ordinary linked lists. In either case, operation time still increases linearly with the size of 