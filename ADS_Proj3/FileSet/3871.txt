Lockheed Martin, National Oceanic and Atmospheric Administration, Northrop Grumman, Siemens, Raytheon, and the US Department of Defense.<ref>(http://www.aviationtoday.com/pressreleases/26821.html Aviation Today</ref> ==Technical details== SEER for Software is designed to be run inside of a Windows environment, and from version 6 onwards, is fully COM-enabled, allowing users to have SEER interact with many Windows products including Microsoft Office. Its current primary API relies on Microsoft Automation. The program itself is written in C and C++. ==Group of Models== SEER for Software (SEER-SEM) is composed of a group of models working together to provide estimates of effort, duration, staffing, and defects. These models can be briefly described by the questions they answer: * Sizing. How large is the software project being estimated (Lines of Code, Function Points, Use Cases, etc.) * Technology. What is the possible productivity of the developers (capabilities, tools, practices, etc.) * Effort and Schedule Calculation. What amount of effort and time are required to complete the project? * Constrained Effort/Schedule Calculation. How does the expected project outcome change when schedule and staffing constraints are applied? * Activity and Labor Allocation. How should activities and labor be allocated into the estimate? * Cost Calculation. Given expected effort, duration, and the labor allocation, how much will the project cost? * Defect Calculation. Given product type, project duration, and other information, what is the expected, objective quality of the delivered software? * Maintenance Effort Calculation. How much effort will be required to adequately maintain and upgrade a fielded software system? * Progress. How is the project progressing and where will it end up. Also how to replan. * Validity. Is this development achievable based on the technology involved? ==Software Sizing== Software size is a key input to any estimating model and across most [[software parametric models]]. Supported sizing metrics include [[source lines of code]] (SLOC), [[function points]], function-based sizing (FBS) and a range of other measures. They are translated for internal use into effective size (<math>S_{e}</math>). <math>S_{e}</math> is a form of common currency within the model and enables new, reused, and even commercial off-the-shelf code to be mixed for an integrated analysis of the software development process. The generic calculation for <math>S_{e}</math> is: <math>S_{e} = NewSize + ExistingSize * (0.4 * Redesign + 0.25 * Reimpl + 0.35 * Retest)</math> As indicated, <math>S_{e}</math> increases in direct proportion to the amount of new software being developed. <math>S_{e}</math> increases by a lesser amount as preexisting code is reused in a project. The extent of this increase is governed by the amount of rework (redesign, re-implementation, and retest) required to reuse the code. ==Function-Based Sizing== While SLOC is an accepted way of measuring the absolute size of code from the developer's perspective, metrics such as function points capture software size functionally from the user's perspective. The function-based sizing (FBS) metric extends function points so that hidden parts of software such as complex algorithms can be sized more readily. FBS is translated directly into unadjusted function points (UFP). In SEER-SEM, all size metrics are translated to <math>S_{e}</math>, including those entered using FBS. This is not a simple conversion, i.e., not a language-driven adjustment as is done with the much-derided [[backfiring]] method. Rather, the model incorporates factors, including phase at estimate, operating environment, application type, and application complexity. All these considerations significantly affect the mapping between functional size and <math>S_{e}</math>. After FBS is translated into function points, it is then converted into <math>S_{e}</math> as: <math>S_{e} = Lx * (AdjFactor * UFP)^{\frac{Entropy}{1.2}}</math> where, <math>Lx</math> is a language-dependent expansion factor. <math>AdjFactor</math> is the outcome of calculations involving other factors mentioned above. Entropy ranges from 1.04 to 1.2 depending on the type of software being developed. ==Effort and Duration Calculations== A project's effort and duration are interrelated, as is reflected in their calculation within the model. Effort drives duration, notwithstanding productivity-related feedback between duration constraints and effort. The basic effort equation is: <math>K = D^{0.4}*(\frac{S_{e}}{C_{te}})^{1.2}</math> where, <math>S_{e}</math> is effective size - introduced earlier. <math>C_{te}</math> is effective technology - a composite metric that captures factors relating to the efficiency or productivity with which development can be carried out. An extensive set of people, process, and product parameters feed into the effective technology rating. A higher rating means that development will be more productive. <math>D</math> is staffing complexity - a rating of the project's inherent difficulty in terms of the rate at which staff are added to a project. Once effort is obtained, duration is solved using the following equation: <math>t_{d} = D^{-0.2}*(\frac{S_{e}}{C_{te}})^{0.4}</math> The duration equation is derived from key formulaic relationships. Its <math>0.4</math> exponent indicates that as a project's size increases, duration also increases, though less than proportionally. This size-duration relationship is also used in component-level scheduling algorithms with task overlaps computed to fall within total estimated project duration. ==Notes== <references/> ==References== [http://www.crosstalkonline.org/storage/issue-archives/2005/200504/200504-Fischman.pdf Fischman, Lee; McRitchie,Karen; and Galorath, Daniel D. ''Inside SEER-SEM'', CROSSTALK The Journal of Defense Software Engineering, April 2005, pp. 26-28.] [http://www.galorath.com/ SEER-SEM Official Site] {{DEFAULTSORT:Seer-Sem}} [[Category:Acronyms]] [[Category:Software engineering costs]]</text> </page> <page> <id>32756</id> <title>SEX (computing)</title> <text>:''The acronym SEX (written in capital letters) redirects here. For other meanings, see [[Sex (disambiguation)]].'' In computing, the '''SEX''' [[assembly language]] [[mnemonic]] has often been used for the "<code>Sign EXtend</code>" machine [[instruction set|instruction]] found in the [[PDP-11]] and many other computer architectures. A computer's or CPU's "sex" can also mean the [[endianness]] of the [[computer architecture]] used.<ref>For hardware, the [[Jargon File]] also reports the less common expression ''byte sex'' [http://catb.org/jargon/html/B/byte-sex.html]. It is unclear whether this terminology is also used when more than two orderings are possible. Similarly, the manual for the ORCA/M [[Assembly language#Assembler|assembler]] refers to a field indicating the order of the bytes in a number field as <code>NUMSEX</code>, and the [[Mac OS X]] operating system refers to "byte sex" in its compiler tools [http://web.mit.edu/darwin/src/modules/cctools/libstuff/arch.c].</ref> [[x86]] computers do not have the same "byte sex"<ref>The [http://catb.org/jargon/html/B/bytesexual.html Jargon] [http://catb.org/jargon/html/B/byte-sex.html file]</ref>, as [[HC11]] computers, for example. Functions are sometimes needed<ref>[http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html#htonsman htons(), htonl(), ntohs(), ntohl()]</ref> for computers of different endianness to communicate with each other over the internet<ref>The [http://catb.org/jargon/html/N/NUXI-problem.html NUXI] problem</ref>, as protocols often use [[big endian]] [[byte]] 