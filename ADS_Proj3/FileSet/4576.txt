same object (already requested/issued) by another transaction by blocking a respective ''write-lock'' from being acquired by the other transaction. The second write-lock will be acquired and the requested write of the object will take place (materialize) after the existing write-lock is released. * A ''write-lock'' blocks an intended (already requested/issued) ''read'' by another transaction by blocking the respective ''read-lock ''. * A ''read-lock'' blocks an intended ''write'' by another transaction by blocking the respective ''write-lock ''. * A ''read-lock'' does not block an intended ''read'' by another transaction. The respective ''read-lock'' for the intended read is acquired (shared with the previous read) immediately after the intended read is requested, and then the intended read itself takes place. Several variations and refinements of these major lock types exist, with respective variations of blocking behavior. If a first lock blocks another lock, the two locks are called ''incompatible''; otherwise the locks are ''compatible''. Often lock types blocking interactions are presented in the technical literature by a ''Lock compatibility table''. The following is an example with the common, major lock types: :{| class="wikitable" style="text-align:center;" |+Lock compatibility table |- ! Lock type !! read-lock !! write-lock |- ! read-lock | || '''X''' |- ! write-lock | '''X''' || '''X''' |} :'''X''' indicates incompatibility, i.e, a case when a lock of the first type (in left column) on an object blocks a lock of the second type (in top row) from being acquired on the same object (by another transaction). An object typically has a queue of waiting requested (by transactions) operations with respective locks. The first blocked lock for operation in the queue is acquired as soon as the existing blocking lock is removed from the object, and then its respective operation is executed. If a lock for operation in the queue is not blocked by any existing lock (existence of multiple compatible locks on a same object is possible concurrently) it is acquired immediately. :'''Comment:''' In some publications the table entries are simply marked "compatible" or "incompatible", or respectively "yes" or "no". ==Two-phase locking and its special cases== ===Two-phase locking=== According to the '''two-phase locking''' protocol a transaction handles its locks in two distinct, consecutive phases during the transaction's execution: # '''Expanding phase''' (aka Growing phase): locks are acquired and no locks are released (the number of locks can only increase). # '''Shrinking phase''': locks are released and no locks are acquired. The [[serializability]] property is guaranteed for a schedule with transactions that obey the protocol. The 2PL ''schedule class'' is defined as the class of all the schedules comprising transactions with data access orders that could be generated by the 2PL protocol (or in other words, all the schedules that the 2PL protocol can generate). Typically, without explicit knowledge in a transaction on end of phase-1, it is safely determined only when a transaction has entered its ''ready'' state in all its processes (processing has ended, and it is ready to be committed; no additional data access and locking are needed and can happen). In this case phase-2 can end immediately (no additional processing is needed), and actually no phase-2 is needed. Also, if several processes (two or more) are involved, then a [[Synchronization (computer science)#Process synchronization|synchronization point]] (similar to ''[[atomic commitment]]'') among them is needed to determine end of phase-1 for all of them (i.e., in the entire distributed transaction), to start releasing locks in phase-2 (otherwise it is very likely that both 2PL and Serializability are quickly violated). Such synchronization point is usually too costly (involving a distributed protocol similar to atomic commitment), and end of phase-1 is usually postponed to be merged with transaction end (atomic commitment protocol for a multi-process transaction), and again phase-2 is not needed. This turns 2PL to SS2PL (see below). All known implementations of 2PL in products are SS2PL based, and whenever 2PL (or Strict 2PL, S2PL) practical utilization has been mentioned in the professional literature, the intention has been SS2PL. ===Strict two-phase locking=== The '''strict two-phase locking''' (S2PL) class of schedules is the intersection of the 2PL class with the class of schedules possessing the ''[[schedule (computer science)#Strict|Strictness]]'' property. To comply with the S2PL protocol a transaction needs to comply with 2PL, and release its ''write (exclusive)'' locks only after it has ended, i.e., being either ''committed'' or ''aborted''. On the other hand, ''read (shared)'' locks are released regularly during phase 2. Implementing general S2PL requires explicit support of phase-1 end, separate from transaction end, and no such widely utilized product implementation is known. S2PL is a special case of 2PL, i.e., the S2PL class is a proper subclass of 2PL. ===Strong strict two-phase locking=== or '''Rigorousness''', or '''Rigorous scheduling''', or '''Rigorous two-phase locking''' To comply with '''strong strict two-phase locking''' (SS2PL) the locking protocol releases both ''write (exclusive)'' and ''read (shared)'' locks applied by a transaction only after the transaction has ended, i.e., only after both completing executing (being ''ready'') and becoming either ''committed'' or ''aborted''. This protocol also complies with the S2PL rules. A transaction obeying SS2PL can be viewed as having phase-1 that lasts the transaction's entire execution duration, and no phase-2 (or a degenerate phase-2). Thus, only one phase is actually left, and "two-phase" in the name seems to be still utilized due to the historical development of the concept from 2PL, and 2PL being a super-class. The SS2PL property of a schedule is also called '''Rigorousness'''. It is also the name of the class of schedules having this property, and an SS2PL schedule is also called a "rigorous schedule". The term "Rigorousness" is free of the unnecessary legacy of "two-phase," as well as being independent of any (locking) mechanism (in principle other blocking mechanisms can be utilized). The property's respective locking mechanism is sometimes referred to as '''Rigorous 2PL'''. SS2PL is a special case of S2PL, i.e., the SS2PL class of schedules is a proper subclass of S2PL (every SS2PL schedule is also an S2PL schedule, but S2PL schedules exist that are not SS2PL). SS2PL has been the 