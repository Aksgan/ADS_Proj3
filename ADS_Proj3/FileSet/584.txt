were expanded into [[generic programming|generic]] versions in [[.NET Framework#.NET Framework 2.0|.NET 2.0]]. The following shows a simple use of iterators in C# 2.0: <source lang="csharp"> // explicit version IEnumerator<MyType> iter = list.GetEnumerator(); while (iter.MoveNext()) Console.WriteLine(iter.Current); // implicit version foreach (MyType value in list) Console.WriteLine(value); </source> ===Generator functionality=== :''This is a feature of [[C Sharp 2.0]].'' The .NET 2.0 Framework allowed C# to introduce an [[iterator]] that provides [[generator (computer science)|generator]] functionality, using a <code>yield return</code> construct similar to <code>yield</code> in [[Python syntax and semantics#Generators|Python]].<ref>{{cite web |url=http://msdn.microsoft.com/en-us/library/9k7k7cf0(VS.80).aspx |title=yield |work=C# Language Reference |publisher=[[Microsoft]] |accessdate=2009-04-26}}</ref> With a <code>yield return</code>, the function automatically keeps its state during the iteration. <source lang="csharp"> // Method that takes an iterable input (possibly an array) // and returns all even numbers. public static IEnumerable<int> GetEven(IEnumerable<int> numbers) { foreach (int i in numbers) { if (i % 2 == 0) yield return i; } } </source> ==LINQ== :''This is a feature of [[C Sharp 3.0]] and [[.NET Framework 3.0]].'' {{Main|LINQ}} LINQ, short for Language Integrated Queries, is a .NET Framework feature which simplifies the handling of data. Mainly it adds support that allows you to query arrays, collections, and databases. It also introduces binders, which makes it easier to access to databases and their data. ===Query syntax=== The LINQ query syntax was introduced in C# 3.0 and lets you write [[SQL]]-like queries in C#. <source lang="csharp"> var list = new List<int>{ 2, 7, 1, 3, 9 }; var result = from i in list where i > 1 select i; </source> The statements are compiled into method calls, whereby almost only the names of the methods are specified. Which methods are ultimately used is determined by normal overload resolution. Thus, the end result of the translation is affected by what symbols are in scope. What differs from SQL is that the from-statement comes first and not last as in SQL. This is because it seems more natural writing like this in C# and supports Intellisense. ==Anonymous methods== Anonymous methods, or in their present form more commonly referred to as "lambda expressions", is a feature which allows you to write inline closure-like functions in your code. There are various ways to create anonymous methods. Prior to C# 3.0 there was limited support by using delegates. '''See also''' * [[Anonymous function]] * [[Closure (computer science)]] ===Anonymous delegates=== :''This is a feature of [[C Sharp 2.0]].'' Anonymous delegates are functions pointers that are holding anonymous methods. The purpose is to make it simpler to use delegates by simplifying the process of assigning the function. Instead of declaring a separate method in code the programmer can use the syntax to write the code inline and the compiler will then generate an anonymous function for it. <source lang="csharp"> Func<int, int> f = delegate(int x) { return x * 2; }; </source> ===Lambda expressions=== :''This is a feature of [[C Sharp 3.0]].'' Lambda expressions provide a simple syntax for inline functions that are similar to closures. Functions with parameters infer the type of the parameters if other is not explicitly specified. <source lang="csharp"> // [arguments] => [method-body] //With parameters n => n == 2 (a, b) => a + b (a, b) => { a++; return a + b; } //With explicitly typed parameters (int a, int b) => a + b //No parameters () => return 0 //Assigning lambda to delegate Func<int, int, int> f = (a, b) => a + b; </source> Multi-statement lambdas have bodies enclosed by brackets and inside of them code can be written like in standard methods. <source lang="csharp"> (a, b) => { a++; return a + b; } </source> Lambda expressions can be passed as arguments directly in method calls similar to anonymous delegates but with a more aesthetic syntax. <source lang="csharp"> var list = stringList.Where(n => n.Length > 2); </source> Lambda expressions are essentially compiler-generated methods that are passed via delegates. These methods are reserved for the compiler only and can not be used in any other context. ==Anonymous types== :''This is a feature of [[C Sharp 3.0]].'' Anonymous types are nameless classes that are generated by the compiler. They are only consumable and yet very useful in a scenario like where you have a LINQ query which returns an object on <code>select<code> and you just want to return some specific values. Then you can define a anonymous type containing auto-generated read-only fields for the values. When instantiating another anonymous type declaration with the same signature the type is automatically inferred by the compiler. <source lang="csharp"> var carl = new { Name = "Carl", Age = 35 }; //Name of the type is only known by the compiler. var mary = new { Name = "Mary", Age = 22 }; //Same type as the expression above </source> ==Extension methods== :''This is a feature of [[C Sharp 3.0]].'' Extension methods are a form of syntactic sugar providing the illusion of adding new methods to the existing class outside its definition. In practice, an extension method is a static method that is callable as if it were an instance method; the receiver of the call is bound to the first parameter of the method, decorated with keyword <code>this</code>: <source lang="csharp"> public static class StringExtensions { public static string Left(this string s, int n) { return s.Substring(0, n); } } string s = "foo"; s.Left(3); // same as StringExtensions.Left(s, 3); </source> '''See also''' * [[Decorator pattern]] ==Miscellaneous== ===Closure Blocks=== C# implements [[Resource Acquisition Is Initialization#Closure Blocks|closure blocks]] by means of the [http://msdn.microsoft.com/en-us/library/yh598w02.aspx <code>using</code> statement]. The <code>using</code> statement accepts an expression which results in an object implementing <code>IDisposable</code>, and the compiler generates code that guarantees the object's disposal when the scope of the <code>using</code>-statement is exited. The <code>using</code> statement is [[syntactic sugar]], but it is much more readable than the equivalent pure C# code. <source lang="csharp"> public void Foo() { using (var bar = File.Open("Foo.txt")) { // do some work throw new Exception(); // bar will still get properly disposed. } } </source> ===Thread synchronization=== C# provides the [http://msdn.microsoft.com/en-us/library/c5kehkcz.aspx <code>lock</code> statement], 