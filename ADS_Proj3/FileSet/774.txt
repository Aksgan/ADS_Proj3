''commit order serializability'', ''dynamic atomicity'' (only since 1993, when its original definition merged into CO; see ''[[The History of Commitment Ordering]]'' and the references there), and ''strong recoverability'' (since 1991). The latter is a misleading name since CO is incomparable with ''[[serializability#Correctness - recoverability|recoverability]]'', and the term "strong" implies a special case. This means that a schedule with a strong recoverability property does not necessarily have the CO property, and vice versa. In 2009 CO has been characterized as a major [[concurrency control]] method, together with the previously known (since the 1980s) three major methods: ''Locking'', ''Time-stamp ordering'', and ''Serialization graph testing'', and as an enabler for the interoperability of systems using different concurrency control mechanisms.<ref name=Bern2009>[[Philip A. Bernstein]], Eric Newcomer (2009): [http://www.elsevierdirect.com/product.jsp?isbn=9781558606234 ''Principles of Transaction Processing'', 2nd Edition], Morgan Kaufmann (Elsevier), June 2009, ISBN 978-1-55860-623-4 (pages 145, 360)</ref> In a [[federated database system]] or any other more loosely defined multidatabase system, which are typically distributed in a communication network, transactions span multiple (and possibly [[Distributed database|distributed]]) databases. Enforcing [[global serializability]] in such system is problematic. Even if every local schedule of a single database is serializable, still, the global schedule of a whole system is not necessarily serializable. The massive communication exchanges of conflict information needed between databases to reach [[Serializability#View and conflict serializability|conflict serializability]] would lead to unacceptable performance, primarily due to computer and communication [[latency (engineering)|latency]]. The problem of achieving global serializability effectively had been characterized as [[open problem|open]] until the end of 1991 (see ''[[Global serializability]]''). Enforcing CO is an effective way to enforce conflict serializability globally in a distributed system, since enforcing CO locally in each database (or other transactional object) also enforces it globally. Each database may use any, possibly different, type of [[concurrency control]] mechanism. With a local mechanism that already provides conflict serializability, enforcing CO locally does not cause any additional aborts, since enforcing CO locally does not affect the data access scheduling strategy of the mechanism (this scheduling determines the serializability related aborts; such a mechanism typically does not consider the commitment events or their order). The CO solution requires no communication overhead, since it uses (unmodified) ''[[atomic commitment]]'' protocol messages only, already needed by each distributed transaction to reach [[atomicity]]. An atomic commitment protocol plays a central role in the distributed CO algorithm, which enforces CO globally, by breaking global cycles (cycles that span two or more database) in the global conflict graph. CO, its special cases, and its generalizations are compatible, and achieve global serializability while transparently being utilized together in a single heterogeneous distributed environment comprising objects with possibly different concurrency control mechanisms. As such, ''Commitment ordering'', including its special cases, and together with its generalizations (see CO variants below), provides a general, high performance, fully distributed solution (no central processing component or central data structure are needed) for guaranteeing ''[[global serializability]]'' in heterogeneous environments of multidatabase systems and other multiple [[transactional object]]s (objects with states accessed and modified only by transactions; e.g., in the framework of [[transactional processes]], and within [[Cloud computing]] and [[Grid computing]]). The CO solution scales up with network size and the number of databases without any negative impact on performance (assuming the statistics of a single distributed transaction, e.g., the average number of databases involved with a single transaction, are unchanged). ==The commitment ordering solution for global serializability== ===General characterization of CO=== ''Commitment ordering'' (CO) is a special case of [[serializability#View and conflict serializability|conflict serializability]]. CO can be enforced with ''non-blocking'' mechanisms (each transaction can complete its task without having its data-access blocked, which allows [[optimistic concurrency control]]; however, commitment could be blocked). In a CO schedule the commitment events' ([[partial order|partial]]) precedence order of the transactions corresponds to the precedence (partial) order of the respective transactions in the ([[directed graph|directed]]) conflict graph ([[Serializability#Testing conflict serializability|precedence graph]], serializability graph), as induced by their conflicting access operations (usually read and write (insert/modify/delete) operations; CO also applies to higher level operations, where they are conflicting if [[noncommutative]], as well as to conflicts between operations upon multi-version data). *'''Definition - Commitment ordering''' :Let <math>T_{1}, T_{2}</math> be two ''committed'' transactions in a schedule, such that <math>T_{2}</math> is ''in a conflict'' with <math>T_{1}</math> (<math>T_{1}</math> ''precedes'' <math>T_{2}</math>). The schedule has the '''Commitment ordering''' (CO) property, if for every two such transactions <math>T_{1}</math> commits before <math>T_{2}</math> commits. The commitment decision events are generated by either a local commitment mechanism, or an [[atomic commitment]] protocol, if different processes need to reach consensus on whether to commit or abort. The protocol may be distributed or centralized. Transactions may be committed concurrently, if the commit [[partial order]] allows (if they do not have conflicting operations). If different conflicting operations induce different partial orders of same transactions, then the conflict graph has [[cyclic graph|cycles]], and the schedule will violate serializability when all the transactions on a cycle are committed. In this case no partial order for commitment events can be found. Thus, cycles in the conflict graph need to be broken by aborting transactions. However, any conflict serializable schedule can be made CO without aborting any transaction, by properly delaying commit events to comply with the transactions' precedence partial order. CO enforcement by itself is not sufficient as a concurrency control mechanism, since CO lacks the [[Serializability#Correctness - recoverability|recoverability]] property, which should be supported as well. ===The distributed CO algorithm=== A fully distributed ''Global commitment ordering'' enforcement algorithm exists, that uses local CO of each participating database, and needs only (unmodified) [[Atomic commitment]] protocol messages with no further communication. The distributed algorithm is the combination of local (to each database) CO algorithm processes, and an atomic commitment protocol ([[Two-phase commit protocol#Common architecture|which can be fully distributed]]). Atomic commitment protocol is essential to enforce [[atomicity]] of each distributed transaction (to decide whether to commit or abort it; this procedure is always carried out for distributed transactions, independently of concurrency control and CO). A common example of an atomic commitment protocol is the ''[[two-phase commit protocol]]'', which is resilient to many types of system failure. In 