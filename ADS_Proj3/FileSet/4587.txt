failures is legitimate and need not be considered an error, while others consider any contravention of the programmer's explicit intent (as communicated via typing annotations) to be erroneous and not "type-safe." In the context of static (compile-time) type systems, type safety usually involves (among other things) a guarantee that the eventual value of any [[expression (programming)|expression]] will be a legitimate member of that expression's static type. The precise requirement is more subtle than this — see, for example, [[subtype]] and [[polymorphism (computer science)|polymorphism]] for complications. Type safety is closely linked to ''[[memory safety]]'', a restriction on the ability to copy arbitrary bit patterns from one memory location to another. For instance, in an implementation of a language that has some type <math>t</math>, such that some sequence of bits (of the appropriate length) does not represent a legitimate member of <math>t</math>, if that language allows data to be copied into a [[Variable (programming)|variable]] of type <math>t</math>, then it is not type-safe because such an operation might assign a non-<math>t</math> value to that variable. Conversely, if the language is type-unsafe to the extent of allowing an arbitrary integer to be used as a [[Pointer (computing)|pointer]], then it is clearly not memory-safe. Most statically typed languages provide a degree of type safety that is strictly stronger than memory safety, because their type systems enforce the proper use of [[abstract data type]]s defined by programmers even when this is not strictly necessary for memory safety or for the prevention of any kind of catastrophic failure. ==Definitions== [kannan] Type-safe code accesses only the memory locations it is authorized to access. (For this discussion, type safety specifically refers to memory type safety and should not be confused with type safety in a broader respect.) For example, type-safe code cannot read values from another object's private fields. [[Robin Milner]] provided the following slogan to describe type safety: :"Well-typed programs never go wrong."{{Citation needed|date=September 2010}} The appropriate formalization of this slogan depends on the style of formal semantics used for a particular language. In the context of [[denotational semantics]], type safety means that the value of an expression that is well-typed, say with type τ, is a ''bona fide'' member of the set corresponding to τ. In 1994, Andrew Wright and [[Matthias Felleisen]] formulated what is now the standard definition and proof technique for type safety in languages defined by [[operational semantics]]. Under this approach, type safety is determined by two properties of the semantics of the programming language: ;(Type-) preservation: "Well typedness" of programs remains invariant under the transition rules (i.e. evaluation rules or reduction rules) of the language. ;Progress: A well typed program never gets "stuck", i.e., never gets into an undefined state where no further transitions are possible. These properties do not exist in a vacuum; they are linked to the semantics of the programming language they describe, and there is a large space of varied languages that can fit these criteria, since the notion of "well typed" program is part of the static semantics of the programming language and the notion of "getting stuck" (or "going wrong") is a property of its [[dynamic semantics]]. Vijay Saraswat provides the following definition: :"A language is type-safe if the only operations that can be performed on data in the language are those sanctioned by the type of the data." ==Type-safe and type-unsafe languages== Type safety is usually a requirement for any [[toy language]] proposed in academic programming language research. Many languages, on the other hand, are too big for human-generated type-safety proofs, as they often require checking thousands of cases. Nevertheless, some languages such as [[Standard ML]], which has rigorously defined semantics, have been proved to meet one definition of type safety.<ref>http://www.smlnj.org/sml.html</ref> On the other hand, some languages, like [[Java (programming language)|Java]], have been proved to not meet this definition of type safety.<ref>{{Cite web|last=Saraswat |first=Vijay | date=1997-08-15 |title=Java is not type-safe |url=http://www.cis.upenn.edu/~bcpierce/courses/629/papers/Saraswat-javabug.html |accessdate=2008-10-08 }}</ref> Some other languages such as [[Haskell (programming language)|Haskell]] are ''believed'' to meet some definition of type safety, provided certain "escape" features are not used (for example Haskell's <tt>unsafePerformIO</tt>, used to "escape" from the usual restricted environment in which I/O is possible, circumvents the type system and so can be used to break type safety.<ref>{{Cite web|url=http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html#v:unsafePerformIO |title=System.IO.Unsafe |work=GHC libraries manual: base-3.0.1.0 |accessdate=2008-07-17 }}</ref>) [[Type punning]] is another example of such an "escape" feature. Regardless of the properties of the language definition, certain errors may occur at [[Run time (computing)|runtime]] due to bugs in the implementation, or in linked [[library (computer science)|libraries]] written in other languages; such errors could render a given implementation type unsafe in certain circumstances. ===Type safety and strong typing=== Type safety is synonymous with one of the many definitions of [[strong typing]]; but type safety and [[dynamic typing]] are mutually compatible. A dynamically typed language such as [[Smalltalk]] can be seen as a strongly typed language with a very permissive type system where any syntactically correct program is well-typed; as long as its dynamic semantics ensures that no such program ever "goes wrong" in an appropriate sense, it satisfies the definition above and can be called type-safe. ==Type safety issues in specific languages== === Ada === {{wikibooks|Ada Programming|Type System}} [[Ada programming language|Ada]] was designed to be suitable for [[embedded system]]s, [[device driver]]s and other forms of [[system programming]], but also to encourage type safe programming. To resolve these conflicting goals, Ada confines type-unsafety to a certain set of special constructs whose names usually begin with the string <tt>Unchecked_</tt>. Unchecked_Deallocation can be effectively banned from a unit of Ada text by applying <tt>pragma Pure</tt> to this unit. It is expected that programmers will use <tt>Unchecked_</tt> constructs very carefully and only when necessary; programs that do not use them are type safe. The [[SPARK programming language]] is a subset of Ada eliminating all its potential ambiguities and insecurities while at the same time adding [[design by contract|statically checked contracts]] to the language features available. SPARK avoids the issues with dangling pointers by disallowing allocation at run time entirely. === C === {{Wikibooks|C Programming}} 