text editors]] [[Category:Apple Design Award winners]] [[Category:Proprietary software]] [[de:TextMate]] [[es:TextMate]] [[fr:TextMate]] [[pl:TextMate]] [[zh:TextMate]]</text> </page> <page> <id>37169</id> <title>Text Mode Demo Contest</title> <text>[[Image:libcaca-cacaplas.png|right|thumb|Screenshot from ''"cacaplas"'', a small text mode demo using the ASCII-Art library [[libcaca]].]] '''Text Mode Demo Contest''' (TMDC) is a semi-annual [[text mode]] [[demo (computer programming)| demo]] competition organized by [[tAAt ry]] and held over the internet. The inherent limitations of text mode graphics create unique challenges for [[demosceners]]. To help promote the event, a text mode invitation [[Demo (computer programming)|demo]] is released ahead of the competition. The competition is held between the 11.11 and the 12.12 every year. One charming aspect of the Text Mode Demo Competition is the technical limitation of the Text Mode. For some demosceners this is a strange thing, other like the challenging factor about it and therefore see this as some good oldschool-flavored democoding. In early 2008, after TMDC 10, Jari Komppa officially announced he would no longer organize TMDC. Shortly after, some members of the Northern Dragons - themselves long-time participants of the compo - decided, with the agreement of tAAt, to revive the competition. ==See also== * [[Text mode demos]] * [[Demoscene]] ==External links== * [http://tmdc.scene.org/ Official Site] * [http://www.pouet.net/party.php?which=167 TMDC] on [[PouÃ«t]] * [http://digitaltools.node3000.com/5minutes/jari_komppa_on_text_mode_demos_and_the_tmdc.php Interview with Jari Komppa] one of the organizers of the TMDC, September 2007 [[Category:Demoscene]] [[Category:Computer science competitions]] {{compu-graphics-stub}}</text> </page> <page> <id>37185</id> <title>Texture filtering</title> <text>{{unref|date=September 2007}} In [[computer graphics]], '''texture filtering''' is the method used to determine the texture color for a [[Texture mapping|texture mapped]] [[pixel]], using the colors of nearby [[Texel (graphics)|texel]]s (pixels of the texture). In short, it blends the texture pixels together by breaking them up into tinier pixels. Another term for texture filtering is called texture smoothing. There are many methods of texture filtering, which make different trade-offs between [[computation]]al complexity and image quality. Since texture filtering is an attempt to find a value at some point given a set of discrete samples at nearby points, it is a form of [[interpolation]]. ==Application== Texture filtering is a cheap approximation to [[Anti-aliasing#First-principles approach to anti-aliasing|anti-aliasing]]. Soft textures, especially [[height map]]s, look better when interpolated. ==The need for filtering== During the texture mapping process, a 'texture lookup' takes place to find out where on the texture each pixel center falls. Since the textured surface may be at an arbitrary distance and orientation relative to the viewer, one pixel does not usually correspond directly to one texel. Some form of filtering has to be applied to determine the best color for the pixel. Insufficient or incorrect filtering will show up in the image as [[Artifact_(observational)|artifacts]] (errors in the image), such as 'blockiness', [[jaggies]], or shimmering. There can be different types of correspondence between a pixel and the texel/texels it represents on the screen. These depend on the position of the textured surface relative to the viewer, and different forms of filtering are needed in each case. Given a square texture mapped on to a square surface in the world, at some viewing distance the size of one screen pixel is exactly the same as one texel. Closer than that, the texels are larger than screen pixels, and need to be scaled up appropriately - a process known as ''texture magnification''. Farther away, each texel is smaller than a pixel, and so one pixel covers multiple texels. In this case an appropriate color has to be picked based on the covered texels, via ''texture minification''. Graphics [[Application programming interface|APIs]] such as [[OpenGL]] allow the programmer to set different choices for minification and magnification filters. Note that even in the case where the pixels and texels are exactly the same size, one pixel will not necessarily match up exactly to one texel - it may be misaligned, and cover parts of up to four neighboring texels. Hence some form of filtering is still required. ==Mipmapping== [[Mipmap]]ping is a standard technique used to save some of the filtering work needed during texture minification. During texture magnification, the number of texels that need to be looked up for any pixel is always four or fewer; during minification, however, as the textured polygon moves farther away potentially the ''entire texture'' might fall into a single pixel. This would necessitate reading '''all''' of its texels and combining their values to correctly determine the pixel color, a prohibitively expensive operation. Mipmapping avoids this by prefiltering the texture and storing it in smaller sizes down to a single pixel. As the textured surface moves farther away, the texture being applied switches to the prefiltered smaller size. Different sizes of the mipmap are referred to as 'levels', with Level 0 being the largest size (used closest to the viewer), and increasing levels used at increasing distances. ==Filtering methods== This section lists the most common texture filtering methods, in increasing order of computational cost and image quality. ===Nearest-neighbor interpolation=== [[Nearest-neighbor interpolation]] is the fastest and crudest filtering method &mdash; it simply uses the color of the texel closest to the pixel center for the pixel color. While fast, this results in a large number of artifacts - texture 'blockiness' during magnification, and [[aliasing]] and shimmering during minification. ===Nearest-neighbor with mipmapping=== This method still uses nearest neighbor interpolation, but adds mipmapping &mdash; first the nearest mipmap level is chosen according to distance, then the nearest texel center is sampled to get the pixel color. This reduces the aliasing and shimmering significantly, but does not help with blockiness. ===Bilinear filtering=== [[Bilinear filtering]] is the next step up. In this method the four nearest texels to the pixel center are sampled (at the closest mipmap level), and their colors are combined by [[weighted mean|weighted average]] according to distance. This removes the 'blockiness' seen during magnification, as there is now a smooth gradient of color change from one texel to the next, instead of an abrupt jump as the pixel center crosses the texel boundary. Bilinear filtering is almost invariably used with mipmapping; though it can be used without, it would suffer the same aliasing and shimmering problems as its nearest 