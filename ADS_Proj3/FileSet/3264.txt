''b'', and the receiver wishes to receive ''m''<sub>''b''</sub>, without the sender learning ''b'', while the sender wants to ensure that the receiver receive only one of the two messages. The protocol of Even, Goldreich, and Lempel (which the authors attribute partially to [[Silvio Micali]]), is general, but can be instantiated using RSA encryption as follows. {| class="wikitable" ! colspan=3 | Alice ! ! colspan=3 | Bob |- | Secret | Public | Calculus | | Secret | Public | Calculus |- | <math>m_0, m_1</math> | | Messages to be sent | | | | |- | <math>d</math> | <math>N, e</math> | Generate RSA key pair and send public portion to Bob | <math>\Rightarrow</math> | | <math>N, e</math> | Receive public key |- | | <math>x_0, x_1</math> | Generate two random messages | <math>\Rightarrow</math> | | <math>x_0, x_1</math> | Receive random messages |- | | | | | <math>k, b, x_b</math> | | Choose <math>b \in (0,1)</math>, <math>x_b \in (x_0, x_1)</math> and generate random <math>k</math> |- | | <math>v</math> | | <math>\Leftarrow</math> | | <math>v = (x_b + k^e) \mod N</math> | Compute the encryption of <math>k</math>, blind with <math>x_b</math> and send to Alice |- | <math>\begin{align}k_0 & = (v - x_0)^d\mod N \\k_1 & = (v - x_1)^d \mod N\end{align}</math> | | One of these will equal <math>k</math>, but Alice does not know which. | | | | |- | | <math>\begin{align}m'_0 = m_0 + k_0 \\ m'_1 = m_1 + k_1\end{align}</math> | Send both messages to Bob | <math>\Rightarrow</math> | | <math>m'_0, m'_1</math> | Receive both messages |- | | | | | <math>m_b = m'_b - k</math> | | Bob decrypts the <math>m'_b</math> since he knows which <math>x_b</math> he selected earlier. |} # Alice has two messages, <math>m_0, m_1</math>, and wants to send exactly one of them to Bob, but does not want to know which Bob receives. # Alice generates a RSA key pair, comprising the modulus <math>N</math>, the public exponent <math>e</math> and the private exponent <math>d</math> # She also generates two random values, <math>x_0, x_1</math> and sends them to Bob along with her public modulus and exponent. # Bob picks <math>b</math> to be either 0 or 1, and selects either the first or second <math>x_b</math>. # He generates a random value <math>k</math> and blinds <math>x_b</math> by computing <math>v = (x_b + k^e)\mod N</math>, which he sends to Alice. # Alice doesn't know which of <math>x_0</math> and <math>x_1</math> Bob chose, so she attempts to unblind with both of her random messages and comes up with two possible values for <math>k</math>: <math>k_0 = (v - x_0)^d\mod N</math> and <math>k_1 = (v - x_1)^d\mod N</math>. One of these will be equal to <math>k</math> since it will correctly decrypt, while the other will produce another random value that does not reveal any information about <math>k</math>. # She blinds the two secret messages with each of the possible keys, <math>m'_0 = m_0 + k_0</math> <math>m'_1 = m_1 + k_1</math>, and sends them both to Bob. # Bob knows which of the two messages can be unblinded with <math>k</math>, so he is able to compute exactly one of the messages <math>m_b = m'_b - k</math> ==1-n oblivious transfer and k-n oblivious transfer== A 1-n oblivious transfer protocol can be defined as a natural generalization of a 1-2 oblivious transfer protocol. Specifically, a sender has ''n'' messages, and the receiver has an index ''i'', and the receiver wishes to receive the ''i''-th among the sender's messages, without the sender learning ''i'', while the sender wants to ensure that the receiver receive only one of the ''n'' messages. Intuitively, it can also be considered as the effect of adding an additional database's privacy requirement to some existing [[private information retrieval]] protocol. The existence of 1-n oblivious transfer protocols from any private information retrieval protocol was first established by [[Giovanni Di Crescenzo]], [[Tal Malkin]] and [[Rafail Ostrovsky]] in [http://citeseer.ist.psu.edu/dicrescenzo00single.html]. Additional constructions of 1-n oblivious transfer protocols also related to private information retrieval, were proposed, e.g., by [[Moni Naor]] and [[Benny Pinkas]] [http://www.wisdom.weizmann.ac.il/~bennyp/PAPERS/ot.ps], [[William Aiello]], [[Yuval Ishai]] and [[Omer Reingold]] [http://www.wisdom.weizmann.ac.il/~reingold/publications/AIR.PS], [[Sven Laur]] and [[Helger Lipmaa]] [http://research.cyber.ee/~lipmaa/papers/ll07]. [[Gilles Brassard|Brassard]], [[Claude Crépeau|Crépeau]] and [[Jean-Marc Robert|Robert]] further generalized this notion to k-n oblivious transfer{{ref|Note5}}, wherein the receiver obtains a set of "k" messages from the "n" message collection. The set of k messages may be received simultaneously ("non-adaptively"), or they may be requested consecutively, with each request based on previous messages received{{ref|Note6}}. ==Generalized oblivious transfer== k-n Oblivious transfer is a special case of Generalized oblivious transfer, which was presented by Ishai and Kushilevitz in {{ref|Note7}}. In that setting, the sender has a set ''U'' of ''n'' messages, and the transfer constraints are specified by a collection ''A'' of permissible subsets of ''U''. The receiver may obtain any subset of the messages in ''U'' that appears in the collection ''A''. The sender should remain oblivious of the selection made by the receiver, while the receiver cannot learn the value of the messages outside the subset of messages that he chose to obtain. The collection ''A'' is monotone decreasing, in the sense that it is closed under containment (i.e., if a given subset ''B'' is in the collection ''A'', so are all of the subsets of ''B''). The solution proposed by Ishai and Kushilevitz uses parallel invocations of 1-2 oblivious transfer while making use of a special model of private protocols. Later on, other solutions that are based on secret sharing were published --- one by Bhavani Shankar, Kannan Srinathan, and C. Pandu Rangan in {{ref|Note8}}, and another by Tamir Tassa in {{ref|Note9}}. ==Origins== In the early seventies [[Stephen Wiesner]] introduced a primitive called '''multiplexing''' in his seminal paper "Conjugate Coding", which was the starting point of [[quantum cryptography]]{{ref|Note0}}. Unfortunately it took more than ten years to be published. Even though this primitive was equivalent to what was later called ''1-2 oblivious transfer'', Wiesner did not see its application to cryptography. ==See also== * [[Secure multiparty computation]] * [[Zero knowledge proof]] ==References== * {{Note|Note0}} Stephen Wiesner, "Conjugate coding", Sigact News, 