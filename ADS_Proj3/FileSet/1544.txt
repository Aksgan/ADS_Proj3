language)|Python]], [[Perl]], [[Tcl]], and [[Ruby programming language|Ruby]], all provide easy access to native code written in C/C++ (or any other language obeying C/C++ calling conventions). ** Python additionally provides the Ctypes module [http://www.python.org/doc/2.5/lib/module-ctypes.html], which can load C functions from [[shared library|shared libraries]]/[[Dynamic-link library|DLL]]s on-the-fly and translate simple data types automatically between Python and C semantics. For example: <source lang="python"> import ctypes libc = ctypes.CDLL( '/lib/libc.so.6' ) # under Linux/Unix t = libc.time(None) # equivalent C code: t = time(NULL) print t </source> * [[P/Invoke]], which provides an interface between the Microsoft [[Common Language Runtime]] and native code. * [[Racket (programming_language)|Racket]] (formerly PLT Scheme) has a native FFI based heavily on macros that enables importing arbitrary shared libraries dynamically.[http://download.plt-scheme.org/doc/372/html/foreign/] * [[Factor_(programming_language)|Factor]] has FFI for C[http://fun-factor.blogspot.com/2007/10/getting-started-with-factor-easy-ffi.html], Fortran[http://article.gmane.org/gmane.comp.lang.factor.general/2790], Objective-C[http://docs.factorcode.org/content/vocab-cocoa.html], and Windows COM[http://docs.factorcode.org/content/vocab-windows.com.html]; all of these enable importing and calling arbitrary shared libraries dynamically. * [[Visual Basic]] has a declarative syntax that allows it to call non-unicode C functions. * One of the bases of the [[Component Object Model]] is a common interface format, which natively uses the same types as Visual Basic for strings and arrays. * [[Google Web Toolkit|GWT]], in which java is compiled to javascript, has a FFI called JSNI which allows java source to call arbitrary Javascript functions, and for Javascript to call back into java. In addition, many FFIs can be generated automatically: for example, [[SWIG]]. ==See also== * [[Language binding]] * [[Calling convention]] * [[Name mangling]] * [[Application programming interface]] - API * [[Application Binary Interface]] - ABI * [[Comparison of application virtual machines]] * [[SWIG]] - opensource interfaces bindings generator from many languages to many languages == External links == *[http://www.c2.com/cgi/wiki?ForeignFunctionInterface c2.com: Foreign function interface] *[http://www.cse.unsw.edu.au/~chak/haskell/ffi/ Haskell 98 Foreign Function Interface] *[http://www.franz.com/support/documentation/6.2/doc/foreign-functions.htm Allegro Common Lisp {{abbr|FFI}}] *[http://www.cs.kent.ac.uk/pubs/2005/2254/ A Foreign Function Interface generator for occam-pi] *[http://uffi.b9.com/ UFFI: Lisp Universal Foreign Function Interface] *[http://common-lisp.net/project/cffi/ CFFI: Common Foreign Function Interface, for Common Lisp] *[http://java.sun.com/docs/books/jni/ Java Native Interface: Programmer's Guide and Specification] *{{Javadoc:SE-guide|jni/spec/jniTOC.html|The JNI Specification}} *[http://code.google.com/webtoolkit/documentation/com.google.gwt.doc.DeveloperGuide.JavaScriptNativeInterface.html JSNI (JavaScript Native Interface)] *[http://dyncall.org/ dyncall library using assembly call kernels for a variety of processors,OS and calling conventions] *[http://www.gnu.org/software/libffcall/ FFCALL] *[http://www.nongnu.org/cinvoke/ C/Invoke] *[http://sourceware.org/libffi/ libffi] [[Category:Application programming interfaces]] [[Category:Subroutines]] [[es:Foreign function interface]]</text> </page> <page> <id>13947</id> <title>Forensic corporate collections</title> <text>{{multiple issues|orphan =April 2008|NPOV=April 2010|unreferenced =May 2010|primarysources = April 2010}} '''Forensic Corporate Collections''' refer to the type of [[debt collection]] and recovery tactics that apply [[computer forensics]] and [[scientific knowledge]] to the debt collection process. ==Purpose== Forensic corporate collections are those that are acquired in a fashion that enables the evidence and results that are collected, preserved, analyzed, and presented to the [[creditor]] to be legally admissible in a [[court of law]]. This type of debt collection employs data collected from computer-driven [[hardware]] such as [[personal computer]]s, public information center databases, PDAâ€™s ([[personal digital assistant]]s), [[cell phone]]s, and other hardware to track down [[debtor]]s nationally and internationally to recover and collect money that is owed to a client/creditor. This is all done within the fullest parameters of the law in order for it to be presented in court, if necessary.{{Citation needed|date=May 2010}} ==Process== By engaging consistently updated [[computer software]] in the debt collection process, forensic corporate collection agencies are able to identify, retrieve, and protect electronic evidence of [[fraud]] (and other illegal means of avoiding debt) found on computers and use it as evidence in case of [[litigation]]. In order for a forensic collections agency to be used as a means of recovering a debt, the agency must be compliant with and knowledgeable of investigation basics, federal, state and local policies, standards, laws and legal processes. They must also have a working knowledge of the types of crimes and incidents in debt deception and fraud, the [[computing]] environment and types of evidence, as well as investigative tools, technical training, and use of forensic recovery equipment. In order to effectively recover and locate debtors and get them to pay what they owe their client(s), forensic collections agents have become adept and conversant in [[evidence collection]] and management, managing the incident scene, the investigation of [[computer system]]s, disks, and file structures, extracting and preserving computer and electronic evidence, [[e-mail]] and [[Internet]] investigations, cell phone and PDA investigations, and other [[digital footprint]]s debtors invariably leave behind. {{DEFAULTSORT:Forensic Corporate Collections}} [[Category:Computer forensics]]</text> </page> <page> <id>13954</id> <title>Fork-exec</title> <text>{{No footnotes|date=September 2010}} '''Fork-exec''' is a commonly used technique in [[Unix]] whereby an executing [[Process (computing)|process]] spawns a new program. <tt>[[Fork (operating system)|fork()]]</tt> is the name of the [[system call]] that the [[parent process]] uses to "divide" itself ("fork" into two identical processes). After calling <tt>fork()</tt>, the created [[child process]] is actually an exact copy of the parent - which would probably be of limited use - so it replaces itself with another process using the system call <tt>[[Exec (operating system)|exec()]]</tt>. When a process forks, a complete copy of the executing program is made into the new process. This new process (which is a child of the parent) has a new [[process identifier]] (PID). The <tt>fork()</tt> function returns the child's PID to the parent, while it returns 0 to the child, in order to allow the two identical processes to distinguish one another. The parent process can either continue execution or wait for the child process to complete. The child, after discovering that it is the child, replaces itself completely with another program, so that the code and [[address space]] of the original program are lost. If the parent chooses to wait for the child to die, then the parent will receive the exit code of the program that the child executed. Otherwise, the parent can ignore the child process and continue executing as it normally would; to prevent the child becoming a [[Zombie process|zombie]] it should [[Wait (operating system)|wait]] on children at intervals or on [[SIGCHLD]]. When the child process calls <tt>exec()</tt>, all data in the original program is lost, and replaced with a running copy of the new program. This is known as [[Overlay (operating system)|overlaying]]. Although all data is replaced, the [[file descriptor]]s that were open in the parent are closed only 