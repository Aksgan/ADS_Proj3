declared without a body and is marked as <code>extern</code>. The <code>DllImport</code> attribute also needs to be added to reference the desired DLL file. <source lang="csharp"> [DllImport("win32.dll")] static extern double Pow(double a, double b); </source> ====Fields==== Fields, or class variables, can be declared inside the class body to store data. It is considered good practice to keep a field private and declare a property to access it. <source lang="csharp"> class Foo { double foo; } </source> Fields can be initialized directly when declared. <source lang="csharp"> class Foo { double foo = 2.3; } </source> '''Modifiers for fields:''' * <code>static</code> - Makes the field a static member. * <code>readonly</code> - Allows the field to be initialized only once in a constructor. * <code>const</code> - Makes the field a constant. * <code>public</code> - Makes the field public. * <code>private</code> - Makes the field private (default). * <code>protected</code> - Makes the field protected. ====Properties==== Properties bring field-like syntax and combine them with the power of methods. A property can have two accessors: <code>get</code> and <code>set</code>. <source lang="csharp"> class Person { string name; string Name { get { return name; } set { name = value; } } } //Using a property Person person = new Person(); person.Name = "Robert"; </source> '''Modifiers for properties:''' * <code>static</code> - Makes the property a static member. * <code>public</code> - Makes the property public. * <code>private</code> - Makes the property private (default). * <code>protected</code> - Makes the property protected. '''Modifiers for property accessors:''' * <code>public</code> - Makes the accessor public. * <code>private</code> - Makes the accessor private. * <code>protected</code> - Makes the accessor protected. The default modifiers for the accessors are inherited from the property. Note that the accessor's modifiers can only be equal or more restrictive than the property's modifier. =====Automatic properties===== :''This is a feature of [[C Sharp 3.0]].'' A feature of C# 3.0 is auto-implemented properties. You define accessors without bodies and the compiler will generate a backing field and the necessary code for the accessors. <source lang="csharp"> double Width { get; private set; } </source> ====Indexers==== Indexers add array-like indexing capabilities to objects. They are implemented in a way similar to properties. <source lang="csharp"> class IntList { int[] items; int this[int index] { get { return this.items[index]; } set { this.items[index] = value; } } } //Using an indexer IntList list = new IntList(); list[2] = 2; </source> ====Inheritance==== Classes in C# may only inherit from one class. A class may derive from any class that is not marked as <code>sealed</code>. <source lang="csharp"> class A { } class B : A { } </source> '''See also''' * [[Inheritance (computer science)]] =====<code>virtual</code>===== Methods marked <code>virtual</code> provide an implementation, but it can be overridden by the inheritors by using the <code>override</code> keyword. The implementation is chosen by the actual type of the object and not the type of the variable. <source lang="csharp"> class Operation { public virtual int Do() { return 0; } } class NewOperation : Operation { public override int Do() { return 1; } } </source> =====<code>new</code>===== When overloading a non-virtual method with another signature, the keyword <code>new</code> may be used. The used method will be chosen by the type of the variable instead of the actual type of the object. <source lang="csharp"> class Operation { public int Do() { return 0; } } class NewOperation : Operation { public new double Do() { return 4.0; } } </source> This demonstrates the case: <source lang="csharp"> NewOperation operation = new NewOperation; // Will call "double Do()" in NewOperation double d = operation.Do(); Operation operation_ = operation; // Will call "int Do()" in Operation int i = operation_.Do(); </source> =====<code>abstract</code>===== Abstract classes are classes that only serve as templates and you can not initialize an object of that type. Otherwise it is just like an ordinary class. There may be abstract members too. Abstract members are members of abstract classes that do not have any implementation. They must be overridden by the class that inherits the member. <source lang="csharp"> abstract class Mammal { public abstract void Walk(); } class Human : Mammal { public override void Walk() { } ... } </source> =====<code>sealed</code>===== The <code>sealed</code> modifier can be combined with the others as an optional modifier for classes to make them uninheritable. <source lang="csharp"> internal sealed class _FOO { } </source> ===Interfaces=== Interfaces are data structures that contain member definitions and not actual implementation. They are useful when you want to define a contract between members in different types that have different implementations. You can declare definitions for methods, properties, and indexers. An interface can either be implicitly or explicitly implemented. <source lang="csharp"> interface IBinaryOperation { double A { get; set; } double B { get; set; } double GetResult(double a, double b); } </source> ====Implementing an interface==== An interface is implemented by a class or extended by another interface in the same way you derive a class from another class using the <code>:</code> notation. '''Implicit implementation''' When implicitly implementing an interface the members of the interface has to be <code>public</code>. <source lang="csharp"> public class Adder : IBinaryOperation { public double A { get; set; } public double B { get; set; } public double GetResult() { return A + B; } } public class Multiplier : IBinaryOperation { public double A { get; set; } public double B { get; set; } public double GetResult() { return A * B; } } </source> In use: <source lang="csharp"> IBinaryOperation op = null; double result; // Adder implements the interface IBinaryOperation. op = new Adder(); op.A = 2; op.B = 3; result = op.GetResult(); //5 // Multiplier also implements the interface. op = new Multiplier(); op.A = 5; op.B = 4; result = op.GetResult(); //20 </source> '''Explicit implementation''' You can also explicitly implement members. The members of the interface that are implemented by a class is the only accessible when the object is handled as the interface type. <source lang="csharp"> public class Adder : IBinaryOperation { double IBinaryOperation.A { get; set; } double IBinaryOperation.B { get; set; 