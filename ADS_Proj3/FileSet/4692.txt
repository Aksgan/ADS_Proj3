new language features (such as the uwire keyword). A separate part of the Verilog standard, [[Verilog-AMS]], attempts to integrate analog and mixed signal modeling with traditional Verilog. ===SystemVerilog=== {{Main|SystemVerilog}} SystemVerilog is a [[superset]] of Verilog-2005, with many new features and capabilities to aid design-verification and design-modeling. As of 2009, the SystemVerilog and Verilog language standards were merged into SystemVerilog 2009 (IEEE Standard 1800-2009). The advent of [[hardware verification language]]s such as [[OpenVera]], and [[Verisity]]'s [[e (verification language)|e language]] encouraged the development of [[Superlog]] by [[Co-Design Automation Inc]]. Co-Design Automation Inc was later purchased by [[Synopsys]]. The foundations of Superlog and Vera were donated to [[Accellera]], which later became the IEEE standard P1800-2005: SystemVerilog. == Example == A [[hello world program]] looks like this: <source lang="verilog"> module main; initial begin $display("Hello world!"); $finish; end endmodule </source> A simple example of two [[Flip-flop (electronics)|flip-flops]] follows: <source lang="verilog"> module toplevel(clock,reset); input clock; input reset; reg flop1; reg flop2; always @ (posedge reset or posedge clock) if (reset) begin flop1 <= 0; flop2 <= 1; end else begin flop1 <= flop2; flop2 <= flop1; end endmodule </source> The "<=" operator in verilog is another aspect of its being a hardware description language as opposed to a normal procedural language. This is known as a "non-blocking" assignment. Its action doesn't register until the next clock cycle. This means that the order of the assignments are irrelevant and will produce the same result: flop1 and flop2 will swap values every clock. The other assignment operator, "=", is referred to as a blocking assignment. When "=" assignment is used, for the purposes of logic, the target variable is updated immediately. In the above example, had the statements used the "=" blocking operator instead of "<=", flop1 and flop2 would not have been swapped. Instead, as in traditional programming, the compiler would understand to simply set flop1 equal to flop2. An example [[counter]] circuit follows: <source lang="verilog"> module Div20x (rst, clk, cet, cep, count,tc); // TITLE 'Divide-by-20 Counter with enables' // enable CEP is a clock enable only // enable CET is a clock enable and // enables the TC output // a counter using the Verilog language parameter size = 5; parameter length = 20; input rst; // These inputs/outputs represent input clk; // connections to the module. input cet; input cep; output [size-1:0] count; output tc; reg [size-1:0] count; // Signals assigned // within an always // (or initial)block // must be of type reg wire tc; // Other signals are of type wire // The always statement below is a parallel // execution statement that // executes any time the signals // rst or clk transition from low to high always @ (posedge clk or posedge rst) if (rst) // This causes reset of the cntr count <= 5'b0; else if (cet && cep) // Enables both true begin if (count == length-1) count <= 5'b0; else count <= count + 5'b1; // 5'b1 is 5 bits end // wide and equal // to the value 1. // the value of tc is continuously assigned // the value of the expression assign tc = (cet && (count == length-1)); endmodule </source> An example of delays: <source lang="verilog"> ... reg a, b, c, d; wire e; ... always @(b or e) begin a = b & e; b = a | b; #5 c = b; d = #6 c ^ e; end </source> The always clause above illustrates the other type of method of use, i.e. the always clause executes any time any of the entities in the list change, i.e. the b or e change. When one of these changes, immediately a and b are assigned new values. After a delay of 5 time units, c is assigned the value of b and the value of c ^ e is tucked away in an invisible store. Then after 6 more time units, d is assigned the value that was tucked away. Signals that are driven from within a process (an initial or always block) must be of type reg. Signals that are driven from outside a process must be of type wire. The keyword reg does not necessarily imply a hardware register. == Definition of Constants == The definition of constants in Verilog supports the addition of a width parameter. The basic syntax is: <''Width in bits''>'<''base letter''><''number''> Examples: *12'h123 - Hexadecimal 123 (using 12 bits) *20'd44 - Decimal 44 (using 20 bits - 0 extension is automatic) *4'b1010 - Binary 1010 (using 4 bits) *6'o77 - Octal 77 (using 6 bits) == ''Synthesizeable constructs'' == There are several statements in Verilog that have no analog in real hardware, e.g. $display. Consequently, much of the language can not be used to describe hardware. The examples presented here are the classic subset of the language that has a direct mapping to real gates. <source lang="verilog"> // Mux examples - Three ways to do the same thing. // The first example uses continuous assignment wire out ; assign out = sel ? a : b; // the second example uses a procedure // to accomplish the same thing. reg out; always @(a or b or sel) begin case(sel) 1'b0: out = b; 1'b1: out = a; endcase end // Finally - you can use if/else in a // procedural structure. reg out; always @(a or b or sel) if (sel) out = a; else out = b; </source> The next interesting structure is a transparent latch; it will pass the input to the output when the gate signal is set for "pass-through", and captures the input and stores it upon transition of the gate signal to "hold". The output will remain stable regardless of the input signal while the gate is set to "hold". In the example below the "pass-through" level of the gate would be when the value of the if clause is true, i.e. gate = 1. This is read "if gate is true, the din is fed to latch_out continuously." Once the if 