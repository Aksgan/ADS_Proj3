* [[Exploding Animal#Snake at Everglades National Park|Exploding snake]] == Footnotes == {{reflist}} ==References== *{{cite book | author=Mattison, Chris | title=Snake| publisher=DK Publishing| year=1999 | isbn=0-7894-4660-X}} *[http://www.anapsid.org/burm.html Anapsid.org: Burmese Python] == Further reading == *Bryan Christy: ''The Lizard King: The True Crimes and Passions of the World's Greatest Reptile Smugglers''. New York: TWELVE, 2008 ISBN 978-0-446-58095-3 ==External links== {{Commons|Python molurus}} {{Wikispecies|Python molurus bivittatus}} [[Category:Pythonidae by common name]] [[Category:Reptiles of Asia]] [[Category:Fauna of Southeast Asia]] [[Category:Fauna of Bangladesh]] [[Category:Fauna of Burma]] [[Category:Fauna of Laos]] [[Category:Fauna of Cambodia]] [[Category:Fauna of Thailand]] [[Category:Fauna of Brunei]] [[Category:Reptiles of Indonesia]] [[Category:Reptiles of Malaysia]] [[Category:Invasive animal species]] [[Category:Invasive animal species in the United States]] [[cs:Krajta tygrovitá]] [[da:Tigerpyton]] [[de:Tigerpython]] [[es:Python molurus bivittatus]] [[eo:Birma pitono]] [[fr:Python molurus]] [[it:Python molurus]] [[he:פיתון בורמזי]] [[lt:Tigrinis pitonas]] [[nl:Tijgerpython]] [[ja:インドニシキヘビ]] [[no:Tigerpyton]] [[pl:Pyton tygrysi]] [[ru:Тёмный тигровый питон]] [[fi:Tiikeripyton]] [[th:งูหลาม]] [[tr:Burma pitonu]] [[zh-yue:緬甸蟒蛇]] [[zh:緬甸蟒]]</text> </page> <page> <id>4743</id> <title>Burton Smith</title> <text>[[Image:Burton J Smith.JPG|right|thumbnail|Burton J. Smith at Supercomputing 2007]] '''Burton J. Smith''' is a [[computer architecture|computer architect]]. From 1988 until 1999, Smith was the chief scientist and member of the board of directors of [[Tera Computer Company]]. Smith received the 1991 [[Eckert-Mauchly Award]] and the 2003 [[Seymour Cray Computer Science and Engineering Award|Cray award]] for computer architecture. In December, 2005, Smith was hired by [[Microsoft]] as a Technical Fellow. ==External links== * [http://www.microsoft.com/presspass/exec/techfellow/Smith/default.mspx Microsoft biography] * [http://www.microsoft.com/presspass/press/2005/dec05/12-09SmithBurtonPR.mspx Press Release] [[Category:Computer hardware researchers|Smith, Burton]] [[Category:Living people]]</text> </page> <page> <id>4744</id> <title>Bus (computing)</title> <text>[[Image:PCIExpress.jpg|right|250px|thumb|4 [[PCI Express]] bus card slots (from top to bottom: x4, x16, x1 and x16), compared to a 32-bit [[conventional PCI]] bus card slot (very bottom).]] In [[computer architecture]], a '''bus''' is a subsystem that transfers data between computer components inside a [[computer]] or between computers. Early computer buses were literally parallel [[electrical bus]]es with multiple connections, but the term is now used for any physical arrangement that provides the same logical functionality as a parallel electrical bus. Modern computer buses can use both parallel and bit-serial connections, and can be wired in either a [[multidrop]] (electrical parallel) or [[Daisy chain (electrical engineering)|daisy chain]] topology, or connected by switched hubs, as in the case of [[Universal Serial Bus|USB]]. ==History== ===First generation=== Early [[computer]] buses were bundles of wire that attached [[Computer storage|memory]] and peripherals. Anecdotally termed the "''digit trunk''"<ref>See the early Australian [[CSIRAC]] computer</ref>, they were named after [[electrical bus]]es, or [[busbar]]s. Almost always, there was one bus for memory, and another for peripherals,{{Citation needed|date=November 2007}}<!-- Early computers did not use a single "peripheral bus": see [[I/O channel]] --> and these were accessed by separate instructions, with completely different timings and protocols. One of the first complications was the use of [[interrupt]]s. Early computer programs performed [[Input/output|I/O]] by [[Busy waiting|waiting in a loop]] for the peripheral to become ready. This was a waste of time for programs that had other tasks to do. Also, if the program attempted to perform those other tasks, it might take too long for the program to check again, resulting in loss of data. Engineers thus arranged for the peripherals to interrupt the CPU. The interrupts had to be prioritized, because the CPU can only execute code for one peripheral at a time, and some devices are more time-critical than others. Later computer programs began to share memory common to several CPUs. Access to this memory bus had to be prioritized, as well. The classic, simple way to prioritize interrupts or bus access was with a [[daisy chain (electrical engineering)|daisy chain]]. [[Digital Equipment Corporation|DEC]] noted that having two buses seemed wasteful and expensive for mass-produced [[minicomputer]]s, and [[Memory-mapped I/O|mapped peripherals]] into the memory bus, so that the devices appeared to be memory locations. Early [[microcomputer]] bus systems were essentially a passive [[backplane]] connected directly or through buffer amplifiers to the pins of the [[Central processing unit|CPU]]. Memory and other devices would be added to the bus using the same address and data pins as the CPU itself used, connected in parallel. Communication was controlled by the [[Central processing unit|CPU]], which had read and written data from the devices as if they are blocks of memory, using the same instructions, all timed by a central clock controlling the speed of the CPU. Still, devices [[interrupt]]ed the CPU by signaling on separate CPU pins. <!--not all buses are synchronous even on microprocessors, DTAK on 68000 e.g. --> For instance, a [[disk drive]] controller would signal the CPU that new data was ready to be read, at which point the CPU would move the data by reading the "memory location" that corresponded to the disk drive. Almost all early microcomputers were built in this fashion, starting with the [[S-100 bus]] in the [[Altair 8800|Altair]]. In some instances, most notably in the [[IBM PC]], although similar physical architecture is employed, instructions to access peripherals (<code>in</code> and <code>out</code>) and memory (<code>mov</code> and others) have not been made uniform at all, and still generate distinct CPU signals, that could be used to implement a separate I/O bus. These simple bus systems had a serious drawback when used for general-purpose computers. All the equipment on the bus has to talk at the same speed, as it shares a single clock. Increasing the speed of the CPU becomes harder, because the speed of all the devices must increase as well. When it is not practical or economical to have all devices as fast as the CPU, the CPU must either enter a [[wait state]], or work at a slower clock frequency temporarily<ref name="bray-aug">{{cite book|last= Bray|first=Andrew C.|coauthors= Dickens, Adrian C.; Holmes, Mark A.|title= The Advanced User Guide for the BBC Microcomputer|url= http://www.nvg.org/bbc/doc/BBCAdvancedUserGuide-PDF.zip|format= zipped PDF|accessdate= 2008-03-28|year= 1983|publisher= Cambridge Microcomputer Centre|location= Cambridge, UK|isbn= 0946827001|pages= 442–443|chapter= 28. The One Megahertz bus}}</ref>, to talk to other devices in the computer. While acceptable in [[embedded systems]], this problem was not tolerated for long in general-purpose, user-expandable computers. Such bus systems are also difficult to configure when constructed from common off-the-shelf equipment. Typically each added [[expansion card]] requires many [[jumper (computing)|jumpers]] in order to set memory addresses, I/O addresses, interrupt priorities, and interrupt numbers. A ''bus controller'' accepted 