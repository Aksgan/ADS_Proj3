concurrent operations, which by its nature is likely to be hard to reproduce and [[debugging|debug]]. ==Primitive atomic instructions== Most modern processors have [[Instruction (computer science)|instructions]] which can be used to implement [[lock (computer science)|locking]] and [[lock-free and wait-free algorithms]]. The ability to temporarily turn off [[interrupt]]s, ensuring that the currently running [[process (computing)|process]] cannot be [[context switch]]ed, also suffices on a [[uniprocessor]]. These instructions are used directly by compiler and operating system writers but are also abstracted and exposed as bytecodes and library functions in higher-level languages. *Atomic read and write *[[Atomic swap]] as used in some [[Burroughs large systems#Multiple processors|Burroughs mainframes]], also called [[XOR_swap_algorithm#The_XCHG_instruction|XCHG]]. *[[Test-and-set]] *[[Fetch-and-add]] *[[Compare-and-swap]] *[[Load-Link/Store-Conditional]] Many of these primitives can be implemented in terms of each other. Many [[central processing unit|processors]], especially [[32-bit]] ones with [[64-bit]] [[floating point]] support, also provide some read and write operations that are not atomic: one [[thread (computer science)|thread]] reading a 64-bit register while another thread is writing to it may see a combination of both "before" and "after" values, a combination that may never actually have been written to the register. Further, only single operations are guaranteed to be atomic; threads arbitrarily performing groups of reads and writes will also observe a mixture of "before" and "after" values. ==High-level atomic operations== The easiest way to achieve linearizability is running groups of primitive operations in a [[critical section]]. Strictly independent operations can then be carefully permitted to overlap their critical sections, provided this does not violate linearizability. Such an approach must balance the cost of large numbers of [[lock (computer science)|locks]] against the benefits of increased parallelism. Another approach, favoured by researchers (but not yet widely used in the software industry), is to design a linearizable object using the native atomic primitives provided by the hardware. This has the potential to maximise available parallelism and minimise synchronisation costs, but requires mathematical proofs which show that the objects behave correctly. A promising hybrid of these two is to provide a [[transactional memory]] abstraction. As with critical sections, the user marks sequential code that must be run in isolation from other threads. The implementation then ensures the code executes atomically. This style of abstraction is common when interacting with databases; for instance, when using the [[Spring Framework]], annotating a method with @Transactional will ensure all enclosed database interactions occur in a single [[database transaction]]. Transactional memory goes a step further, ensuring that all memory interactions occur atomically. As with database transactions, issues arise regarding composition of transactions, especially database and in-memory transactions. A common theme when designing linearizable objects is to provide an all-or-nothing interface: either an operation succeeds completely, or it fails and does nothing. ([[ACID]] databases refer to this principle as [[Atomicity_(database_systems)|atomicity]].) If the operation fails (usually due to concurrent operations), the user must retry, usually performing a different operation. For example: * [[Compare-and-swap]] writes a new value into a location only if it matches a supplied old value. This is commonly used in a read-modify-CAS sequence: the user reads the location, computes a new value to write, and writes it with a CAS; if the value changes concurrently, the CAS will fail and the user tries again. * [[Load-Link/Store-Conditional]] encodes this pattern more directly: the user reads the location with load-link, computes a new value to write, and writes it with store-conditional; if the value has changed concurrently, the SC will fail and the user tries again. * In a [[database transaction]], if the transaction cannot be completed due to a concurrent operation (e.g. in a [[deadlock]]), the transaction will be aborted and the user must try again. ==Example atomic operation== Consider a simple counter which different processes can increment. ===Non-atomic=== The naive, non-atomic implementation: # reads the value in the memory location; # adds one to the value; # writes the new value back into the memory location. Now, imagine two processes are running incrementing a single, shared memory location: # the first process reads the value in memory location; # the first process adds one to the value; but before it can write the new value back to the memory location it is suspended, and the second process is allowed to run: # the second process reads the value in memory location, the ''same'' value that the first process read; # the second process adds one to the value; # the second process writes the new value into the memory location. The second process is suspended and the first process allowed to run again: # the first process writes a now-wrong value into the memory location, unaware that the other process has already updated the value in the memory location. This is a trivial example. In a real system, the operations can be more complex and the errors introduced extremely subtle. For example, reading a [[64-bit]] value from memory may actually be implemented as two [[sequence|sequential]] reads of two [[32-bit]] memory locations. If a process has only read the first 32 bits, and before it reads the second 32 bits the value in memory gets changed, it will have neither the original value nor the new value but a mixed-up [[garbage (computer science)|garbage]] value. Furthermore, the specific order in which the processes run can change the results, making such an error difficult to detect, reproduce and [[debug]]. ===Compare-and-swap=== Most systems provide an atomic [[compare-and-swap]] instruction that reads from a memory location, compares the value with an "expected" one provided by the user, and writes out a "new" value if the two match, returning whether the update succeeded. We can use this to fix the non-atomic counter algorithm as follows: :# read the value in the memory location; :# add one to the value :# use compare-and-swap to write the incremented value back :# retry if the value read in by the compare-and-swap did not match the value we originally read Since the compare-and-swap occurs (or appears to occur) instantaneously, if another process updates the location while we are in-progress, the compare-and-swap is guaranteed to fail. ===Locking=== {{main|Lock (computer 