---- Now we prove the Elias–Bassalygo bound. Define <math>e = n J_q(\delta)-1 </math>. By Lemma 1, there exists a Hamming ball with <math>B</math> codewords such that <math>B\ge { {|C|Vol(0,e)} \over {q^n}} </math> By [[Johnson bound|Johnson Bound Johnson bound]], we have <math>B\le qdn</math>. Thus, <math>\mid C \mid \le qnd \cdot {{q^n} \over {Vol_q(0,e)}} \le q^{n(1-H_q(J_q(\delta))+o(1))}</math> The second inequality follows from lower bound on the volume of a Hamming ball: <math> Vol_q(0, \lfloor {{d-1} \over 2} \rfloor) \le q^{H_q({\delta \over 2})n-o(n)} </math> Putting in <math>d=2e+1</math> and <math> \delta = {d \over n}</math> gives the second inequality. Therefore we have : <math>R={\log_q{|C|} \over n} \le 1-H_q(J_q(\delta))+o(1) </math> == See also == * [[Singleton bound]] * [[Hamming bound]] * [[Plotkin bound]] * [[Gilbert–Varshamov bound]] * [[Johnson bound]] [[Category:Coding theory]] [[Category:Articles containing proofs]]</text> </page> <page> <id>11962</id> <title>Elias delta coding</title> <text>'''Elias delta code''' is a [[Universal code (data compression)|universal code]] encoding the positive integers developed by [[Peter Elias]]. To code a number: #Write it in binary. #Count the bits and write down that number of bits in binary (X). #Use the binary representation written in step 1 again, remove the leading bit and write down the remaining bits (Y). #Append the second binary representation (Y) to the first binary representation (X). #Count the bits written in step 2 (X), subtract 1 from that number and prepend that many zeros. An equivalent way to express the same process: #Separate the integer into the highest power of 2 it contains (2<sup>''N' ''</sup>) and the remaining ''N''' binary digits of the integer. #Encode ''N = N' + 1'' with [[Elias gamma coding]]. #Append the remaining ''N''' binary digits to this representation of ''N''. The code begins: Implied probability 1 = 2<sup>0</sup> => N' = 0, N = 1 => 1 1/2 2 = 2<sup>1</sup> + ''0'' => N' = 1, N = 2 => 010''0'' 1/16 3 = 2<sup>1</sup> + ''1'' => N' = 1, N = 2 => 010''1'' " 4 = 2<sup>2</sup> + ''0'' => N' = 2, N = 3 => 011''00'' 1/32 5 = 2<sup>2</sup> + ''1'' => N' = 2, N = 3 => 011''01'' " 6 = 2<sup>2</sup> + ''2'' => N' = 2, N = 3 => 011''10'' " 7 = 2<sup>2</sup> + ''3'' => N' = 2, N = 3 => 011''11'' " 8 = 2<sup>3</sup> + ''0'' => N' = 3, N = 4 => 00100''000'' 1/256 9 = 2<sup>3</sup> + ''1'' => N' = 3, N = 4 => 00100''001'' " 10 = 2<sup>3</sup> + ''2'' => N' = 3, N = 4 => 00100''010'' " 11 = 2<sup>3</sup> + ''3'' => N' = 3, N = 4 => 00100''011'' " 12 = 2<sup>3</sup> + ''4'' => N' = 3, N = 4 => 00100''100'' " 13 = 2<sup>3</sup> + ''5'' => N' = 3, N = 4 => 00100''101'' " 14 = 2<sup>3</sup> + ''6'' => N' = 3, N = 4 => 00100''110'' " 15 = 2<sup>3</sup> + ''7'' => N' = 3, N = 4 => 00100''111'' " 16 = 2<sup>4</sup> + ''0'' => N' = 4, N = 5 => 00101''0000'' 1/512 17 = 2<sup>4</sup> + ''1'' => N' = 4, N = 5 => 00101''0001'' " To decode an Elias delta-coded integer: #Read and count zeroes from the stream until you reach the first one. Call this count of zeroes ''L''. #Considering the one that was reached to be the first digit of an integer, with a value of 2<sup>''L''</sup>, read the remaining ''L'' digits of the integer. Call this integer ''N''. #Put a one in the first place of our final output, representing the value 2<sup>''N-1''</sup>. Read and append the following ''N-1'' digits. Example: 001010001 1. 2 leading zeros in 001 2. read 2 more bits i.e. 00101 3. decode N = 00101 = 5 4. get N' = 5 - 1 = 4 remaining bits for the complete code i.e. '0001' 5. encoded number = 2<sup>4</sup> + 1 = 17 This code can be generalized to zero or negative integers in the same ways described in [[Elias gamma coding#Generalizations|Elias gamma coding]]. == See also == *[[Elias gamma coding]] *[[Elias omega coding]] == References == {{Unreferenced|date=April 2007}} {{Compression Methods}} [[Category:Numeration]] [[Category:Lossless compression algorithms]] [[fr:Codage delta]] [[ko:엘리어스 델타 부호]] [[ja:デルタ符号]] [[ru:Дельта-код Элиаса]]</text> </page> <page> <id>11976</id> <title>Elkies trinomial curves</title> <text>[[image:C168.png|thumb|Elkies trinomial curve C<sub>168</sub>]] In [[number theory]], the '''Elkies trinomial curves''' are certain [[hyperelliptic curve]]s constructed by [[Noam Elkies]] which have the property that rational points on them correspond to trinomial polynomials giving an extension of '''Q''' with particular [[Galois group]]s. One curve, C<sub>168</sub>, gives Galois group [[PSL(2,7)]] from a polynomial of degree seven, and the other, C<sub>1344</sub>, gives Galois group AL(8), the [[semidirect product]] of a [[2-elementary group]] of order eight acted on by PSL(2, 7), giving a transitive permutation subgroup of the symmetric group on eight roots of order 1344. The equation of the curve C<sub>168</sub> is :<math>y^2 = x(81x^5+396x^4+738x^3+660x^2+269x+48)</math> The curve is a [[algebraic curve|plane algebraic curve]] model for a [[Galois resolvent]] for the trinomial polynomial equation x<sup>7</sup> + bx + c = 0. If there exists a point (x, y) on the (projectivized) curve, there is a corresponding pair (b, c) of rational numbers, such that the trinomial polynomial either factors or has Galois group PSL(2,7), the finite simple group of order 168. The curve has [[geometric genus|genus]] two, and so by [[Faltings theorem]] there are only a finite number of rational points on it. These rational points were proven by Nils Bruin using the computer program [[Kash]] to be the only ones on C<sub>168</sub>, and they give only four distinct trinomial polynomials with Galois group PSL(2,7): x<sup>7</sup>-7x+3 (the Trinks polynomial), (1/11)x<sup>7</sup>-14x+3<sup>2</sup> (the Erbach-Fisher-McKay polynomial) and two new polynomials with Galois group PSL(2,7), :<math>37^2x^7-28x+3^2</math> and :<math>(499^2/113)x^7-212x+3^4</math>. On the other hand, the equation of curve C<sub>1344</sub> is :<math>y^2 = 2 x^6 + 4 x^5 + 36 x^4 + 16 x^3 - 45 x^2 + 190 x + 1241</math> Once again the genus is two, and by [[Faltings theorem]] the list of rational points 