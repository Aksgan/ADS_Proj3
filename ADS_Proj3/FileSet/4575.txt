Captain and two senior ranking officers as well due to the Executive Officer not being present at the time. == Other meanings == The requirement for the presence of at least two staff members is also used in other contexts where there are security concerns, such as in banks. When bank employees perform some tasks, such as removing money from safes or opening Automated Teller Machine deposits, company policies often require that at least two employees be present. Many banks also make use of physical measures to ensure this - such as cabinets which require the simultaneous use of two keys, or by issuing only half of a vault combination to certain employees and the other half of the combination to the remaining employees. As an extension of the broader rationale for the "two-man rule", regulations for some companies or not-for-profit organizations may require signatures of two executives on checks. These rules make it harder for an individual acting alone to defraud the organization. == See also == * [[Buddy system]] * [[Fail-deadly]] * [[Segregation of duties]] * ''[[The Hunt for Red October]]'' * ''[[The Sum of All Fears]]'' * ''[[Crimson Tide (film)|Crimson Tide]]'' == References == * [http://www.cr.nps.gov/history/online_books/mimi/hrs2-5a.htm U.S. National Park Service article] on [[Minuteman missile]] [[Launch control center (ICBM)|launch control center]]s, with details on operation * [http://www.fas.org/nuke/guide/usa/doctrine/dod/5100-52m/chap15.pdf U.S. DOD nuclear weapons recovery manual with reference to two-man rule] {{Reflist}} {{DEFAULTSORT:Two-Man Rule}} [[Category:Nuclear command and control]] [[Category:Nuclear weapon safety]] [[Category:Access control]]</text> </page> <page> <id>38472</id> <title>Two-phase locking</title> <text>In [[databases]] and [[transaction processing]] (transaction management), '''Two-phase locking''', ('''2PL''') is a ''[[concurrency control]]'' locking protocol, or mechanism, that guarantees ''[[Serializability]]'' (e.g., see [[#Bern1987|Bernstein et al. 1987]], [[#Weikum2001|Weikum and Vossen 2001]]). It is also the name of the resulting ''class'' (set) of [[Database transaction|transaction]] [[schedule (computer science)|schedule]]s. The protocol utilizes ''[[lock (computer science)|locks]]'' that during a transaction's life block other transactions from accessing data accessed by the transaction. Locks are applied and removed in two phases: # Expanding phase (number of locks can only increase): locks are acquired and no locks are released. # Shrinking phase: locks are released and no locks are acquired. Using locks that block processes, 2PL may be subject to ''[[deadlock]]s'' that result from the mutual blocking of two transactions or more. 2PL is a super-class of '''Strong strict two-phase locking''' ('''SS2PL'''; name from [[#Raz1992|Raz 1992]] and its earlier versions), also called '''Rigorousness''' (name from [[#Breit1991|Breitbart et al. 1991]] and its earlier versions), which has been widely utilized for concurrency control in general-purpose database systems since their early days in the 1970s. SS2PL implementation has many variants. SS2PL was called in the past ''Strict 2PL'' (e,g., in [[#Bern1987|Bernstein et al. 1987]], page 59), and confusingly it is still called so by some (now Strict 2PL, or S2PL, is the intersection of ''[[Schedule (computer science)#Strict|Strictness]]'' and 2PL, which is different from SS2PL). SS2PL is also a [[special case]] (subclass) of ''[[Commitment ordering]]'' (Commit ordering; CO; [[#Raz1992|Raz 1992]]), and [[Global serializability#The commitment ordering solution|inherits many of CO's useful properties]]. SS2PL actually comprises only one phase: Phase-2 does not exist, and all locks are released only after transaction end. Neither 2PL in its general form, nor even when combined with [[Schedule (computer science)#Strict|Strictness]], i.e., Strict 2PL (S2PL), are known to be utilized in practice. Thus 2PL by itself does not seem to have much practical importance, and whenever 2PL (or Strict 2PL, S2PL) practical utilization has been mentioned in the professional literature, the intention has been SS2PL. What has made SS2PL (and Distributed SS2PL) so popular is the effective and efficient locking-based combination of two ingredients: #[[Commitment ordering]], which provides both [[Serializability]] and effective [[Serializability#Distributed serializability|Distributed serializability]] and [[Global serializability]] (without the need in the [[Scalability|not scalable]] [[Distributed lock manager]], and while distributed deadlocks are resolved automatically), and #[[Schedule (computer science)#Strict|Strictness]], which provides cascadeless [[Serializability#Correctness - recoverability|Recoverability]] and (independently) allows efficient database [[data recovery|recovery]] from failure. In addition to this SS2PL is easier to implement than 2PL and S2PL (no need in handling end of phase-1 separately from transaction end), with practically the same concurrency (exactly same locking, with practically not much earlier lock release for 2PL and S2PL). '''Comment''': Note that the two-phase locking protocol (2PL protocol) is different from the [[two-phase commit protocol]] (2PC protocol) for commit [[Consensus (computer science)|consensus]] within a distributed transaction. ==Data-access locks== A [[Lock (computer science)|lock]] is a system object associated with a shared resource such as a data item of an elementary type, a row in a database, or a page of memory. In a database, a lock on a database object (a data-access lock) may need to be acquired by a transaction before accessing the object. Correct use of locks prevents undesired, incorrect or inconsistent operations on shared resources by other concurrent transactions. When a database object with an existing lock acquired by one transaction needs to be accessed by another transaction, the existing lock for the object and the type of the intended access are checked by the system. If the existing lock type does not allow this specific attempted concurrent access type, the transaction attempting access is blocked (according to a predefined agreement/scheme). In practice a lock on an object does not directly block a transaction' operation upon the object, but rather blocks that transaction from acquiring another lock on the same object, needed to be held/owned by the transaction before performing this operation. Thus, with a locking mechanism, needed operation blocking is controlled by a proper lock blocking scheme, which indicates which lock type blocks which lock type. Two major types of locks are utilized: *'''Write-lock''' ('''exclusive lock''') is associated with a database object by a transaction (Terminology: "the transaction locks the object," or "acquires lock for it") before ''writing'' (inserting/modifying/deleting) this object. *'''Read-lock''' ('''shared lock''') is associated with a database object by a transaction before ''reading'' (retrieving the state of) this object. The common interactions between these lock types are defined by blocking behavior as follows: * An existing ''write-lock'' on a database object blocks an intended ''write'' upon the 