shortest path is desired, the algorithm may also update each neighbor with its immediate predecessor in the best path found so far; this information can then be used to reconstruct the path by working backwards from the goal node. Additionally, if the heuristic is ''monotonic'' (or [[Consistent heuristic|consistent]], see below), a ''closed set'' of nodes already traversed may be used to make the search more efficient. ==Pseudocode== The following [[pseudocode]] describes the algorithm: <source lang="matlab"> function A*(start,goal) closedset := the empty set // The set of nodes already evaluated. openset := set containing the initial node // The set of tentative nodes to be evaluated. came_from := the empty map // The map of navigated nodes. g_score[start] := 0 // Distance from start along optimal path. h_score[start] := heuristic_estimate_of_distance(start, goal) f_score[start] := h_score[start] // Estimated total distance from start to goal through y. while openset is not empty x := the node in openset having the lowest f_score[] value if x = goal return reconstruct_path(came_from, came_from[goal]) remove x from openset add x to closedset foreach y in neighbor_nodes(x) if y in closedset continue tentative_g_score := g_score[x] + dist_between(x,y) if y not in openset add y to openset tentative_is_better := true elseif tentative_g_score < g_score[y] tentative_is_better := true else tentative_is_better := false if tentative_is_better = true came_from[y] := x g_score[y] := tentative_g_score h_score[y] := heuristic_estimate_of_distance(y, goal) f_score[y] := g_score[y] + h_score[y] return failure function reconstruct_path(came_from, current_node) if came_from[current_node] is set p = reconstruct_path(came_from, came_from[current_node]) return (p + current_node) else return current_node </source> The closed set can be omitted (yielding a tree search algorithm) if a solution is guaranteed to exist, or if the algorithm is adapted so that new nodes are added to the open set only if they have a lower <math>f</math> value than at any previous iteration. ===Example=== An example of A star (A*) algorithm in action where nodes are cities connected with roads and h(x) is the straight-line distance to target point: [[File:AstarExample.gif|An example of A star (A*) algorithm in action (nodes are cities connected with roads, h(x) is the straight-line distance to target point) Green: Start, Blue: Target, Orange: Visited]] '''Key:''' green: start; blue: goal; orange: visited '''Note:''' This example uses a comma as the [[decimal separator]]. ==Properties== Like [[breadth-first search]], A* is ''complete'' and will always find a solution if one exists. If the heuristic function <math>h</math> is [[Admissible heuristic|admissible]], meaning that it never overestimates the actual minimal cost of reaching the goal, then A* is itself admissible (or ''optimal'') if we do not use a closed set. If a closed set is used, then <math>h</math> must also be ''monotonic'' (or [[Consistent heuristic|consistent]]) for A* to be optimal. This means that for any pair of adjacent nodes <math>x</math> and <math>y</math>, where <math>d(x,y)</math> denotes the length of the edge between them, we must have: :<math>h(x) \le d(x,y) + h(y)</math> This ensures that for any path <math>X</math> from the initial node to <math>x</math>: :<math>L(X) + h(x) \le L(X) + d(x,y) + h(y) = L(Y) + h(y)</math> where <math>L(\cdot)</math> denotes the length of a path, and <math>Y</math> is the path <math>X</math> extended to include <math>y</math>. In other words, it is impossible to decrease (total distance so far + estimated remaining distance) by extending a path to include a neighboring node. (This is analogous to the restriction to nonnegative edge weights in [[Dijkstra's algorithm]].) Monotonicity implies admissibility when the heuristic estimate at any goal node itself is zero, since (letting <math>P = (f,v_1,v_2,\ldots,v_n,g)</math> be a shortest path from any node <math>f</math> to the nearest goal <math>g</math>): :<math>h(f) \le d(f,v_1) + h(v_1) \le d(f,v_1) + d(v_1,v_2) + h(v_2) \le \ldots \le L(P) + h(g) = L(P)</math> A* is also optimally efficient for any heuristic <math>h</math>, meaning that no algorithm employing the same heuristic will expand fewer nodes than A*, except when there are multiple partial solutions where <math>h</math> exactly predicts the cost of the optimal path. Even in this case, for each graph there exists some order of breaking ties in the priority queue such that A* examines the fewest possible nodes. ===Special cases=== [[Dijkstra's algorithm]], as another example of a uniform-cost search search algorithm, can be viewed as a special case of A* where <math>h(x) = 0</math> for all <math>x</math>. General [[depth-first search]] can be implemented using the A* by considering that there is a global counter ''C'' initialized with a very large value. Every time we process a node we assign ''C'' to all of its newly discovered neighbors. After each single assignment, we decrease the counter ''C'' by one. Thus the earlier a node is discovered, the higher its <math>h(x)</math> value. It should be noted, however, that both Dijkstra's algorithm and depth-first search can be implemented more efficiently without including a <math>h(x)</math> value at each node. ===Implementation details=== There are a number of simple optimizations or implementation details that can significantly affect the performance of an A* implementation. The first detail to note is that the way the priority queue handles ties can have a significant effect on performance in some situations. If ties are broken so the queue behaves in a [[LIFO (computing)|LIFO]] manner, A* will behave like [[depth-first search]] among equal cost paths. When a path is required at the end of the search, it is common to keep with each node a reference to that node's parent. At the end of the search these references can be used to recover the optimal path. If these references are being kept then it can be important that the same node doesn't appear in the priority queue more than once (each entry corresponding to a different path to the node, and each with a different cost). A standard approach here is to check if a node about to be added already appears in the priority queue. If it does, then the priority and parent pointers are changed to correspond to the lower cost path. When finding a node in a queue to perform this check, many standard implementations of a [[Heap (data structure)|min-heap]] require <math>O(n)</math> time. Augmenting the 