of L4 deployed in commercial products have found it necessary to add an asynchronous notification mechanism to better support asynchronous communication. This [[signal (computing)|signal]]-like mechanism does not carry data and therefore does not require buffering by the kernel. As synchronous IPC blocks the first party until the other is ready, unrestricted use could easily lead to deadlocks. Furthermore, a client could easily mount a [[denial-of-service]] attack on a server by sending a request and never attempting to receive the reply. Therefore synchronous IPC must provide a means to prevent indefinite blocking. Many microkernels provide [[timeout (telecommunication)|timeouts]] on IPC calls, which limit the blocking time. In practice, choosing sensible timeout values is difficult, and systems almost inevitably use infinite timeouts for clients and zero timeouts for servers. As a consequence, the trend is towards not providing arbitrary timeouts, but only a flag which indicates that the IPC should fail immediately if the partner is not ready. This approach effectively provides a choice of the two timeout values of zero and infinity. Recent versions of L4 and MINIX have gone down this path (older versions of L4 used timeouts, as does QNX). ==Servers== Microkernel servers are essentially [[daemon (computer software)|daemon]] programs like any others, except that the kernel grants some of them privileges to interact with parts of physical memory that are otherwise off limits to most programs. This allows some servers, particularly device drivers, to interact directly with hardware. A basic set of servers for a general-purpose microkernel includes file system servers, device driver servers, networking servers, display servers, and user interface device servers. This set of servers (drawn from [[QNX]]) provides roughly the set of services offered by a [[monolithic kernel|monolithic]] UNIX kernel. The necessary servers are started at system startup and provide services, such as file, network, and device access, to ordinary application programs. With such servers running in the environment of a user application, server development is similar to ordinary application development, rather than the build-and-boot process needed for kernel development. Additionally, many "crashes" can be corrected by simply [[Crash-only software|stopping and restarting the server]]. However, part of the system state is lost with the failing server, hence this approach requires applications to cope with failure. A good example is a server responsible for [[Internet protocol suite|TCP/IP]] connections: If this server is restarted, applications will experience a "lost" connection, a normal occurrence in networked system. For other services, failure is less expected and may require changes to application code. For QNX, restart capability is offered as the QNX High Availability Toolkit.<ref><nowiki>http://www.qnx.com/download/download/8107/QNX_High_Availability_Toolkit.pdf</nowiki>{{Dead link|date=June 2009}} QNX High Availability Toolkit</ref> In order to make all servers restartable, some microkernels have concentrated on adding various [[database]]-like techniques like [[database transaction|transaction]]s, [[Replication (computer science)|replication]] and [[checkpointing]] in order to preserve essential state across single server restarts. An example is [[ChorusOS]], which was targeted at high-availability applications in the [[telecommunication]]s world. Chorus included features to allow any "properly written" server to be restarted at any time, with clients using those servers being paused while the server brought itself back into its original state.{{Citation needed|date=February 2007}} However, such kernel features are incompatible with the minimality principle, and are therefore not provided in modern microkernels, which instead rely on appropriate user-level protocols. ==Device drivers== [[Device driver]]s frequently perform [[direct memory access]] (DMA), and therefore can write to arbitrary locations of physical memory, including over kernel data structures. Such drivers must therefore be trusted. It is a common misconception that this means that they must be part of the kernel. In fact, a driver is not inherently more or less trustworthy by being part of the kernel. While running a device driver in user space does not necessarily reduce the damage a misbehaving driver can cause, in practice it is beneficial for system stability in the presence of buggy (rather than malicious) drivers: memory-access violations by the driver code itself (as opposed to the device) may still be caught by the memory-management hardware. Furthermore, many devices are not DMA-capable, their drivers can be made untrusted by running them in user space. Recently, an increasing number of computers feature [[IOMMU]]s, many of which can be used to restrict a device's access to physical memory.<ref name="Wong_07">{{cite journal |title=I/O, I/O, It's Off to Virtual Work We Go |url=http://www.elecdesign.com/Articles/Index.cfm?AD=1&ArticleID=15350 |last=Wong |first=William |journal=[[Electronic Design Magazine]] |date=2007-04-27 |accessdate=2009-06-08}}</ref> (IBM mainframes have had IO MMUs since the [[IBM System/360 Model 67]] and [[System/370]].) This also allows user-mode drivers to become untrusted. User-mode drivers actually predate microkernels. The [[Michigan Terminal System]] (MTS), in 1967, supported user space drivers (including its file system support), the first operating system to be designed with that capability.<ref>{{cite journal |title=Organization and Features of the Michigan Terminal System |first=Michael T. |last=Alexander |journal=Proceedings of the November 16–18, 1971, fall joint computer conference |volume=40 |year=1971 |pages=589–591 |doi=10.1145/1478873.1478951}}</ref> Historically, drivers were less of a problem, as the number of devices was small and trusted anyway, so having them in the kernel simplified the design and avoided potential performance problems. This led to the traditional driver-in-the-kernel style of UNIX,<ref name="Lions book">{{cite book |title=[[Lions' Commentary on UNIX 6th Edition, with Source Code]] |last=Lions |first=John |date=1977-08-01 |isbn=978-1-57398-013-5 |publisher=Peer-To-Peer Communications}}</ref> Linux, and Windows. With the proliferation of various kinds of peripherals, the amount of driver code escalated and in modern operating systems dominates the kernel in terms of code size. ==Essential components and minimality== As a microkernel must allow building arbitrary operating system services on top, it must provide some core functionality. At the least, this includes: * some mechanisms for dealing with [[address space]]s — this is required for managing memory protection; * some execution abstraction to manage CPU allocation — typically [[thread (computer science)|threads]] or [[scheduler activation]]s; and * [[inter-process communication]] — required to invoke servers running in their own address spaces. This minimal design was pioneered by [[Brinch Hansen]]'s [[RC 4000 Multiprogramming System|Nucleus]] and the hypervisor of IBM's [[VM (operating system)|VM]]. It has since been formalised in Liedtke's ''minimality principle'': <blockquote>A concept is tolerated inside the microkernel only if moving it outside the kernel, i.e., 