a calculation is impossible. This can often save a lot of time. For example, this type of proof was used to prove that the area of a circle is not a simple ratio of its diameter, and that [[angle trisection|no angle can be trisected]] with compass and straightedge—both puzzles that fascinated the ancients. ===Recursive optimization=== [[Dynamic programming]] is an approach to [[optimization (mathematics)|optimization]] which restates a multiperiod or multistep optimization problem in recursive form. The key result in dynamic programming is the [[Bellman equation]], which writes the value of the optimization problem at an earlier time (or earlier step) in terms of its value at a later time (or later step). ==Recursion in computer science== [[File:Web Page.png|thumb|alt=|This screenshot of a web page includes the screen shot itself.]] {{Main|Recursion (computer science)}} A common method of simplification is to divide a problem into subproblems of the same type. As a [[computer programming]] technique, this is called [[divide and conquer algorithm|divide and conquer]] and is key to the design of many important algorithms. Divide and conquer serves as a top-down approach to problem solving, where problems are solved by solving smaller and smaller instances. A contrary approach is [[dynamic programming]]. This approach serves as a bottom-up approach, where problems are solved by solving larger and larger instances, until the desired size is reached. A classic example of recursion is the definition of the [[factorial]] function, given here in C code: <source lang="c"> unsigned int factorial(unsigned int n) { if (n <= 1) return 1; else return n * factorial(n-1); } </source> The function calls itself recursively on a smaller version of the input (n - 1) and multiplies the result of the recursive call by n, until reaching the [[base case]], analogously to the mathematical definition of factorial. Recursion in computer programming is exemplified when a function is defined in terms of simpler, often smaller versions of itself. The solution to the problem is then devised by combining the solutions obtained from the simpler versions of the problem. One example application of recursion is in [[parser]]s for programming languages. The great advantage of recursion is that an infinite set of possible sentences, designs or other data can be defined, parsed or produced by a finite computer program. [[Recurrence relation]]s are equations to define one or more sequences recursively. Some specific kinds of recurrence relation can be "solved" to obtain a non-recursive definition. Use of recursion in an algorithm has both advantages and disadvantages. The main advantage is usually simplicity. The main disadvantage is often that the algorithm may require large amounts of memory if the depth of the recursion is very large. ==The recursion theorem== In [[set theory]], this is a theorem guaranteeing that recursively defined functions exist. Given a set ''X'', an element ''a'' of ''X'' and a function <math>f: X \rightarrow X</math>, the theorem states that there is a unique function <math>F: \mathbb{N} \rightarrow X</math> (where <math>\mathbb{N}</math> denotes the set of natural numbers including zero) such that :<math>F(0) = a</math> :<math>F(n + 1) = f(F(n))</math> for any natural number ''n''. ===Proof of uniqueness=== Take two functions <math>F: \mathbb{N} \rightarrow X</math> and <math>G: \mathbb{N} \rightarrow X</math> such that: :<math>F(0) = a</math> :<math>G(0) = a</math> :<math>F(n + 1) = f(F(n))</math> :<math>G(n + 1) = f(G(n))</math> where ''a'' is an element of ''X''. It can be proved by [[mathematical induction]] that <math>F(n) = G(n)</math> for all natural numbers ''n'': :'''Base Case''': <math>F(0) = a = G(0)</math> so the equality holds for <math>n = 0</math>. :'''Inductive Step''': Suppose <math>F(k) = G(k)</math> for some <math>k \in \mathbb{N}</math>. Then <math>F(k+1) = f(F(k)) = f(G(k)) = G(k+1).</math> ::Hence F(k) = G(k) implies F(k+1) = G(k+1). By Induction, <math>F(n) = G(n)</math> for all <math>n \in \mathbb{N}</math>. ===Examples=== Some common recurrence relations are: {{col-begin}} {{col-break}} *[[Factorial]]: <math>n! = n (n - 1)! = n (n - 1)\cdots 1</math> *[[Fibonacci numbers]]: <math>f (n) = f (n - 1) + f (n - 2)</math> *[[Catalan number]]s: <math>C_0=1</math>, <math>C_{n+1} = (4n+2)C_n/(n+2)</math> *Computing compound [[interest]] *The [[Tower of Hanoi]] *[[Ackermann function]] *[[Population growth rate]] *Odds of a [[birthday problem|shared birthday]] among a group of people. {{col-end}} ==See also== <div style="-moz-column-count:4; column-count:4;"> * [[Church-Turing thesis]] * [[Continuous predicate]] * [[Corecursion]] * [[Course-of-values recursion]] * [[Fixed point combinator]] * [[Infinite loop]] * [[Infinitism]] * [[Iterated function]] * [[Mise en abyme]] * [[Primitive recursive function]] <!-- Your radical ideas about adding [[Recursion]] have already occurred to other people and been removed by people with no sense of humor.. See the subsection "Recursive humor" for details. --> * [[Reentrant (subroutine)]] * [[Self-reference]] * [[Strange loop]] * [[Tail recursion]] * [[Turtles all the way down]] * [[Viable System Model]] </div> ==References== <references/> ==External links== {{Wiktionary|recursion|recursivity}} *{{cite book | author=Johnsonbaugh, Richard | title=Discrete Mathematics | publisher=Prentice Hall | year=2004 | isbn=0-13-117686-2 }} *{{cite book | author=Hofstadter, Douglas | title=Gödel, Escher, Bach: an Eternal Golden Braid | publisher=Basic Books | year=1999 | isbn=0-465-02656-7 }} *{{cite book | author=Shoenfield, Joseph R. | title=Recursion Theory | publisher=A K Peters Ltd | year=2000 | isbn=1-56881-149-7 }} *{{cite book | author=Causey, Robert L. | title=Logic, Sets, and Recursion | publisher=Jones & Bartlett | year=2001 | isbn=0-7637-1695-2 }} *{{cite book | author=Cori, Rene; Lascar, Daniel; Pelletier, Donald H. | title=Recursion Theory, Godel's Theorems, Set Theory, Model Theory | publisher=Oxford University Press | year=2001 | isbn=0-19-850050-5 }} *{{cite book | author=Barwise, Jon; Moss, Lawrence S. | title=Vicious Circles | publisher=Stanford Univ Center for the Study of Language and Information | year=1996 | isbn=0-19-850050-5 }} - offers a treatment of [[corecursion]]. *{{cite book | author=Rosen, Kenneth H. | title=Discrete Mathematics and Its Applications | publisher=McGraw-Hill College | year=2002 | isbn=0-07-293033-0 }} *{{cite book | author=Cormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, Clifford Stein | title=Introduction to Algorithms | publisher=Mit Pr | year=2001 | isbn=0-262-03293-7 }} *{{cite book | author = Kernighan, B.; Ritchie, D. | title=The C programming Language | publisher=Prentice Hall | year = 1988 | isbn = 0-13-110362-8 }} *{{cite book | author=Stokey, Nancy,; Robert Lucas; Edward Prescott | title=Recursive Methods in Economic Dynamics 