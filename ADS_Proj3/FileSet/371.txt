[[algorithm]] for finding all (or some) solutions to some computational problem, that incrementally builds candidates to the solutions, and abandons each partial candidate ''c'' ("backtracks") as soon as it determines that ''c'' cannot possibly be completed to a valid solution.<ref>{{cite book | title = [[The Art of Computer Programming]] | author = Donald E. Knuth | publisher = Addison-Wesley | year = 1968}}</ref><ref> {{cite book | title = Introduction to Algorithms | author = Thomas H. Cormen | coauthors = Charles E. Leiserson, Ronald R. Rivest, Cliff Stein | publisher = McGraw-Hill | year = 1990}}</ref><ref>{{cite web | url=http://www.cse.ohio-state.edu/~gurari/course/cis680/cis680Ch19.html#QQ1-51-128 Backtracking algorithms | title=CIS 680: DATA STRUCTURES: Chapter 19: Backtracking Algorithms | year=1999 | author=Gurari, Eitan}}</ref> The classic textbook example of the use of backtracking is the [[eight queens puzzle]], that asks for all arrangements of eight queens on a standard [[chess|chessboard]] so that no queen attacks any other. In the common backtracking approach, the partial candidates are arrangements of ''k'' queens in the first ''k'' rows of the board, all in different rows and columns. Any partial solution that contains two mutually attacking queens can be abandoned, since it cannot possibly be completed to a valid solution. Backtracking can be applied only for problems which admit the concept of a "partial candidate solution" and a relatively quick test of whether it can possibly be completed to a valid solution. It is useless, for example, for locating a given value in an unordered table. When it is applicable, however, backtracking is often much faster than [[brute force search|brute force enumeration]] of all complete candidates, since it can eliminate a large number of candidates with a single test. Backtracking is an important tool for solving [[constraint satisfaction problem]]s, such as [[crosswords]], [[verbal arithmetic]], [[Algorithmics_of_sudoku|Sudoku]], and many other puzzles. It is often the most convenient (if not the most efficient) technique for [[parsing]], for the [[knapsack problem]] and other [[combinatorial optimization]] problems. It is also the basis of the so-called [[logic programming]] languages such as [[Icon programming language|Icon]], [[Planner programming language|Planner]] and [[Prolog]]. Backtracking is also utilized in the (diff) difference engine for the [[MediaWiki]] software. Backtracking depends on user-given "[[procedural parameter|black box procedure]]s" that define the problem to be solved, the nature of the partial candidates, and how they are extended into complete candidates. It is therefore a [[metaheuristic]] rather than a specific algorithm --- although, unlike many other meta-heuristics, it is guaranteed to find all solutions to a finite problem in a bounded amount of time. The term "backtrack" was coined by American mathematician [[Derrick Henry Lehmer|D. H. Lehmer]] in the 1950s.<ref>{{cite book | title= Handbook of Constraint Programming | url= http://books.google.com/books?id=Kjap9ZWcKOoC | series= [http://www.elsevier.com/wps/find/bookdescription.cws_home/BS_FAI/description#description Foundations of Artificial Intelligence] | last= Rossi | first= Francesca | coauthors= Beek, Peter Van; Walsh, Toby | date= August 2006 | page= 14 | chapter= Constraint Satisfaction: An Emerging Paradigm | chapterurl= http://books.google.com/books?id=Kjap9ZWcKOoC&pg=PA14 | publisher= [[Elsevier]] | location= [[Amsterdam]] | quote= Bitner and Reingold credit Lehmer with first using the term 'backtrack' in the 1950s. | isbn= 978-0-444-52726-4 | accessdate= 2008-12-30 }}</ref> The pioneer string-processing language [[SNOBOL]] (1962) may have been the first to provide a built-in general backtracking facility. == Description of the method == The backtracking algorithm enumerates a set of ''partial candidates'' that, in principle, could be ''completed'' in various ways to give all the possible solutions to the given problem. The completion is done incrementally, by a sequence of ''candidate extension steps.'' Conceptually, the partial candidates are the nodes of a [[tree structure]], the ''potential search tree.'' Each partial candidate is the parent of the candidates that differ from it by a single extension step; the leaves of the tree are the partial candidates that cannot be extended any further. The backtracking algorithm traverses this search tree [[recursion (computer science)|recursively]], from the root down, in [[depth-first search|depth-first order]]. At each node ''c'', the algorithm checks whether ''c'' can be completed to a valid solution. If it cannot, the whole sub-tree rooted at ''c'' is skipped (''pruned''). Otherwise, the algorithm (1) checks whether ''c'' itself is a valid solution, and if so reports it to the user; and (2) recursively enumerates all sub-trees of ''c''. The two tests and the children of each node are defined by user-given procedures. Therefore, the ''actual search tree'' that is traversed by the algorithm is only a part of the potential tree. The total cost of the algorithm is basically the number of nodes of the actual tree times the cost of obtaining and processing each node. This fact should be considered when choosing the potential search tree and implementing the pruning test. === Pseudocode === In order to apply backtracking to a specific class of problems, one must provide the data ''P'' for the particular instance of the problem that is to be solved, and six [[procedural parameter]]s, ''root'', ''reject'', ''accept'', ''first'', ''next'', and ''output''. These procedures should take the instance data ''P'' as a parameter and should do the following: # '''''root("P")'': return the partial candidate at the root of the search tree. # ''reject''(''P'',''c''): return ''true'' only if the partial candidate ''c'' is not worth completing. # ''accept''(''P'',''c''): return ''true'' if ''c'' is a solution of ''P'', and ''false'' otherwise. # ''first''(''P'',''c''): generate the first extension of candidate ''c''. # ''next''(''P'',''s''): generate the next alternative extension of a candidate, after the extension ''s''. # ''output''(''P'',''c''): use the solution ''c'' of ''P'', as appropriate to the application. The backtracking algorithm reduces then to the call ''bt''(''root''(''P'')), where ''bt'' is the following recursive procedure: '''procedure''' ''bt''(''c'') '''if''' ''reject''(''P'',''c'') '''then''' '''return''' '''if''' ''accept''(''P'',''c'') '''then''' ''output''(''P'',''c'') ''s'' ← ''first''(''P'',''c'') '''while''' ''s'' ≠ Λ '''do''' ''bt''(''s'') ''s'' ← ''next''(''P'',''s'') ===Usage considerations=== The ''reject'' procedure should be a [[boolean-valued function]] that returns ''true'' only if it is certain that no possible extension of ''c'' is a valid solution for ''P''. If the procedure cannot reach a definite conclusion, it should return ''false''. An incorrect ''true'' result may cause the ''bt'' procedure to miss some valid solutions. The procedure may 