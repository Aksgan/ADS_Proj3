also in '''RLP'''.<ref>Borodin, A., Cook, S. A., Dymond, P. W., Ruzzo, W. L., and Tompa, M. 1989. [http://portal.acm.org/citation.cfm?id=68485# Two applications of inductive counting for complementation problems]. SIAM J. Comput. 18, 3 (Jun. 1989), 559-578. </ref> This placed USTCON, and '''SL''', in co-'''RLP''' and in the intersection of '''RLP''' and co-'''RLP''', which is [[ZPLP]], the class of problems which have log-space, expected polynomial-time, no-error randomized algorithms. In 1992, Nisan, Szemerédi, and Wigderson finally found a new deterministic algorithm to solve USTCON using only log<sup>1.5</sup> ''n'' space.<ref>Noam Nisan, Endre Szemerédi, Avi Wigderson. Undirected connectivity in O(log1.5 n) space. In Proc. 33rd IEEE Symposium on Foundations of Computer Science, 1992, pp.24-29.</ref> This was improved slightly, but there would be no more significant gains until Reingold. In 1995, Nisan and Ta-Shma showed the surprising result that '''SL''' is closed under complement, which at the time was believed by many to be false; that is, '''SL''' = co-'''SL'''.<ref>Nisan, N. and Ta-Shma, A. 1995. [http://portal.acm.org/citation.cfm?id=225101# Symmetric logspace is closed under complement]. In Proceedings of the Twenty-Seventh Annual ACM Symposium on theory of Computing (Las Vegas, Nevada, United States, May 29 - June 01, 1995). STOC '95. ACM, New York, NY, 140-146.</ref> Equivalently, if a problem can be solved by reducing it to a graph and asking if two vertices are in the ''same'' component, it can also be solved by reducing it to another graph and asking if two vertices are in ''different'' components. However, Reingold's paper would later make this result redundant. One of the most important corollaries of '''SL''' = co-'''SL''' is that '''L'''<sup>'''SL'''</sup> = '''SL'''; that is, a deterministic, log-space machine with an [[oracle machine|oracle]] for '''SL''' can solve problems in '''SL''' (trivially) but cannot solve any other problems. This means it does not matter whether we use Turing reducibility or many-one reducibility to show a problem is in '''SL'''; they are equivalent. A breakthrough October 2004 paper by [[Omer Reingold]] showed that USTCON is in fact in [[L (complexity)|L]].<ref>Reingold, O. 2008. [http://portal.acm.org/citation.cfm?id=1391291# Undirected connectivity in log-space]. J. ACM 55, 4 (Sep. 2008), 1-24.</ref> Since USTCON is '''SL'''-complete, this implies that '''SL''' = '''L''', essentially eliminating the usefulness of consideration of '''SL''' as a separate class. A few weeks later, graduate student Vladimir Trifonov showed that USTCON could be solved deterministically using O(log ''n'' log log ''n'') space—a weaker result—using different techniques.<ref>Trifonov, V. 2005. [http://portal.acm.org/citation.cfm?id=1060684# An O(log n log log n) space algorithm for undirected st-connectivity]. In Proceedings of the Thirty-Seventh Annual ACM Symposium on theory of Computing (Baltimore, MD, USA, May 22 - 24, 2005). STOC '05. ACM, New York, NY, 626-633.</ref> ==Consequences of L = SL == The collapse of '''L''' and '''SL''' has a number of significant consequences. Most obviously, all '''SL'''-complete problems are now in '''L''', and can be gainfully employed in the design of deterministic log-space and polylogarithmic-space algorithms. In particular, we have a new set of tools to use in [[log-space reduction]]s. It is also now known that a problem is in '''L''' if and only if it is log-space reducible to USTCON. ==Footnotes== <references/> ==References== *<div id="Papadimitriou">[[Christos H. Papadimitriou|C. Papadimitriou]]. ''Computational Complexity''. Addison-Wesley, 1994. ISBN 0-201-53082-1.</div> *<div id="Sipser">[[Michael Sipser]]. ''Introduction to the Theory of Computation''. PWS Publishing Co., Boston 1997 ISBN 0-534-94728-X.</div> {{ComplexityClasses}} [[Category:Complexity classes]] [[es:SL (clase de complejidad)]] [[ja:SL (計算複雑性理論)]]</text> </page> <page> <id>32869</id> <title>SM-1420</title> <text>{{Unreferenced|date=November 2006}} The '''SM-1420''' (CM-1420) was a [[PDP-11|PDP-11/34+]] clone, and the successor to [[SM-4]] in [[Soviet Bloc]] countries. It was produced in the [[Soviet Union]], [[Bulgaria]], and [[East Germany]]. The standard package included 256[[kilobyte|KB]] [[Metal Oxide Semiconductor|MOS]] memory, two [[RK-06]] disks, 2xTU-10, CM-6315 [[barrel printer|barrel]] or DZM-180 [[dot-matrix printer]], Mera [[VT52]] compatible or VTA-2000-15 (BTA 2000-15) [[VT100]] compatible [[computer terminal|terminal]]s. Some 1420s were produced by the UK company [[Quest Automation]] Plc. ==See also== *[[SM EVM]] *[[List of Soviet computer systems]] ==References== {{reflist}} [[Category:Minicomputers]] [[Category:Soviet computer systems]] [[Category:PDP-11]] {{mini-compu-stub}}</text> </page> <page> <id>32872</id> <title>SMA*</title> <text>{{Technical|date=November 2009}} {{graph search algorithm}} The '''Simplified Memory-Bounded Algorithm (SMA*)''' is a variant of [[A* search]] which is memory-bounded<ref>Russell, S. 1992. [http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.105.7839&rep=rep1&type=pdf Efficient memory-bounded search methods]. In Proceedings of the 10th European Conference on Artificial intelligence (Vienna, Austria). B. Neumann, Ed. John Wiley & Sons, New York, NY, 1-5.</ref> Pseudo code: <source lang="pascal"> function SMA-star(problem): path queue: set of nodes, ordered by f-cost; begin queue.insert(problem.root-node); while True do begin if queue.empty() then return failure; node := queue.begin(); // min-f-cost-node if problem.is-goal(node) then return success; s := next-successor(node) f(s) := max(f(node), g(s) + h(s)) if no more successors then update node-s f-cost and those of its ancestors if needed if node.successors ⊆ queue then queue.remove(node); if memory is full then begin badNode := queue.popEnd(); // removes node with highest f-cost out of queue for parent in badNode.parents do begin parent.successors.remove(badNode); if needed then queue.insert(parent); end; end; queue.insert(s); end; end; </source> ==References== {{Reflist}} {{DEFAULTSORT:Sma*}} [[Category:Graph algorithms]] [[Category:Routing algorithms]] [[Category:Search algorithms]] [[Category:Game artificial intelligence]] [[Category:Articles with example pseudocode]] [[de:Simplified Memory-Bounded Algorithm]] [[pl:Algorytm SMA*]]</text> </page> <page> <id>32889</id> <title>SMX (computer language)</title> <text>{{Notability|date=June 2009}} {{Citations missing|date=May 2009}} '''SMX''' (from '''Server Macro Expansion''') is a [[Macro (computer science)|macro]] processing language designed to embed macros in web pages. Originally shipped with the popular Internet Factory's Commerce Builder software, it has been ported as an [[Apache HTTP Server|Apache]] module. ==Overview== SMX was designed to embed macros in HTML/XML pages. It originally shipped with the Internet Factory's Commerce Builder software, a relatively popular web server in the early days of the Internet, due to the ease with which a developer could produce an [[e-commerce]] website. Rather than re-implement websites in more popular languages, like [[Perl]] or [[PHP]], a small group of SMX fans decided to re-implement the language itself as an [[Apache HTTP Server|Apache]] module. A good example of a macro is '''%counter()'''. This embeds a simple incremental counter on an HTML page. To include the results of a [[SQL]] query on a page, you can simply type '''%sql(<dsn>,<query>,%col(1)<br />)''' in the middle of an [[XHTML]] page. Owing to the high-level nature of the language, SMX can greatly reduce the programming effort required to build dynamic or database-driven web 