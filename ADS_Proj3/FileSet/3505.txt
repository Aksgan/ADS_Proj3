following which it is now <math>P'</math>. This ''reduction relation'' <math>\rightarrow</math> is defined as the least relation closed under a set of reduction rules. The main reduction rule which captures the ability of processes to communicate through channels is the following: * <math>\overline{x}\langle z \rangle.P | x(y).Q \rightarrow P | Q[z/y] </math> : where <math>Q[z/y]</math> denotes the process <math>Q</math> in which the free name <math>z</math> has been ''substituted'' for the free occurrences of <math>y</math>. If a free occurrence of <math>y</math> occurs in a location where <math>z</math> would not be free, alpha-conversion may be required. There are three additional rules: * If <math>P \rightarrow Q</math> then also <math>P|R \rightarrow Q|R</math>. : This rule says that parallel composition does not inhibit computation. * If <math>P \rightarrow Q</math>, then also <math>(\nu x)P \rightarrow (\nu x)Q</math>. : This rule ensures that computation can proceed underneath a restriction. * If <math>P \equiv P'</math> and <math>P' \rightarrow Q'</math> where <math>Q' \equiv Q</math>, then also <math>P \rightarrow Q</math>. The latter rule states that processes that are structurally congruent have the same reductions. === The example revisited === Consider again the process :<math> (\nu x)(\overline{x} \langle z \rangle.0 | x(y). \overline{y}\langle x \rangle . x(y).0 ) | z(v) . \overline{v}\langle v \rangle. 0 </math> Applying the definition of the reduction semantics, we get the reduction :<math> (\nu x)(\overline{x} \langle z \rangle.0 | x(y). \overline{y}\langle x \rangle . x(y).0 ) | z(v) . \overline{v}\langle v \rangle. 0 \rightarrow (\nu x)(0| \overline{z}\langle x \rangle . x(y). 0 ) | z(v). \overline{v}\langle v \rangle .0 </math> Note how, applying the reduction substitution axiom, occurrences of <math>y</math> are now labeled as <math>z</math>. Next, we get the reduction :<math> (\nu x)(0| \overline{z}\langle x \rangle . x(y). 0 ) | z(v). \overline{v}\langle v \rangle .0 \rightarrow (\nu x)(0| x(y). 0 | \overline{x}\langle x \rangle .0) </math> Note that since the local name <math>x</math> has been output, the scope of <math>x</math> is extended to cover the third component as well. This was captured using the scope extension axiom. === Labelled semantics === Alternatively, one may give the pi-calculus a labelled transition semantics (as has been done with the [[Calculus of Communicating Systems]]). Transitions in this semantics are of the form: :<math>P\,\xrightarrow\alpha\,P'</math> This [[State transition system|notation]] signifies that <math>P</math> after the action <math>\alpha</math> becomes <math>P'</math>. <math>\alpha</math> can be an ''input action'' <math>a(x)</math>, an ''output action'' ''<math>\overline{a}\langle x \rangle</math>'', or a tau-action <math>\tau</math> corresponding to an internal communication. A standard result about the labelled semantics is that it agrees with the reduction semantics in the sense that <math>P \rightarrow P'</math> if and only if <math>P\,\xrightarrow\tau\,P'</math> for some action <math>\tau</math>. == Extensions and variants == The syntax given above is a minimal one. However, the syntax may be modified in various ways. A ''nondeterministic choice operator'' <math>P + Q</math> can be added to the syntax. A test for ''name equality'' <math>[x=y]P</math> can be added to the syntax. This ''match operator'' can proceed as <math>P</math> if and only if <math>x</math> and <math>y</math> are the same name. Similarly, one may add a ''mismatch operator'' for '''name inequality'''. Practical programs which can pass names (URLs or pointers) often use such functionality: for directly modelling such functionality inside the calculus, this and related extensions are often useful. The ''asynchronous <math>\pi</math>-calculus'' allows only outputs with no continuation, i.e. output atoms of the form <math>\overline{x}\langle y \rangle</math>, yielding a smaller calculus. However, any process in the original calculus can be represented by the smaller asynchronous <math>\pi</math>-calculus using an extra channel to simulate explicit acknowledgement from the receiving process. Since a continuation-free output can model a message-in-transit, this fragment shows that the original <math>\pi</math>-calculus, which is intuitively based on synchronous communication, has an expressive asynchronous communication model inside its syntax. The ''polyadic <math>\pi</math>-calculus'' allows communicating more than one name in a single action: <math>\overline{x}<z_1,...z_n>.P</math> ''(polyadic output)'' and <math>x(z_1,...z_n)</math> ''(polyadic input)''. This polyadic extension, which is useful especially when studying types for name passing processes, can be encoded in the monadic calculus by passing the name of a private channel through which the multiple arguments are then passed in sequence. The encoding is defined recursively by the clauses <math>\overline{x}\langle y_1,\cdots,y_n\rangle.P</math> is encoded as <math>(\nu w) \overline{x}\langle w \rangle.\overline{w}\langle y_1\rangle.\cdots.\overline{w}\langle y_n\rangle.[P]</math> <math>x(y_1,\cdots,y_n).P</math> is encoded as <math>x(w).w(y_1).\cdots.w(y_n).[P]</math> All other process constructs are left unchanged by the encoding. In the above, <math>[P]</math> denotes the encoding of all prefixes in the continuation <math>P</math> in the same way. The full power of replication <math>!P</math> is not needed. Often, one only considers ''replicated input'' <math>! x(y).P</math>, whose structural congruence axiom is <math>! x(y).P \equiv x(y).P | !x(y).P</math>. Replicated input process such as <math> !x(y).P</math> can be understood as servers, waiting on channel <math>x</math> to be invoked by clients. Invocation of a server spawns a new copy of the process <math>P[a/y]</math>, where a is the name passed by the client to the server, during the latter's invocation. A ''higher order <math>\pi</math>-calculus'' can be defined where not only names but processes are sent through channels. The key reduction rule for the higher order case is <math>\overline{x}\langle R \rangle.P | x(Y).Q \rightarrow P | Q[R/Y] </math> Here, <math>Y</math> denotes a ''process variable'' which can be instantiated by a process term. Sangiorgi established the surprising result that the ability to pass processes does not increase the expressivity of the <math>\pi</math>-calculus: passing a process ''P'' can be simulated by just passing a name that points to ''P'' instead. == Properties == === Turing completeness === The <math>\pi</math>-calculus is a [[Turing complete|universal model of computation]]. This was first observed by Milner in his paper "Functions as Processes" (Mathematical Structures in Computer Science, Vol. 2, pp. 119–141, 1992), in which he presents two encodings of the [[lambda-calculus]] in the <math>\pi</math>-calculus. One encoding simulates the eager (call-by-value) evaluation strategy, the other encoding simulates the normal-order (call-by-name) strategy. In both of these, the crucial insight is the modeling of environment bindings – for instance, "<math>x</math> is bound to term <math>M</math>" – as replicating agents that respond to requests for their bindings by sending back a connection to the term <math>M</math>. The features 