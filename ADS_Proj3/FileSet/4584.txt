[[Category:Zoological nomenclature]] [[Category:Botanical nomenclature]] [[bg:Тип (таксономия)]] [[ca:Tipus nomenclatural]] [[cs:Nomenklatorický typ v botanice]] [[de:Typus (Nomenklatur)]] [[es:Tipo nomenclatural]] [[eo:Tipo (biologio)]] [[fr:Type nomenclatural (botanique)]] [[it:Tipo nomenclaturale]] [[hu:Típuspéldány]] [[nl:Type (biologie)]] [[ja:タイプ (分類学)]] [[no:Type (biologi)]] [[pl:Typ nomenklatoryczny]] [[pt:Tipo nomenclatural]] [[ru:Типовые экземпляры]] [[sv:Typ (biologi)]] [[th:ต้นแบบ (ชีววิทยา)]]</text> </page> <page> <id>38491</id> <title>Type 1 product</title> <text>In [[cryptography]], a '''Type 1 product''' is a device or system certified by the [[National Security Agency]] (NSA) for use in [[cryptography|cryptographically]] securing [[classified information|classified]] [[United States|U.S.]] Government [[information]]. Type 1 certification is a rigorous process that includes testing and formal analysis of (among other things) cryptographic security, functional security, [[tamper resistance]], emissions security ([[EMSEC]]/[[TEMPEST]]), and security of the product manufacturing and distribution process. For a historically-oriented list of NSA encryption products (most of them Type 1), see ''[[NSA encryption systems]]''. For algorithms that NSA has participated in the development of, see ''[[NSA cryptography]]''. Types 1 through 4 are defined in the [[National Information Assurance Glossary]] (CNSSI No. 4009) which defines Type 1, Type 2, Type 3, and Type 4 '''products''' and '''keys'''. A Type 1 product is defined as: : ''Classified or controlled cryptographic item endorsed by the NSA for securing classified and sensitive U.S. Government information, when appropriately keyed. The term refers only to products, and not to information, key, services, or controls. Type 1 products contain approved NSA algorithms. They are available to U.S. Government users, their contractors, and federally sponsored non-U.S. Government activities subject to export restrictions in accordance with International Traffic in Arms Regulation.'' ==External links== <!-- * [http://www.cnss.gov/Assets/pdf/cnssi_4009.pdf National Information Assurance (IA) Glossary] (PDF)--> * [http://webcache.googleusercontent.com/search?hl=en&source=hp&q=cache%3Ahttp%3A%2F%2Fwww.cnss.gov%2FAssets%2Fpdf%2Fcnssi_4009.pdf&aq=f&aqi=&aql=&oq=&gs_rfai= National Information Assurance Glossary on Google Cache] (HTML) ==See also== * [[Type 2 product]] * [[Type 3 product]] * [[Type 4 product]] * [[NSA Suite B Cryptography]] * [[NSA Suite A Cryptography]] [[Category:Cryptographic algorithms]] [[Category:Type 1 encryption algorithms| ]] [[Category:National Security Agency encryption devices]] {{crypto-stub}}</text> </page> <page> <id>38493</id> <title>Type 3 product</title> <text>{{Unreferenced|date=February 2008}} In [[National Security Agency|NSA]] terminology, a '''Type 3 product''' is a device for use with [[Classified information in the United States|Sensitive, But Unclassified (SBU) information]] on non-national security systems. Approved algorithms include [[Data Encryption Standard|DES]], [[Triple DES]] and [[Advanced Encryption Standard|AES]] (although AES might also be usable in NSA-certified [[Type 1 encryption|Type 1]] products). ==See also== * [[Type 1 product]] * [[Type 2 product]] * [[Type 4 product]] * [[NSA Suite B Cryptography]] * [[NSA Suite A Cryptography]] {{crypto-stub}} [[Category:National Security Agency encryption devices]] [[Category:Cryptographic algorithms]]</text> </page> <page> <id>38498</id> <title>Type Tunnel pattern</title> <text>{{notability|date=March 2010}} {{refimprove|date=March 2010}} In [[computer programming]], a '''Type Tunnel [[Design_pattern_(computer_science)|pattern]]''' is where a group of physically-unrelated types may be tunneled through an extensible adaptation layer and presented in unified form to an underlying layer for manipulation as a whole. It consists of the following: # a generic, extensible [[Interface (computer science)|interface]] layer, used in client code, which can interact with heterogeneous types, and # a tunnel mechanism, which translates between the heterogeneous types expressed in the client code into the [[Type system|type]] understood by # a concrete [[API]] layer, which manipulates a single concrete type. Tunnel mechanism include [[Shim (computing)|Shims]] and conversion [[Constructor (object-oriented_programming)|constructors]]. ==Examples== ===C++=== Example that uses Shims as tunnel mechanism. <source lang="cpp"> // 1. Interface layer template <typename S> void foo( S s ) { bar( to_cstr_ptr( s ) ); } // 2. Tunnel mechanism: Shim char const * to_cstr_ptr( int ) { ... } char const * to_cstr_ptr( char const * ) { ... } char const * to_cstr_ptr( std::string ) { ... } // 3. Concrete API layer void bar( char const * ) { ... } // Using it void main() { foo( 123 ); foo( "a C-string" ); foo( std::string( "a std::string" ) ); } </source> ==References== {{refbegin|1}} * <cite id=refDrDobbsWeb>{{Citation | last = Wilson | first = Matthew | title = Generalized String Manipulation: Access Shims and Type Tunneling | url = http://www.drdobbs.com/cpp/184401689 | journal = C/C++ User's Journal | volume = 21 | issue = 8 | date = August 2003 }} * <cite id=refMonolithWeb>{{Cite web | last = Wilson | first = Matthew | title = Breaking Up The Monolith: Advanced C++ Design without Compromise | url=http://synesis.com.au/publishing/monolith/glossary.html#type-tunnel | accessdate = 11 March 2010 }} ==See also== *[[Design pattern (computer science)|Design patterns]] *[[Duck typing]] [[Category:Software design patterns]] [[Category:Generic programming]] [[Category:Articles with example C++ code]] {{Software-eng-stub}}</text> </page> <page> <id>38502</id> <title>Type conversion</title> <text>{{for|type conversion in aviation|type conversion (aviation)}} {{No footnotes|date=November 2010}} In [[computer science]], '''type conversion''', '''typecasting''', and '''coercion''' refers to different ways of, implicitly or explicitly, changing an entity of one [[data type]] into another. This is done to take advantage of certain features of type hierarchies or type representations. One example would be small integers, which can be stored in a compact format and converted to a larger representation when used in arithmetic computations. In [[object-oriented]] programming, type conversion allows programs to treat objects of one type as one of their ancestor types to simplify interacting with them. Each [[programming language]] has its own rules on how types can be converted. In general, both objects and fundamental data types can be converted. In most languages, the word '''coercion''' is used to denote an ''implicit'' conversion, either during compilation or during [[run time]]. A typical example would be an expression mixing integer and floating point numbers (like 5 + 0.1), where the integers are normally converted into the latter. Explicit type conversions can either be performed via built-in routines (or a special syntax) or via separately defined conversion routines such as an [[Polymorphism (computer science)|overloaded]] [[Object (computer science)|object]] [[Constructor (computer science)|constructor]]. In most [[Algol (programming language)|Algol-based]] languages with [[nested function]] definitions, such as Pascal, Delphi, Modula 2 and Ada, '''conversion''' and '''casting''' are distinctly different concepts. In these languages, '''conversion''' refers to either implicitly or explicitly changing a value from one data type to another, e.g. a 16-bit integer to a 32-bit integer. The storage requirements may change as a result of the conversion. A loss of precision or truncation may also occur. The word '''cast''', on the other hand, refers to explicitly changing the ''interpretation'' of the 