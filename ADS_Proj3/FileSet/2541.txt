changed, and thus lead to more stable routing. Later work at [[BBN Technologies]] showed how to use the link-state technique in a hierarchical system, i.e. one in which the network was divided into areas, so that each switching node does not need a map of the entire network, only the area(s) in which it is included. The technique was later adapted for use in the contemporary link-state routing protocols [[IS-IS]] and [[OSPF]]. Cisco literature refers to [[EIGRP]] as a "hybrid" protocol, despite the fact it distributes routing tables instead of topology maps. However, it does synchronize routing tables at start up as OSPF does, and sends specific updates only when topology changes occur. In 2004 [[Radia Perlman]] proposed using link-state routing for [[Layer 2]] frame forwarding with devices called Routing Bridges or [[RBridges]]. The [[Internet Engineering Task Force]] is standardizing the [[TRILL (Computer Networking)]] protocol to accomplish this. More recently, this hierarchical technique was applied to [[wireless mesh network]]s using the [[optimized link state routing protocol]]. Where a connection can have varying quality, the quality of a connection can be used to select better connections. This is used in some [[Ad hoc routing protocol list|routing protocols]] that use radio frequency transmission. ==Distributing maps== This description covers only the simplest configuration; i.e. one with no areas, so that all nodes do have a map of the entire network. The hierarchical case is somewhat more complex; see the various protocol specifications. As previously mentioned, the first main stage in the link-state algorithm is to give a map of the network to every node. This is done with several simple subsidiary steps. ===Determining the neighbors of each node=== First, each node needs to determine what other ports it is connected to, over fully-working links; it does this using a simple ''reachability protocol'' which it runs separately with each of its directly-connected neighbors. ===Distributing the information for the map=== Next, each node periodically and in case of connectivity changes makes up a short message, the ''link-state advertisement'', which: * Identifies the node which is producing it. * Identifies all the other nodes to which it is directly connected. * Includes a ''sequence number'', which increases every time the source node makes up a new version of the message. This message is then ''flooded'' throughout the network. As a necessary precursor, each node in the network remembers, for every other node in the network, the sequence number of the last link-state message which it received from that node. With that in hand, the method used is simple. Starting with the node which originally produced the message, it sends a copy to all of its neighbors. When a link-state advertisement is received at a node, the node looks up the sequence number it has stored for the source of that link-state message. If this message is newer (i.e. has a higher sequence number), it is saved, and a copy is sent in turn to each of that node's neighbors. This procedure rapidly gets a copy of the latest version of each node's link-state advertisement to every node in the network. Networks running link state algorithms can also be segmented into hierarchies which limit the scope of route changes. These features mean that link state algorithms scale better to larger networks. ===Creating the map=== Finally, with the complete set of link-state advertisements (one from each node in the network) in hand, it is obviously easy to produce the graph for the map of the network. The algorithm simply iterates over the collection of link-state advertisements; for each one, it makes links on the map of the network, from the node which sent that message, to all the nodes which that message indicates are neighbors of the sending node. No link is considered to have been correctly reported unless the two ends agree; i.e. if one node reports that it is connected to another, but the other node does not report that it is connected to the first, there is a problem, and the link is not included on the map. ===Notes about this stage=== The link-state message giving information about the neighbors is recomputed, and then flooded throughout the network, whenever there is a change in the connectivity between the node and its neighbors, e.g. when a link fails. Any such change will be detected by the reachability protocol which each node runs with its neighbors. ==Calculating the routing table== As initially mentioned, the second main stage in the link-state algorithm is to produce routing tables, by inspecting the maps. This is again done with several steps. ===Calculating the shortest paths=== Each node independently runs an [[algorithm]] over the map to determine the [[Shortest path problem|shortest path]] from itself to every other node in the network; generally some variant of [[Dijkstra's algorithm]] is used. This is based around a link cost across each path which includes available bandwidth among other things. Basically, a node maintains two data structures: a [[Tree data structure|tree]] containing nodes which are "done", and a list of ''candidates''. The algorithm starts with both structures empty; it then adds to the first one the node itself. The algorithm then repetitively: * Adds to the second (candidate) list all nodes which are connected to the node just added to the tree (excepting of course any nodes which are already in either the tree or the candidate list). * Of the nodes in the candidate list, moves to the tree (attaching it to the appropriate neighbor node already there) the one which is the closest to any of the nodes already in the tree. * Repeat as long as there aren't any nodes left in the candidate list. (When there are none, all the nodes in the network will have been added to the tree.) This procedure ends with the tree containing all the nodes in the network, with the node on which the algorithm is running as the ''root'' of the tree. The shortest path from that node to any other node is indicated by 