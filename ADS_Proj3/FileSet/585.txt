which is yet another example of beneficial syntactic sugar. It works by marking a block of code as a [[critical section]] by mutual exclusion of access to a provided object. Like the <code>using</code> statement, it works by the compiler generating a <code>try</code> ... </code>finally</code> block in its place. <source lang="csharp"> private static StreamWriter _writer; public void ConcurrentMethod() { lock (_writer) { _writer.WriteLine("Line 1."); _writer.WriteLine("Followed by line 2."); } } </source> ===Attributes=== Attributes are entities of data that is stored as metadata in the compiled assembly. An attribute can be added to types and members like properties and methods. Attributes [http://www.knowdotnet.com/articles/attributes.html can be used for] better maintenance of preprocessor directives. <source lang="csharp"> [CompilerGenerated] public class $AnonymousType$120 { [CompilerGenerated] public string Name { get; set; } } </source> The .NET Framework comes with predefined attributes that can be used. Some of them serve an important role at runtime while some are just for syntactic decoration in code like <code>CompilerGenerated</code>. It does only mark that it is a compiler-generated element. Programmer-defined attributes can also be created. An attribute is essentially a class which inherits from the <code>System.Attribute</code> class. By convention, attribute classes end with "Attribute" in their name. This will not be required when using it. <source lang="csharp"> public class EdibleAttribute : Attribute { public Edible() : base() { } public Edible(bool isNotPoisonous) { this.IsPoisonous = !isNotPoisonous; } public bool IsPoisonous { get; set; } } </source> Showing the attribute in use using the optional constructor parameters. <source lang="csharp"> [Edible(true)] public class Peach : Fruit { //Members if any } </source> ===Preprocessor=== C# features "preprocessor directives"<ref>{{cite web |url=http://msdn.microsoft.com/en-us/library/ed8yd1ha.aspx |title=C# Preprocessor Directives |work=C# Language Reference |publisher=[[Microsoft]] |accessdate=June 18, 2009 }}</ref> (though it does not have an actual preprocessor) based on the [[C preprocessor]] that allow programmers to define [[symbol]]s, but not macros. Conditionals such as <code>#if</code>, <code>#endif</code>, and <code>#else</code> are also provided. Directives such as <code>#region</code> give hints to editors for [[code folding]]. ===Code comments=== C# utilizes a double forward [[slash (punctuation)|slash]] (<code>//</code>) to indicate the rest of the line is a comment. <source lang="csharp"> public class Foo { // a comment public static void Bar(int firstParam) {} //Also a comment } </source> Multi-line comments can be indicated by a starting forward slash/asterisk (<code>/*</code>) and ending asterisk/forward slash (<code>*/</code>). <source lang="csharp"> public class Foo { /* A Multi-Line comment */ public static void Bar(int firstParam) {} } </source> ===XML documentation system=== C#'s documentation system is similar to Java's [[Javadoc]], but based on [[Extensible Markup Language|XML]]. Two methods of documentation are currently supported by the C# [[compiler]]. Single-line documentation comments, such as those commonly found in [[Microsoft Visual Studio|Visual Studio]] generated code, are indicated on a line beginning with <code>///<code>. <source lang="csharp"> public class Foo { /// <summary>A summary of the method.</summary> /// <param name="firstParam">A description of the parameter.</param> /// <remarks>Remarks about the method.</remarks> public static void Bar(int firstParam) {} } </source> Multi-line documentation comments, while defined in the version 1.0 language specification, were not supported until the [[.NET Framework|.NET]] 1.1 release.<ref>{{cite web |url=http://blogs.msdn.com/ansonh/archive/2006/09/11/750056.aspx |title=C# XML documentation comments FAQ |first=Anson |last=Horton |date=2006-09-11 |accessdate=2007-12-11 }}</ref> These comments are designated by a starting forward slash/asterisk/asterisk (<code>/**</code>) and ending asterisk/forward slash (<code>*/<code>).<ref name="Delimiters for Documentation Tags">{{cite web |url=http://msdn.microsoft.com/en-us/library/5fz4y783(VS.71).aspx |title=Delimiters for Documentation Tags |date=January 1, 1970 GMT |work=C# Programmer's Reference |publisher=[[Microsoft]] |accessdate=June 18, 2009 }}</ref> <source lang="csharp"> public class Foo { /** <summary>A summary of the method.</summary> * <param name="firstParam">A description of the parameter.</param> * <remarks>Remarks about the method.</remarks> */ public static void Bar(int firstParam) {} } </source> Note there are some stringent criteria regarding white space and XML documentation when using the forward slash/asterisk/asterisk (<code>/**</code>) technique. This code block: <source lang="csharp"> /** * <summary> * A summary of the method.</summary>*/ </source> produces a different XML comment than this code block:<ref name="Delimiters for Documentation Tags"/> <source lang="csharp"> /** * <summary> A summary of the method.</summary>*/ </source> Syntax for documentation comments and their [[XML]] markup is defined in a non-normative annex of the [[Ecma International|ECMA]] C# standard. The same standard also defines rules for processing of such comments, and their transformation to a plain [[XML]] document with precise rules for mapping of [[Common Language Infrastructure]] (CLI) identifiers to their related documentation elements. This allows any C# [[integrated development environment]] (IDE) or other development tool to find documentation for any symbol in the code in a certain well-defined way. ==Future features== This section presents features of the planned 5th version of the C# specification. ===Asynchronous programming syntax=== C# will have native language support for asynchrony. As .NET Framework 4 there is a task library that makes it easier to write parallel and multi-threaded applications through tasks. This has made it easier writing concurrent code but it has yet been proven a bit hard from the perspective of the ordinary programmer. The next version of C# will introduce a new syntax that makes it easier writing asynchronous. Introducing ''asynchronous methods'' and the <code>await</code> keyword. <source lang="csharp"> public async Task<int> SumPageSizesAsync(IList<Uri> uris) { int total = 0; foreach (var uri in uris) { statusText.Text = string.Format("Found {0} bytes ...", total); var data = await new WebClient().DownloadDataTaskAsync(uri); total += data.Length; } statusText.Text = string.Format("Found {0} bytes total", total); return total; } </source> ==Dialects== ===Spec#=== {{Main|Spec Sharp}} Spec# is a dialect of C# that is developed in parallel with the standard implementation from Microsoft. It extends C# with specification language features and is a possible future feature to the C# language. It also adds syntax for the code contracts API that was introduced in [[.NET Framework#.NET Framework 4.0|.NET Framework 4.0]]. Spec# is being developed by [[Microsoft Research]]. This sample shows two of the basic structures that are used when adding contracts to your code. <source lang="csharp"> static void Main(string![] args) requires args.Length > 0 { foreach(string arg in args) { Console.WriteLine(arg); } } </source> * '''!''' is used to make a reference type non-nullable, e.g. you cannot set the value to null. This in contrast of nullable types which allow value types to be set as ''null''. * '''requires''' indicates a condition that must be 