assume that ''reject''(''P'',''t'') returned ''false'' for every ancestor ''t'' of ''c'' in the search tree. On the other hand, the efficiency of the backtracking algorithm depends on ''reject'' returning ''true'' for candidates that are as close to the root as possible. If ''reject'' always returns ''false'', the algorithm will still find all solutions, but it will be equivalent to a brute-force search. The ''accept'' procedure should return ''true'' if ''c'' is a complete and valid solution for the problem instance ''P'', and ''false'' otherwise. It may assume that the partial candidate ''c'' and all its ancestors in the tree have passed the ''reject'' test. Note that the general pseudo-code above does not assume that the valid solutions are always leaves of the potential search tree. In other words, it admits the possibility that a valid solution for ''P'' can be further extended to yield other valid solutions. The ''first'' and ''next'' procedures are used by the backtracking algorithm to enumerate the children of a node ''c'' of the tree, that is, the candidates that differ from ''c'' by a single extension step. The call ''first''(''P'',''c'') should yield the first child of ''c'', in some order; and the call ''next''(''P'',''s'') should return the next sibling of node ''s'', in that order. Both functions should return a distinctive "null" candidate, denoted here by 'Λ', if the requested child does not exist. Together, the ''root'', ''first'', and ''next'' functions define the set of partial candidates and the potential search tree. They should be chosen so that every solution of ''P'' occurs somewhere in the tree, and no partial candidate occurs more than once. Moreover, they should admit an efficient and effective ''reject'' predicate. ===Early stopping variants=== The pseudo-code above will call ''output'' for every candidate that is a solution to the given instance ''P''. The algorithm is easily modified to stop after finding the first solution, or a specified number of solutions; or after testing a specified number of partial candidates, or after spending a given amount of [[central processing unit|CPU]] time. == Examples == ===Constraint satisfaction=== The general [[constraint satisfaction problem]] consists in finding a list of integers ''x'' = (''x''[1],''x''[2], …, ''x''[''n'']), each in some range {1, 2, …, ''m''}, that satisfies some arbitrary constraint (boolean function) ''F''. For this class of problems, the instance data ''P'' would be the integers ''m'' and ''n'', and the predicate ''F''. In a typical backtracking solution to this problem, one could define a partial candidate as a list of integers ''c'' = (''c''[1],''c''[2], … ''c''[k]), for any ''k'' between 0 and ''n'', that are to be assigned to the first ''k'' variables ''x''[1],''x''[2], …, ''x''[''k'']). The root candidate would then be the empty list (). The ''first'' and ''next'' procedures would then be '''function''' ''first''(''P'',''c'') ''k'' ← '''length'''(''c'') '''if''' ''k'' = ''n'' '''then''' '''return''' Λ '''else''' '''return''' (''c''[1], ''c''[2], …, ''c''[''k''], 1) '''function''' ''next''(''P'',''s'') ''k'' ← '''length'''(''s'') '''if''' ''s''[''k''] = ''m'' '''then''' '''return''' Λ '''else''' '''return''' (''s''[1], ''s''[2], …, ''s''[''k''-1], 1 + ''s''[''k'']) Here "'''length'''(''c'')" is the number of elements in the list ''c''. The call ''reject''(''P'',''c'') should return ''true'' if the constraint ''F'' cannot be satisfied by any list of ''n'' integers that begins with the ''k'' elements of ''c''. For backtracking to be effective, there must be a way to detect this situation, at least for some candidates ''c'', without enumerating all those ''m''<sup>''n''-''k''</sup> ''n''-tuples. For example, if ''F'' is the [[conjunction]] of several boolean predicates, ''F'' = ''F''[1] <math>\wedge</math> ''F''[2] <math>\wedge</math> <math>\cdots</math> <math>\wedge</math> ''F''[p], and each ''F''[i] depends only on a small subset of the variables ''x''[1], …, ''x''[''n''], then the ''reject'' procedure could simply check the terms ''F''[i] that depend only on variables ''x''[1], …, ''x''[''k''], and return ''true''if any of those terms returns ''false''. In fact, ''reject'' needs only check those terms that do depend on ''x''[''k''], since the terms that depend only on ''x''[1], …, ''x''[''k''-1] will have been tested further up in the search tree. Assuming that ''reject'' is implemented as above, then ''accept''(''P'',''c'') needs only check whether ''c'' is complete, that is, whether it has ''n'' elements. It is generally better to order the list of variables so that it begins with the most critical ones (i.e. the ones with fewest value options, or which have a greater impact on subsequent choices). One could also allow the ''next'' function to choose which variable should be assigned when extending a partial candidate, based on the values of the variables already assigned by it. Further improvements can be obtained by the technique of [[constraint propagation]]. In addition to retaining minimal recovery values used in backing up, backtracking implementations commonly keep a [[variable trail]], to record value change history. An efficient implementation will avoid creating a variable trail entry between two successive changes when there is no choice point, as the backtracking will erase all of the changes as a single operation. An alternative to the variable trail is to keep a [[timestamp]] of when the last change was made to the variable. The timestamp is compared to the timestamp of a choice point. If the choice point has an associated time later than that of the variable, it is unnecessary to revert the variable when the choice point is backtracked, as it was changed before the choice point occurred. ==See also== *[[Ariadne's thread (logic)]] *[[Backjumping]] *[[Recursion (computer science)]] ==Notes== {{Reflist}} ==References== {{Refbegin}} * {{cite book | author = Gilles Brassard, Paul Bratley | title = Fundamentals of Algorithmics | publisher = Prentice-Hall | date = 1995 }} {{Refend}} ==External links== *[http://www.hbmeyer.de/backtrack/backtren.htm HBmeyer.de], Interactive animation of a backtracking algorithm *[http://github.com/kapild/Permutations Sample Java Code], Sample code for Back tracking of 8 Queens problem. [[Category:Operations research]] [[Category:Search algorithms]] [[Category:Pattern matching]] [[cs:Backtracking]] [[de:Backtracking]] [[es:Vuelta Atrás]] [[fa:پس‌گرد (الگوریتم)]] [[fr:Retour sur trace]] [[ko:퇴각검색]] [[it:Backtracking]] [[he:גישוש נסוג]] [[nl:Backtracking]] [[ja:バックトラッキング]] [[pl:Backtracking]] [[pt:Backtracking]] [[ro:Backtracking recursiv]] [[ru:Поиск с возвратом]] [[uk:Пошук з вертанням]] [[vi:Quay lui (khoa học máy tính)]] [[zh:回溯法]]</text> </page> <page> <id>3241</id> <title>Backup</title> <text>{{Otherusesof}} In [[Information Technology]], a '''backup''' or the process of '''backing up''' refers to making 