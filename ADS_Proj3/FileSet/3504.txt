a <code>goto c</code> operation. ** ''output prefixing'' <math>\overline{c} \langle y \rangle.P</math> describes that the name <math>y</math> is emitted on channel <math>c</math> before proceeding as {{nowrap|<math>P</math>.}} Typically, this models either sending a message on the network or a <code>goto c</code> operation. * ''replication'', written <math>!\,P</math>, which may be seen as a process which can always create a new copy of {{nowrap|<math>P</math>.}} Typically, this models either a network service or a label <code>c</code> waiting for any number of <code>goto c</code> operations. * ''creation of a new name'', written <math>\left(\nu x\right)P</math>, which may be seen as a process allocating a new constant <math>x</math> within {{nowrap|<math>P</math>.}} The constants of {{nowrap|<math>\pi</math>-calculus}} are defined by their names only and are always communication channels. * the nil process, written ''0'', is a process whose execution is complete and has stopped. Although the minimalism of the <math>\pi</math>-calculus prevents us from writing programs in the normal sense, it is easy to extend the calculus. In particular, it is easy to define both control structures such as recursion, loops and sequential composition and datatypes such as first-order functions, [[truth value]]s, lists and integers. Moreover, extensions of the {{nowrap|<math>\pi</math>-calculus}} have been proposed which take into account distribution or public-key cryptography. The ''applied {{nowrap|<math>\pi</math>-calculus}}'' due to Abadi and Fournet [http://citeseer.ist.psu.edu/rd/0%2C573109%2C1%2C0.25%2CDownload/http%3AqSqqSqwww.cse.ucsc.eduqSq%7EabadiqSqPapersqSqisss02.pdf] put these various extensions on a formal footing by extending the {{nowrap|<math>\pi</math>-calculus}} with arbitrary datatypes. === A small example === Below is a tiny example of a process which consists of three parallel components. The channel name <math>x</math> is only known by the first two components. :<math> \begin{align} & \begin{align} (\nu x) \; & ( \; \overline{x} \langle z \rangle . \; 0 \\ & | \; x(y). \; \overline{y}\langle x \rangle . \; x(y). \; 0 \; ) \end{align} \\ | \; & z(v) . \; \overline{v}\langle v \rangle . 0 \end{align} </math> The first two components are able to communicate on the channel <math>x</math>, and the name <math>y</math> becomes bound to <math>z</math>. The next step in the process is therefore :<math> \begin{align} & \begin{align} ( \nu x) \; ( \; & 0 \\ | \; & \overline{z} \langle x \rangle . \; x(y). \; 0 \; ) \end{align} \\ | \; & z(v). \; \overline{v}\langle v \rangle . \; 0 \end{align} </math> Note that the remaining <math>y</math> is not affected because it is defined in an inner scope. The second and third parallel components can now communicate on the channel name <math>z</math>, and the name <math>v</math> becomes bound to <math>x</math>. The next step in the process is now :<math> \begin{align} (\nu x) ( \; & 0 \\ | \; & x(y). \; 0 \\ | \; & \overline{x}\langle x \rangle . \; 0 \; ) \end{align} </math> Note that since the local name <math>x</math> has been output, the scope of <math>x</math> is extended to cover the third component as well. Finally, the channel <math>x</math> can be used for sending the name <math>x</math>. == Formal definition == === Syntax === Let Χ be a set of objects called ''names''. The [[abstract syntax]] for the <math>\pi</math>-calculus is built from the following [[BNF grammar]] (where ''x'' and ''y'' are any names from Χ):<ref>[http://www.lfcs.inf.ed.ac.uk/reports/89/ECS-LFCS-89-85/ A Calculus of Mobile Processes part 1] page 10, by R. Milner, J. Parrow and D. Walker published in Information and Computation 100(1) pp.1-40, Sept 1992</ref> :<math> \begin{align} P ::= \, & x(y).P \,\,\, \\ |\,\,\, & \overline{x} \langle y \rangle.P \,\,\, \\ |\,\,\, & P|P \,\,\, \\ |\,\,\, & (\nu x)P \,\,\, \\ |\,\,\, & !P \,\,\, \\ |\,\,\, & 0 \end{align} </math> In the concrete syntax below, the prefixes bind more tightly than the parallel composition (|), and parentheses are used to disambiguate. Names are bound by the restriction and input prefix constructs. Formally, the sets of free and bound names of a process in <math>\pi</math>–calculus are defined inductively as follows. * The <math>0</math> process has no free names and no bound names. * The free names of <math>\overline{a} \langle x \rangle.P</math> are <math>a</math>, <math>x</math>, and the free names of <math>P</math>. The bound names of <math>\overline{a} \langle x \rangle.P</math> are the bound names of <math>P</math>. * The free names of <math>a(x).P</math> are <math>a</math> and the free names of <math>P</math>, except for <math>x</math>. The bound names of <math>a(x).P</math> are <math>x</math> and the bound names of <math>P</math>. * The free names of <math>P|Q</math> are those of <math>P</math> together with those of <math>Q</math>. The bound names of <math>P|Q</math> are those of <math>P</math> together with those of <math>Q</math>. * The free names of <math>(\nu x).P</math> are those of <math>P</math>, except for <math>x</math>. The bound names of <math>(\nu x).P</math> are <math>x</math> and the bound names of <math>P</math>. * The free names of <math>!P</math> are those of <math>P</math>. The bound names of <math>!P</math> are those of <math>P</math>. === Structural congruence === Central to both the reduction semantics and the labelled transition semantics is the notion of '''structural congruence'''. Two processes are structurally congruent, if they are identical up to structure. In particular, parallel composition is commutative and associative. More precisely, structural congruence is defined as the least equivalence relation preserved by the process constructs and satisfying: ''Alpha-conversion'': :* <math>P \equiv Q</math> if <math>Q</math> can be obtained from <math>P</math> by renaming one or more bound names in <math>P</math>. ''Axioms for parallel composition'': :* <math>P|Q \equiv Q|P</math> :* <math>(P|Q)|R \equiv P|(Q|R)</math> :*<math>P | 0 \equiv P</math> ''Axioms for restriction'': :* <math>(\nu x)(\nu y)P \equiv (\nu y)(\nu x)P</math> :* <math>(\nu x)0 \equiv 0</math> ''Axiom for replication'': :* <math>!P \equiv P|!P</math> ''Axiom relating restriction and parallel'': :* <math>(\nu x)(P | Q) \equiv (\nu x)P | Q </math> if <math>x</math> is not a free name of <math>Q</math>. This last axiom is known as the "scope extension" axiom. This axiom is central, since it describes how a bound name <math>x</math> may be extruded by an output action, causing the scope of <math>x</math> to be extended. In cases where <math>x</math> is a free name of <math>Q</math>, alpha-conversion may be used to allow extension to proceed. === Reduction semantics === We write <math>P \rightarrow P'</math> if <math>P</math> can perform a computation step, 