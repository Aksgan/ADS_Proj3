(OOP)== C# has direct support for [[object-oriented programming]]. ===Objects=== An object is created with the type as a template and is called an ''instance'' of that particular type. In C# objects are either references or values. No further syntactical distinction is made between those in code. ====<code>object</code> class==== All types, even value types in their boxed form, implicitly inherit from the <code>System.Object</code> class which is the ultimate base class of all objects. The class contains the most common methods shared by all objects. Some of these are <code>virtual</code> and can be overridden. Classes inherit <code>System.Object</code> either directly or indirectly through another base class. '''Members'''</br> Some of the members of the <code>Object</code> class: * <code>Equals</code> - Supports comparisons between objects. * <code>Finalize</code> - Performs cleanup operations before an object is automatically reclaimed. (Default destructor) * <code>GetHashCode</code> - Gets the number corresponding to the value of the object to support the use of a hash table. * <code>GetType</code> - Gets the Type of the current instance. * <code>ToString</code> - Creates a human-readable text string that describes an instance of the class. Usually it returns the name of the type. ===Classes=== Classes are fundamentals of an object-oriented language such as C#. They serve as a template for objects. They contain members that store and manipulate data in real-life-like way. '''See also''' * [[Class (computer science)]] * [[Structure (computer science)]] ====Differences between classes and structs==== Although classes and structures are similar in both the way they are declared and how they are used, there are some significant differences. Classes are reference types and structs value types. A structure is allocated on the stack when it is declared and the variable is bound to its address. It directly contains the value. Classes are different because the memory is allocated as objects on the heap. Variables are rather managed pointers on the stack which point to the objects. They are references. Structures require some more than classes. For example, you need to explicitly create a default constructor which takes no arguments to initialize the struct and its members. The compiler will create a default one for classes. All fields and properties of a struct must have been initialized before an instance is created. Structs do not have finalizers and cannot inherit from another class like classes do. However, they inherit from <code>System.ValueType</code>, that inherits from <code>System.Object</code>. Structs are more suitable for smaller constructs of data. This is a short summary of the differences: {|class="wikitable" |- ! !Default constructor !Finalizer !Member initialization !Inheritance |- !Classes |not required ''(auto generated)'' |yes |not required |yes (if base class is not <code>sealed</code>) |- !Structs |required ''(not auto generated)'' |no |required |not supported |- |} ====Declaration==== A class is declared like this: <source lang="csharp"> class Foo { //Member declarations } </source> =====Partial class===== :''This is a feature of [[C Sharp 2.0]].'' A partial class is a class declaration whose code is divided into separate files. The different parts of a partial class must be marked with keyword <code>partial</code>. <source lang="csharp"> //File1.cs partial class Foo { ... } //File2.cs partial class Foo { ... } </source> ====Initialization==== Before you can use the members of the class you need to initialize the variable with a reference to an object. To create it you call the appropriate constructor using the <code>new</code> keyword. It has the same name as the class. <source lang="csharp"> Foo foo = new Foo(); </source> For ''structs'' it is optional to explicitly call a constructor because the default one is called automatically. You just need to declare it and it gets initialized with standard values. =====Object initializers===== :''This is a feature of [[C Sharp 3.0]].'' Provides a more convenient way of initializing public fields and properties of an object. Constructor calls are optional when there is a default constructor. <source lang="csharp"> Person person = new Person { Name = "John Doe", Age = 39 }; //Equal to Person person = new Person(); person.Name = "John Doe"; person.Age = 39; </source> =====Collection initializers===== :''This is a feature of [[C Sharp 3.0]].'' Collection initializers give an array-like syntax for initializing collections. The compiler will simply generate calls to the Add-method. This works for classes that implement the interface <code>ICollection</code>. <source lang="csharp"> List<int> list = new List<int> {2, 5, 6, 6 }; //Equal to List<int> list = new List<int>(); list.Add(2); list.Add(5); list.Add(6); list.Add(6); </source> ====Accessing members==== Members of both instances and static classes are accessed with the <code>.</code> operator. '''Accessing an instance member'''</br> Instance members can be accessed through the name of a variable. <source lang="csharp"> string foo = "Hello"; string fooUpper = foo.ToUpper(); </source> '''Accessing a static class member'''</br> Static members are accessed by using the name of the class or any other type. <source lang="csharp"> int r = String.Compare(foo, fooUpper); </source> '''Accessing a member through a pointer'''</br> In ''unsafe code'', members of a value (struct type) referenced by a pointer are accessed with the <code>-></code> operator just like in C and C++. <source lang="csharp"> POINT p; p.X = 2; p.Y = 6; POINT* ptr = &p; ptr->Y = 4; </source> ====Modifiers==== Modifiers are keywords used to modify declarations of types and type members. Most notably there is a sub-group containing the access modifiers. * '''<code>abstract</code>''' - Specifies that a class only serves as a base class. It must be implemented in an inheriting class. * '''<code>const</code>''' - Specifies that a variable is a constant value that has to be initialized when it gets declared. * '''<code>event</code>''' - Declare an event. * '''<code>extern</code>''' - Specify that a method signature without a body uses a DLL-import. * '''<code>override</code>''' - Specify that a method or property declaration is an override of a virtual member or an implementation of a member of an abstract class. * '''<code>readonly</code>''' - Declare a field that can only be assigned values as part of the declaration or in a constructor in the same class. * '''<code>sealed</code>''' - Specifies that a class cannot be inherited. * '''<code>static</code>''' - Specifies that a member belongs to the class and not to a specific 