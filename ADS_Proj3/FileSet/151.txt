q cannot alias. #The variables p and q must alias. #It cannot be conclusively determined at compile time if p and q alias or not. If p and q cannot alias, then <code>i = p.foo + 3;</code> can be changed to <code>i = 4</code>. If p and q must alias, then <code>i = p.foo + 3;</code> can be changed to <code>i = 5</code>. In both cases, we are able to perform optimizations from the alias knowledge. On the other hand, if it is not known if p and q alias or not, then no optimizations can be performed and the whole of the code must be executed to get the result. Two memory references are said to have a ''may-alias'' relation if their aliasing is unknown. ==Performing Alias Analysis== In alias analysis, we divide the program's memory into ''alias classes''. Alias classes are disjoint sets of locations that cannot alias to one another. For the discussion here, it is assumed that the optimizations done here occur on a low-level [[Intermediate language|intermediate representation]] of the program. This is to say that the program has been compiled into binary operations, jumps, moves between registers, moves from registers to memory, moves from memory to registers, branches, and function calls/returns. ===Type Based Alias Analysis=== If the language being compiled is [[type safe]], the compiler's type checker is correct, and the language lacks the ability to create pointers referencing local variables, (such as ML, Haskell, or Java) then some useful optimizations can be made. There are many cases where we know that two memory locations must be in different alias classes: #Two variables of different types cannot be in the same alias class since it is a property of strongly typed, memory reference-free (i.e. references to memory locations cannot be changed directly) languages that two variables of different types cannot share the same memory location simultaneously. #Allocations local to the current stack frame cannot be in the same alias class as any previous allocation from another stack frame. This is the case because new memory allocations must be disjoint from all other memory allocations. #Each record field of each record type has its own alias class, in general, because the typing discipline usually only allows for records of the same type to alias. Since all records of a type will be stored in an identical format in memory, a field can only alias to itself. #Similarly, each array of a given type has its own alias class. When performing alias analysis for code, every load and store to memory needs to be labeled with its class. We then have the useful property, given memory locations <math>A_i</math> and <math>B_j</math> with <math>i,j</math> alias classes, that if <math>i=j</math> then <math>A_i</math> may-alias <math>B_j</math>, and if <math>i \neq j</math> then the memory locations will not alias. ===Flow Based Alias Analysis=== Analysis based on flow, unlike type based analysis, can be applied to programs in a language with references or type-casting. Flow based analysis can be used in lieu of or to supplement type based analysis. In flow based analysis, new alias classes are created for each memory allocation, and for every global and local variable whose address has been used. References may point to more than one value over time and thus may be in more than one alias class. This means that each memory location has a set of alias classes instead of a single alias class. ==References== {{cite book |author=Appel, Andrew W. |title=Modern Compiler Implementation in ML |publisher=Cambridge University Press |location=Cambridge, UK |year=1998 |pages= |isbn=0 521 60764 7 |oclc= |doi=}} ==See also== * [[Escape analysis]] * [[Pointer analysis]] * [[Shape analysis (software)|Shape analysis]] ==External links== * [http://lenherr.name/~thomas/ma/ Alias Analysis Library] - A simple C library for implementing alias analysis and a Master's Thesis giving an introduction to the field. [[Category:Compiler theory]] [[Category:Static code analysis]] [[ja:エイリアス解析]]</text> </page> <page> <id>1481</id> <title>Alice and Bob</title> <text>The names '''Alice and Bob''' are commonly used [[placeholder name]]s for archetypal characters in fields such as [[cryptography]] and [[physics]]. The names are used for convenience; for example, "Alice sends a message to Bob encrypted with his public key" is easier to follow than "Party A sends a message to Party B encrypted by Party B's public key." Following the alphabet, the specific names have evolved into common parlance within these fields—helping technical topics to be explained in a more understandable fashion. In [[cryptography]] and [[computer security]], there are a number of widely used names for the participants in discussions and presentations about various [[protocol (cryptography)|protocols]]. The names are conventional, somewhat self-suggestive, sometimes humorous, and effectively act as [[metasyntactic variable]]s. In typical implementations of these protocols, it is understood that the actions attributed to characters such as Alice or Bob need not always be carried out by human parties directly, but also by a trusted automated agent (such as a computer program) on their behalf. Despite the advantage of Alice and Bob's distinct genders in reducing ambiguity, there has been little tendency to introduce inanimate parties so they could be referred by neuter pronouns. ==List of characters== [[File:Public key shared secret.svg|thumb|right|An example of an "Alice and Bob" analogy used in cryptography.]] [[File:Asymetric cryptography - step 2.svg|thumb|right|Alice and Bob diagram used to explain [[Cryptographic hash function|cryptographic hashing]].]] This list is drawn mostly from the book ''Applied Cryptography'' by [[Bruce Schneier]]. Alice and Bob are archetypes in cryptography; Eve is also common. Names further down the alphabet are less common. * '''Alice''' and '''Bob'''. Generally, Alice wants to send a message to Bob. These names were used by [[Ron Rivest]] in the 1978 ''Communications of the [[Association for Computing Machinery|ACM]]'' article presenting the [[RSA]] cryptosystem, and in ''A Method for Obtaining Digital Signatures and Public-Key Cryptosystems'' published April 4, 1977, revised September 1, 1977 as technical Memo LCS/TM82. Rivest denies that these names have any relation to the 1969 movie ''[[Bob & Carol & Ted & Alice]]'' as occasionally suggested by others.{{citation needed|date=October 2010}} * '''Carol''', '''Carlos''' or '''Charlie''', as a third participant in communications. * '''Chuck''', as a 