method of scanning a table due to the heavy amount of I/O reads and writes required from the disk which consists of multiple seeks as well as costly disk to memory transfers. Sequential scan takes place usually when, the [[Column (database)|column]] or group of columns of a table (the table may be on disk or may be an intermediate table created by the join of two or more tables) needed for the scan do not contain an index which can be used for the purpose. [[Category:Database theory]] {{database-stub}}</text> </page> <page> <id>14348</id> <title>Fumifugium</title> <text>'''''Fumifugium''', or, The inconveniencie of the aer and smoak of London dissipated together with some remedies humbly proposed by J.E. esq. to His Sacred Majestie, and to the Parliament now assembled'' is a pamphlet published in [[London]], 1661 (see [[1661 in literature]]), by [[John Evelyn]]. It is one of the earliest known works on [[air pollution]]. Evelyn was appointed to the newly formed [[Royal Society]], and both Society and pamphlet are celebrated in the 1663 "[[s:Ballad_of_Gresham_College|"Ballad of Gresham College]]". Stanza 23 (given here in modern English) describes how Evelyn <blockquote>[...] shows that 'tis the [[coal#Etymology and folklore|sea-coal]] smoke<br> That always London does environ, <br> Which does our lungs and spirits choke, <br> Our hanging spoil, and rust our iron. <br> Let none at ''Fumifuge'' be scoffing <br> Who heard at Church our Sunday's coughing. </blockquote> The pamphlet suggests that burning wood, particularly aromatic woods, will be less harmful to the lungs and recommends relocating some of London's more polluting industries outside the capital, in particular [[limekiln|lime-burning]] and [[brewing]]. ==References== * [http://www.archive.org/details/fumifugium00eveluoft Text of ''Fumifugium'']. Internet Archive. Retrieved 7 January 2010. * [http://www.gyford.com/archive/2009/04/28/www.geocities.com/Paris/LeftBank/1914/fumifug.html HTML text of ''Fumifugium'']. Retrieved 7 March 2010. * "[[s:Ballad_of_Gresham_College|Ballad of Gresham College]]". Original text. ==See also== * [[smog]] [[Category:scientific documents]] [[Category:Pamphlets]] [[Category:1661 works]] {{sci-hist-stub}}</text> </page> <page> <id>14354</id> <title>Function-level programming</title> <text>{{Programming paradigms}} In computer science, '''function-level''' programming refers to one of the two contrasting [[programming paradigm]]s identified by [[John Backus]] in his work on [[programs as mathematical objects]], the other being [[value-level programming]]. In his 1977 [[Turing award]] lecture, Backus set forth what he considered to be the need to switch to a different philosophy in programming language design:<ref>http://www.stanford.edu/class/cs242/readings/backus.pdf</ref> <blockquote>Programming languages appear to be in trouble. Each successive language incorporates, with a little cleaning up, all the features of its predecessors plus a few more. [...] Each new language claims new and fashionable features... but the plain fact is that few languages make programming sufficiently cheaper or more reliable to justify the cost of producing and learning to use them.</blockquote> He designed [[FP (programming language)|FP]] to be the first [[programming language]] to specifically support the function-level programming style. A ''function-level'' program is '''variable-free''' (cf. [[point-free programming|''point-free'' programming]]), since [[Variable (programming)|program variable]]s, which are essential in value-level definitions, are not needed in function-level ones. In the function-level style of programming, a program is built directly from programs that are given at the outset, by combining them with '''program-forming operations''' or '''functionals'''. Thus, in contrast with the value-level approach that applies the given programs to values to form a ''succession of values'' culminating in the desired result value, the function-level approach applies program-forming operations to the given programs to form a ''succession of programs'' culminating in the desired result program. As a result, the function-level approach to programming invites study of the ''space of programs under program-forming operations'', looking to derive useful algebraic properties of these program-forming operations. The function-level approach offers the possibility of making the set of programs a [[Programs as mathematical objects|mathematical space]] by emphasizing the algebraic properties of the program-forming operations over the ''space of programs''. Another potential advantage of the function-level view is the ability to use only [[strict function]]s and thereby have [[bottom-up semantics]], which are the simplest kind of all. Yet another is the existence of function level definitions that are not the ''lifted'' (that is, ''lifted'' from a lower value-level to a higher function-level) image of any existing value-level one: these (often terse) function-level definitions represent a more powerful style of programming not available at the value-level and, arguably, are often easier to understand and reason about. ==Contrast to functional programming== When Backus studied and publicized his function-level style of programming, almost thirty years ago, his message was mostly misunderstood, giving boost to the traditional [[functional programming]] style languages instead of his own [[FP (programming language)|FP]] and its successor [[FL programming language|FL]]. Backus calls functional programming '''applicative''' programming; his function-level programming is a particular, constrained ''type'' of [[applicative programming]]. A key distinction from functional languages is that Backus' language has the following hierarchy of types: * atoms * functions, which take atoms to atoms * [[Higher-order functions]] (which he calls "functional forms"), which take one or two functions to functions ...and the only way to generate new functions is to use one of the functional forms, which are fixed: you cannot build your own functional form (at least not within FP; you can within FFP ([[Formal FP]])). This restriction means that functions in FP are a [[Module (mathematics)|module]] (generated by the built-in functions) over the algebra of functional forms, and are thus algebraically tractable. For instance, the general question of equality of two functions is equivalent to the [[halting problem]], and is undecidable, but equality of two functions in FP is just equality in the algebra, and thus (Backus imagines) easier. Even today, many users of [[Lambda calculus|lambda style]] languages often misinterpret Backus' function-level approach as a restrictive variant of the lambda style, which is a ''de facto'' value-level style. In fact, Backus would not have disagreed with the 'restrictive' accusation: he argued that it was ''precisely'' due to such restrictions that a well-formed mathematical space could arise, in a manner analogous to the way [[structured programming]] limits programming to a ''restricted'' version of all the control-flow possibilities available in plain, unrestricted [[unstructured programming|unstructured programs]]. The value-free style of FP is closely related to the equational logic of a [[cartesian-closed category]]. ==Example languages== The canonical function-level programming language is [[FP 