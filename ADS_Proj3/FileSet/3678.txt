and Computability |origyear=1951 |format=hardcover |edition=1 |series=Undergraduate Texts in Computer Science |year=1997 |publisher=Springer-Verlag |location=New York |language=English |isbn=0-387-94907-0 |pages=368–370}}</ref> === Turing completeness === We can prove that a queue machine is equivalent to a Turing machine by showing that a queue machine can simulate a Turing machine and vice-versa. In the former case, one can see that the left-right movements along the Turing machine tape can be simulated by continuously pushing and popping from the queue, so that the whole of the tape is stored in the queue. The queue machine's alphabet only has to indicate with a new symbol those elements which are being read by the Turing machine so that it can properly transition its state. In the latter case of simulating a queue machine on a Turing machine, this is done more easily using a [[multi-tape Turing machine]], which is equivalent to a normal single-tape machine. Then one simply reads input on one tape and stores the queue in the second, with pushes and pops defined by simple transitions to the beginning and end symbols of the tape.<ref>{{cite web |url=http://www.cs.uiowa.edu/~rus/Courses/Theory/Notes/turing3.pdf |title=Variants of Turing Machines |accessdate=2007-11-06 |last=Rus |first=Teodor |date= |work=Lecture Notes Covering Theory of Computation |publisher=University of Iowa, Iowa City, IA, 52242-1419}}</ref> A formal proof of this is often an exercise in theoretical computer science courses. == Applications == Queue machines offer a simple model on which to base [[computer architectures]],<ref>{{cite journal |last=Feller |first=M. |coauthors=M.D. Ercegovac |year=1981 |title=Queue machines: An organization for parallel computation |journal=Lecture Notes in Computer Science |volume= 111|issue= |pages= 37|id= |url=http://www.springerlink.com/content/m8w6x22741k5u093/ |accessdate=2007-11-06 |doi=10.1007/BFb0105108}}</ref><ref>{{cite journal |last=Schmit |first=Herman |authorlink= |coauthors=Benjamin Levine, Benjamin Ylvisaker |year= 2002|month= |title=Queue Machines: Hardware Compilation in Hardware |journal=10th Annual IEEE Symposium on Field-Programmable Custom Computing Machines (FCCM'02) |volume= |issue= |pages=152 |id= |url=http://doi.ieeecomputersociety.org/10.1109/FPGA.2002.1106670 |accessdate=2007-11-06|doi=10.1109/FPGA.2002.1106670}}</ref> [[programming languages]], or [[algorithms]].<ref>{{cite web |url=http://algo.inria.fr/seminars/sem99-00/moore1.html |title=Queues, Stacks, and Transcendentality at the Transition to Chaos |accessdate=2007-11-06 |last=Moore |first=Christopher |coauthors= |date=1999-09-20 |work=Algorithms Project's Seminar |publisher=INRIA}}</ref><ref>{{cite web |url=http://www.latrobe.edu.au/philosophy/phimvt/misc/queue.html |title=A queue machine for evaluating expressions |accessdate=2007-11-06 |last=von Thum |first=Manfred |date=2007 |publisher=LaTrobe University}}</ref> == See also == * [[Computability]] * [[Turing machine equivalents]] * [[Deterministic finite-state machine]] * [[Pushdown automaton]] * [[Tag system]] * [http://pleasingfungus.com/ Manufactoria], a browser flash game tasking the player with implementation of various algorithms using a queue machine model. == References == {{reflist}} [[Category:Automata theory]] {{comp-sci-stub}}</text> </page> <page> <id>30918</id> <title>Quine (computing)</title> <text>{{examplefarm}}{{Citations missing|date=October 2010}}{{Unreferenced section|date=October 2010}} A '''quine''' is a [[computer program]] which produces a copy of its own [[source code]] as its only output. The standard terms for these programs in the [[computability theory]] and [[computer science]] literature are '''self-replicating programs''', '''self-reproducing programs''', and '''self-copying programs'''. A quine is a [[Fixed point (mathematics)|fixed point]] of an execution environment, when the execution environment is viewed as a function. Quines are possible in any programming language that has the ability to output any computable string, as a direct consequence of [[Kleene's recursion theorem]]. For amusement, programmers sometimes attempt to develop the shortest possible quine in any given [[programming language]]. The name "quine" is coined by [[Douglas Hofstadter]] in his popular science book [[Gödel, Escher, Bach: An Eternal Golden Braid]] in the honor of philosopher [[Willard Van Orman Quine]] (1908–2000), who made an extensive study of [[indirect self-reference]], and in particular for the following paradox-producing expression, known as [[Quine's paradox]]: <blockquote> "Yields falsehood when preceded by its quotation" yields falsehood when preceded by its quotation. </blockquote> The name has become popular between amateur enthusiasts and programming hobbyists although it is not adopted by computer scientists. A quine takes no input. Allowing input would permit the source code to be fed to the program via the keyboard, opening the source file of the program, and similar mechanisms. In some languages, an empty source file is a fixed point of the language, producing no output. Such an empty program, submitted as "the world's smallest self reproducing program", once won the "worst abuse of the rules" prize in the [[Obfuscated C]] contest.<ref>[http://www0.us.ioccc.org/1994/smr.hint IOCCC 1994 Worst Abuse of the Rules]</ref> ==History== The idea of self-reproducing programs first appeared in ''[[Paul Bratley|Bratley, Paul]] and Jean Millo. "Computer Recreations; Self-Reproducing Automata", Software -- Practice & Experience, Vol. 2 (1972). pp. 397-400.'' Bratley first became interested in self-reproducing programs after seeing the first known such program written in [[Atlas Autocode]] at Edinburgh in the 1960s by the [[University of Edinburgh]] lecturer and researcher [[Hamish Dewar]]. This program appears below: %BEGIN !THIS IS A SELF-REPRODUCING PROGRAM %ROUTINESPEC R R PRINT SYMBOL(39) R PRINT SYMBOL(39) NEWLINE %CAPTION %END~ %CAPTION %ENDOFPROGRAM~ %ROUTINE R %PRINTTEXT ' %BEGIN !THIS IS A SELF-REPRODUCING PROGRAM %ROUTINESPEC R R PRINT SYMBOL(39) R PRINT SYMBOL(39) NEWLINE %CAPTION %END~ %CAPTION %ENDOFPROGRAM~ %ROUTINE R %PRINTTEXT ' %END %ENDOFPROGRAM ==Examples== <!-- DO NOT ADD ANY MORE QUINE EXAMPLES! Please read the talk page. --> In general, the method used to create a quine in any programming language is to have, within the program, two pieces: (a) [[Source code|code]] used to do the actual printing and (b) [[data]] that represents the textual form of the code (e.g., <code>progdata</code> in the first C example below). The code functions by using the data to print the code (which makes sense since the data represents the textual form of the code), but it also uses the data, processed in a simple way (e.g., <code>quote()</code> below) to print the textual representation of the data itself. An example in colloquial English would be: "quoted and followed by itself is a quine." quoted and followed by itself is a quine. The following [[Haskell (programming language)|Haskell]] example neatly illustrates the point:<ref>{{cite web|url=http://spikeypillow.com/nc/item/31|title=12/09: Quines of the World Unite}}</ref> main=putStr(p++show(p))where p="main=putStr(p++show(p))where p=" You read the above source as follows: print out ('''putStr''') the program text ('''p''') accompanied by a quoted ('''show'''n) version of the same, where the program text is the same as has just been said. Depending on programming environment, there could exist many ways the code and the data can be organized together within the program (neither must be contiguous), but a common telltale sign of the data section is that it mirrors some part of the entire program. Here is 