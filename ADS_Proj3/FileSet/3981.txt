the new rules and vice versa, the modified rules may still be called LK. First of all, as mentioned above, the sequents can be viewed to consist of sets or [[multiset]]s. In this case, the rules for permuting and (when using sets) contracting formulae are obsolete. The rule of weakening will become admissible, when the axiom (I) is changed, such that any sequent of the form <math>\Gamma , A \vdash A , \Delta</math> can be concluded. This means that <math>A</math> proves <math>A</math> in any context. Any weakening that appears in a derivation can then be performed right at the start. This may be a convenient change when constructing proofs bottom-up. Independent of these one may also change the way in which contexts are split within the rules: In the cases (&and;R), (&or;L), and (&rarr;L) the left context is somehow split into &Gamma; and &Sigma; when going upwards. Since contraction allows for the duplication of these, one may assume that the full context is used in both branches of the derivation. By doing this, one assures that no important premises are lost in the wrong branch. Using weakening, the irrelevant parts of the context can be eliminated later. ===Substructural logics=== {{main|Substructural logic}} Alternatively, one may restrict or forbid the use of some of the structural rules. This yields a variety of [[substructural logic]] systems. They are generally weaker than LK (''i.e.'', they have fewer theorems), and thus not complete with respect to the standard semantics of first-order logic. However, they have other interesting properties that have led to applications in theoretical [[computer science]] and [[artificial intelligence]]. ===Intuitionistic sequent calculus: System LJ=== Surprisingly, some small changes in the rules of LK suffice to turn it into a proof system for [[intuitionistic logic]]. To this end, one has to restrict to sequents with exactly one formula on the right-hand side, and modify the rules to maintain this invariant. For example, (&or;L) is reformulated as follows (where C is an arbitrary formula): :<math> \cfrac{\Gamma, A \vdash C \qquad \Sigma, B \vdash C }{\Gamma, \Sigma, A \or B \vdash C} \quad ({\or}L) </math> The resulting system is called LJ. It is sound and complete with respect to intuitionistic logic and admits a similar cut-elimination proof. ==See also== * [[Resolution (logic)]] ==Notes== <references/> ==References== * {{cite book | first=Jean-Yves | last=Girard | authorlink=Jean-Yves Girard | coauthors=Paul Taylor, Yves Lafont | title=Proofs and Types | publisher=Cambridge University Press (Cambridge Tracts in Theoretical Computer Science, 7) | year=1990 | origyear=1989 | isbn=0-521-37181-3 | url= http://www.paultaylor.eu/stable/Proofs%2BTypes.html}} ==External links== * [http://scienceblogs.com/goodmath/2006/07/a_brief_diversion_sequent_calc.php A Brief Diversion: Sequent Calculus] [[Category:Proof theory]] [[Category:Logical calculi]] [[Category:Automated theorem proving]] [[de:Sequenzenkalkül]] [[eo:Sekvaĵa kalkulo]] [[fr:Calcul des séquents]] [[ja:シークエント計算]] [[pl:Sekwenty Gentzena]] [[uk:Числення секвенцій]] [[zh:相继式演算]]</text> </page> <page> <id>33950</id> <title>Sequential coupling</title> <text>In [[object-oriented programming]], '''sequential coupling''' refers to a [[class (computer science)|class]] that requires its [[method (computer science)|method]]s to be called in a particular sequence. This may be an [[anti-pattern]], depending on context. Methods whose name starts with Init, Begin, Start, etc. may indicate the existence of sequential coupling. Using a [[car_analogy|car as an analogy]], if the user steps on the gas without first starting the engine, the car does not crash, fail, or throw an exception - it simply fails to accelerate. Side Note: Exceptions are acceptable some of the time because programs (especially large ones) need the feedback to determine why an object is not performing the expected behavior when one of its methods is called. Object initialization is not always possible at construction and may need to be delayed to a later time. The programmer using a class may not be the same programmer who wrote it. [[Category:Anti-patterns]] {{soft-eng-stub}}</text> </page> <page> <id>33960</id> <title>Serenity Code Coverage</title> <text>{{New unreviewed article|source=ArticleWizard|date=February 2010}} {{ Infobox Software | name = Serenity | logo = | screenshot = [[Image:SerenityReportScreenShot.jpg|250px]] | caption = Serenity code coverage report in Hudson | collapsible = yes | developer = | latest_release_version = 0.2 | latest_release_date = {{release_date|2010|01|27}} | latest_preview_version = | latest_preview_date = | operating_system = [[Cross-platform]] | programming_language = [[Java (programming language)|Java]] | genre = [[code coverage]] | license = [[MIT license]] | website = http://www.ikokoon.com/ikokoon/ | AsOf = {{release_date|2010|01|17}} }} '''Serenity''' is a [[Java (programming language)|Java]] code coverage, complexity, dependency, abstractness and distance metrics library with a [[Hudson (software)|Hudson]] plugin for displaying reports. Serenity uses dynamic byte code manipulation to add coverage code to class files. Trend reports are generated and rendered in the GUI. Serenity supports Ant and Maven projects. == References == {{Empty section|date=July 2010}} ==External links== * [http://wiki.hudson-ci.org/display/HUDSON/Serenity+Plugin Serenity wiki] * [http://www.ikokoon.com/ikokoon iKokoon Site] * [http://hudson.dev.java.net/ Hudson homepage] <!--- Categories ---> [[Category:Compiling tools]] [[Category:Java development tools]] [[Category:Continuous integration]] [[Category:Software testing]] [[Category:Software metrics]] {{software-stub}}</text> </page> <page> <id>33966</id> <title>Sergey Brin</title> <text>{{Infobox person | name = Sergey Brin | image = Sergey Brin.JPG| image_size = | caption = | birth_name = Sergey Mikhaylovich Brin | birth_date = {{birth date and age|mf=yes|1973|8|21}} | birth_place = [[Moscow]], [[Soviet Union]] | residence = [[Los Altos Hills, California]] | nationality = [[United States|American]] <!--per [[nationality]]--> | ethnicity = | citizenship = [[United States]] <!--[[naturalized citizen]]--> | education = Univ. of Maryland (B.S., 1993)<br/> Stanford University (M.S., 1995) | alma_mater = [[University of Maryland, College Park|University of Maryland]] <br/> [[Stanford University]] | occupation = [[Computer scientist]], technology innovator, entrepreneur | known_for = Co-founder of [[Google]], Inc. | networth = {{gain}}[[United States dollar|US$]]15 [[1,000,000,000 (number)|billion]] (2010)<ref name="Profile page on Sergey Brin">{{cite web | title = Profile page on Sergey Brin | publisher = Forbes | url = http://www.forbes.com/profile/Sergey-Brin | accessdate = 2010-04-05}}</ref> | salary = [[United States dollar|USD]] free of wage (2008)<ref>2005 compensations from Google: $1 in salary, $1723 in bonus, $41,999 other annual compensation, $3 all other compensation. Source: [[United States Securities and Exchange Commission|SEC]]. [http://www.sec.gov/Archives/edgar/data/1288776/000119312506070406/ddef14a.htm Google form 14A]. Filed March 31, 2006.</ref><ref name="myDanwei">[http://www.mydanwei.com/detail.php?org_oid=49f9f04e17e64d2652dc06384adf3d83&type=org&tab=1 Google Executives Compensation]</ref> | spouse = [[Anne Wojcicki]]<ref name="Washington Post"/> | website = [http://www-db.stanford.edu/~sergey/ stanford.edu/~sergey] | footnotes = }} '''Sergey Mikhaylovich Brin''' ({{lang-ru|Серге́й Миха́йлович Брин}}) born August 21, 1973 is a Soviet-American [[computer scientist]], software developer and [[entrepreneur]] who, with [[Larry Page]], is best known as the 