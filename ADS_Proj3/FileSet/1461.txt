meet the specific needs of a 15 month, 50 person software development project at a large [[Singapore]] bank in 1997. Jeff De Luca delivered a set of [[Feature Driven Development#Activities|five processes]] that covered the development of an overall model and the listing, planning, design and building of features. The first process is heavily influenced by [[Peter Coad]]´s approach to object modeling. The second process incorporates Peter Coad's ideas of using a feature list to manage functional requirements and development tasks. The other processes and the blending of the processes into a cohesive whole is a result of Jeff De Luca's experience. Since its successful use on the Singapore project there have been several implementations of FDD. The description of FDD was first introduced to the world in Chapter 6 of the book ''Java Modeling in Color with UML''{{ref|Coad}} by Peter Coad, [[Eric Lefebvre]] and Jeff De Luca in 1999. In [[Stephen Palmer]] and [[Mac Felsing]]´s book ''A Practical Guide to Feature-Driven Development''{{ref|Palmer}} (published in 2002) a more general description of FDD, decoupled from java modeling in color, is given. The original and latest FDD processes can be found on [http://www.nebulon.com/ Jeff De Luca´s website] under the ´Article´ area. There is also a [http://www.featuredrivendevelopment.com/ Community website] available at which people can learn more about FDD, questions can be asked, and experiences and the processes themselves are discussed. == Overview == FDD is a model-driven short-iteration process that consists of five basic activities. For accurate state reporting and keeping track of the software development project, [[Feature Driven Development#Milestones|milestones]] that mark the progress made on each feature are defined. This section gives a high level overview of the activities. [[Image:Fdd process diagram.png|thumb|250px|Process model for FDD]] === Activities === FDD describes five basic [[Activity_(project_management)|activities]] that are within the software development process. In the figure on the right the [[Meta-Process Modeling|meta-process model]] for these activities is displayed. During the first three sequential activities an [[#OVERALL MODEL|overall model]] shape is established. The final two activities are [[iteration|iterated]] for each feature. For more detailed information about the individual sub-activities have a look at Table 2 (derived from the process description in the ´Article´ section of [http://www.nebulon.com/ Jeff De Luca´s website]). The [[concept]]s involved in these activities are explained in Table 3. ==== Develop Overall Model ==== The project starts with a high-level [[walkthrough]] of the scope of the system and its context. Next, detailed domain walkthroughs are held for each modeling area. In support of each domain, walkthrough models are then composed by [[#SMALL GROUP|small groups]] which are presented for [[peer review]] and discussion. One of the proposed models or a merge of them is selected which becomes the model for that particular domain area. Domain area models are merged into an overall model, the overall model shape being adjusted along the way. ==== Build Feature List ==== The knowledge that is gathered during the initial modeling is used to identify a list of features. This is done by functionally decomposing the domain into [[#SUBJECT AREA|subject areas]]. Subject areas each contain [[#BUSINESS ACTIVITY|business activities]], the steps within each business activity form the categorized feature list. Features in this respect are small pieces of client-valued functions expressed in the form <action> <result> <object>, for example: ´Calculate the total of a sale´ or ´Validate the password of a user´. Features should not take more than two weeks to complete, else they should be broken down into smaller pieces. ==== Plan By Feature ==== Now that the feature list is complete, the next step is to produce the development plan. Class ownership is done by ordering and assigning features (or feature sets) as [[Class (computer science)|classes]] to chief [[programmer]]s. ==== Design By Feature ==== A [[#DESIGN PACKAGE|design package]] is produced for each feature. A chief programmer selects a small group of features that are to be developed within two weeks. Together with the corresponding class owners, the chief programmer works out detailed [[sequence diagrams]] for each feature and refines the overall model. Next, the [[#CLASS AND METHOD PROLOGUE|class and method prologues]] are written and finally a [[Software inspection|design inspection]] is held. ==== Build By Feature ==== After a successful design inspection a per feature activity to produce a completed client-valued function (feature) is being produced. The class owners develop the actual code for their classes. After a [[unit test]] and a successful [[Code review|code inspection]], the completed feature is [[#BUILD PROMOTION|promoted to the main build]]. === Milestones === Since features are small, completing a feature is a relatively small task. For accurate state reporting and keeping track of the software development project it is however important to mark the progress made on each feature. FDD therefore defines six milestones per feature that are to be completed sequentially. The first three milestones are completed during the [[Feature Driven Development#Design By Feature|Design By Feature]] activity, the last three are completed during the [[Feature Driven Development#Build By Feature|Build By Feature]] activity. To help with tracking progress, a percentage complete is assigned to each milestone. In the table below the milestones (and their completion percentage) are shown. A feature that is still being coded is 44% complete (Domain Walkthrough 1%, Design 40% and Design Inspection 3% = 44%). {| class="wikitable" |+ Table 1: Milestones ! | Domain Walkthrough ! | Design ! | Design Inspection ! | Code ! | Code Inspection ! | Promote To Build |- | | 1% | | 40% | | 3% | | 45% | | 10% | | 1% |} == Best practices == Feature-Driven Development is built around a core set of industry-recognized [[best practices]], derived from [[software engineering]]. These practices are all driven from a client-valued feature perspective. It is the combination of these practices and techniques that makes FDD so compelling. The best practices that make up FDD are shortly described below. For each best practice a short description will be given. * '''Domain Object Modeling'''. Domain Object Modeling consists of exploring and explaining the domain of the problem to be solved. The resulting 