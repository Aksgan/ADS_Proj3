the program's data to be accessible from any part of the program. As programs grow in size, allowing any function to modify any piece of data means that bugs can have wide-reaching effects. By contrast, the object-oriented approach encourages the programmer to place data where it is not directly accessible by the rest of the program. Instead the data is accessed by calling specially written 'functions', commonly called [[method (computer science)|methods]], which are bundled in with the data and act as the intermediaries for retrieving or modifying that data. The programming construct that combines data with a set of methods for accessing and managing that data is called an object. An object-oriented program will usually contain different types of objects, each type corresponding to a particular kind of complex data to be managed or perhaps to a real-world object or concept such as a bank account, a hockey player, or a bulldozer. A program might well contain multiple copies of each type of object, one for each of the real-world objects the program is dealing with. For instance, there could be one bank account object for each real-world account at a particular bank. Each copy of the bank account object would be alike in the methods it offers for manipulating or reading its data, but the data inside each object would differ reflecting the different history of each account. Objects can be thought of as wrapping their data within a set of functions designed to ensure that the data is used appropriately, and to assist in that use. The object's methods will typically include checks and safeguards that are specific to the type of data the object contains. An object can also offer simple-to-use, standardized methods for performing particular operations on its data, while concealing the specifics of how those tasks are accomplished. In this way alterations can be made to the internal structure or methods of an object without requiring that the rest of the program be modified. This approach can also be used to offer standardized methods across different types of objects. As an example, several different types of objects might offer print methods. Each type of object might implement that print method in a different way, reflecting the different kinds of data each contains, but all the different print methods might be called in the same standardized manner from elsewhere in the program. These features become especially useful when more than one programmer is contributing code to a project or when the goal is to reuse code between projects. Object-oriented programming has roots that can be traced to the 1960s. As hardware and software became increasingly complex, manageability often became a concern<!--isn't this always going to be the case with any complex entity?-->. Researchers studied ways to maintain software quality and developed object-oriented programming in part to address common problems by strongly emphasizing discrete, reusable units of programming logic{{Citation needed|date=February 2010}}. The technology focuses on data rather than processes, with programs composed of self-sufficient modules ("classes"), each instance of which ("objects") contains all the information needed to manipulate its own data structure ("members"). This is in contrast to the existing [[modular programming]] that had been dominant for many years that focused on the ''function'' of a module, rather than specifically the data, but equally provided for [[code reuse]], and self-sufficient reusable units of programming logic, enabling [[collaboration]] through the use of linked modules ([[subroutine]]s). <!-- this obvious fact seems to have been deliberately overlooked or ignored in earlier editing and needed stating. It is clearly not the only method of achieving these goals implied in earlier article--> This more conventional approach, which still persists, tends to consider data and behavior separately. An object-oriented program may thus be viewed as a collection of interacting ''objects'', as opposed to the conventional model, in which a program is seen as a list of tasks ([[subroutine]]s) to perform. In OOP, each object is capable of receiving messages, processing data, and sending messages to other objects. Each object can be viewed as an independent "machine" with a distinct role or responsibility. The actions (or "[[Method (computer science)|methods]]") on these objects are closely associated with the object. For example, OOP [[data structures]] tend to 'carry their own operators around with them' (or at least "[[Inheritance (object-oriented programming)|inherit]]" them from a similar object or class). In the conventional model, the data and operations on the data don't have a tight, formal association. ==History== The terms "objects" and "oriented" in something like the modern sense of object-oriented programming seem to make their first appearance at [[MIT]] in the late 1950s and early 1960s. In the environment of the [[artificial intelligence]] group, as early as 1960, "object" could refer to identified items ([[LISP]] atoms) with properties (attributes);<ref>{{Cite journal | last = McCarthy | first = J. |editor-link = John McCarthy | last2 = Brayton | first2 = R. | author2-link = Robert Brayton (computer scientist) | last3 = Edwards | first3 = D. | author3-link = Daniel Edwards (programmer) | last4 = Fox | first4 = P. | author4-link = Phyllis Fox | last5 = Hodes | first5 = L. | author5-link = Louis Hodes | last6 = Luckham | first6 = D. | author6-link = David Luckham | last7 = Maling | first7 = K. | author7-link = Klim Maling (programmer) | last8 = Park | first8 = D. | author8-link = David Park (computer scientist) | last9 = Russell | first9 = S. | author9-link = Steve Russell | title = LISP I Programmers Manual | place = [[Boston]], [[Massachusetts]] | publisher = Artificial Intelligence Group, [[M.I.T. Computation Center]] and [[Research Laboratory of Electronics at MIT|Research Laboratory]] | year = 1960 | month= March | page = 88f | pages = | url = http://history.siam.org/sup/Fox_1960_LISP.pdf | quote = In the local M.I.T. patois, association lists [of atomic symbols] are also referred to as 'property lists', and atomic symbols are sometimes called 'objects'. | postscript = <!--None-->}}</ref><ref>{{Cite book | url = http://community.computerhistory.org/scc/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf | title = 