enables printf output to be written to any file. Programmers frequently use it to print errors, by writing to the [[Standard streams#Standard error|standard error]] device, but it can operate with any file opened with the <code>[[fopen]]</code> (or <code>[[fdopen]]</code>) function. ===sprintf=== <source lang="c">int sprintf (char *str, const char *format, ...)</source> '''<code>sprintf</code>''' prints to a string (<code>char</code> array) instead of to [[Standard streams#Standard output|standard output]]. Users of <code>sprintf</code> must ensure, via calculation or via a [[guard page]], that the resulting string will not be larger than the memory allocated for ''str''. Failure to ensure this can allow a [[buffer overflow]] to occur. In higher-level languages such as [[PHP]] the <code>sprintf</code> function does not have the <code>str</code> argument. Instead, it returns the formatted output string. The prototype in PHP is like this: <source lang="php">string sprintf (const string format, ...)</source> ===Buffer safety and sprintf=== In ISO C99, '''<code>snprintf</code>''' was introduced as an alternative to '''<code>sprintf</code>''' that can help avoid the risk of a buffer overflow: <source lang="c">int snprintf(char *str, size_t size, const char * restrict format, ...)</source> <code>snprintf</code> is guaranteed not to write more than ''size'' bytes into ''str'', so use of it can help avoid the risk of a buffer overflow, as in the following code fragment: <source lang="c"> #define BUFFER_SIZE 50 char buf[BUFFER_SIZE]; int n; n = snprintf(buf, BUFFER_SIZE, "Your name is %s.\n", username); if (n >= BUFFER_SIZE) /* Handle error */ </source> If ''username'' in the above example causes result to exceed 49 bytes in length, the function will limit the string that gets saved in ''buf'' by cutting off final bytes ([[truncation|truncating]]{{dn}}). The null terminator will always be written to the 50th location so the result is always null terminated. Additionally, the return code of <code>snprintf</code> indicates how many bytes (not counting the null) the function ''would'' have written to the string had enough space existed. Systems can use this information to allocate a new (larger) buffer if they require the whole string. A number of <code>snprintf</code> implementations deviated from the above description, in particular many Windows libraries, [[glibc]] before version 2.0.6, and [[Solaris (operating system)|Solaris]]. The most common mistake was returning -1 on truncation rather than the length needed. More troublesome were implementations that did not write the null terminator on truncation, or returned size-1 (making it impossible to detect truncation). These deviations make writing portable safe code using <code>snprintf</code> harder than it should be. Another safe <code>sprintf</code> alternative is '''<code>asprintf</code>''' which is a GNU extension: <source lang="c">int asprintf(char **ret, const char *format, ...)</source> <code>asprintf</code> automatically allocates enough memory to hold the final string. It sets <code>*ret</code> to a pointer to the resulting string, or to an undefined value if an error occurred ([[glibc]] is notable in being the only implementation that doesn't always set <code>*ret</code> to [[Null pointer|NULL]] on error). The programmer using <code>asprintf</code> has the responsibility of freeing the allocated memory after use. Though not part of any standard, <code>asprintf</code> comes in the C libraries of several operating systems (including [[OpenBSD]], [[FreeBSD]], and [[NetBSD]]) and on other platforms in the [[libiberty]] library. [[GLib]] provides yet another safe alternative: <code>g_strdup_printf</code>, which allocates enough memory, but, unlike <code>asprintf</code>, returns the resulting string as its return value rather than via the first argument. ===C++ alternatives to sprintf for numeric conversion=== The standard method for string formatting and the conversion of other types to strings in C++ is [[iostream]]. Unlike printf, the iostream standard library is type-safe and extensible. A common programming task is to convert a numeric type into a string (char buffer). The <code>sprintf</code> family, while useful, in many applications seems like overkill for such a simple task. In addition many programs using these are not designed to handle the variations in output when the [[locale]] changes. A number of alternative means in C/C++ have been developed: * [http://boost.org/libs/conversion/lexical_cast.htm Boost::lexical_cast ] * [http://www.boost.org/libs/format/index.html Boost::format ] * [http://sourceforge.net/projects/loki-lib/ Loki::SafeFormat ] * [[itoa]] ==vprintf, vfprintf, vsprintf, vsnprintf, and vasprintf== <source lang="c"> #include <stdio.h> /* va_list versions of above */ int vprintf(const char *format, va_list ap); int vfprintf(FILE *stream, const char *format, va_list ap); int vsprintf(char *str, const char *format, va_list ap); int vsnprintf(char *str, size_t size, const char *format, va_list ap); int vasprintf(char **ret, const char *format, va_list ap); </source> These are analogous to the above functions without the ''v''s, except that they use [[Variadic function|variable argument]] lists. These functions offer the ability for programmers to essentially create their own printf variants. For instance, a programmer could write a function <source lang="c">void fatal_error(const char *format, ...)</source> which would use the <code>va_start</code> macro to obtain a <code>va_list</code> variable from the extra parameters, print a message on the standard error device using <code>vfprintf</code>, clean up after the <code>va_list</code> variable with the <code>va_end</code> macro, and finally perform the necessary tasks to cleanly shut down the program. Another common application of these functions is to write a custom printf that prints to a different target than a file. For instance, a graphical library might provide a printf-like function with X and Y coordinates: <source lang="c">int graphical_printf(int x, int y, const char *format, ...)</source> This would work by temporarily saving the string to a private buffer using <code>vsnprintf</code> or <code>vasprintf</code>. ==Format placeholders== Formatting takes place via placeholders within the format string. For example, if a program wanted to print out a person's age, it could present the output by prefixing it with "Your age is ". To denote that we want the integer for the age to be shown immediately after that message, we may use the format string: "Your age is %d." The syntax for a format placeholder is "''%[parameter][flags][width][.precision][length]type''". *'''Parameter''' can be omitted or can be: :{| class="wikitable" |- ! Character ! Description |- | <code>n$</code> | ''n'' is the number of the parameter to display using this format specifier, allowing the parameters provided to be output multiple times, using varying format specifiers or in different orders. This is a [[POSIX]] extension and not in [[C99]]. Example: <code>printf("%2$d %1$#x %1$d",16,17)</code> produces "17 0x10 16" |} *'''Flags''' can be zero or more (in any order) 