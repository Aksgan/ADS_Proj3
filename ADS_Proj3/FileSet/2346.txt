typically 10-100 MHz (100-10 ns per bit). The TRST pin is an optional active-low reset to the test logic - usually asynchronous, but sometimes synchronous, depending on the chip. If the pin is not available, the test logic can be reset by switching to the reset state synchronously, using TCK and TMS. Note that resetting test logic doesn't necessarily imply resetting anything else. There are generally some processor-specific JTAG operations which can reset all or part of the chip being debugged. As with any clocked signal, data presented to TDI must be valid for some chip-specific ''Setup'' time before and ''Hold'' time after the relevant (here, rising) clock edge. TDO data is valid for some chip-specific time after the falling edge of TCK. In short, there are some constraints on signal timings. TCK frequencies vary based on chip, board, and adapter capabilities and state. One chip might support a 40 MHz JTAG clock, but only if it's using a 200 MHz clock for non-JTAG operations; and it might need to use a much slower clock when it's in a low power mode. Accordingly, some JTAG adapters support ''adaptive clocking'' using an RTCK (Return TCK) signal. Faster TCK frequencies are most useful when JTAG is used to transfer lots of data, such as when storing a system image into NAND flash. JTAG platforms often add additional signals to the handful defined by the IEEE 1149.1 specification. A System Reset (SRST) signal is quite common, letting debuggers reset the whole system not just the parts with JTAG support. Sometimes there are event signals used to trigger activity by the host or by the device being monitored through JTAG; or additional control lines. Even though few consumer products provide an explicit JTAG port connector, the connections are often available on the [[printed circuit board]] as a remnant from development [[prototype|prototyping]] and/or production. When exploited, these connections often provide an excellent means for [[reverse engineering]]. == Communications Model == In JTAG, devices expose one or more ''test access ports'' (TAPs). The picture above shows three TAPs, which might be individual chips or might be modules inside one chip. A daisy chain of TAPs is called a ''scan chain'', or (loosely) a target. Scan chains can be arbitrarily long, but in practice twenty TAPs is unusually long{{Citation needed|date=June 2010}}. To use JTAG, a host is connected to the target's JTAG signals (TMS, TCK, TDI, TDO, etc.) through some kind of ''JTAG adapter'', which may need to handle issues like level shifting and galvanic isolation. The adapter connects to the host using some interface such as USB, PCI, Ethernet, and so forth. === Primitives === The host communicates with the TAPs by manipulating TMS and TDI in conjunction with TCK, then reading results through TDO (which is the only standard host-side input). TMS/TDI/TCK output transitions create the basic JTAG communication primitive on which higher layer protocols build: * ''State switching'' ... All TAPs are in the same state, and that state changes on TCK transitions. This JTAG state machine is part of the JTAG spec, and includes sixteen states. There are six “stable states” where keeping TMS stable prevents the state from changing. In all other states, TCK always changes that state. In addition, asserting TRST forces entry to one of those stable states (Test_Logic_Reset), in a slightly quicker way than the alternative of holding TMS high and cycling TCK five times. * ''Shifting'' ... Most parts of the JTAG state machine support two stable states used to transfer data. Each TAP has an ''instruction register'' (IR) and a ''data register'' (DR). The size of those registers varies between TAPs, and those registers are combined through TDI and TDO to form a large shift register. (The size of the DR is a function of the value in that TAP's current IR, and possibly of the value specified by a SCAN_N instruction.) There are three operations defined on that shift register: ** ''Capturing'' a temporary value ... entry to the Shift_IR stable state goes via the Capture_IR state, loading the shift register with a partially fixed value (not the current instruction). Entry to the Shift_DR stable state goes via the Capture_DR state, loading the value of the Data Register specified by the TAP's current IR. ** ''Shifting'' that value bit-by-bit, in either the Shift_IR or Shift_DR stable state; TCK transitions will shift the shift register one bit, from TDI towards TDO, exactly like a [[Serial Peripheral Interface Bus|SPI]] mode 1 data transfer through a daisy chain of devices (with TMS=0 acting like the chip select signal, TDI as MOSI, etc.). ** ''Updating'' IR or DR from the temporary value shifted in, on transition through the Update_IR or Update_DR state. Note that it is not possible to read (capture) a register without writing (updating) it, and vice versa. A common idiom adds flag bits to say whether the update should have side effects, or whether the hardware is ready to execute such side effects. * ''Running'' ... One stable state is called Run_Test/Idle. The distinction is TAP-specific. Clocking TCK in the Idle state has no particular side effects, but clocking it in the Run_Test state may change system state. For example, some [[ARM9]] cores support a debugging mode where TCK cycles in the Run_Test state drive the instruction pipeline. So at a basic level, using JTAG involves reading and writing instructions and their associated data registers; and sometimes involves running a number of test cycles. Behind those registers is hardware that is not specified by JTAG, and which has its own states that will be affected by JTAG activities. Most JTAG hosts use the shortest path between two states, perhaps constrained by quirks of the adapter. (For example, one adapter{{Which?|date=March 2010}} only handles paths whose lengths are multiples of seven bits.) Some layers built on top of JTAG monitor the state transitions, and use uncommon paths to trigger higher level operations. Some ARM cores use such sequences to enter and exit a two-wire (non-JTAG) [[Serial Wire Debug|SWD]] mode. 