pattern|Chain of Responsibility Pattern]], [[Command Pattern]], [[Interpreter Pattern]], [[Iterator Pattern]], [[Mediator Pattern]], [[Memento Pattern]], [[Observer Pattern]], [[State pattern|State Pattern]], [[Strategy Pattern]], [[Template Method Pattern]], [[Visitor Pattern]] ===Object-orientation and databases=== {{Main|Object-Relational impedance mismatch|Object-relational mapping|Object database}} Both object-oriented programming and [[relational database management systems]] (RDBMSs) are extremely common in software {{As of|2006|alt=today}}. Since [[relational database]]s don't store objects directly (though some RDBMSs have object-oriented features to approximate this), there is a general need to bridge the two worlds. The problem of bridging object-oriented programming accesses and data patterns with relational databases is known as [[Object-Relational impedance mismatch]]. There are a number of approaches to cope with this problem, but no general solution without downsides.<ref name="RDMDBobjectmis">{{Cite web| first = Ted| last=Neward | title = The Vietnam of Computer Science| date=2006-06-26|accessdate=2010-06-02| publisher = Interoperability Happens| url=http://blogs.tedneward.com/2006/06/26/The+Vietnam+Of+Computer+Science.aspx}}</ref> One of the most common approaches is [[object-relational mapping]], as found in libraries like [[Java Data Objects]] and [[Ruby on Rails]]' ActiveRecord. There are also [[object database]]s that can be used to replace RDBMSs, but these have not been as technically and commercially successful as RDBMSs. ===Matching real world=== OOP can be used to translate from real-world phenomena to program elements (and vice versa). OOP was even invented for the purpose of physical modeling in the [[Simula]] 67 language. However, not everyone agrees that direct real-world mapping is facilitated by OOP (see [[Object-oriented programming#Criticisms|Criticisms]] section), or is even a worthy goal; [[Bertrand Meyer]] argues in ''[[Object-Oriented Software Construction]]''<ref name="Meyer230">Meyer, Second Edition, p. 230</ref> that a program is not a model of the world but a model of some part of the world; "Reality is a cousin twice removed". At the same time, some principal limitations of OOP had been noted.<ref>M.Trofimov, ''OOOP - The Third "O" Solution: Open OOP.'' First Class, [[Object Management Group|OMG]], 1993, Vol. 3, issue 3, p.14.</ref> An example for a real world problem that cannot be modeled elegantly with OOP techniques is the [[Circle-ellipse problem]]. However, [[Niklaus Wirth]] (who popularized the adage now known as [[Wirth's law]]: "Software is getting slower more rapidly than hardware becomes faster") said of OOP in his paper, "Good Ideas through the Looking Glass", "This paradigm closely reflects the structure of systems 'in the real world', and it is therefore well suited to model complex systems with complex behaviours" (contrast [[KISS principle]]). However, it was also noted (e.g. in Steve Yegge's essay ''Execution in the Kingdom of Nouns''[http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html]) that the OOP approach of strictly prioritizing ''things'' (objects/[[noun]]s) before ''actions'' (methods/[[verb]]s) is a paradigm not found in natural languages.<ref name="executioniKoN">{{Cite web| first = Steve| last=Yegge | title = Execution in the Kingdom of Nouns| date=2006-03-30|accessdate=2010-07-03| publisher = steve-yegge.blogspot.com| url=http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html}}</ref> This limitation may lead for some real world modelling to overcomplicated results compared e.g. to procedural approaches.<ref name="executioniKoN2">{{Cite web| first = Timothy| last= Boronczyk | title = What's Wrong with OOP| date=2009-06-11|accessdate=2010-07-03| publisher = zaemis.blogspot.com| url=http://zaemis.blogspot.com/2009/06/whats-wrong-with-oop.html}}</ref> === OOP and control flow === OOP was developed to increase the [[Code reuse|reusability]] and [[Software maintenance|maintainability]] of source code.<ref name="realisticcodereuse">{{Cite web| first = Scott| last= Ambler| title = A Realistic Look at Object-Oriented Reuse| date=1998-01-01| accessdate=2010-07-04| publisher = www.drdobbs.com| url=http://www.drdobbs.com/184415594}}</ref> Transparent representation of the [[control flow]] had no priority and was meant to be handled by a compiler. With the increasing relevance of parallel hardware and [[Thread (computer science)|multithreaded coding]], developer transparent control flow becomes more important, something hard to achieve with OOP.<ref name="flaws">{{Cite web| first = Asaf| last= Shelly |title = Flaws of Object Oriented Modeling| date=2008-08-22|accessdate=2010-07-04| publisher = Intel® Software Network| url=http://software.intel.com/en-us/blogs/2008/08/22/flaws-of-object-oriented-modeling/}}</ref><ref name="multithreadingisaverb">{{Cite web| first = Justin | last= James| title = Multithreading is a verb not a noun| date=2007-10-01|accessdate=2010-07-04| publisher = techrepublic.com| url=http://blogs.techrepublic.com.com/programming-and-development/?p=518}}</ref><ref name="multicore">{{Cite web| first = Asaf| last= Shelly| title = HOW TO: Multicore Programming (Multiprocessing) Visual C++ Class Design Guidelines, Member Functions| date=2008-08-22| accessdate=2010-07-04| publisher = support.microsoft.com| url=http://support.microsoft.com/?scid=kb%3Ben-us%3B558117}}</ref> ===Responsibility vs. data-driven design=== [[Responsibility-driven design]] defines classes in terms of a contract, that is, a class should be defined around a responsibility and the information that it shares. This is contrasted by Wirfs-Brock and Wilkerson with [[data-driven design]], where classes are defined around the data-structures that must be held. The authors hold that responsibility-driven design is preferable. ==Criticism== {{POV-section|date=August 2010}} A large number of software engineers agree that gathering commands and data into discrete objects in this way makes their software easier to develop, document and maintain. However, a significant number of engineers feel the reverse may be true: that software becomes more complex to maintain and document, or even to engineer from the start. The conditions under which OOP prevails over alternative techniques (and vice-versa) often remain unstated by either party, however, making rational discussion of the topic difficult, and often leading to heated debates {{Citation needed|date=September 2010}} over the matter. A number of well-known researchers and programmers have criticized OOP. Here is an incomplete list: * [[Luca Cardelli]] wrote a paper titled "Bad Engineering Properties of Object-Oriented Languages".<ref name="badprop">{{Cite journal| first=Luca| last=Cardelli|title=Bad Engineering Properties of Object-Oriented Languages |url=http://lucacardelli.name/Papers/BadPropertiesOfOO.html| year=1996| accessdate=2010-04-21| doi=10.1145/242224.242415| journal = ACM Comput. Surv.| volume=28| issn = 0360-0300| pages = 150| publisher = ACM| authorlink=Luca Cardelli}}</ref> * [[Richard Stallman]] wrote in 1995, "Adding OOP to [[Emacs]] is not clearly an improvement; I used OOP when working on the [[Lisp Machine]] [[window system]]s, and I disagree with the usual view that it is a superior way to program."<ref>{{Cite web| url=http://groups.google.com/group/comp.emacs.xemacs/browse_thread/thread/d0af257a2837640c/37f251537fafbb03?lnk=st&q=%22Richard+Stallman%22+oop&rnum=5&hl=en#37f251537fafbb03| title=Mode inheritance, cloning, hooks & OOP |accessdate=2008-06-21| last=Stallman|first=Richard|date=1995-01-16| publisher=Google Groups Discussion| authorlink=Richard Stallman}}</ref> * A study by Potok et al.<ref>{{Cite journal| url=http://www.csm.ornl.gov/~v8q/Homepage/Papers%20Old/spetep-%20printable.pdf| title=Productivity Analysis of Object-Oriented Software Developed in a Commercial Environment| last=Potok| first=Thomas| coauthors=Mladen Vouk, Andy Rindos| journal=Software – Practice and Experience| volume=29|issue=10|pages=833–847 |year=1999 | accessdate=2010-04-21| doi=10.1002/(SICI)1097-024X(199908)29:10<833::AID-SPE258>3.0.CO;2-P}}</ref> has shown no significant difference in productivity between OOP and procedural approaches. * [[Christopher J. Date]] stated that critical comparison of OOP to other technologies, relational in particular, is difficult because of lack of an agreed-upon and rigorous definition of OOP.<ref name="DatePage650">C. J. Date, Introduction to Database Systems, 6th-ed., Page 650</ref> Date and Darwen<ref name="ThirdManifesto">C. J. Date, Hugh Darwen. ''Foundation for Future Database Systems: The Third Manifesto'' (2nd Edition)</ref> propose 