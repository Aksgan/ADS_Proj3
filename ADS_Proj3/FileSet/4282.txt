Consider the regression model : <math>y = \alpha + \beta^T\textbf{x} + \varepsilon,\text{ where }\varepsilon\perp\!\!\!\perp\textbf{x}.</math> Note that the distribution of <math>y|\textbf{x}</math> is the same as the distribution of <math>y|\beta^T\textbf{x}</math>. Hence, the span of <math>\beta</math> is a dimension reduction subspace. Also, <math>\beta</math> is 1-dimensional (unless <math>\beta=\textbf{0}</math>), so the structural dimension of this regression is <math>d=1</math>. The [[ordinary least squares|OLS]] estimate <math>\hat{\beta}</math> of <math>\beta</math> is [[consistent estimator|consistent]], and so the span of <math>\hat{\beta}</math> is a consistent estimator of <math>\mathcal{S}_{y|x}</math>. The plot of <math>y</math> versus <math>\hat{\beta}^T\textbf{x}</math> is a sufficient summary plot for this regression. == See also == *[[Dimension reduction]] *[[Sliced inverse regression]] *[[Principal component analysis]] *[[Linear discriminant analysis]] *[[Curse of dimensionality]] == Notes == {{Reflist}} == References == {{refbegin}} *Cook, R.D. (1998) ''Regression Graphics: Ideas for Studying Regressions through Graphics'', Wiley Series in Probability and Statistics. [http://www.stat.umn.edu/RegGraph/ Regression Graphics]. *Cook, R.D. and Adragni, K.P. (2009) "Sufficient Dimension Reduction and Prediction in Regression", [[Philosophical Transactions of the Royal Society A: Physical, Mathematical and Engineering Sciences]], 367(1906), 4385–4405. [http://rsta.royalsocietypublishing.org/content/367/1906/4385.full Full-text] *Cook, R.D. and Weisberg, S. (1991) "Sliced Inverse Regression for Dimension Reduction: Comment", [[Journal of the American Statistical Association]], 86(414), 328–332. [http://www.jstor.org/stable/2290564 Jstor] *Li, K-C. (1991) "Sliced Inverse Regression for Dimension Reduction", [[Journal of the American Statistical Association]], 86(414), 316–327. [http://www.jstor.org/stable/2290563 Jstor] {{refend}} == External links == * [http://www.stat.umn.edu/~dennis/SDR/ Sufficient Dimension Reduction] * [http://www.stat.umn.edu/RegGraph/ Regression Graphics] [[Category:Multivariate statistics]] [[Category:Regression analysis]]</text> </page> <page> <id>36101</id> <title>Suffix array</title> <text>In [[computer science]], a '''suffix array''' is an [[array data structure|array]] of integers giving the starting positions of [[suffix (computer science)|suffixes]] of a [[string (computer science)|string]] in [[lexicographical order]]. ==Details== Consider the string {| class="wikitable" border="1" |- ! 1 ! 2 ! 3 ! 4 ! 5 ! 6 ! 7 ! 8 ! 9 ! 10 ! 11 ! 12 |- align=center | a | b | r | a | c | a | d | a | b | r | a | $ |} of length 12, that ends with a sentinel letter $, appearing only once, and less (in lexicographical order) than any other letter in the string. It has twelve suffixes: "abracadabra$", "bracadabra$", "racadabra$", and so on down to "a$" and "$" that can be sorted into lexicographical order to obtain: {| class="wikitable" border="1" |- ! index ! sorted suffix ! lcp |- | 12 | $ | 0 |- | 11 | a$ | 0 |- | 8 | abra$ | 1 |- | 1 | abracadabra$ | 4 |- | 4 | acadabra$ | 1 |- | 6 | adabra$ | 1 |- | 9 | bra$ | 0 |- | 2 | bracadabra$ | 3 |- | 5 | cadabra$ | 0 |- | 7 | dabra$ | 0 |- | 10 | ra$ | 0 |- | 3 | racadabra$ | 2 |} If the original string is available, each suffix can be completely specified by the index of its first character. The suffix array is the array of the indices of suffixes sorted in lexicographical order. For the string "abracadabra$", using [[1-based array|one-based]] indexing, the suffix array is {12,11,8,1,4,6,9,2,5,7,10,3}, because the suffix "$" begins at position 12, "a$" begins at position 11, "abra$" begins at position 8, and so forth. The longest common prefix is also shown above as lcp. This value, stored alongside the list of prefix indices, indicates how many characters a particular suffix has in common with the suffix directly above it, starting at the beginning of both suffixes. The lcp is useful in making some string operations more efficient. For example, it can be used to avoid comparing characters that are already known to be the same when searching through the list of suffixes. The fact that the minimum lcp value belonging to a consecutive set of sorted suffixes gives the longest common prefix among all of those suffixes can also be useful. ==Algorithms== The easiest way to construct a suffix array is to use an efficient [[comparison sort]] algorithm. This requires <math>O(n \log n)</math> suffix comparisons, but a suffix comparison requires <math>O(n)</math> time, so the overall runtime of this approach is <math>O(n^2 \log n)</math>. More sophisticated algorithms improve this to <math>O(n \log n)</math> by exploiting the results of partial sorts to avoid redundant comparisons. Several <math>\Theta(n)</math> algorithms (of Pang Ko and Srinivas Aluru, Juha Kärkkäinen and Peter Sanders, etc) have also been developed which provide faster construction and have space usage of <math>O(n)</math> with low constants. Recent work by Salson ''et al.'' proposes an algorithm for updating the suffix array of a text that has been edited instead of rebuilding a new suffix array from scratch. Even if the theoretical worst-case time complexity is <math>O(n \log n)</math>, it appears to perform well in practice: experimental results from the authors showed that their implementation of dynamic suffix arrays is generally more efficient than rebuilding when comparing the insertion of 500 characters into their dynamic array with a complete rebuild of a static suffix array containing the updated text. ==Applications== The suffix array of a string can be used as an [[index (information technology)|index]] to quickly locate every occurrence of a substring within the string. Finding every occurrence of the substring is equivalent to finding every suffix that begins with the substring. Thanks to the lexicographical ordering, these suffixes will be grouped together in the suffix array, and can be found efficiently with a [[binary search]]. If implemented straightforwardly, this binary search takes <math>O(m \log n)</math> time, where <math>m</math> is the length of the substring W. The following pseudo-code from Manber and Myers shows how to find W (or the suffix lexicographically immediately before W if W is not present) in a suffix array with indices stored in pos. <pre> if W <= suffixAt(pos[0]) then ans = 0 else if W > suffixAt(pos[m-1]) then ans = m else { L = 0, R = m-1 while R-L > 1 do { M = (L + R)/2 if W <= suffixAt(pos[M]) then R = M else L = M } ans = R } </pre> To avoid 