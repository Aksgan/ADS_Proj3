Community Process]] as JSR 924.<ref>[http://www.jcp.org/en/jsr/detail?id=924 JSR 924], specifies changes to the JVM specification starting with J2SE 5.0</ref> {{As of|2006}}, changes to specification to support changes proposed to the [[class (file format)|class file format]] (JSR 202<ref>[http://www.jcp.org/en/jsr/detail?id=202 JSR 202], specifies a number of changes to the class file format</ref>) are being done as a maintenance release of JSR 924. The specification for the JVM is published in book form,<ref>''[http://java.sun.com/docs/books/vmspec/ The Java Virtual Machine Specification]'' (the [http://java.sun.com/docs/books/vmspec/html/VMSpecTOC.doc.html first] and [http://java.sun.com/docs/books/vmspec/2nd-edition/html/VMSpecTOC.doc.html second] editions are also available online)</ref> known as "blue book". The preface states: {{quote|We intend that this specification should sufficiently document the Java Virtual Machine to make possible compatible clean-room implementations. Sun provides tests that verify the proper operation of implementations of the Java Virtual Machine.}} Sun's JVM is called [[HotSpot]]. [[clean room design|Clean-room]] Java implementations include [[Kaffe]], [[IBM J9]] and [[Dalvik (software)|Dalvik]]. Sun retains control over the Java trademark, which it uses to certify implementation suites as fully compatible with Sun's specification. == Heap == The ''Java Virtual Machine heap'' is the area of memory used by the JVM (and specifically [[HotSpot]]) for [[dynamic memory allocation]].<ref name="hotspotfaq">{{cite web | url=http://java.sun.com/docs/hotspot/gc1.4.2/faq.html | title=Frequently Asked Questions about Garbage Collection in the Hotspot Java Virtual Machine | date=6 February 2003 | publisher=[[Sun Microsystems]] | accessdate=7 February 2009}}</ref> The [[heap (data structure)|heap]] is split up into "generations": * The ''young generation'' stores short-lived [[object (computer science)|objects]] that are created and immediately [[garbage collection (computer science)|garbage collected]]. * Objects that persist longer are moved to the ''old generation'' (also called the ''tenured generation''). * The ''permanent generation'' (or ''permgen'') is used for [[class (file format)|class]] definitions and associated metadata.<ref name="permgen">{{cite web | url=http://blogs.sun.com/jonthecollector/entry/presenting_the_permanent_generation | title=Presenting the Permanent Generation | date=28 November 2006 | last=Masamitsu|first=Jon | accessdate=7 February 2009}}</ref><ref>{{cite web | url=http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html | title=A First Taste of InvokeDynamic | date=11 September 2008 | last=Nutter|first=Charles | accessdate=7 February 2009}}</ref> Originally there was no permanent generation, and objects and classes were stored together in the same area. But as class unloading occurs much more rarely than objects are collected, moving class structures to a specific area allows significant performance improvements.<ref name=permgen/> == See also == {{Portal|Java}} * [[List of Java virtual machines]] * [[Comparison of application virtual machines]] * [[Automated Exception Handling]] * [[Java performance]] * [[List of JVM languages]] * [[Java processor]] == Notes == {{Reflist}} {{Reflist|2}} ==References== {{Refbegin}} * ''[http://java.sun.com/docs/books/vmspec/2nd-edition/jvms-clarify.html Clarifications and Amendments to the Java Virtual Machine Specification, Second Edition]'' includes list of changes to be made to support J2SE 5.0 and JSR 45 * [http://www.jcp.org/en/jsr/detail?id=45 JSR 45], specifies changes to the class file format to support source-level debugging of languages such as [[JavaServer Pages]] (JSP) and [[SQLJ]] that are translated to Java {{Refend}} ==External links== * [http://java.sun.com/docs/books/vmspec/ The Java Virtual Machine Specification] * {{dmoz|Computers/Programming/Languages/Java/Implementations|Java implementations}} * [http://www.computerworld.com/action/article.do?command=viewArticleBasic&articleId=9067358 Sun to build virtual machine for iPhone - ComputerWorld] * [http://java.com/en/download/inc/windows_new_xpi.jsp Java Virtual Machine Download Link] * [http://igormaznitsa.com/projects/mjvm/index.html JVM implementation in pure Java] {{Java Virtual Machine}} {{Java (Sun)}} {{Sun Microsystems}} <!-- Categories --> [[Category:Cross-platform software]] [[Category:Java platform|Virtual machine]] [[Category:Java platform software]] [[Category:Java programming language|Virtual machine]] [[Category:Java specification requests|Virtual machine]] [[Category:Java virtual machine]] [[Category:Stack-based virtual machines]] <!-- Interwikis --> [[ar:آلة جافا الافتراضية]] [[bs:Java Virtualna Mašina]] [[ca:Màquina Virtual Java]] [[cs:Java Virtual Machine]] [[de:Java Virtual Machine]] [[es:Máquina virtual Java]] [[fa:ماشین مجازی جاوا]] [[fr:Machine virtuelle Java]] [[ko:자바 가상 머신]] [[hi:जावा आभासी मशीन]] [[hr:Java (virtualni stroj)]] [[it:Macchina virtuale Java]] [[he:Java Virtual Machine]] [[hu:Java virtuális gép]] [[ml:ജാവ വിർച്ച്വൽ മെഷീൻ]] [[nl:Java Virtual Machine]] [[ja:Java仮想マシン]] [[pl:Wirtualna maszyna Javy]] [[pt:Máquina virtual Java]] [[ru:Java Virtual Machine]] [[sq:Java Virtual Machine]] [[simple:Java Virtual Machine]] [[sh:Java (virtualni stroj)]] [[sv:Java Virtual Machine]] [[uk:Віртуальна машина Java]] [[zh:Java虚拟机]]</text> </page> <page> <id>19791</id> <title>Java bytecode instruction listings</title> <text>{{Main|Java bytecode}} This is a list of the instructions that make up the [[Java bytecode]], an abstract machine language that is ultimately executed by the [[Java virtual machine]]. The Java bytecode is generated by language compilers targeting the [[Java Platform]], most notably the [[Java programming language]]. {| class="wikitable" ! Mnemonic !! Opcode<br>''(in hex)'' !! Other bytes !! Stack<br>[before]&rarr;[after] !! Description |- ! colspan="5" | A |- | aaload || align="center" | 32 || || arrayref, index &rarr; value || loads onto the stack a reference from an array |- | aastore || align="center" | 53 || || arrayref, index, value &rarr; || stores into a reference to an array |- | aconst_null || align="center" | 01 || || &rarr; null || pushes a ''null'' reference onto the stack |- | aload || align="center" | 19 || index || &rarr; objectref || loads a reference onto the stack from a local variable ''#index'' |- | aload_0 || align="center" | 2a || || &rarr; objectref || loads a reference onto the stack from local variable 0 |- | aload_1 || align="center" | 2b || || &rarr; objectref || loads a reference onto the stack from local variable 1 |- | aload_2 || align="center" | 2c || || &rarr; objectref || loads a reference onto the stack from local variable 2 |- | aload_3 || align="center" | 2d || || &rarr; objectref || loads a reference onto the stack from local variable 3 |- | anewarray || align="center" | bd || indexbyte1, indexbyte2 || count &rarr; arrayref || creates a new array of references of length ''count'' and component type identified by the class reference ''index'' (''indexbyte1 << 8 + indexbyte2'') in the constant pool |- | areturn || align="center" | b0 || || objectref &rarr; [empty] || returns a reference from a method |- | arraylength || align="center" | be || || arrayref &rarr; length || gets the length of an array |- | astore || align="center" | 3a || index || objectref &rarr; || stores a reference into a local variable ''#index'' |- | astore_0 || align="center" | 4b || || objectref &rarr; || stores a reference into local variable 0 |- | astore_1 || align="center" | 4c || || objectref &rarr; || stores a reference into local variable 1 |- | astore_2 || align="center" | 4d || || objectref &rarr; || stores a reference into local variable 2 |- | 