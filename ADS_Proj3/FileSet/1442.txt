req.GetResponseAsync() use stream = response.GetResponseStream() use streamreader = new System.IO.StreamReader(stream) return streamreader.ReadToEnd() } </source> The <code>let!</code> allows the rest of the async block to be defined as the delegate and passed as the [[callback (computer science)|callback function]] of an asynchronous operation. This helps deal with [[inversion of control]] issues.<ref name="aw"/> The async block is invoked using the <code>Async.Run</code> function. Multiple async blocks are executed in parallel using the <code>Async.Parallel</code> function that takes a list of <code>async</code> objects (in the example, <code>asynctask</code> is an async object) and creates another async object to run the tasks in the lists in parallel. The resultant object is invoked using <code>Async.Run</code>.<ref name="aw">{{cite web | url = http://blogs.msdn.com/dsyme/archive/2007/10/11/introducing-f-asynchronous-workflows.aspx | title = Introducing F# Asynchronous Workflows | accessdate = 2007-12-14}}</ref> F# comes with a [[Microsoft Visual Studio]] language service that integrates it with the IDE. With the language service installed, Visual Studio can be used to create F# projects and the Visual Studio debugger used to debug F# code. In addition, it comes with a Visual Studio-hosted interactive console that executes F# code as it is being written. == Examples == A few small samples follow: <source lang="ocaml"> (* This is commented *) (* Sample hello world program *) printfn "Hello World!" </source> A simple example that is often used to demonstrate the syntax of functional languages is the factorial function for non-negative 32-bit integers, here shown in F#: <source lang="ocaml"> let rec factorial n = match n with | 0 -> 1 | _ -> n * factorial (n - 1) </source> Recursive function examples: <source lang="ocaml"> (* print a list of numbers recursively *) let rec printList lst = match lst with | [] -> () | h :: t -> printf "%d\n" h printList t (* Same thing, using matching against list elements *) let rec printList2 l = match l with | [] -> () | h :: t -> printfn "%A" h printList2 t (* Using shorthand for match *) let rec printList3 = function | [] -> () | h :: t -> printfn "%A" h printList3 t (* Or, using a higher-order function *) let printlist4 lst = List.iter (printfn "%A") lst </source> <source lang="ocaml"> (* Fibonacci Number formula *) let rec fib n = match n with | 0 | 1 -> n | _ -> fib (n - 1) + fib (n - 2) (* An alternative approach - a lazy recursive sequence of Fibonacci numbers *) let rec fibs = Seq.cache <| seq { yield! [1; 1] for x, y in Seq.zip fibs <| Seq.skip 1 fibs -> x + y } (* Another approach - a lazy infinite sequence of Fibonacci numbers *) let fibSeq = Seq.unfold (fun (a,b) -> Some(a+b, (b, a+b))) (1,1) (* Print even fibs *) [1 .. 10] |> List.map fib |> List.filter (fun n -> (n % 2) = 0) |> printlist (* Same thing, using sequence expressions *) [ for i in 1..10 do let r = fib i if r % 2 = 0 then yield r ] |> printlist </source> <source lang="ocaml"> (* Sample Windows Forms Program *) (* We need to open the System library for the STAThreadAttribute class *) open System (* We need to open the Windows Forms library *) open System.Windows.Forms (* Create a window and set a few properties *) let form = new Form(Visible=true, TopMost=true, Text="Welcome to F#") (* Create a label to show some text in the form *) let label = let temp = new Label() let x = 3 + (4 * 5) (* Set the value of the Text*) temp.Text <- sprintf "x = %d" x (* Remember to return a value! *) temp (* Add the label to the form *) form.Controls.Add(label) (* Finally, run the form *) [<STAThread>] Application.Run(form) </source> <source lang="ocaml"> (* Async workflows sample (parallel CPU and I/O tasks) *) (* A very naive prime number detector *) let isPrime (n:int) = let bound = int (System.Math.Sqrt(float n)) seq {2 .. bound} |> Seq.exists (fun x -> n % x = 0) |> not (* We are using async workflows *) let primeAsync n = async { return (n, isPrime n) } (* Return primes between m and n using multiple threads *) let primes m n = seq {m .. n} |> Seq.map primeAsync |> Async.Parallel |> Async.RunSynchronously |> Array.filter snd |> Array.map fst (* Run a test *) primes 1000000 1002000 |> Array.iter (printfn "%d") </source> ==See also== * [[OCaml]] * [[C Sharp (programming language)|C#]] * [[Haskell (programming language)|Haskell]] * [[ML (programming language)|ML]] * [[Scala (programming language)|Scala]] * [[Nemerle]] ==Notes== {{reflist}} ==References== * {{Cite document| first1=Don |last1=Syme |author1-link=Don Syme |first2=Adam |last2=Granicz |first3=Antonio |last3=Cisternino |title=Expert F# |year=2007 |publisher=[[Apress]]| ref=harv| postscript=<!--None-->}} * {{Cite document| first1=Jon |last1=Harrop |title=Visual F# 2010 for Technical Computing |year=2010 |publisher=Flying Frog Consultancy| ref=harv| postscript=<!--None-->}} * {{Cite document| first1=Robert |last1=Pickering |title=Foundations of F# |year=2007 |publisher=[[Apress]]| ref=harv| postscript=<!--None-->}} * {{Cite document|first=Chris |last=Smith |title=Programming F# |year=2009 |publisher=[[O'Reilly]]|ref=harv|postscript=<!--None-->}} * {{Cite document |first=Tomas |last=Petricek |title=Real World Functional Programming With Examples in F# and C# |year=2009 |publisher=Manning Publications |ref=harv |postscript=<!--None-->}} ==External links== {{Wikibooks|F Sharp Programming}} * [http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/ Microsoft Research's website for F#] * [http://msdn.microsoft.com/en-us/fsharp/default.aspx Microsoft F# Developer Center] * [http://blogs.msdn.com/dsyme Don Syme's web log, a key source of information on F#] * [http://feedproxy.google.com/planet_fsharp Planet F#] * [http://www.ctocorner.com/fsharp/book The F# Survival Guide, Dec 2009 (Web-based book)] {{DotNET}} [[Category:Functional languages]] [[Category:ML programming language family]] [[Category:.NET programming languages]] [[Category:Microsoft Research]] [[Category:Free cross-platform software]] [[Category:Programming languages created in the 2000s]] [[ar:إف شارب (لغة برمجة)]] [[cs:F Sharp]] [[da:F Sharp]] [[de:F-Sharp]] [[es:F Sharp]] [[fr:F Sharp]] [[ko:F 샤프]] [[it:F Sharp]] [[ka:F Sharp]] [[ms:F Sharp]] [[nl:F♯]] [[ja:F Sharp]] [[pl:F Sharp]] [[pt:F Sharp]] [[ru:F Sharp]] [[sv:F Sharp]] [[th:ภาษาเอฟชาร์ป]] [[zh:F♯]]</text> </page> <page> <id>13181</id> <title>Fabrik (software)</title> <text>'''Fabrik''' is a [[Visual programming language|visual]] [[Computer programming|programming]] [[integrated development environment]] implemented in [[Smalltalk]] and designed at [[Apple Computer]] by [[Dan Ingalls]], Scott Wallace, [[Yu-Ying Chow]], [[Frank Ludolph]], [[Ken Doyle]] and others during the mid-1980s. It consists of a kit of computational and [[Graphical user interface|graphic]] [[user interface]] components that can 