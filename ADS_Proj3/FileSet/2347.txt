A Zero Bit Scan (ZBS) sequence is used in IEEE 1149.7<ref name="ieee-1149.7">Texas Instruments is one mover behind this standard, and has an [http://tiexpressdsp.com/wiki/index.php?title=IEEE_1149.7 IEEE 1149.7 wiki page] with more information.</ref> to access advanced functionality such as switching TAPs into and out of scan chains, power management, and a different two-wire mode. === JTAG IEEE Std 1149.1 (Boundary-scan) Instructions === Instruction register sizes tend to be small, perhaps four or seven bits wide. Except for BYPASS, all instruction opcodes are defined by the TAP implementor, as are their associated data registers; undefined instruction codes should not be used. Two key instructions are: * The BYPASS instruction, opcode all ones regardless of the TAP's instruction register size, must be supported by all TAPs. It is associated with a single bit data register (also called BYPASS) which always reads as zero. * The optional IDCODE instruction, with an implementor-defined opcode. IDCODE is associated with a 32-bit register (IDCODE). Its data uses a standardized format that includes a manufacturer code (derived from the [[JEDEC]] ''Standard Manufacturer's Identification Code'' standard, JEP-106), a part number assigned by the manufacturer, and a part version code. IDCODE is widely, but not universally, supported. On exit from the RESET state, the instruction register is preloaded with either BYPASS or IDCODE. This allows JTAG hosts to identify the size and, at least partially, contents of the scan chain to which they are connected. (They can enter the RESET state then scan the Data Register until they read back the data they wrote. A BYPASS register has only a zero bit; while an IDCODE register is 32-bits and starts with a one. So the bits not written by the host can easily be mapped to TAPs.) Such identification is often used to sanity check manual configuration, since IDCODE is often unspecific. It could for example identify an ARM Cortex-M3 based microcontroller, without specifying the microcontroller vendor or model; or a particular FPGA, but not how it has been programmed. A common idiom involves shifting BYPASS into the instruction registers of all TAPs except one, which receives some other instruction. That way all TAPs except one expose a single bit data register, and values can be selectively shifted into or out of that one TAP's data register without affecting any other TAP. The IEEE 1149.1 (JTAG) standard describes a number of instructions to support boundary scan applications. Some of these instructions are "mandatory", but TAPs used for debug instead of boundary scan testing sometimes provide minimal or no support for these instructions. Those "mandatory" instructions operate on the Boundary Scan Register (BSR) defined in the [[boundary scan description language|BSDL]] file, and include: * EXTEST for external testing, such as using pins to probe board-level behaviors * PRELOAD loading pin output values before EXTEST (sometimes combined with SAMPLE) * SAMPLE reading pin values into the boundary scan register IEEE-defined "Optional" instructions include: * CLAMP a variant of BYPASS which drives the output pins using the PRELOADed values * HIGHZ deactivates the outputs of all pins * INTEST for internal testing, such as using pins to probe on-chip behaviors * RUNBIST places the chip in a self-test mode * SCAN_N configures a scan path select register (SCREG) affecting the signals to which other boundary scan operations apply * USERCODE returns a user-defined code, for example to identify which FPGA image is active Devices may define more instructions, and those definitions should be part of a BSDL file provided by the manufacturer. They will often just be marked as PRIVATE. === Boundary Scan Register === Devices communicate to the world via a set of input and output pins. By themselves, these pins provide limited visibility into the workings of the device. However, devices that support [[boundary scan]] contain a shift-register cell for each signal pin of the device. These registers are connected in a dedicated path around the device's boundary (hence the name). The path creates a virtual access capability that circumvents the normal inputs and outputs, providing direct control of the device and detailed visibility for signals.<ref name="oshana">{{cite news | first = Rob | last = Oshana | url = http://www.embedded.com/story/OEG20021028S0049 | title = Introduction to JTAG | work = Embedded Systems Design | date = October 29, 2002 | accessdate = 2007-04-05 }}</ref> The contents of the boundary scan register, including signal I/O capabilities, are usually described by the manufacturer using a part-specific [[boundary scan description language|BSDL]] file. These are used with design 'netlists' from CAD/EDA systems to develop tests used in board manufacturing. Commercial test systems will often cost several thousand dollars for a fully-fledged system, and include diagnostic options to accurately pin-point faults such as open circuits and shorts. They may also offer schematic or layout viewers to depict the fault in a graphical manner. To provide the boundary scan capability, IC vendors add additional logic to each of their devices, including scan cells for each of the signal pins. These cells are then connected together to form the boundary scan shift register (BSR), which is connected to a TAP controller. These designs are parts of most Verilog or VHDL libraries. Overhead for this additional logic is minimal, and generally is well worth the price to enable efficient testing at the board level. == Example: ARM11 Debug TAP== A concrete example will help show the way JTAG works in real systems. The example here is the debug tap of an [[ARM11]] processor, the ARM1136<ref name="ARM1136">[http://infocenter.arm.com/help/topic/com.arm.doc.ddi0211k/DDI0211K_arm1136_r1p5_trm.pdf ARM1136JF-S and ARM1136J-S Technical Reference Manual] revision r1p5, ARM DDI 0211K. Chapter 14 presents the Debug TAP. Other ARM11 cores present the same model through their Debug TAPs.</ref> core. The processor itself has extensive JTAG capability, not unlike what is found in other CPU cores, and it is integrated into chips with even more extensive capabilities accessed through JTAG. So this is a non-trivial example, which is representative of a significant cross section of JTAG-enabled systems. In addition, it shows how control mechanisms are built using JTAG's register read/write primitives, and how those combine to facilitate 