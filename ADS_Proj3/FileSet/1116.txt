support the declared interface. Such systems, typically using a domain specific [[XML]] [[Xml namespace|namespace]], include abstractions of [[SQL]] database syntax or parameterised calls to web services using [[Representational State Transfer|REST]] and [[SOAP]]. ===Hybrid languages=== [[Makefiles]], for example, specify dependencies in a declarative fashion [http://phoenix.labri.fr/wiki/doku.php?id=an_overview_on_dsls], but include an imperative list of actions to take as well. Similarly, [[yacc]] specifies a context free grammar declaratively, but includes code snippets from a host language, which is usually imperative (such as [[C (programming language)|C]]). == See also == * [[:Category:Declarative programming languages]] * [[Comparison of programming paradigms]] * [[Constraint programming]] * [[Domain-specific language]] * [[Functional programming]] * [[Imperative programming]] (contrast) * [[Logic programming]] == References == {{More footnotes|date=April 2010}} {{Reflist|colwidth=30em}} == External links == * Frans Coenen. [http://www.csc.liv.ac.uk/~frans/OldLectures/2CS24/declarative.html#detail Characteristics of declarative programming languages]. 1999. * Olof Torgersson. [http://www.cs.chalmers.se/~oloft/Papers/wm96/wm96.html A Note on Declarative Programming Paradigms and the Future of Definitional Programming]. 1996. {{Programming language}} {{DEFAULTSORT:Declarative Programming}} [[Category:Programming paradigms]] [[Category:Declarative programming|*]] [[cs:Deklarativní programování]] [[de:Deklarative Programmierung]] [[el:Δηλωτικός προγραμματισμός]] [[es:Programación declarativa]] [[fa:زبان‌های اعلانی]] [[fr:Programmation déclarative]] [[ko:선언형 프로그래밍]] [[it:Programmazione dichiarativa]] [[he:תכנות הצהרתי]] [[nl:Declaratieve taal]] [[ja:宣言型プログラミング]] [[pl:Programowanie deklaratywne]] [[pt:Programação declarativa]] [[ru:Декларативное программирование]] [[sv:Deklarativ programmering]] [[uk:Декларативне програмування]] [[zh:宣告式編程]]</text> </page> <page> <id>9767</id> <title>Dedekind number</title> <text><imagemap> Image:Monotone Boolean functions 0,1,2,3.svg|400px|thumb|right|The free distributive lattices of monotonic Boolean functions on 0, 1, 2, and 3 arguments, with 2, 3, 6, and 20 elements respectively <small>(move mouse over right diagram to see description)</small> circle 659 623 30 [[File:Boolean function 0000 0000.svg|contradiction]] circle 658 552 35 [[File:Boolean functions like 1000 0000.svg|A and B and C]] circle 587 480 35 [[File:Boolean functions like 1000 1000.svg|A and B]] circle 659 481 35 [[File:Boolean functions like 1010 0000.svg|A and C]] circle 729 481 35 [[File:Boolean functions like 1100 0000.svg|B and C]] circle 588 410 35 [[File:Boolean functions like 1010 1000.svg|(A and B) or (A and C)]] circle 658 410 35 [[File:Boolean functions like 1100 1000.svg|(A and B) or (B and C)]] circle 729 410 35 [[File:Boolean functions like 1110 0000.svg|(A and C) or (B and C)]] circle 548 339 30 [[File:Boolean functions like 1010 1010.svg|A]] circle 604 339 30 [[File:Boolean functions like 1100 1100.svg|B]] circle 758 339 30 [[File:Boolean functions like 1111 0000.svg|C]] circle 661 339 35 [[File:Boolean functions like 1110 1000.svg|(A or B) and (A or C) and (B or C) <====> (A and B) or (A and C) or (B and C)]] circle 588 268 35 [[File:Boolean functions like 1110 1010.svg|(A or B) and (A or C)]] circle 659 267 35 [[File:Boolean functions like 1110 1100.svg|(A or B) and (B or C)]] circle 729 268 35 [[File:Boolean functions like 1111 1000.svg|(A or C) and (B or C)]] circle 588 197 35 [[File:Boolean functions like 1110 1110.svg|A or B]] circle 658 197 35 [[File:Boolean functions like 1111 1010.svg|A or C]] circle 729 197 35 [[File:Boolean functions like 1111 1100.svg|B or C]] circle 658 126 35 [[File:Boolean functions like 1111 1110.svg|A or B or C]] circle 659 56 30 [[File:Boolean function 1111 1111.svg|tautology]] desc bottom-left </imagemap> In [[mathematics]], the '''Dedekind numbers''' are a rapidly-growing [[integer sequence|sequence of integers]] named after [[Richard Dedekind]], who defined them in 1897. The Dedekind number ''M''(''n'') counts the number of [[Monotone boolean function|monotonic Boolean functions]] of ''n'' variables. Equivalently, it counts the [[Antichain#Integer sequences|number of antichains]] of subsets of an ''n''-element set, the number of elements in a [[Free distributive lattice|free distributive lattice]] with ''n'' generators, or the number of [[abstract simplicial complex]]es with ''n'' elements. Finding a closed-form expression for ''M''(''n'') is known as '''Dedekind's problem'''. Although accurate [[asymptotic expansion|asymptotic]] estimates of ''M''(''n''),<ref>{{harvtxt|Kleitman|Markowsky|1975}}; {{harvtxt|Korshunov|1981}}; {{harvtxt|Kahn|2002}}.</ref> and an exact expression as a [[summation]],<ref>{{harvtxt|Kisielewicz|1988}}.</ref> are known, computing ''M''(''n'') remains difficult and its exact values have been found only for ''n'' ≤ 8.<ref>{{harvtxt|Wiedemann|1991}}.</ref> ==Definitions== A [[Boolean function]] is a function that takes as input ''n'' [[Boolean data type|Boolean variables]] (that is, values that can be either false or true, or equivalently [[bit|binary values]] that can be either 0 or 1), and produces as output another Boolean variable. It is [[monotonic]] if, for every combination of inputs, switching one of the inputs from false to true can only cause the output to switch from false to true and not from true to false. The Dedekind number ''M''(''n'') is the number of different monotonic Boolean functions on ''n'' variables. An [[antichain]] of sets (also known as a [[Sperner family]]) is a family of sets, none of which is contained in any other set. If ''V'' is a set of ''n'' Boolean variables, an antichain ''A'' of subsets of ''V'' defines a monotone Boolean function ''f'', where the value of ''f'' is true for a given set of inputs if some subset of the true inputs to ''f'' belongs to ''A'' and false otherwise. Conversely every monotone Boolean function defines in this way an antichain, of the minimal subsets of Boolean variables that can force the function value to be true. Therefore, the Dedekind number ''M''(''n'') equals the number of different antichains of subsets of an ''n''-element set.<ref>{{harvtxt|Kahn|2002}}.</ref> A third, equivalent way of describing the same class of objects uses [[lattice theory]]. From any two monotone Boolean functions ''f'' and ''g'' we can find two other monotone Boolean functions ''f'' ∧ ''g'' and ''f'' ∨ ''g'', their [[logical conjunction]] and [[logical disjunction]] respectively. The family of all monotone Boolean functions on ''n'' inputs, together with these two operations, forms a [[distributive lattice]], the lattice given by [[Birkhoff's representation theorem]] from the [[partially ordered set]] of subsets of the ''n'' variables with set inclusion as the partial order. This construction produces the [[Free distributive lattice|free distributive lattice]] with ''n'' generators.<ref>The definition of free distributive lattices used here allows as lattice operations any finite meet and join, including the empty meet and empty join. For the free distributive lattice in which only pairwise meets and joins are allowed, one should eliminate the top and bottom lattice elements and subtract two from the Dedekind numbers.</ref> Thus, the Dedekind numbers count the number of elements in free distributive lattices.<ref>{{harvtxt|Church|1940}}; {{harvtxt|Church|1965}}; {{harvtxt|Zaguia|1993}}.</ref> The Dedekind numbers also count the number of [[abstract simplicial complex]]es on ''n'' 