way that local transactions (confined to a single database) cannot be identified as such by an autonomous database system. This is realistic for some transactional objects, but less realistic for general purpose database systems. If autonomy is augmented with the ability to identify local transactions, then compliance with a more general property, ''Extended commitment ordering'' (ECO, see below), is the necessary condition. ===Summary=== The ''Commitment ordering'' (CO) solution (technique) for ''[[Global serializability]]'' can be summarized as follows: If each ''database'' (or any other ''transactional object'') in a multidatabase environment complies with CO, i.e., arranges its local transactions' commitments and its votes on (global, distributed) transactions to the ''[[atomic commitment]]'' protocol according to the local (to the database) [[partial order]] induced by the local [[serializability#Testing conflict serializability|conflict graph]] (serializability graph) for the respective transactions, then ''Global CO'' and ''Global serializability'' are guaranteed. A database's CO compliance can be achieved effectively with any local [[Serializability#View serializability and conflict serializability|conflict serializability]] based concurrency control mechanism, with neither affecting any transaction's execution process or scheduling, nor aborting it. Also the database's autonomy is not violated. The only low overhead incurred is detecting conflicts (e.g., as with locking, but with no data-access blocking; if not already detected for other purposes), and ordering votes and local transactions' commits according to the conflicts. [[Image:CO-ScheduleClasses.jpg|thumb|350px| '''Schedule classes containment:''' An arrow from class A to class B indicates that class A strictly contains B; a lack of a directed path between classes means that the classes are incomparable. A property is '''inherently-blocking''', if it can be enforced only by blocking transactionâ€™s data access operations until certain events occur in other transactions. ([[#Raz1992|Raz 1992]])]] In case of incompatible partial orders of two or more databases (no global partial order can [[Embedding|embed]] the respective local partial orders together), a global cycle (spans two databases or more) in the global conflict graph is generated. This, together with CO, results in a cycle of blocked votes, and a ''voting-[[deadlock]]'' occurs for the databases on that cycle (however, allowed concurrent voting in each database, typically for almost all the outstanding votes, continue to execute). In this case the atomic commitment protocol fails to collect all the votes needed for the blocked transactions on that global cycle, and consequently the protocol aborts some transaction with a missing vote. This breaks the global cycle, the voting-deadlock is resolved, and the related blocked votes are free to be executed. Breaking the global cycle in the global conflict graph ensures that both Global CO and [[Global serializability]] are maintained. Thus, in case of incompatible local (partial) commitment orders no action is needed since the atomic commitment protocol resolves it automatically by aborting a transaction that is a cause for the incompatibility. Furthermore, also global deadlocks due to locking (global cycles in the ''augmented conflict graph'' with at least one data access blocking) result in voting deadlocks and are resolved automatically by the same mechanism. ''Local CO'' is a necessary condition for guaranteeing ''Global serializability,'' if the databases involved do not share any concurrency control information beyond (unmodified) atomic commitment protocol messages, i.e., if the databases are ''autonomous'' in the context of concurrency control. This means that every global serializability solution for autonomous databases must comply with CO. Otherwise global serializability may be violated (and thus, is likely to be violated very quickly in a high-performance environment). The CO solution [[Scalability|scales up]] with network size and the number of databases without performance penalty when it utilizes [[Two-phase commit protocol#Common architecture|common distributed atomic commitment architecture]]. See [[Commitment ordering#Examples|Examples]] below. ==Distributed serializability and CO== The previous section explains how CO guarantees [[Global serializability]] in a multidatabase and multi transactional-object environment. This section explores the conditions under which CO provides [[serializability#Distributed serializability|Distributed serializability]], i.e., [[Serializability]] in a general [[Distributed computing|distributed]] transactional environment (e.g., a [[distributed database]] system), achieving a major goal of [[distributed concurrency control]]. ===Distributed CO=== A distinguishing characteristic of the CO solution to distributed serializability from other techniques is the fact that it requires no conflict information distributed (e.g., local precedence relations, locks, [[Timestamp-based concurrency control|timestamps]], tickets), which makes it uniquely effective. It utilizes (unmodified) [[atomic commitment]] protocol messages (which are already used) instead. A common way to achieve distributed serializability in a [[Distributed system|(distributed) system]] is by a [[distributed lock manager]] (DLM). DLMs, which communicate lock (non-materialized conflict) information in a distributed environment, typically suffer from computer and communication [[Latency (engineering)|latency]], which reduces the performance of the system. CO allows to achieve distributed serializability under very general conditions, without a distributed lock manager, exhibiting the benefits already explored above for multidatabase environments; in particular: [[Reliability engineering|reliability]], high performance, [[scalability]], possibility of using ''[[optimistic concurrency control]]'' when desired, no conflict information related communications over the network (which have incurred overhead and delays), and automatic distributed deadlock resolution. All ''distributed transactional systems'' rely on some [[atomic commitment]] protocol to coordinate [[atomicity (database systems)|atomicity]] (whether to commit or abort) among processes in a [[distributed transaction]]. Also, typically ''recoverable data'' (i.e., data under transactions' control, e.g., database data; not to be confused with the ''[[Serializability#Correctness - recoverability|recoverability]]'' property of a schedule) are directly accessed by a single ''transactional data manager'' component (also referred to as a ''resource manager'') that handles local sub-transactions (the distributed transaction's portion in a single location, e.g., network node), even if these data are accessed indirectly by other entities in the distributed system during a transaction (i.e., indirect access requires a direct access through a local sub-transaction). Thus recoverable data in a distributed transactional system are typically partitioned among transactional data managers. In such system these transactional data managers typically comprise the participants in the system's atomic commitment protocol. If each participant complies with CO (e.g., by using SS2PL, or COCOs, or a combination; see above), then the entire distributed system provides CO (by the theorems above; each participant can be considered a separate transactional object), and thus (distributed) serializability. Furthermore: When CO is utilized together with an atomic commitment protocol also ''distributed deadlocks'' (i.e., deadlocks that span two 