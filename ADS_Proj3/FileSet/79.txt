bound on how much ''n'' can increase — and it will often increase greatly. The Péter-Ackermann function can also be expressed in terms of various other versions of the Ackermann function: * the indexed version of [[Knuth's up-arrow notation]] (extended to integer indices ≥ -2): ::''A''(''m'', ''n'') = <math>2\uparrow^{m-2} (n+3) - 3.</math> :The part of the definition ''A''(''m'', 0) = A(''m''-1, 1) corresponds to <math>2\uparrow^{m+1} 3=2\uparrow^m 4.</math> * [[hyper operator]]s: ::''A''(''m'', ''n'') = hyper(2, m, n + 3) − 3. * [[Conway chained arrow]] notation: ::''A''(''m'', ''n'') = (2 → (''n''+3) → ''(m'' − 2)) − 3 for ''m'' > 2 :hence ::2 → ''n'' → ''m'' = ''A''(''m''+2,''n''-3) + 3 for ''n''>2. :(''n''=1 and ''n''=2 would correspond with ''A''(''m'',−2) = −1 and ''A''(''m'',−1) = 1, which could logically be added.) For small values of ''m'' like 1, 2, or 3, the Ackermann function grows relatively slowly with respect to ''n'' (at most [[exponential growth|exponentially]]). For ''m'' ≥ 4, however, it grows much more quickly; even ''A''(4, 2) is about 2{{e|19728}}, and the decimal expansion of ''A''(4, 3) is very large by any typical measure. If we define the function ''f'' (''n'') = ''A''(''n'', ''n''), which increases both ''m'' and ''n'' at the same time, we have a function of one variable that dwarfs every primitive recursive function, including very fast-growing functions such as the [[exponential function]], the factorial function, multi- and [[superfactorial]] functions, and even functions defined using Knuth's up-arrow notation (except when the indexed up-arrow is used). This extreme growth can be exploited to show that ''f'', which is obviously computable on a machine with infinite memory such as a [[Turing machine]] and so is a [[computable function]], grows faster than any primitive recursive function and is therefore not primitive recursive. In a category with exponentials, using the isomorphism <math>A \times B \rightarrow C \cong A \rightarrow (B \rightarrow C)</math> (in computer science, this is called [[currying]]), the Ackermann function may be defined via primitive recursion over higher-order functionals as follows: :<math> \begin{array}{lcl} \operatorname{Ack}(0) & = & \operatorname{Succ} \\ \operatorname{Ack}(m+1) & = & \operatorname{Iter}(\operatorname{Ack}(m)) \end{array} </math> where ''Succ'' is the usual [[successor function]] and ''Iter'' is defined by primitive recursion as well: :<math> \begin{array}{lcl} \operatorname{Iter}(f)(0) & = & f(1) \\ \operatorname{Iter}(f)(n+1) & = & f(\operatorname{Iter}(f)(n)). \end{array} </math> One interesting aspect of the Ackermann function is that the only arithmetic operations it ever uses are addition and subtraction of 1. Its properties come solely from the power of unlimited recursion. This also implies that its running time is at least proportional to its output, and so is also extremely huge. In actuality, for most cases the running time is far larger than the output; see below. ==Table of values== Computing the Ackermann function can be restated in terms of an infinite table. We place the natural numbers along the top row. To determine a number in the table, take the number immediately to the left, then look up the required number in the previous row, at the position given by the number just taken. If there is no number to its left, simply look at the column headed "1" in the previous row. Here is a small upper-left portion of the table: {| class="wikitable" |+ Values of ''A''(''m'', ''n'') |- ! ''m''\''n'' ! 0 ! 1 ! 2 ! 3 ! 4 ! n |- ! 0 | 1 || 2 || 3 || 4 || 5 || <math>n + 1</math> |- ! 1 | 2 || 3 || 4 || 5 || 6 || <math>n + 2 = 2 + (n + 3) - 3</math> |- ! 2 | 3 || 5 || 7 || 9 || 11 || <math>2n + 3 = 2\cdot(n + 3) - 3</math> |- ! 3 | 5 || 13 || 29 || 61 || 125 || <math>2^{(n+3)} - 3</math> |- ! 4 | 13 || 65533 | 2<sup>65536</sup> − 3 | <math>{2^{2^{65536}}} - 3</math> | <math>{2^{2^{2^{65536}}}} - 3</math> | <math>\begin{matrix}\underbrace{{2^2}^{{\cdot}^{{\cdot}^{{\cdot}^2}}}} - 3 \\n\mbox{ + 3}\end{matrix}</math> |} The numbers listed here in a recursive reference are very large and cannot be easily notated in some other form. Despite the large values occurring in this early section of the table, some even larger numbers have been defined, such as [[Graham's number]], which cannot be written with any small number of [[Knuth's up-arrow notation|Knuth arrows]]. This number is constructed with a technique similar to applying the Ackermann function to itself recursively. This is a repeat of the above table, but with the values replaced by the relevant expression from the function definition to show the pattern clearly: {| class="wikitable" |+ Values of ''A''(''m'', ''n'') |- ! ''m''\''n'' ! 0 ! 1 ! 2 ! 3 ! 4 ! n |- ! 0 | 0+1 || 1+1 || 2+1 || 3+1 || 4+1 || <math>n + 1</math> |- ! 1 | A(0,1) || A(0,A(1,0)) || A(0,A(1,1)) || A(0,A(1,2)) || A(0,A(1,3)) || <math>n + 2 = 2 + (n + 3) - 3</math> |- ! 2 | A(1,1) || A(1,A(2,0)) || A(1,A(2,1)) || A(1,A(2,2)) || A(1,A(2,3)) || <math>2n + 3 = 2\cdot(n + 3) - 3</math> |- ! 3 | A(2,1) || A(2,A(3,0)) || A(2,A(3,1)) || A(2,A(3,2)) || A(2,A(3,3)) || <math>2^{(n+3)} - 3</math> |- ! 4 | A(3,1) || A(3,A(4,0)) || A(3,A(4,1)) || A(3,A(4,2)) || A(3,A(4,3)) || <math>\begin{matrix}\underbrace{{2^2}^{{\cdot}^{{\cdot}^{{\cdot}^2}}}} - 3 \\n\mbox{ + 3}\end{matrix}</math> |- ! 5 | A(4,1) || A(4,A(5,0)) || A(4,A(5,1)) || A(4,A(5,2)) || A(4,A(5,3)) || ''A''(4, ''A''(5, n-1)) |- ! 6 | A(5,1) || A(5,A(6,0)) || A(5,A(6,1)) || A(5,A(6,2)) || A(5,A(6,3)) || ''A''(5, ''A''(6, n-1)) |} ==Expansion== To see how the Ackermann function grows so quickly, it helps to expand out some simple expressions using the rules in the original definition. For example, we can fully evaluate <math>A(1, 2)</math> in the following way: :<math>\begin{align} A(1,2) & = A(0, A(1, 1)) \\ & = A(0, A(0, A(1, 0))) \\ & = A(0, A(0, A(0, 1))) \\ & = A(0, A(0, 2)) \\ & = A(0, 3) \\ & = 4. \end{align}</math> To demonstrate how <math>A(4, 3)</math>'s 