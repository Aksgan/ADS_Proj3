clause <math>a</math> is now removed from the set. The resulting set of clause is equivalent to the original one under the assumption of validity of the literals in the partial model. ==Complexity== The direct implementation of unit propagation takes time [[quadratic growth|quadratic]] in the total size of the set to check , which is defined to be the sum of the size of all clauses, where the size of each clause is the number of literals it contains. Unit propagation can however be done in linear time by storing, for each variable, the list of clauses in which each literal is contained. For example, the set above can be represented by numbering each clause as follows: : <math>\{1: a \vee b, 2: \neg a \vee c, 3: \neg c \vee d, 4: a\}</math> and then storing, for each variable, the list of clauses containing the variable or its negation: : <math>a : 1\ 2\ 4</math> : <math>b : 1\,</math> : <math>c : 2\ 3</math> : <math>d : 3\, </math> This simple data structure can be built in time linear in the size of the set, and allows finding all clauses containing a variable very easily. Unit propagation of a literal can be performed efficiently by scanning only the list of clauses containing the variable of the literal. More precisely, the total running time for doing unit propagation for all unit clauses is linear in the size of the set of clauses. ==See also== * [[Horn-satisfiability|Horn satisfiability]] * [[Horn clause]] * [[Automated theorem proving]] * [[DPLL algorithm]] ==References== * W. Dowling and J. Gallier (1984). Linear-time algorithms for testing the satisfiability of propositional Horn formulae. <em>Journal of Logic Programming</em>, 1(3):267&ndash;284. * H. Zhang and M. Stickel (1996). An efficient algorithm for unit-propagation. In <em>Proceedings of the Fourth International Symposium on Artificial Intelligence and Mathematics</em>. {{DEFAULTSORT:Unit Propagation}} [[Category:Automated theorem proving]] [[nl:One-literal rule]]</text> </page> <page> <id>38858</id> <title>Unit type</title> <text>{{About|the notion used in [[computer programming]] and [[type theory]]|types of measurement units|Units of measurement|other uses|Unit (disambiguation)}} In the area of [[mathematical logic]], and [[computer science]] known as [[type theory]], a '''unit type''' is a [[data type|type]] that allows only one value (and thus can hold no information).<!-- see general reference at the end and WP:CITE --> The carrier (underlying set) associated with a unit type can be any [[singleton set]]. There is an [[isomorphism]] between any two such sets, so it is customary to talk about ''the'' unit type and ignore the details of its value. One may also regard the unit type as the type of 0-[[tuple]]s, i.e. the [[product (category theory)|product]] of no types. The unit type is the [[terminal object]] in the [[category theory|category]] of types and typed functions. It should not be confused with the '''zero''' or [[bottom type]], which allows ''no'' values and is the [[initial object]] in this category. The unit type is implemented in most [[functional programming language]]s. The [[void type]] that is used in some imperative programming languages serves some of its functions, but because its carrier set is empty, there are some limitations (as detailed below). ==In programming languages== Several computer [[programming language]]s provide a unit type to specify the result type of a [[function (computer science)|function]] with the sole purpose of causing a [[side effect (computer science)|side effect]], and the argument type of a function that does not require arguments. *In the [[functional programming]] language [[Haskell (programming language)|Haskell]], the unit type is called <code>()</code> and its only value is also <code>()</code>, reflecting the 0-tuple interpretation. *In [[ML programming language|ML]], the type is called <code>unit</code> but the value is written as <code>()</code>. *In [[Scala (programming language)|Scala]], the unit type is called <code>Unit</code> and its only value is written as <code>()</code>. *In [[Common Lisp]] the type named <tt>NULL</tt> is a unit type which has one value, namely the symbol <tt>NIL</tt>. <tt>NIL</tt> itself is used as the name of the [[bottom type]]. The unit type is useful even in functions without side effects if the programming language supports [[algebraic data types]]. Any [[nullary]] [[data constructor]] is effectively isomorphic with the unit type. One can solve the [[semipredicate problem]] (the problem of distinguishing between a "normal" return value of a function and an "error") elegantly in such a language, by encoding the "error" as the unit type. In Haskell, the [[parametric polymorphism|polymorphic type]] <code>Maybe</code> is predefined for this purpose. Here <code>Nothing</code> is isomorphic to the unit type: <pre> data Maybe a = Nothing | Just a </pre> The type <code>Maybe</code> is called the [[option type]] in type theory. === Void type as unit type === In [[C programming language|C]], [[C++]], [[C Sharp (programming language)|C#]], and [[Java (programming language)|Java]], <code>[[void return type|void]]</code> expresses the empty type. The unit type in C would be <code>struct {}<code>, but an empty struct is forbidden by the C language specification. Instead void is used in a manner that simulates some, but not all, of the properties of the unit type, as detailed below. Like most imperative languages, C allows functions that do not return a value; these are specified as having the void return type. Such functions are called procedures in other imperative languages like [[Pascal (programming language)|Pascal]], where a syntactic, instead of type-system distinction, is made between functions and procedures. ==== Difference in calling convention ==== The first notable difference between a true unit type and the void type is that the unit type may always be the type of the argument to a function, but the void type cannot be the type of an argument in C, despite the fact that it may appear as the sole argument in the list. This problem is best illustrated by the following program, which is a compile-time error in C: <source lang=c> void f(void) {} void g(void) {} int main(void) { f(g()); // compile-time error here return 0; } </source> This issue does not arise in most programming practice in C, because since the <code>void</code> type carries no information, it is useless to pass it anyway; but it may arise in [[generic programming]], such as 