[[es:Teoría algorítmica de la información]] [[fa:نظریه الگوریتمی اطلاعات]] [[fr:Théorie algorithmique de l'information]] [[ja:アルゴリズム情報理論]] [[ru:Алгоритмическая теория информации]] [[simple:Algorithmic information theory]] [[tr:Algoritmik bilgi teorisi]] [[zh:算法信息论]]</text> </page> <page> <id>1463</id> <title>Algorithmic skeleton</title> <text>In [[computing]], '''algorithmic skeletons''' (a.k.a. Parallelism Patterns) are a high-level [[parallel programming model]] for parallel and distributed computing. Algorithmic skeletons take advantage of common programming patterns to hide the complexity of parallel and distributed applications. Starting from a basic set of patterns (skeletons), more complex patterns can be built by combining the basic ones. ==Overview== The most outstanding feature of algorithmic skeletons, which differentiates them from other high-level parallel programming models, is that orchestration and synchronization of the parallel activities is implicitly defined by the skeleton patterns. Programmers do not have to specify the synchronizations between the application's sequential parts. This yields two implications. First, as the communication/data access patterns are known in advance, cost models can be applied to schedule skeletons programs<ref>''K. Hammond and G. Michelson, editors.'' "Research Directions in Parallel Functional Programming." Springer-Verlag, London, UK, 1999.</ref>. Second, that algorithmic skeleton programming reduces the number of errors when compared to traditional lower-level parallel programming models (Threads, MPI). ==History== Algorithmic skeletons were first introduced by Cole <ref name="cole_thesis">''Murray Cole.'' "Algorithmic Skeletons: structured management of parallel computation" MIT Press, Cambdridge, MA, USA, 1989</ref> in 1989. Several frameworks have been proposed by different research groups using different techniques such as functional, imperative, custom and object oriented languages. A recent survey of algorithmic skeleton frameworks can be found in <ref name="survey_2010">''Horacio González-Vélez and Mario Leyton'' "A survey of algorithmic skeleton frameworks: high-level structured parallel programming enablers" Software: Practice and Experience Volume 40, Issue 12, pages 1135-1160, November/December 2010. [http://onlinelibrary.wiley.com/doi/10.1002/spe.1026/abstract View Article]</ref>. ==Well-known skeleton patterns== This section describes some well known Algorithmic Skeleton patterns. Additionally, the patterns signature in the [http://skandium.niclabs.cl Skandium] library is provided for clarity. * '''FARM''' is also known as '''master-slave'''. Farm represents task replication where the execution of different tasks by the same farm are replicated and executed in parallel. <source lang="java"> Farm(Skeleton<P,R> skeleton){...} </source> * '''PIPE''' represents staged computation. Different tasks can be computed simultaneously on different pipe stages. A pipe can have a variable number of stages, each stage of a pipe may be a nested skeleton pattern. Note that an n-stage pipe can be composed by nesting n-1 2-stage pipes. <source lang="java"> <X> Pipe(Skeleton<P,X> stage1, Skeleton<P,X> stage2){...} </source> * '''FOR''' represents fixed iteration, where a task is executed a fixed number of times. In some implementations the executions may take place in parallel. <source lang="java"> For(Skeleton<P,X> skeleton, int times){...} </source> * '''WHILE''' represents conditional iteration, where a given skeleton is executed until a condition is met. <source lang="java"> public While(Skeleton<P,P> skeleton, Condition<P> condition){...} </source> * '''IF''' represents conditional branching, where the execution choice between two skeleton patterns is decided by a condition. <source lang="java"> If(Condition<P> condition, Skeleton<P,R> trueCase, Skeleton<P,R> falseCase){...} </source> * '''MAP''' represents ''split'', ''execute'', ''merge'' computation. A task is divided into sub-tasks, sub-tasks are executed in parallel according to a given skeleton, and finally sub-task's results are merged to produce the original task's result. <source lang="java"> <X,Y> Map(Split<P,X> split, Skeleton<X,Y> skeleton, Merge<Y,R> merge){...} </source> * '''D&C''' represents divide and conquer parallelism. A task is recursively sub-divided until a condition is met, then the sub-task is executed and results are merged while the recursion is unwound. <source lang="java"> DaC(Condition<P> condition, Split<P,P> split, Skeleton<P,R> skeleton, Merge<R,R> merge){...} </source> * '''SEQ''' does not represent parallelism, but it is often used a convenient tool to wrap code as the leafs of the skeleton nesting. <source lang="java"> public Seq(Execute <P,R> execute){...} </source> ==Example program== The following example is based on the Java [http://skandium.niclabs.cl Skandium] library for parallel programming. The objective is to implement an Algorithmic Skeleton based parallel version of the '''QuickSort''' algorithm using the Divide and Conquer pattern. Notice that the high-level approach hides Thread management from the programmer. <source lang="java"> // 1. Define the skeleton program Skeleton<Range, Range> sort = new DaC<Range, Range>( new ShouldSplit(threshold, maxTimes), new SplitList(), new Sort(), new MergeList()); // 2. Input parameters Future<Range> future = sort.input(new Range(generate(...))); // 3. Do something else here. // ... // 4. Block for the results Range result = future.get(); </source> # The first thing is to define a new instance of the skeleton with the functional code that fills the pattern (ShouldSplit, SplitList, Sort, MergeList). The functional code is written by the programmer without parallelism concerns. # The second step is the input of data which triggers the computation. In this case Range is a class holding an array and two indexes which allow the representation of a subarray. For every data entered into the framework a new Future object is created. More than one Future can be entered into a skeleton simultaneously. # The Future allows for asynchronous computation, as other tasks can be performed while the results are computed. # We can retrieve the result of the computation, blocking if necessary (i.e. results not yet available). The functional codes in this example correspond to four types Condition, Split, Execute, and Merge. <source lang="java"> public class ShouldSplit implements Condition<Range>{ int threshold, maxTimes, times; public ShouldSplit(int threshold, int maxTimes){ this.threshold = threshold; this.maxTimes = maxTimes; this.times = 0; } @Override public synchronized boolean condition(Range r){ return r.right - r.left > threshold && times++ < this.maxTimes; } } </source> The ShouldSplit class implements the Condition interface. The function receives an input, Range r in this case, and returning true or false. In the context of the Divide and Conquer where this function will be used, this will decide whether a sub-array should be subdivided again or not. The SplitList class implements the split interface, which in this case divides an (sub-)array into smaller sub-arrays. The class uses a helper function <code>partition(...)</code> which implements the well known QuickSort pivot and swap scheme. <source lang="java"> public class SplitList implements Split<Range, Range>{ @Override public Range[] split(Range r){ int i = partition(r.array, r.left, r.right); Range[] intervals = {new Range(r.array, r.left, i-1), new Range(r.array, i+1, r.right)}; return intervals; } } </source> The Sort class implements and 