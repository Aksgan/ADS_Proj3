works other than fully functional versions of POV-Ray. Although the [[source code]] is available for modification, due to specific restrictions, it is not [[open source]] according to the [[Open Source Initiative|OSI]] definition of the term. One of the reasons that POV-Ray is not licensed under the free software [[GNU General Public License]] (GPL), or other open source licenses, is that POV-Ray was developed before the GPL-style licenses became widely used; the developers wrote their own license for the release of POV-Ray, and contributors to the software have worked under the assumption that their contributions would be licensed under the POV-Ray License. A complete rewrite of POV-Ray ("POV-Ray 4.0") is currently under discussion, which would use a more liberal license, most likely [[GPL#Version 3|GPL v3]].<ref>{{cite web | url=http://news.povray.org/povray.general/message/%3C46e091ef%241%40news.povray.org%3E/#%3C46e091ef%241%40news.povray.org%3E | title=Re: Status of Moray? (''The answer is about POVRay'') | last=Cason|first=Chris | date=6 September 2007 | quote=''Now that process has been completed, as a group we feel the GPL3 is the way to go and have informally decided that 4.0 will be GPL3-licensed.'' | accessdate=9 December 2007}}</ref> ==See also== {{commons|POV-Ray}} *[[YafaRay]] A popular free open-source raytracing engine *[[Kerkythea]] Free ray tracing program with enhanced [[Sketchup]] compatibility *[[Sunflow]] an open source rendering system for photo-realistic image synthesis written in Java *[[Blender (software)|Blender]] a free and open-source software program for 3D modeling, animation, and rendering *[[Internet Ray Tracing Competition]] has a large number of submissions from POV-Ray users ==References== {{Reflist}} ==External links== {{commonscat|Created with Persistence of Vision}} *[http://www.povray.org/ POV-Ray homepage] *{{dmoz|Computers/Software/Graphics/3D/Animation_and_Design_Tools/POV-Ray}} {{DEFAULTSORT:Pov-Ray}} [[Category:Freeware 3D graphics software]] [[Category:Domain-specific programming languages]] [[Category:Global illumination software]] [[Category:Articles with example code]] [[Category:Cross-platform software]] [[af:POV-Ray]] [[ca:POV-Ray]] [[cs:POV-Ray]] [[de:POV-Ray]] [[es:POV-Ray]] [[fr:POV-Ray]] [[ko:POV-Ray]] [[hr:POV-Ray]] [[it:POV-Ray]] [[nl:Persistence of Vision Raytracer]] [[ja:POV-Ray]] [[pl:POV-Ray]] [[pt:POV-Ray]] [[ru:POV-Ray]] [[fi:POV-Ray]] [[sv:POV-Ray]] [[tr:POV-Ray]] [[vi:POV-Ray]] [[zh:POV-Ray]]</text> </page> <page> <id>28155</id> <title>PPA (complexity)</title> <text>PPA is a [[complexity class]], standing for "Polynomial Parity Argument" (on a graph). Introduced by [[Christos Papadimitriou]] in 1994<ref>{{cite journal | author = Christos Papadimitriou | year = 1994 | title = On the complexity of the parity argument and other inefficient proofs of existence | journal = [[Journal of Computer and System Sciences]] | volume = 48 | issue = 3 | pages = 498–532 | url = http://www.cs.berkeley.edu/~christos/papers/On%20the%20Complexity.pdf | doi = 10.1016/S0022-0000(05)80063-7}}</ref> (page 528), PPA is a subclass of [[TFNP]]. It is a class of search problems that can be shown to be total by an application of the [[handshaking lemma]]: ''any undirected graph that has a vertex whose degree is an odd number must have some other vertex whose degree is an odd number''. This observation means that if we are given a graph and an odd-degree vertex, and we are asked to find some other odd-degree vertex, then we are searching for something that is guaranteed to exist (so, we have a total search problem). PPA is defined as follows. Suppose we have a graph on whose vertices are n-bit binary strings, and the graph is represented by a polynomial-sized circuit that takes a vertex as input and outputs its neighbors. (Note that this allows us to represent an exponentially-large graph on which we can efficiently perform local exploration.) Suppose furthermore that a specific vertex (say the all-zeroes vector) has an odd number of neighbors. We are required to find another odd-degree vertex. Note that this problem is in NP - given a solution it may be verified using the circuit that the solution is correct. A function computation problem belongs to PPA if it admits a [[polynomial-time reduction]] to this graph search problem. A problem is [[Complete_(complexity)|complete]] for the class PPA if in addition, this graph search problem is reducible to that problem. PPA contains [[PPAD]] as a subclass. This is because the corresponding problem that defines PPAD, known as END OF THE LINE, can be reduced (in a straightforward way) to the above search for an additional odd-degree vertex (essentially, just by ignoring the directions of the edges in END OF THE LINE). There is an un-oriented version of the Sperner lemma known to be complete for PPA<ref>{{cite journal | author = Michelangelo Grigni | year = 1995 | title = A Sperner Lemma Complete for PPA | journal = [[Information Processing Letters]] | volume = 77 | pages = 255–259 | doi = 10.1016/S0020-0190(00)00152-6}}</ref>. The problem of searching for a second [[Hamiltonian_cycle | Hamiltonian cycle]] on a 3-regular graph is a member of PPA, but is not known to be complete for PPA. ==References== {{reflist}} [[Category:Complexity classes]]</text> </page> <page> <id>28162</id> <title>PQ tree</title> <text>A '''PQ tree''' is a tree-based [[data structure]] that represents a family of [[permutation]]s on a set of elements, discovered and named by [[Kellogg S. Booth]] and [[George S. Lueker]] in 1976. It is a rooted, labeled tree, in which each element is represented by one of the [[leaf node]]s, and each non-leaf node is labelled P or Q. A P node has at least two children, and a Q node has at least three children. A PQ tree represents its permutations via permissible reorderings of the children of its nodes. The children of a P node may be reordered in any way. The children of a Q node may be put in reverse order, but may not otherwise be reordered. A PQ tree represents all leaf node orderings that can be achieved by any sequence of these two operations. A PQ tree with many P and Q nodes can represent complicated subsets of the set of all possible orderings. However, not every set of orderings may be representable in this way; for instance, if an ordering is represented by a PQ tree, the reverse of the ordering must also be represented by the same tree. PQ trees are used to solve problems where the goal is to find an ordering that satisfies various constraints. In these problems, constraints on the ordering are included one at a time, by modifying the PQ tree structure in such a way that it represents only orderings satisfying the constraint. Applications of PQ trees include creating a contig map from [[DNA]] fragments, testing a 