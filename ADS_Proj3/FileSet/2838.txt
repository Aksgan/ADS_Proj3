|- |yotta- <sup>Note 2</sup> |Y |10<sup>24</sup> |2<sup>80</sup> |} (1) k = 10<sup>3</sup> and K = 2<sup>10</sup> (2) Not generally used to express data throughput The power-of-10 multipliers and the power-of-2 multipliers for a given word prefix are almost, but not quite, the same. For example, the power-of-10 definition of kilo- (k) refers to 1,000, while the power-of-2 definition (K) refers to 1,024. As if this is not confusing enough, when referring to a data throughput of one kilobit per second (1 kbit/s), analysts generally mean 1,000 bits per second (10<sup>3</sup> bit/s), but when talking about one kilobyte (1 KB) of data storage, they usually mean 1,024 bytes (2<sup>10</sup> Bytes). This prevailing confusion could be eliminated (some computer scientists believe) by adopting special prefixes referring to the binary quantities. The proposed scheme is as follows. {| class="wikitable" |- !Full technical name !Proposed Prefix !Proposed Symbol !Numeric Multiplier |- |kilobinary |kibi- |Ki |2<sup>10</sup> |- |megabinary |mebi- |Mi |2<sup>20</sup> |- |gigabinary |gibi- |Gi |2<sup>30</sup> |- |terabinary |tebi- |Ti |2<sup>40</sup> |- |petabinary |pebi- |Pi |2<sup>50</sup> |- |exabinary |exbi- |Ei |2<sup>60</sup> |} In scenarios such as the one mentioned above, if the new binary prefixes are used, it should be easy to know whether an engineer is talking or writing about the decimal or binary multiplier. We will know that one kilobit per second (1 kbit/s) means 1,000 bit/s, and one kibibyte (1 KiB) means 1,024 bytes, for example. As of January 2008, the binary prefix multipliers have not yet come into general use. Pronunciation: Based on a suggestion from [[NIST]], "the first syllable of the name of the binary-multiple prefix should be pronounced in the same way as the first syllable of the name of the corresponding International Standard (SI) prefix, and the second syllable should be pronounced as 'bee.'" Thus, "kibi" would be pronounced "KIH-bee"; "mebi" would be "MEH-bee", and so forth ==Confusing and inconsistent use of prefixes== It is usual for people to abbreviate commonly used expressions. For file sizes, it is usual for someone to say that they have a '64 k' file (meaning 64 kilobytes), or a '100 meg' file (meaning 100 megabytes). When talking about circuit [[bit rate]]s, people will interchangeably use the terms [[throughput]], [[Bandwidth (computing)|bandwidth]] and speed, and refer to a circuit as being a '64 k' circuit, or a '2 meg' circuit &mdash; meaning 64 kbit/s or 2 Mbit/s (see also the [[List of device bandwidths|List of connection bandwidths]]). A '64 k' circuit will, therefore, not transmit a '64 k' file in one second. This may not be obvious to those unfamiliar with telecommunications and computing, so misunderstandings sometimes arise. In actuality, a 64 kilobyte file is 64 × 1,024 × 8 bits in size and the 64 k circuit will transmit bits at a rate of 64 × 1,000 bit/s, so the amount of time taken to transmit a 64 kilobyte file over the 64 k circuit will be at least (64 × 1,024 × 8)/(64 × 1,000) seconds, which works out to be 8.192 seconds. ==Compression== Some equipment can improve matters by compressing the data as it is sent. This is a feature of most analogue [[modem]]s and of several popular [[operating system]]s. If the 64 k file can be shrunk by [[Data compression|compression]], the time taken to transmit can be reduced. This can be done invisibly to the user, so a highly compressible file may be transmitted considerably faster than expected. As this 'invisible' compression cannot easily be disabled, it therefore follows that when measuring throughputs by using files and timing the time to transmit, one should use files that cannot be compressed. Typically, this would mean using an already compressed file, such as a 'zip' file. Assuming your data cannot be compressed, the 8.192 seconds to transmit a 64 kilobyte file over a 64 kilobit/s communications link is a theoretical minimum time which will not be achieved in practice. This is due to the effect of overheads which are used to format the data in an agreed manner so that both ends of a connection have a consistent view of the data. ==Overheads and data formats== A common communications link used by many people is the [[asynchronous start-stop]], or just "asynchronous", serial link. If you have an external modem attached to your home or office computer, the chances are that the connection is over an asynchronous serial connection. Its advantage is that it is simple &mdash; it can be implemented using only three wires: Send, Receive and Signal Ground (or Signal Common). In an [[RS232]] interface, an idle connection has a continuous negative voltage applied. A 'zero' bit is represented as a positive voltage difference with respect to the Signal Ground and a 'one' bit is a negative voltage with respect to signal ground, thus indistinguishable from the idle state. This means you need to know when a 'one' bit starts to distinguish it from idle. This is done by agreeing in advance how fast data will be transmitted over a link, then using a start bit to signal the start of a byte &mdash; this start bit will be a 'zero' bit. Stop bits are 'one' bits i.e. negative voltage. Actually, more things will have been agreed in advance &mdash; the speed of bit transmission, the number of bits per character, the [[parity bit|parity]] and the number of stop bits (signifying the end of a character). So a designation of 9600-8-E-2 would be 9,600 bits per second, with eight bits per character, even parity and two stop bits. A common set-up of an asynchronous serial connection would be 9600-8-N-1 (9,600 bit/s, 8 bits per character, no parity and 1 stop bit) - this add up to 10 bits transmitted to send one 8 bit character (one start bit, the 8 bits making up the byte transmitted, no parity bit, and one stop bit). This is an overhead of 25%, so a 9,600 bit/s asynchronous serial link will not transmit data at 9600/8 bytes per second (1200 byte/s) but actually, in this 