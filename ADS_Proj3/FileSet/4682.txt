of a variable. Most languages define a specific ''scope'' for each variable (as well as any other named entity), which may differ within a given program. The scope of a variable is the portion of the program code for which the variable's name has meaning and for which the variable is said to be "visible". Entrance into that scope typically begins a variable's lifetime and exit from that scope typically ends its lifetime. For instance, a variable with "lexical scope" is meaningful only within a certain block of statements or [[subroutine]]. Variables only accessible within a certain functions are termed "[[local variable]]s". A "[[global variable]]", or one with indefinite scope, may be referred to anywhere in the program. ''Extent'', on the other hand, is a runtime ([[Dynamic variable scoping#Dynamic scoping|dynamic]]) aspect of a variable. Each [[name binding|binding]] of a variable to a value can have its own ''extent'' at runtime. The extent of the binding is the portion of the program's execution time during which the variable continues to refer to the same value or memory location. A running program may enter and leave a given extent many times, as in the case of a [[closure (computer science)|closure]]. In portions of code, a variable in scope may never have been given a value, or its value may have been destroyed. Such variables are described as "out of extent" or "unbound". In many languages, it is an error to try to use the value of a variable when it is out of extent. In other languages, doing so may yield [[undefined behavior|unpredictable results]]. Such a variable may, however, be assigned a new value, which gives it a new extent. By contrast, it is permissible for a variable binding to extend beyond its scope, as occurs in Lisp closures and C [[Local variable#Static local variables|static local variable]]s. When execution passes back into the variable's scope, the variable may once again be used. For space efficiency, a memory space needed for a variable may be allocated only when the variable is first used and freed when it is no longer needed. A variable is only needed when it is in scope, but beginning each variable's lifetime when it enters scope may give space to unused variables. To avoid wasting such space, compilers often warn programmers if a variable is declared but not used. It is considered good programming practice to make the scope of variables as narrow as feasible so that different parts of a program do not accidentally interact with each other by modifying each other's variables. Doing so also prevents [[action at distance (computer science)|action at a distance]]. Common techniques for doing so are to have different sections of a program use different [[namespace (programming)|namespace]]s, or to make individual variables "private" through either [[Dynamic variable scoping#Dynamic scoping|dynamic variable scoping]] or [[Lexical variable scoping#Static scoping|lexical variable scoping]]. Many programming languages employ a reserved value (often named ''[[null pointer|null]]'' or ''nil'') to indicate an invalid or uninitialized variable. ==Typing== {{Main|Type system}} {{See also|Datatype}} In [[static typing|statically-typed]] languages such as [[Java (programming language)|Java]] or [[ML programming language|ML]], a variable also has a ''type'', meaning that only values of a given class (or set of classes) can be stored in it. A variable of a [[Primitive data type|primitive]] type holds a value of that exact primitive type. A variable of a class type can hold a null reference or a reference to an object whose type is that class type or any subclass of that class type. A variable of an interface type can hold a null reference or a reference to an instance of any class that implements the interface. A variable of an array type can hold a null reference or a reference to an array. In [[dynamic typing|dynamically-typed]] languages such as [[Python (programming language)|Python]], it is values, not variables, which carry type. In [[Common Lisp]], both situations exist simultaneously: a variable is given a type (if undeclared, it is assumed to be <code>T</code>, the universal [[Subtype|supertype]]) which exists at compile time. Values also have types, which can be checked and queried at runtime. Typing of variables also allows [[type polymorphism|polymorphisms]] to be resolved at compile time. However, this is different from the polymorphism used in object-oriented function calls (referred to as ''[[virtual functions]]'' in [[C++]]) which resolves the call based on the value type as opposed to the supertypes the variable is allowed to have. Variables often store simple data-like integers and literal strings, but some programming languages allow a variable to store values of other [[datatype]]s as well. Such languages may also enable functions to be [[Parametric polymorphism#Parametric polymorphism|parametric polymorphic]]. These functions operate like variables to represent data of multiple types. For example, a function named <code>length</code> may determine the length of a list. Such a <code>length</code> function may be parametric polymorphic by including a type variable in its [[type signature]], since the amount of elements in the list is independent of the elements' types. ==Parameters== The ''formal parameters'' of functions are also referred to as variables. For instance, in this [[Python (programming language)|Python]] code segment, <source lang="python"> def addtwo(x): return x + 2 addtwo(5) # yields 7 </source> The variable named <code>x</code> is a ''parameter'' because it is given a value when the function is called. The integer 5 is the ''argument'' which gives <code>x</code> its value. In most languages, function parameters have local scope {{Citation needed|date=October 2007}}. This specific variable named <code>x</code> can only be referred to within the <code>addtwo</code> function (though of course other functions can also have variables called <code>x</code>). ==Memory allocation== The specifics of variable allocation and the representation of their values vary widely, both among programming languages and among implementations of a given language. Many language implementations allocate space for ''[[local variable]]s'', whose extent lasts for a single function call on the ''[[call stack]]'', and whose memory is automatically reclaimed when the function returns. (More generally, in ''[[name binding]]'', the name of a variable is bound to the address of some particular block (contiguous sequence) 