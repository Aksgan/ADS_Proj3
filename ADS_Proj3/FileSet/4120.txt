at [[Run time (computing)|runtime]]. In addition, many recently-invented languages have deliberately excluded features which can easily lead to bugs, at the expense of making code slower than it need be: the general principle being that, because of [[Moore's law]], computers get faster and software engineers get slower; it is ''almost always'' better to write simpler, slower code than "clever", inscrutable code, especially considering that [[maintenance cost]] is considerable. For example, the [[Java (programming language)|Java programming language]] does not support [[Pointer (computing)|pointer]] arithmetic; implementations of some languages such as [[Pascal (programming language)|Pascal]] and [[scripting language]]s often have runtime [[bounds checking]] of arrays, at least in a debugging build. ; Code analysis: Tools for [[Static code analysis|code analysis]] help developers by inspecting the program text beyond the compiler's capabilities to spot potential problems. Although in general the problem of finding all programming errors given a specification is not solvable (see [[halting problem]]), these tools exploit the fact that human programmers tend to make the same kinds of mistakes when writing software. ; [[Instrumentation]]: Tools to monitor the performance of the software as it is running, either specifically to find problems such as [[Bottleneck (engineering)|bottlenecks]] or to give assurance as to correct working, may be embedded in the code explicitly (perhaps as simple as a statement saying <code>PRINT "I AM HERE"</code>), or provided as tools. It is often a surprise to find where most of the time is taken by a piece of code, and this removal of assumptions might cause the code to be rewritten. == Debugging == [[Image:Classpath bugs.png|thumb|350px|The typical bug history ([[GNU Classpath]] project data). A new bug submitted by the user is ''unconfirmed.'' Once it has been reproduced by a developer, it is a ''confirmed'' bug. The confirmed bugs are later ''fixed''. Bugs belonging to other categories (unreproducible, will not be fixed, etc) are usually in the minority]] {{Main|Debugging}} Finding and fixing bugs, or "debugging", has always been a major part of [[computer programming]]. [[Maurice Wilkes]], an early computing pioneer, described his realization in the late 1940s that much of the rest of his life would be spent finding mistakes in his own programs.<ref>[[q:Maurice Wilkes|Maurice Wilkes Quotes]]</ref> As computer programs grow more complex, bugs become more common and difficult to fix. Often programmers spend more time and effort finding and fixing bugs than writing new code. [[Software tester]]s are professionals whose primary task is to find bugs, or write code to support testing. On some projects, more resources can be spent on testing than in developing the program. Usually, the most difficult part of debugging is finding the bug in the [[source code]]. Once it is found, correcting it is usually relatively easy. Programs known as [[debugger]]s exist to help programmers locate bugs by executing code line by line, watching variable values, and other features to observe program behavior. Without a debugger, code can be added so that messages or values can be written to a console (for example with ''printf'' in the [[C programming language]]) or to a window or log file to trace program execution or show values. However, even with the aid of a debugger, locating bugs is something of an art. It is not uncommon for a bug in one section of a program to cause failures in a completely different section, thus making it especially difficult to track (for example, an error in a graphics [[Rendering (computer graphics)|rendering]] routine causing a file [[Input/output|I/O]] routine to fail), in an apparently unrelated part of the system. Sometimes, a bug is not an isolated flaw, but represents an error of thinking or planning on the part of the programmer. Such ''[[logic error]]s'' require a section of the program to be overhauled or rewritten. As a part of [[Code review]], stepping through the code modelling the execution process in one's head or on paper can often find these errors without ever needing to reproduce the bug as such, if it can be shown there is some faulty logic in its implementation. But more typically, the first step in locating a bug is to reproduce it reliably. Once the bug is reproduced, the programmer can use a debugger or some other tool to monitor the execution of the program in the faulty region, and find the point at which the program went astray. It is not always easy to reproduce bugs. Some are triggered by inputs to the program which may be difficult for the programmer to re-create. One cause of the [[Therac-25]] radiation machine deaths was a bug (specifically, a [[race condition]]) that occurred only when the machine operator very rapidly entered a treatment plan; it took days of practice to become able to do this, so the bug did not manifest in testing or when the manufacturer attempted to duplicate it. Other bugs may disappear when the program is run with a debugger; these are [[heisenbug]]s (humorously named after the [[uncertainty principle|Heisenberg uncertainty principle]].) Debugging is still a tedious task requiring considerable effort. Since the 1990s, particularly following the [[Ariane 5 Flight 501]] disaster, there has been a renewed interest in the development of effective automated aids to debugging. For instance, methods of [[static code analysis]] by [[abstract interpretation]] have already made significant achievements, while still remaining much of a work in progress. As with any creative act, sometimes a flash of inspiration will show a solution, but this is rare and, by definition, cannot be relied on. There are also classes of bugs that have nothing to do with the code itself. If, for example, one relies on faulty documentation or hardware, the code may be written perfectly properly to what the documentation says, but the bug truly lies in the documentation or hardware, not the code. However, it is common to change the code instead of the other parts of the system, as the cost and time to change it is generally less. [[Embedded system]]s frequently have [[workaround]]s for hardware bugs, since to make a new version of a [[Read-only memory|ROM]] is much cheaper than 