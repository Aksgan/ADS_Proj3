the line. I thought, "Damn the torpedoes, at least this will make a good article," [and] asked the team to crank up all the knobs to 10 on the things I thought were essential and leave out everything else.}} Beck invited [[Ron Jeffries]] to the project to help develop and refine these methods. Jeffries thereafter acted as a coach to instill the practices as habits in the C3 team. Information about the principles and practices behind XP was disseminated to the wider world through discussions on the original [[Wiki]], Cunningham's [[WikiWikiWeb]]. Various contributors discussed and expanded upon the ideas, and some spin-off methodologies resulted (see [[agile software development]]). Also, XP concepts have been explained, for several years, using a [[hypertext]] system map on the XP website at "http://www.extremeprogramming.org" circa 1999. Beck edited a series of books on XP, beginning with his own ''Extreme Programming Explained'' (1999, ISBN 0-201-61641-6), spreading his ideas to a much larger, yet very receptive, audience. Authors in the series went through various aspects attending XP and its practices. Even a book was written, critical of the practices. === Current state === XP created quite a buzz in the late 1990s and early 2000s, seeing adoption in a number of environments radically different from its origins. The high discipline required by the original practices often went by the wayside, causing some of these practices, such as those thought too rigid, to be deprecated or reduced, or even left unfinished, on individual sites. For example, the practice of end-of-day integration tests, for a particular project, could be changed to an end-of-week schedule, or simply reduced to mutually agreed dates. Such a more relaxed schedule could avoid people feeling rushed to generate artificial stubs just to pass the end-of-day testing. A less rigid schedule allows, instead, for some complex features to be more fully developed over a several-day period. However, some level of periodic integration testing can detect groups of people working in non-compatible, tangent efforts before too much work is invested in divergent, wrong directions. Meanwhile, other agile development practices have not stood still, and XP is still evolving, assimilating more lessons from experiences in the field, to use other practices. In the second edition of ''Extreme Programming Explained'', Beck added more values and practices and differentiated between primary and corollary practices. == Concept == === Goals === ''Extreme Programming Explained'' describes Extreme Programming as a software development discipline that organizes people to produce higher quality software more productively. In traditional system development methods (such as [[Structured Systems Analysis and Design Methodology|SSADM]] or the [[waterfall model]]) the requirements for the system are determined at the beginning of the development project and often fixed from that point on. This means that the cost of changing the requirements at a later stage (a common feature of software engineering projects{{Citation needed|date=November 2010}}<!-- Should this be qualified, i.e. "a common feature of BLAH software engineering projects"? -->) will be high. Like other [[agile software development]] methods, XP attempts to reduce the cost of change by having multiple short development cycles, rather than one long one. In this doctrine changes are a natural, inescapable and desirable aspect of software development projects, and should be planned for instead of attempting to define a stable set of requirements. Extreme programming also introduces a number of basic values, principles and practices on top of the agile programming framework. === Activities === XP describes four basic activities that are performed within the software development process: coding, testing, listening, and designing. Each of those activities is described below. ==== Coding ==== The advocates of XP argue that the only truly important product of the system development process is code - software instructions a computer can interpret. Without code, there is no working product. Coding can also be used to figure out the most suitable solution. Coding can also help to communicate thoughts about programming problems. A programmer dealing with a complex programming problem and finding it hard to explain the solution to fellow programmers might code it and use the code to demonstrate what he or she means. Code, say the proponents of this position, is always clear and concise and cannot be interpreted in more than one way. Other programmers can give feedback on this code by also coding their thoughts. ==== Testing ==== One can not be certain that a function works unless one tests it. [[Software bug|Bug]]s and design errors are pervasive problems in software development. Extreme programming's approach is that if a little testing can eliminate a few flaws, a lot of testing can eliminate many more flaws. * [[Unit test]]s determine whether a given feature works as intended. A programmer writes as many automated tests as they can think of that might "break" the code; if all tests run successfully, then the coding is complete. Every piece of code that is written is tested before moving on to the next feature. *[[Acceptance test]]s verify that the requirements as understood by the programmers satisfy the customer's actual requirements. These occur in the exploration phase of release planning. A "testathon" is an event when programmers meet to do collaborative test writing, a kind of brainstorming relative to software testing. ==== Listening ==== Programmers must listen to what the customers need the system to do, what [[Business logic|"business logic"]] is needed. They must understand these needs well enough to give the customer feedback about the technical aspects of how the problem might be solved, or cannot be solved. Communication between the customer and programmer is further addressed in [[Extreme programming practices#Planning game|the Planning Game]]. ==== Designing ==== From the point of view of simplicity, of course one could say that system development doesn't need more than coding, testing and listening. If those activities are performed well, the result should always be a system that works. In practice, this will not work. One can come a long way without [[design]]ing but at a given time one will get stuck. The system becomes too complex and the dependencies 