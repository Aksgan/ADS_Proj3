that their code is not what they intended to write. ==Similar terms== *Cardboard Programmer or Programmer's Dummy <ref name="duckie3">[http://www.c2.com/cgi/wiki?CardboardProgrammer Cardboard Programer - The Pragmatic Programme]</ref> *Cardboard Coder <ref name="duckie4">[[Cardboard coder]]</ref> *Cone Of Answers <ref name="duckie5">[http://www.c2.com/cgi/wiki?ConeOfAnswers Cone of Answers- The Pragmatic Programmer]</ref> *Thinking Out Loud <ref name="duckie6">[http://www.c2.com/cgi/wiki?ThinkingOutLoud Thinking out Loud - The Pragmatic Programmer]</ref> ==References== <references/> ==External links== *[http://lists.ethernal.org/oldarchives/cantlug-0211/msg00174.html Description of the method] *[http://www.rubberduckdebugging.com/ Site honoring the Rubber Duck Debugging method] {{compu-prog-stub}} [[Category:Debugging]] [[uk:Метод каченяти]]</text> </page> <page> <id>32540</id> <title>Rubberhose (file system)</title> <text>In computing, '''rubberhose''' (also known by its development codename '''Marutukku''')<ref>{{cite web |title=The Idiot Savants' Guide to Rubberhose |author=Suelette Dreyfus |url=http://iq.org/~proff/rubberhose.org/current/src/doc/maruguide/t1.html }}</ref> is a [[deniable encryption]] archive containing multiple [[file system]]s whose existence can only be verified using the appropriate cryptographic key. == Name and history == The project was originally named Rubberhose, as it was designed to be resistant to attacks by people willing to use [[torture]] on those who knew the encryption keys. This is a reference to the [[rubber-hose cryptanalysis]] euphemism. It was written by [[Julian Assange]], Suelette Dreyfus and Ralf Weinmann.<ref>{{cite web|url=http://iq.org/~proff/rubberhose.org/|title=Rubberhose cryptographically deniable transparent disk encryption system|accessdate=21 October 2010}}</ref> It was originally designed for use by [[human rights]] groups working in [[third world]] [[dictatorship]]s, but was often proposed for use in other countries such as the [[United Kingdom]] where threats of imprisonment can be used to force people to reveal their encryption keys (see ''[[Regulation of Investigatory Powers Act 2000]]''). ==Technical== The following paragraphs are extracts from the project's documentation: :Rubberhose works by initially writing random characters to an entire hard drive or other dynamic storage device. This random noise is indistinguishable from the encrypted data to be stored on that disk. If you have a 1 GB drive and want to have two Rubberhose encrypted portions of 400 MB and 200 MB, it assumes that each aspect (as the encrypted partitions are called) will be 1 GB and fill the entire drive. It will keep doing this until the drive is really filled to capacity with encrypted material. It breaks up the pieces of each aspect into small pieces and scatters them across the entire 1 GB drive in a random manner, with each aspect looking as if it is actually 1 GB in size upon decryption. :Each aspect has its own passphrase that must be separately decrypted, and if a hard drive is seized neither mathematical analysis nor physical disk testing can reveal how many aspects actually exist. Internal maps are used to locate where the data is stored amongst the random characters, with each aspect having its own map which can only be decrypted via its specific passphrase. As such, a Rubberhose disk can only be written to after all the passphrases have been entered. Everything works on a "need to know" basis, i.e. each aspect knows nothing about the others other than when to avoid writing over the top of another. == Status == Rubberhose is not actively maintained, although it is currently available for [[Linux kernel]] 2.2, [[NetBSD]] and [[FreeBSD]]. Latest version available, still in alpha stage, is v0.8.3. As of 2006, the domain rubberhose.org does not host the Rubberhose project anymore. == References == {{reflist}} ==External links== *[http://iq.org/~proff/rubberhose.org/ Rubberhose mirror] [[Category:Cryptographic software]]</text> </page> <page> <id>32545</id> <title>RubyCocoa</title> <text>{{Unreferenced|date=May 2010}} {{Portal|Free software}} '''RubyCocoa''' is a [[Mac OS X]] [[Software framework|framework]] that provides a bridge between the [[Ruby (programming language)|Ruby]] and the [[Objective-C]] programming languages, allowing the user to manipulate Objective-C [[object (computer science)|object]]s from Ruby, and vice-versa. It makes it possible to write a [[Cocoa (API)|Cocoa]] application completely in Ruby as well as to write an application that mixes Ruby and Objective-C code. As of 2008, an Apple project called [[MacRuby]] is under development to replace RubyCocoa. Some useful applications of RubyCocoa are exploration of a Cocoa object's features with irb interactively, prototyping of a Cocoa application, writing a Cocoa application that combines the features of Ruby and Objective-C and wrapping Mac OS X's native [[GUI]] for a Ruby script. RubyCocoa is [[free software]], released under both the [[Ruby License]] and the [[LGPL]]. == History == RubyCocoa was started in 2001 by Hisakuni Fujimoto when he implemented a Ruby extension module to wrap NSObject and NSClassFromString function. Later it was integrated with Project Builder (which later become [[Xcode]]). In 2002 the project was registered on [http://www.sourceforge.net SourceForge] and the development team began to grow. In 2006 the commiters list was first joined by a developer from [[Apple Inc.|Apple]], Laurent Sansonetti, and then a RubyCocoa presentation was made during [[WWDC]]. Apple stated that RubyCocoa will be included and supported in [[Mac OS X v10.5]] “Leopard”. In August 2008, Sansonetti confirmed that [[MacRuby]] "[http://forums.pragprog.com/forums/76/topics/687#posts-4160 is supposed to replace RubyCocoa.]" in the future. == How Does the Bridge Work? == RubyCocoa is sometimes interpreted as a set of bindings to the Cocoa frameworks, which is false. RubyCocoa is a real bridge between the Objective-C and Ruby programming languages. === Lazy Class Import === RubyCocoa will import the Objective-C classes into the Ruby world on demand. For example, when you access <code>OSX::NSTableView</code> for the very first time in your code, RubyCocoa will retrieve all the necessary information regarding this class from the Objective-C runtime and create a Ruby class of the same name that will act as a proxy. It will also import in the same way all the inherited classes. === Forwarding Messages === As stated earlier, RubyCocoa creates special proxy objects. Every time you send a Ruby message to a proxy object, RubyCocoa will try to forward it to the embedded Objective-C instance, by translating the message name to an Objective-C selector and asking the Objective-C runtime to forward it. If an exception is raised from the Objective-C world, RubyCocoa will convert it to a Ruby exception and forward it to you. RubyCocoa uses the [[libffi]] library to call the Objective-C methods implementations. === Automatic Method Overriding === RubyCocoa makes it easy to override an Objective-C method from Ruby, either in a subclass or directly to the class (as you would do in Objective-C 