the list of nodes one traverses to get from the root of the tree, to the desired node in the tree. ===Filling the routing table=== With the shortest paths in hand, filling in the routing table is trivial. For any given destination node, the best path for that destination is the node which is the first step from the root node, down the branch in the shortest-path tree which leads toward the desired destination node. To create the routing table, it is only necessary to walk the tree, remembering the identity of the node at the head of each branch, and filling in the routing table entry for each node one comes across with that identity. ===Optimizations to the algorithm=== The algorithm described above was made as simple as possible, to aid in ease of understanding. In practice, there are a number of optimizations which are used. Most importantly, whenever a change in the connectivity map happens, it is necessary to recompute the shortest-path tree, and then recreate the routing table. Work by [[BBN Technologies]] discovered how to recompute only that part of the tree which could have been affected by a given change in the map. Also, the routing table would normally be filled in as the shortest-path tree is computed, instead of making it a separate operation. ==Failure modes== If all the nodes are not working from '''exactly''' the same map, ''routing loops'' can form. (These are situations in which, in the simplest form, two neighboring nodes each think the other is the best path to a given destination. Any packet headed to that destination arriving at either node will loop between the two, hence the name. Routing loops involving more than two nodes are also possible.) The reason is fairly simple: since each node computes its shortest-path tree and its routing table without interacting in any way with any other nodes, then if two nodes start with different maps, it is easy to have scenarios in which routing loops are created. ==The Optimized Link State Routing Protocol for Mobile ad-hoc Networks== A link-state routing protocol - optimized for [[mobile ad-hoc network]]s, which can also be used on other [[wireless ad-hoc network]]s - is the ''[[Optimized Link State Routing Protocol]] (OLSR).<ref>RFC 3626</ref> OLSR is proactive, it uses Hello and Topology Control (TC) messages to discover and disseminate link state information into the [[mobile ad-hoc network]]. Using Hello messages each node discovers 2-hop neighbor information and elects a set of ''[[multipoint relay]]s'' (MPRs). MPRs makes OLSR unique from other link state routing protocols. Individual nodes use the topology information to compute next hop paths regard to all nodes in the network utilising shortest hop forwarding paths. ==See also== *[[Routing#Comparison of routing algorithms|Comparison of routing algorithms]] ==References== <references /> {{No footnotes|date=September 2010}} * [[John M. McQuillan]], Isaac Richer and Eric C. Rosen, ''ARPANet Routing Algorithm Improvements'', BBN Report No. 3803, Cambridge, April 1978 * [[John M. McQuillan]], Isaac Richer and Eric C. Rosen, ''The New Routing Algorithm for the ARPANet'', [[IEEE]] Trans. on Comm., 28(5), pp. 711–719, 1980 * Josh Seeger and Atul Khanna, ''Reducing Routing Overhead in a Growing DDN'', MILCOMM '86, IEEE, 1986 * [[Radia Perlman]] [http://www.ieee-infocom.org/2004/Papers/26_1.PDF “Rbridges: Transparent Routing”], Infocom 2004. ==Further reading== * [http://docwiki.cisco.com/wiki/Routing_Basics#Link-State_Versus_Distance_Vector Section "Link-State Versus Distance Vector"] in the Chapter "Routing Basics" in the [[Cisco Systems|Cisco]] "Internetworking Technology Handbook" {{DEFAULTSORT:Link-State Routing Protocol}} [[Category:Routing protocols]] [[Category:Routing algorithms]] [[de:Link-State]] [[es:Estado de enlace]] [[it:Link State]] [[mk:Link-state routing protocol]]</text> </page> <page> <id>21797</id> <title>Link register</title> <text>{{Unreferenced stub|auto=yes|date=December 2009}} {{Orphan|date=May 2008}} A '''link register''', in many [[instruction set architecture]]s such as the [[PowerPC]], [[ARM architecture|ARM]], and the [[PA-RISC]], is a special purpose [[processor register|register]] which holds the address to return to when a [[function (programming)|function]] call completes. Other architectures (such as [[SPARC]]) have a register with the same purpose but another name (in this case, "output register 7"). The usage of a link register allows for faster calls to [[leaf subroutine]]s. When the subroutine is non-leaf, passing the result address in a register still results in generation of more efficient code for [[thunk]]s, i.e. for a function whose sole purpose is to call another function with arguments rearranged in some way. Other subroutines can benefit from the use of link register because it can be saved in a batch with other callee-used registers—e.g. an ARM subroutine pushes registers 4-7 along with the link register, LR, by the single instruction <code>STMDB SP!, {R4-R7, LR}</code> pipelining all memory writes required. {{DEFAULTSORT:Link Register}} [[Category:Central processing unit]] {{Compu-hardware-stub}}</text> </page> <page> <id>21799</id> <title>Linkage (software)</title> <text>In programming languages, particularly [[C++]], '''linkage''' describes how names can or can not refer to the same entity throughout the whole program or one single [[Translation unit (programming)|translation unit]]. The <code>static</code> keyword is used in C to restrict the visibility of a function or variable to its translation unit. This is also valid in C++, although C++ deprecates this usage in favor of [[anonymous namespace]]s (which are not available in C). Also, C++ implicitly treats any <code>const</code> namespace-scope variable as having internal linkage unless it is explicitly declared <code>extern</code>, unlike C. A name's linkage is related to, but distinct from, its [[scope (programming)|scope]]. The scope of a name is the part of a translation unit where it is visible. For instance, a name with global scope (which is the same as file-scope in C and the same as the global namespace-scope in C++) is visible in any part of the file. Its scope will end at the end of the translation unit, whether or not that name has been given external or internal linkage. If the name has external linkage, the entity that name denotes may be referred to from another translation unit using a distinct declaration for that same name, and from other scopes within the same translation unit using distinct declarations. Were the name given internal linkage, such a declaration would denote a distinct entity, although using the same name, but its entity could be referred to by distinct declarations within the same translation unit. A name that has 