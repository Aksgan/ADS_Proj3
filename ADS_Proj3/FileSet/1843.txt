place, by [[Sandstorm (vehicle)|Sandstorm]], its sister vehicle. ==Cultural references== The Hummer driven by Denzel Washington in the movie ''[[Déjà Vu (2006 film)|Déjà Vu]]'' was heavily based on H1ghlander, sharing a similar gimbal dome on the top, SICK laser sensors in the same positions, a camera tube on the side of the vehicle, and many other visual similarities. ''See [http://imdb.com/title/tt0453467/trivia IMDB Trivia for Déjà Vu].'' ==References== <references/> ==See also== * [[Driverless car]] ==External links== * [http://www.redteamracing.org/ Carnegie Mellon Red Team Racing] [[Category:Driverless cars]] [[Category:Carnegie Mellon University]] [[Category:Unmanned vehicles]] [[de:H1ghlander]] [[pl:H1ghlander]]</text> </page> <page> <id>15988</id> <title>HATEOAS</title> <text>The '''HATEOAS''' constraint is an acronym for '''Hypermedia as the Engine of Application State'''. This principle is the key differentiator between a [[Representational State Transfer|REST]] and most other forms of [[Client–server model|client server]] system. Rather than the [[Action (UML)|actions]] and [[Interface (computer science)|interfaces]] a [[Client (computing)|client]] may use being defined elsewhere, such as in a [[Web Services Description Language|WSDL]] file or predefined in the client code, the principle is that the [[hypermedia]] in each [[Server (computing)|server]] [[Output|response]] will contain [[Hyperlink|links]] that correspond to all the actions that the client can currently perform. Therefore, dependent on the current [[State (computer science)|application state]], every server response describes the new actions that are available. The server can change the range of allowable responses in a dynamic way, and a client should adapt its behavior to these changes. A client of a RESTful application need only know a single fixed [[Uniform Resource Locator|URL]] to access it. All future actions should be discoverable dynamically from hypermedia links included in the representations of the [[Resource (Web)|resources]] that are returned from that URL. Standardized [[Internet media type|media types]] are also expected to be understood by any client that might use a RESTful [[Application programming interface|API]]. Application state transitions are driven by a combination of the known processing rules for each media type, client selection from the server-provided choices in representations received, and the user's manipulation of those representations. Thus interactions are driven by hypermedia, rather than by any out-of-band information.<ref name="untangled2008"/> If necessary, the client’s knowledge of media types, resource communication mechanisms, and user interaction, may be improved on-the-fly by the transmission of code-on-demand from the server to the client as defined elsewhere in the REST architecture.<ref name="Fielding-Ch5"/> == Origins of the constraint == The details of this design constraint were introduced, but not named as such, by Roy Fielding in the doctoral dissertation where he first defined the REST architectural style.<ref name="Fielding-Ch5">Chapter 5 of Fielding's dissertation is [http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm "Representational State Transfer (REST)"].</ref> The concept has been further described by Fielding on his blog.<ref name="untangled2008">{{cite web |url=http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven|title=REST APIs must be hypertext-driven|date=20 Oct 2008|first=Roy T.|last=Fielding|accessdate=20 May 2010}}</ref> The purpose of some of the strictness of this and other REST constraints, Fielding explains, is "software design on the scale of decades: every detail is intended to promote software longevity and independent evolution. Many of the constraints are directly opposed to short-term efficiency. Unfortunately, people are fairly good at short-term design, and usually awful at long-term design."<ref name="untangled2008"/> == References == {{reflist}} [[Category:Software engineering]] {{software-eng-stub}}</text> </page> <page> <id>16015</id> <title>HFS Plus</title> <text>{{Infobox filesystem | name = HFS+ | full_name = Hierarchical File System Plus | developer = [[Apple Computer|Apple]] | introduction_os = [[Mac OS 8.1]] | introduction_date = January 19, 1998 | partition_id = <tt>Apple_HFS</tt> ([[Apple Partition Map]])<br /><tt>0xAF</tt> ([[Master boot record|MBR]])<br /><tt>Apple_HFSX</tt> ([[Apple Partition Map]]) when HFSX <br /><tt>48465300-0000-11AA-<br />AA11-00306543ECAC</tt> ([[GUID Partition Table|GPT]]) | directory_struct = [[B-tree]] | file_struct = [[Bitmap]] | bad_blocks_struct = [[B-tree]] | max_files_no = 4,294,967,295 (2<sup>32</sup>-1) | max_file_size = 8 [[exbibyte|EiB]]<ref name="tn1150" /> | max_filename_size = 255 characters (255 UTF-16 encoding units, normalized to Apple-modified variant of Unicode Normalization Format D) | max_volume_size = 8 [[exbibyte|EiB]] <ref>{{cite web|url=http://support.apple.com/kb/HT2422 |title=Mac OS X: Mac OS Extended format (HFS Plus) volume and file limits |publisher=Support.apple.com |date=2008-07-29 |accessdate=2010-07-05}}</ref> | filename_character_set = [[Unicode]], any character, including [[ASCII code#ASCII control characters|NUL]]. OS APIs may limit some characters for legacy reasons | dates_recorded = access, attributes modified, backed up, contents modified, created | date_range = January 1, 1904 - February 6, 2040 | date_resolution = 1s | forks_streams = Yes | attributes = Color (3 bits, all other flags 1 bit), locked, custom icon, bundle, invisible, alias, system, stationery, inited, no INIT resources, shared, desktop | file_system_permissions = Unix permissions, NFSv4 [[Access Control List|ACLs]] ([[Mac OS X v10.4]] onward) | compression = Yes (on OS X 10.6 and higher) | encryption = No, although per-[[home directory]] [[Advanced Encryption Standard|AES]] using HFS+ formatted [[.dmg]] volumes is possible using [[FileVault]] in [[Mac OS X v10.3]] onward | OS = [[Mac OS 8.1]], [[Mac OS 9]], [[Mac OS X]], & [[Darwin OS|Darwin]], [[Linux]], [[Microsoft Windows]] (through [[MacDrive]] or [[Bootcamp]]{{Citation needed|date=December 2010}} [[Installable File System|IFS]] drivers)}} '''HFS Plus''' or '''HFS+''' is a [[file system]] developed by [[Apple Inc.]] to replace their [[Hierarchical File System]] (HFS) as the primary file system used in [[Apple Macintosh|Macintosh]] computers (or other systems running [[Mac OS]]). It is also one of the formats used by the [[iPod]] digital music player. HFS Plus is also referred to as '''Mac OS Extended''' (or, erroneously, “HFS Extended”), where its predecessor, HFS, is also referred to as ''Mac OS Standard'' (or, erroneously, as “HFS Standard”). During development, Apple referred to this filesystem with the codename ''Sequoia''.<ref>{{cite web | url=http://developer.apple.com/adcnews/pastissues/devnews090597.html | title=New Mac OS Extended Format (HFS+) Available | date=1997 | work=Apple Developer News | accessdate=2007-03-28}}</ref> HFS Plus is an improved version of HFS, supporting much larger files (block addresses are 32-bit length instead of 16-bit) and using [[Unicode]] (instead of [[Mac OS Roman]] or any of several other character sets) for naming the items (files, folders) – names which are also character encoded in [[UTF-16]] and normalized to a form very nearly the same as [[Unicode normalization|Unicode Normalization Form D (NFD)]]<ref>{{cite web | url=http://developer.apple.com/qa/qa2001/qa1235.html | title=Technical Q&A QA1235: Converting to Precomposed Unicode | date=February 7, 2003 | work=Apple Developer Connection | accessdate=2007-03-28 }}</ref> (which means that precomposed characters like are decomposed in the HFS+ filename and therefore count as two characters<ref>there are some 