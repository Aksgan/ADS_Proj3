1 B = n1 + 2*n2 n = n1+ 2*n2 + 1 n = n0 + n1 + n2 n1+ 2*n2 + 1 = n0 + n1 + n2 ==> n0 = n2 + 1 == Common Operations == There are a variety of different operations that can be performed on binary trees. Some are [[mutator method|mutator]] operations, while others simply return useful information about the tree. === Insertion === Nodes can be inserted into binary trees in between two other nodes or added after an [[external node]]. In binary trees, a node that is inserted is specified as to which child it is. ==== External nodes ==== Say that the external node being added on to is node A. To add a new node after node A, A assigns the new node as one of its children and the new node assigns node A as its parent. ==== Internal nodes ==== [[File:Insertion of binary tree node.JPG|thumb|360px|The process of inserting a node into a binary tree]] Insertion on [[internal node]]s is slightly more complex than on external nodes. Say that the internal node is node A and that node B is the child of A. (If the insertion is to insert a right child, then B is the right child of A, and similarly with a left child insertion.) A assigns its child to the new node and the new node assigns its parent to A. Then the new node assigns its child to B and B assigns its parent as the new node. === Deletion === Deletion is the process whereby a node is removed from the tree. Only certain nodes in a binary tree can be removed uambiguously.<ref name="rice">{{cite web |url=http://www.clear.rice.edu/comp212/03-spring/lectures/22/|title=Binary Tree Strucutre|author=Dung X. Nguyen|date=2003|work= |publisher=rice.edu|accessdate=December 28, 2010}} </ref> ==== Node with zero or one children ==== [[File:Deletion of internal binary tree node.JPG|thumb|360px|The process of deleting an internal node in a binary tree]] Say that the node to delete is node A. If a node has no children ([[external node]]), deletion is accomplished by setting the child of A's parent to [[null pointer|null]] and A's parent to null. If it has one child, set the parent of A's child to A's parent and set the child of A's parent to A's child. ==== Node with two children ==== In a binary tree, a node with two children cannot be deleted unambiguously.<ref name="rice"/> However, in certain binary trees these nodes ''can'' be deleted, including [[binary search tree|binary search trees]]. === Iteration === Often, one wishes to visit each of the nodes in a tree and examine the value there, a process called [[iteration]] or [[enumeration]]. There are several common orders in which the nodes can be visited, and each has useful properties that are exploited in algorithms based on binary trees: * Pre-Order: Root first, children after * Post-Order: Children first, root after * In-Order: Left child, root, right child. ==== Pre-order, in-order, and post-order traversal ==== {{Main|Tree traversal}} Pre-order, in-order, and post-order traversal visit each node in a tree by recursively visiting each node in the left and right subtrees of the root. If the root node is visited before its subtrees, this is pre-order; if after, post-order; if between, in-order. In-order traversal is useful in [[binary search tree]]s, where this traversal visits the nodes in increasing order. ==== Depth-first order ==== In depth-first order, we always attempt to visit the node farthest from the root that we can, but with the caveat that it must be a child of a node we have already visited. Unlike a depth-first search on graphs, there is no need to remember all the nodes we have visited, because a tree cannot contain cycles. Pre-order is a special case of this. See [[depth-first search]] for more information. ==== Breadth-first order ==== Contrasting with depth-first order is breadth-first order, which always attempts to visit the node closest to the root that it has not already visited. See [[breadth-first search]] for more information. Also called a ''level-order traversal''. ==Type theory== In [[type theory]], a binary tree with nodes of type A is defined [[inductive datatype|inductively]] as ''T''<sub>''A''</sub> = μα. 1 + ''A'' &times; α &times; α. ==Definition in graph theory== For each binary tree data structure, there is equivalent rooted [[binary tree (graph theory)|binary tree]] in graph theory. [[graph theory|Graph theorists]] use the following definition: A binary tree is a [[connected graph|connected]] [[acyclic graph]] such that the [[degree (graph theory)|degree]] of each [[vertex (graph theory)|vertex]] is no more than three. It can be shown that in any binary tree of two or more nodes, there are exactly two more nodes of degree one than there are of degree three, but there can be any number of nodes of degree two. A '''rooted binary tree''' is such a graph that has one of its vertices of degree no more than two singled out as the root. With the root thus chosen, each vertex will have a uniquely defined parent, and up to two children; however, so far there is insufficient information to distinguish a left or right child. If we drop the connectedness requirement, allowing multiple [[connected component (graph theory)|connected components]] in the graph, we call such a structure a forest. Another way of defining binary trees is a recursive definition on directed graphs. A binary tree is either: * A single vertex. * A graph formed by taking two binary trees, adding a vertex, and adding an edge directed from the new vertex to the root of each binary tree. This also does not establish the order of children, but does fix a specific root node. ==Combinatorics== In combinatorics one considers the problem of counting the number of binary trees of a given size. Here the trees have no values attached to their nodes (this would just multiply the number of possible trees by an easily determined factor), and trees are distinguished only by their structure; however the left and right child of any node are distinguished (if they are different trees, then interchanging 