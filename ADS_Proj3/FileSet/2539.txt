science)}} Another approach is to turn the naive algorithm into a [[critical section]], preventing other threads from disrupting it, using a [[lock (computer science)|lock]]. Once again fixing the non-atomic counter algorithm: :# take a lock, excluding other threads from running the critical section (steps 2-4) at the same time :# read the value in the memory location :# add one to the value :# write the incremented value back to the memory location :# release the lock This strategy works with any problem; compared with direct use of atomic operations, it is relatively easy to get right, but it requires great care to not suffer significant overhead. To improve program performance, it may therefore be a good idea to replace simple critical sections with atomic operations for [[non-blocking synchronization]] (as we have just done for the counter with compare-and-swap), instead of the other way around, but unfortunately a significant improvement is not guaranteed and lock-free algorithms can easily become too complicated to be worth the effort. ==History of linearizability== Linearizability was first introduced as a [[consistency model]] by Herlihy and Wing in 1987. It encompassed more restrictive definitions of atomic, such as "an atomic operation is one which cannot be (or is not) interrupted by concurrent operations", which are usually vague about when an operation is considered to begin and end. An atomic object can be understood immediately and completely from its sequential definition, as a set of operations run in parallel will always appear to occur one after the other; no inconsistencies may emerge. Specifically, linearizability guarantees that the [[Invariant (computer science)|invariants]] of a system are ''observed'' and ''preserved'' by all operations: if all operations individually preserve an invariant, the system as a whole will. ==Definition of linearizability== A ''history'' is a sequence of ''invocations'' and ''responses'' made of an object by a set of [[Thread (computer science)|threads]]. Each invocation of a function will have a subsequent response. This can be used to model any use of an object. Suppose, for example, that two threads, A and B, both attempt to grab a lock, backing off if it's already taken. This would be modeled as both threads invoking the lock operation, then both threads receiving a response, one successful, one not. {| border="1" cellspacing="0" | A invokes ''lock'' | B invokes ''lock'' | A gets "failed" response | B gets "successful" response |} A ''sequential'' history is one in which all invocations have immediate responses. A sequential history should be trivial to reason about, as it has no real concurrency; the previous example was not sequential, and thus is hard to reason about. This is where linearizability comes in. A history is ''linearizable'' if: * its invocations and responses can be reordered to yield a sequential history * that sequential history is correct according to the sequential definition of the object * if a response preceded an invocation in the original history, it must still precede it in the sequential reordering (Note that the first two bullet points here match [[serializability]]: the operations appear to happen in some order. It is the last point which is unique to linearizability, and is thus the major contribution of Herlihy and Wing.) Let us look at two ways of reordering the locking example above. {| border="1" cellspacing="0" | A invokes ''lock'' | A gets "failed" response | B invokes ''lock'' | B gets "successful" response |} Reordering B's invocation below A's response yields a sequential history. This is easy to reason about, as all operations now happen in an obvious order. Unfortunately, it doesn't match the sequential definition of the object: A should have successfully obtained the lock, and B should have subsequently aborted. {| border="1" cellspacing="0" | B invokes ''lock'' | B gets "successful" response | A invokes ''lock'' | A gets "failed" response |} This is another correct sequential history. It is also a linearization! Note that the definition of linearizability only precludes responses that precede invocations from being reordered; since the original history had no responses before invocations, we can reorder it as we wish. Hence the original history is indeed linearizable. An object (as opposed to a history) is linearizable if all valid histories of its use can be linearized. Note that this is a much harder assertion to prove. ===Linearizability versus serializability=== Consider the following history, again of two objects interacting with a lock: {| border="1" cellspacing="0" | A invokes lock | A successfully locks | B invokes unlock | B successfully unlocks | A invokes unlock | A successfully unlocks |} This history is visibly not linearizable, as it cannot be reordered to another sequential history without violating the ordering rule. However, under serializability, we may reorder B's unlock operation to ''before'' A's original lock, which is a valid history assuming the object begins the history in a locked state: {| border="1" cellspacing="0" | B invokes unlock | B successfully unlocks | A invokes lock | A successfully locks | A invokes unlock | A successfully unlocks |} While weird, this reordering is sensible provided there is no alternative means of communicating between A and B. Linearizability is better when considering individual objects separately, as the reordering restrictions ensure that multiple linearizable objects are, considered as a whole, still linearizable. ===Linearization points=== This definition of linearizability is equivalent to the following: * All function calls have a ''linearization point'' at some instant between their invocation and their response * All functions appear to occur instantly at their linearization point, behaving as specified by the sequential definition This alternative is usually much easier to prove. It is also much easier to reason about as a user, largely due to its intuitiveness. This property of occurring instantaneously, or indivisibly, leads to the use of the term ''atomic'' as an alternative to the longer "linearizable". In the examples above, the linearization point of the counter built on CAS is the linearization point of the first (and only) successful CAS update. The counter built using locking can be considered to 