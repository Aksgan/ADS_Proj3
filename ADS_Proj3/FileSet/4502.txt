size and each program consisted of a single record (aka ''segment''). Therefore a comprehensive application needed many segments. With the advent of C-support, application programs were no longer limited to 4K sizes, much larger C programs could be created, loaded to the TPF system as multiple 4K records and read into memory during a fetch operation and correctly reassembled. Since in the past core memory was at a premium, only highly used programs ran 100% of the time as '''core resident''', most ran as '''file resident'''. Given the limitations of older hardware, and even today's relative limitations, a fetch of a program, be it a single 4K record or many, is expensive. Since core memory is monetarily cheap and physically much much larger, greater numbers of programs could be allocated to reside in core. With the advent of z/TPF, all programs will reside in core - eventually - the only question is when they get fetched the first time. Before z/TPF, all assembler language programs were limited to 4K in size. Assembler is a more space-efficient language to program in so a lot of function can be packed into relatively few 4K segments of assembler code compared to C in 4K segments. However, C language programming is much easier to obtain skilled people in, so most if not all new development is done in C. Since z/TPF allows assembler programs to be repackaged into 1 logical file, critical legacy applications can be maintained and actually improve efficiency - the cost of entering one of these programs will now come at the initial enter when the entire program is fetched into core and logical flow through the program is accomplished via simple branch instructions, instead of a dozen or so IBM instructions previously needed to perform what is known as 'core resident enter/back'. =====Core usage===== Historically and in step with the previous, core blocks - memory - were also 381, 1055 and 4K bytes in size. Since '''ALL''' memory blocks had to be of this size, most of the overhead for obtaining memory found in other systems was discarded. The programmer merely needed to decide what size block would fit the need and ask for it. TPF would maintain a list of blocks in use and simply hand the first block on the available list. Physical memory was carved into sections reserved for each size so a 1055 byte block always came from a section and returned there, the only overhead needed was to add its address to the physical block table's proper list. No compaction or data collection was required. As applications got more advanced demands for more core increased and once C became available, memory chunks of indeterminate or large size were required. This gave rise to the use of heap storage and of course some memory management routines. To ease the overhead, TPF memory was broken into frames - 4K in size (and now 1Mb in size with z/TPF). If an application needed a certain number of bytes, the number of contiguous frames required to fill that need were granted. ==References== {{Reflist}} ==External links== *[http://publib.boulder.ibm.com/infocenter/tpfhelp/current/index.jsp TPF Information Center] (IBM) *[http://www.ibm.com/tpf z/TPF] (IBM) *[http://www.tpfug.org TPF User Group] (TPF User Group) *[http://www.blackbeard.com/tpf/ Blackbeard] (Alternative TPF Homepage) *[http://www.bedford.com/ Bedford Associates] (Suppliers of step by step trace and TPF Consultancy Services) *[http://tech.groups.yahoo.com/group/tpffers/ TPFfers] (Single largest online community of TPF programmers) *[http://www.pcs-training.co.uk PCS Training] (Independent training company specialising in TPF) *[http://jobs.tpfwork.com TPFWork.com] (Job board specialising in TPF and ALCS) *[http://www.tpfsoftware.com TPFSOFTWARE] (Provides products & Services in TPF & Allied technologies for Airline, Banking & Hospitality) *[http://www.vsoftsys.com Virtual Software Systems] (Provides software to allow concurrent testing of TPF programs by several programmers under VM) {{IBM operating systems}} {{Real-time operating systems}} [[Category:Real-time operating systems]] [[Category:IBM Mainframe computer operating systems]] [[Category:Transaction processing|Transaction processing facility]] [[de:Transaction Processing Facility]] [[fr:Transaction processing facility]] [[nl:Transaction Processing Facility]] [[ja:Transaction Processing Facility]]</text> </page> <page> <id>38064</id> <title>Transaction authentication</title> <text>{{Cleanup|date=March 2008}} {{unreferenced|date=March 2008}} '''Transaction authentication''' generally refers to the Internet-based security method of securely identifying a user through two or three factor authentication ([[Two-factor authentication]]: something you know plus something you have and/or something you are) at a transaction level, rather than at the traditional Session or Logon level. An internet banking application may allow a customer to perform numerous transactions within the single session and hence each, or selected transactions, will require the user to re-authenticate themselves using the appropriate two or three factor authentication method (see [[Two-factor authentication]]). Authentication, no matter how strong the method(s) used cannot protect against so called [[Man-in-the-Middle]] (MitM) or [[Man in the Browser|Man-in-the-Browser]] (MitB) attacks. This differs from [[Transaction verification]], also an Internet based security method, which is specifically designed to combat so called [[Man-in-the-Middle]] (MitM) and [[Man in the Browser|Man-in-the-Browser]] (MitB) attacks through not only authenticating the identity of the user, but also verifying the integrity of the actual content of the transaction, i.e. ensuring it has not been altered by one of these fraudulent techniques. [[Category:Applications of cryptography]] [[Category:Authentication methods]]</text> </page> <page> <id>38070</id> <title>Transaction processing system</title> <text>A '''transaction processing system''' is a type of [[Management information system|information system]]. TPSs collect, store, modify, and retrieve the [[transaction]]s of an organization. A transaction is an event that generates or modifies [[data]] that is eventually stored in an information system. To be considered a transaction processing system the computer must pass the [[ACID|ACID test]]. The essence of a transaction program is that it manages data that must be left in a consistent state. E.g. if an electronic payment is made, the amount must be both withdrawn from one account and added to the other; it cannot complete only one of those steps. Either both must occur, or neither. In case of a failure preventing transaction completion, the partially executed transaction must be '[[Rollback (data management)|rolled back]]' by the TPS. While this type of integrity must be provided also for [[batch processing|batch transaction processing]], it is particularly important for online processing: if e.g. an airline seat reservation system is accessed by multiple operators, after an empty seat inquiry, the 