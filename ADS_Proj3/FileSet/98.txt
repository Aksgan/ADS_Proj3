[[virtual memory|virtual memory area]] space over which the randomization occurs or reducing the period over which the randomization occurs. The period is typically implemented as small as possible, so most systems must increase VMA space randomization. To defeat the randomization, attackers must successfully guess the positions of all areas they wish to attack. For data areas such as stack and heap, where custom code or useful data can be loaded, more than one state can be attacked by using [[NOP slide]]s for code or repeated copies of data. This allows an attack to succeed if the area is randomized to one of a handful of values. In contrast, code areas such as library base and main executable need to be discovered exactly. Often these areas are mixed, for example [[stack frame]]s are injected onto the stack and a library is returned into. To begin, let us declare the following variables: :<math>E_s = \mbox{entropy bits of stack top}\,</math> :<math>E_m = \mbox{entropy bits of mmap() base}\,</math> :<math>E_x = \mbox{entropy bits of main executable base}\,</math> :<math>E_h = \mbox{entropy bits of heap base}\,</math> :<math>A_s = \mbox{attacked bits per attempt of stack entropy}\,</math> :<math>A_m = \mbox{attacked bits per attempt of mmap() base entropy}\,</math> :<math>A_x = \mbox{attacked bits per attempt of main executable entropy}\,</math> :<math>A_h = \mbox{attacked bits per attempt of heap base entropy}\,</math> :<math>\alpha = \mbox{attempts made}\,</math> :<math>N = E_s-A_s + E_m-A_m + E_x-A_x + E_h-A_h\,</math> To calculate the probability of an attacker succeeding, we have to assume a number of attempts <math>\alpha</math> carried out without being interrupted by a signature-based IPS, law enforcement, or other factor; in the case of brute forcing, the daemon cannot be restarted. We also have to figure out how many bits are relevant and how many are being attacked in each attempt, leaving however many bits the attacker has to defeat. The following formulas represent the probability of success for a given set of <math>\alpha\,</math> attempts on <math>N</math> bits of entropy. :<math>g \left ( \alpha\, \right ) = \mbox{isolated guessing; address space is re-randomized after each attempt}\,</math> :<math>g \left ( \alpha\, \right ) = 1 - { \left ( 1 - {2^{-N}} \right ) ^ \alpha\,} : 0 \le \, \alpha\,</math> :<math>b \left ( \alpha\, \right ) = \mbox{systematic brute forcing on copies of the program with the same address space}</math> :<math>b \left ( \alpha\, \right ) = \frac{\alpha\,}{{2^N}} : 0 \le \, \alpha\, \le \, {2^N}</math> In many systems, <math>2^N</math> can be in the thousands or millions; on {{as of | 2009 | alt = modern}} [[64-bit]] systems, these numbers typically reach the millions at least. For 32-bit systems at 2004 computer speeds which have 16 bits for address randomization, Shacham and co-workers state "â€¦ 16 bits of address randomization can be defeated by a [[brute force attack]] within minutes."<ref>On the Effectiveness of Address-Space Randomization,Shacham, H. and Page, M. and Pfaff, B. and Goh, E.J. and Modadugu, N. and Boneh, D,Proceedings of the 11th ACM conference on Computer and communications security,pp 298--307, 2004</ref> It should be noted that the authors' statement depends on the ability to attack the same application multiple times without any delay. Proper implementations of ASLR, like that included in [[grsecurity]], provide several methods to make such brute force attacks infeasible. One method involves preventing an executable from executing for a configurable amount of time if it has crashed a certain number of times. Some systems implement ''Library Load Order Randomization'', a form of ASLR which randomizes the order in which libraries are loaded. This supplies very little entropy. An approximation of the number of bits of entropy supplied per needed library is shown below; this does not yet account for varied library sizes, so the actual entropy gained is really somewhat higher. Note that attackers usually need only one library; the math is more complex with multiple libraries, and shown below as well. Note that the case of an attacker using only one library is a simplification of the more complex formula for <math>l = 1</math>. :<math> l = \mbox{number of libraries loaded}</math> :<math> \beta\, = \mbox{number of libraries used by the attacker}</math> :<math>E_m = \log_2 \left (l \right ) : \beta\, = 1, l \ge \, 1</math> :<math>E_m = \sum_{i=l}^{l - \left ( \beta\, - 1 \right )} \log_2 \left (i \right ) : \beta\, \ge \, 1, l \ge \, 1</math> These values tend to be low even for large values of <math>l</math>, most importantly since attackers typically can use only the [[C standard library]] and thus one can often assume that <math>\beta\, = 1</math>. Interestingly, however, even for a small number of libraries there are a few bits of entropy gained here; it is thus potentially interesting to combine library load order randomization with VMA address randomization to gain a few extra bits of entropy. Note that these extra bits of entropy will not apply to other mmap() segments, only libraries. ==== Reducing entropy ==== Attackers may make use of several methods to reduce the entropy present in a randomized address space, ranging from simple information leaks to attacking multiple bits of entropy per attack (such as by [[heap spraying]]). There is little that can be done about this. It is possible to leak information about memory layout using [[format string vulnerability|format string vulnerabilities]]. Format string functions such as [[printf]]() use a [[variable argument list]] to do their job; format specifiers describe what the argument list looks like. Because of the way arguments are typically passed, each format specifier moves closer to the top of the stack frame. Eventually, the return pointer and stack frame pointer can be extracted, revealing the address of a vulnerable library and the address of a known stack frame; this can completely eliminate library and stack randomization as an obstacle to an attacker. One can also decrease entropy in the stack or heap. The stack typically must be aligned to 16 bytes, and so this is the smallest possible randomization interval; while the heap must be page-aligned, typically 4096 bytes. When attempting an attack, it is 