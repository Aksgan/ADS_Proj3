good to fair score of 6.9 out of 10 with a total of 28 reviews.<ref>[http://www.gamespot.com/n64/puzzle/goldennugget/players.html?tag=scoresummary%3Buser-score GameSpot Review]</ref> ==References== {{reflist}} ==External links== *{{moby game|id=/golden-nugget-64|name=''Golden Nugget 64''}} *[http://www.gamefaqs.com/console/n64/data/574488.html ''Golden Nugget 64''] at [[GameFAQs]] [[Category:1998 video games]] [[Category:Nintendo 64 games]] [[Category:North America-exclusive video games]] [[Category:Video games set in Las Vegas]] [[Category:Casino video games]] [[Category:Westwood Studios games]] [[Category:Card game video games]] {{casino-videogame-stub}} {{ElectronicArts-stub}} [[fr:Golden Nugget 64]]</text> </page> <page> <id>15503</id> <title>Golden Realm RPG Engine</title> <text>The '''Golden Realm RPG Engine''' is a [[Game Maker Language|GML]] based, easy-to-use [[Game engine|engine setup]] for creating both single player and [[Massively multiplayer online role-playing game|MMO RPG]] games on [[Microsoft Windows|Windows]] and [[Macintosh|Mac]]. It has been constantly edited and updated since its release in 2008. This engine can be found and purchased at [http://goldenrealmrpgengine.50webs.com/ http://goldenrealmrpgengine.50webs.com/]. [[Category:Video game engines]] {{videogame-stub}}</text> </page> <page> <id>15510</id> <title>Golem (ILP)</title> <text>{{Unreferenced stub|auto=yes|date=December 2009}} '''Golem''' is an [[inductive logic programming]] algorithm developed by [[Stephen Muggleton]] and Feng. It uses the technique [[relative least general generalization]] proposed by [[Gordon Plotkin]]. Therefore, only positive examples are used and the search is bottom-up. Negative examples can be used to reduce the size of the hypothesis by deleting useless literals from the body clause. {{DEFAULTSORT:Golem (Ilp)}} [[Category:Inductive logic programming]] {{software-eng-stub}}</text> </page> <page> <id>15513</id> <title>Golomb coding</title> <text>'''Golomb coding''' is a [[lossless data compression]] method using a family of [[data compression]] codes invented by [[Solomon W. Golomb]] in the 1960s. Alphabets following a [[geometric distribution]] will have a Golomb code as an optimal [[prefix code]], making Golomb coding highly suitable for situations in which the occurrence of small values in the input stream is significantly more likely than large values. '''Rice coding''' (invented by [[Robert F. Rice]]) denotes using a subset of the family of Golomb codes to produce a simpler (but possibly suboptimal) prefix code; Rice used this in an [[adaptive coding]] scheme, although "Rice coding" can refer to either that scheme or merely using that subset of Golomb codes. Whereas a Golomb code has a tunable parameter that can be any positive value, Rice codes are those in which the tunable parameter is a power of two. This makes Rice codes convenient for use on a computer, since multiplication and division by 2 can be implemented more efficiently in [[binary arithmetic]]. Rice coding is used as the [[entropy encoding]] stage in a number of lossless [[image compression]] and [[audio data compression]] methods. == Overview == ===<span id="Preparation">Use with signed integers</span>=== Golomb's scheme was designed to encode sequences of non-negative numbers. However it is easily extended to accept sequences containing negative numbers using an ''overlap and interleave'' scheme, in which all values are re-assigned to some positive number in a unique and reversible way. The sequence begins: 0, -1, 1, -2, 2, -3, 3, -4, 4 ... The n<sup>th</sup> negative value (i.e., -n) is mapped to the n<sup>th</sup> odd number (2n-1), and the m<sup>th</sup> positive value is mapped to the m<sup>th</sup> even number (2m). This may be expressed mathematically as follows: a positive value <math>x</math> is mapped to (<math>x^\prime=2|x|=2x, x\ge0</math>), and a negative value <math>y</math> is mapped to (<math>y^\prime=2|y|-1=-2y-1, y<0</math>). ===Construction of codes=== Golomb coding uses a tunable parameter ''M'' to divide an input value into two parts: <math>q</math>, the result of a division by ''M'', and <math>r</math>, the remainder. The quotient is sent in [[unary coding]], followed by the remainder in [[truncated binary encoding]]. When <math>M=1</math> Golomb coding is equivalent to unary coding. [[Image:golomb rice code.png]] Golomb-Rice codes can be thought of as codes that indicate a number by the position of the ''bin'' (''q''), and the ''offset'' within the bin (''r''). The above figure shows the position ''q'', and offset ''r'' for the encoding of integer ''N'' using Golomb-Rice parameter ''M''. Formally, the two parts are given by the following expression, where <math>x</math> is the number being encoded: <math>q = \left \lfloor \frac{\left (x-1 \right )}{M} \right \rfloor</math> and <math>r = x-qM-1</math> The final result looks like: <math>\left (q+1 \right ) r</math> Note that <math>r</math> can be of a varying number of bits, and is specifically only ''b'' bits for Rice code, and switches between ''b''-1 and ''b'' bits for Golomb code (i.e. ''M'' is not a power of 2): Let <math>b = \lceil\log_2(M)\rceil</math>. If <math>0 \leq r < 2^b-M</math>, then use ''b''-1 bits to encode ''r''. If <math>2^b-M \leq r < M</math>, then use ''b'' bits to encode ''r''. Clearly, <math>b=\log_2(M)</math> if ''M'' is a power of 2 and we can encode all values of ''r'' with ''b'' bits. The parameter ''M'' is a function of the corresponding [[Bernoulli process]], which is parameterized by <math>p=P(X=0)</math> the probability of success in a given [[Bernoulli trial]]. <math>M</math> and <math>p</math> are related by these inequalities: : <math>(1-p)^M + (1-p)^{M+1} \leq 1 < (1-p)^{M-1} + (1-p)^M.</math> The Golomb code for this distribution is equivalent to the [[Huffman code]] for the same probabilities, if it were possible to compute the Huffman code. == Simple algorithm == Note below that this is the Rice-Golomb encoding, where the remainder code uses simple truncated binary encoding, also named "Rice coding" (other varying-length binary encodings, like arithmetic or Huffman encodings, are possible for the remainder codes, if the statistic distribution of remainder codes is not flat, and notably when not all possible remainders after the division are used). In this algorithm, if the ''M'' parameter is a power of 2, it becomes equivalent to the simpler Rice encoding. # Fix the parameter ''M'' to an integer value. # For ''N'', the number to be encoded, find ## quotient = ''q'' = int[''N''/''M''] ## remainder = ''r'' = ''N'' modulo ''M'' # Generate Codeword ## The Code format : <Quotient Code><Remainder Code>, where ## Quotient Code (in [[unary coding]]) ### Write a ''q''-length string of 1 bits ### Write a 0 bit ## Remainder Code (in [[truncated binary encoding]]) ### If ''M'' is power of 2, code remainder as binary format. So <math>\log_2(M)</math> bits are needed. (Rice code) ### If ''M'' is not a power of 2, set <math>b = \lceil\log_2(M)\rceil</math> #### If <math>r < 2^b-M</math> code ''r'' as plain 