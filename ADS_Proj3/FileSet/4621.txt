last1 = Clark | first1 = Brent N. | last2 = Colbourn | first2 = Charles J. | authorlink3 = David S. Johnson | last3 = Johnson | first3 = David S. | title = Unit disk graphs | journal = [[Discrete Mathematics (journal)|Discrete Mathematics]] | volume = 86 | issue = 1–3 | year = 1990 | pages = 165–177 | doi = 10.1016/0012-365X(90)90358-O}} * {{citation | last1 = Dall | first1 = Jesper | last2 = Christensen | first2 = Michael | title = Random geometric graphs | journal = Phys. Rev. E | volume = 66 | pages = 016121 | year = 2002 | id = {{arxiv|archive = cond-mat|id = 0203026}} | doi = 10.1103/PhysRevE.66.016121}} * {{citation | last1 = Huson | first1 = Mark L. | last2 = Sen | first2 = Arunabha | contribution = Broadcast scheduling algorithms for radio networks | title = Military Communications Conference, IEEE MILCOM '95 | year = 1995 | pages = 647–651 | volume = 2 | doi = 10.1109/MILCOM.1995.483546}} * {{citation | last1 = Marathe | first1 = Madhav V. | last2 = Breu | first2 = Heinz | last3 = Hunt, III | first3 = Harry B. | last4 = Ravi | first4 = S. S. | last5 = Rosenkrantz | first5 = Daniel J. | title = Geometry based heuristics for unit disk graphs | year = 1994 | id = {{arxiv|archive = math.CO|id = 9409226}}}} * {{citation | doi = 10.1007/978-3-540-46515-7_16 | last = Matsui | first = Tomomi | title = Approximation Algorithms for Maximum Independent Set Problems and Fractional Coloring Problems on Unit Disk Graphs | journal = Lecture Notes in Computer Science | volume = 1763 | pages = 194–200 | year = 2000}} * {{citation | doi = 10.1007/11496199_26 | last1 = Miyamoto | first1 = Yuichiro | last2 = Matsui | first2 = Tomomi | title = Perfectness and Imperfectness of the kth Power of Lattice Graphs | journal = Lecture Notes in Computer Science | volume = 3521 | pages = 233–242 | year = 2005}} [[Category:NP-complete problems]] [[Category:Intersection classes of graphs]] [[Category:Geometric graphs]] [[fr:Graphe de disques]]</text> </page> <page> <id>38855</id> <title>Unit propagation</title> <text>'''Unit propagation''' ('''UP''') or the '''one-literal rule''' ('''OLR''') is a [[procedure]] of [[automated theorem proving]] that can simplify a set of (usually [[propositional logic|propositional]]) [[Clause (logic)|clauses]]. ==Definition== The procedure is based on '''unit clauses''', i.e. clauses that are composed of a single [[literal (mathematical logic)|literal]]. If a set of clauses contains the unit clause <math>l</math>, the other clauses are simplified by the application of the two following rules: # every clause containing <math>l</math> is removed; # in every clause that contains <math>\neg l</math> this literal is deleted. The application of these two rules lead to a new set of clauses that is equivalent to the old one. For example, the following set of clauses can be simplified by unit propagation because it contains the unit clause <math>a</math>. : <math>\{a \vee b, \neg a \vee c, \neg c \vee d, a\}</math> Since <math>a \vee b</math> contains the literal <math>a</math>, this clause can be removed altogether. Since <math>\neg a \vee c</math> contains the negation of the literal in the unit clause, this literal can be removed from the clause. The unit clause <math>a</math> is not removed; this would make the resulting set not equivalent to the original one; this clause can be removed if already stored in some other form (see section "Using a partial model"). The effect of unit propagation can be summarized as follows. {| border="0" align="center" cellpadding="5" style="text-align: center;" | <math>\{</math> || <math>a \vee b,</math> || <math>\neg a \vee c,</math> || <math>\neg c \vee d</math> || <math>a</math> || <math>\}</math> |- | || (removed) || (<math>\neg a</math> deleted) || (unchanged) || (unchanged) |- | <math>\{</math> || || <math>c,</math> || <math>\neg c \vee d,</math> || <math>a</math> || <math>\}</math> |} The resulting set of clauses <math>\{c, \neg c \vee d, a\}</math> is equivalent to the above one. The new unit clause <math>c</math> that results from unit propagation can be used for a further application of unit propagation, which would transform <math>\neg c \vee d</math> into <math>d</math>. ==Unit propagation and resolution== The second rule of unit propagation can be seen as a restricted form of [[Resolution (logic)|resolution]], in which one of the two resolvents must always be a unit clause. As for resolution, unit propagation is a correct inference rule, in that it never produces a new clause that was not entailed by the old ones. The difference between unit propagation and resolution are: # resolution is a complete refutation procedure while unit propagation is not; in other words, even if a set of clause is contradictory, unit propagation may not generate an inconsistency; # the two clauses that are resolved cannot in general be removed after the generated clause is added to the set; on the contrary, the non-unit clause involved in a unit propagation can be removed when its simplification is added to the set; # resolution does not in general include the first rule used in unit propagation. Resolution calculi that include [[subsumption]] can model rule one by subsumption and rule two by a unit resolution step, followed by subsumption. Unit propagation, applied repeatedly as new unit clauses are generated, is a complete satisfiability algorithm for sets of propositional [[Horn clause]]s; it also generates a minimal model for the set if satisfiable: see [[Horn-satisfiability]]. ==Using a partial model== The unit clauses that are present in a set of clauses or can be derived from it can be stored in form of a partial model (this partial model may also contain other literals, depending on the application). In this case, unit propagation is performed based on the literals of the partial model, and unit clauses are removed if their literal is in the model. In the example above, the unit clause <math>a</math> would be added to the partial model; the simplification of the set of clause would then proceed as above with the difference that the unit 