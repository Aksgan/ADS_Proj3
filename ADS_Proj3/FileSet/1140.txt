user can take with the document, ranging from entering text, changing formatting, quitting, saving, etc. '''Problems and Constraints''' #Operations must be accessed through different inputs, such as a menu option and a keyboard shortcut for the same command #Each option has an interface, which should be modifiable #Operations are implemented in several different classes #In order to avoid coupling, there must not be a lot of dependencies between implementation and user interface classes. #Undo and redo commands must be supported on most document changing operations, with no arbitrary limit on the number of levels of undo #Functions are not viable, since they don't undo/redo easily, are not easily associated with a state, and are hard to extend or reuse. #Menus should be treated like hierarchical composite structures. Hence, a menu is a menu item that contains menu items which may contain other menu items, etc. '''Solution and Pattern''' Each menu item, rather than being instantiated with a list of parameters, is instead done with a ''Command'' object. Command is an abstract object that only has a single abstract <code>Execute()</code> method. Derivative objects extend the <code>Execute()</code> method appropriately (i.e., the <code>PasteCommand.Execute()</code> would utilize the content's clipboard buffer). These objects can be used by widgets or buttons just as easily as they can be used by menu items. To support undo and redo, <code>Command</code> is also given <code>Unexecute()</code> and <code>Reversible()</code>. In derivative classes, the former contains code that will undo that command, and the latter returns a boolean value that defines if the command is undoable. <code>Reversible()</code> allows some commands to be non-undoable, such as a Save command. All executed <code>Commands</code> are kept in a list with a method of keeping a "present" marker directly after the most recently executed command. A request to undo will call the <code>Command.Unexecute()</code> directly before "present", then move "present" back one command. Conversely, a <code>Redo</code> request will call <code>Command.Execute()</code> after "present", and move "present" forward one. This <code>Command</code> history is an implementation of the [[Command pattern]]. It encapsulates requests in objects, and uses a common interface to access those requests. Thus, the client can handle different requests, and commands can be scattered throughout the application. ===Spell Check and Hyphenation=== This is the document editor's ability to textually analyze the contents of a document. Although there are many analyses that can be performed, spell check and hyphenation-formatting are the focus. '''Problems and Constraints''' #Allow for multiple ways to check spelling and identify places for hyphenation #Allow for expansion for future analysis (e.g., word count, grammar check) #Be able to iterate through a text's contents without access to the text's actual structure (e.g., array, linked list, string) #Allow for any manner of traversal of document (beginning to end, end to beginning, alphabetical order, etc.) '''Solution and Pattern''' Removing the integer-based index from the basic element allows for a different iteration interface to be implemented. This will require extra methods for traversal and object retrieval. These methods are put into an abstract <code>Iterator</code> interface. Each element then implements a derivation of the <code>Iterator</code>, depending on how that element keeps its list (<code>ArrayIterator</code>, <code>LinkListIterator</code>, etc.). Functions for traversal and retrieval are put into the abstract Iterator interface. Future Iterators can be derived based on the type of list they will be iterating through, such as Arrays or Linked Lists. Thus, no matter what type of indexing method any implementation of the element uses, it will have the appropriate Iterator. This is an implementation of the [[Iterator pattern]]. It allows the client to traverse through any object collection, without needing to access the contents of the collection directly, or be concerned about the type of list the collection's structure uses. Now that traversal has been handled, it is possible to analyze the elements of a structure. It is not feasible to build each type of analysis into the element structure themselves; every element would need to be coded, and much of the code would be the same for similar elements. Instead, a generic <code>CheckMe()</code> method is built into the element's abstract class. Each Iterator is given a reference to a specific algorithm (such as spell check, grammar check, etc.). When that Iterator iterates through its collection, it calls each element's <code>CheckMe</code>, passing the specified algorithm. <code>CheckMe</code> then passes a reference to its element back to said algorithm for analysis. Thus, to perform a spell check, a front-to-end iterator would be given a reference to a <code>SpellCheck</code> object. The iterator would then access each element, executing its <code>CheckMe()</code> method with the <code>SpellCheck</code> parameter. Each <code>CheckMe</code> would then call the <code>SpellCheck</code>, passing a reference to the appropriate element. In this manner, any algorithm can be used with any traversal method, without hard-code coupling one with the other. For example, Find can be used as "find next" or "find previous", depending on if a "forward" iterator was used, or a "backwards" iterator. In addition, the algorithm themselves can be responsible for dealing with different elements. For example, a <code>SpellCheck</code> algorithm would ignore a <code>Graphic</code> element, rather than having to program every <code>Graphic</code>-derived element to not send themselves to a <code>SpellCheck</code>. ==Creational patterns== These patterns have to do with class instantiation. They can be further divided into class-creation patterns and object-creational patterns. While class-creation patterns use inheritance effectively in the instantiation process, object-creation patterns use delegation to get the job done. * [[Abstract factory pattern|Abstract Factory]] groups object factories that have a common theme. * [[Builder pattern|Builder]] constructs complex objects by separating construction and representation. * [[Factory method pattern|Factory Method]] creates objects without specifying the exact class to create. * [[Prototype pattern|Prototype]] creates objects by cloning an existing object. * [[Singleton pattern|Singleton]] restricts object creation for a class to only one instance. * [[Multiton pattern|Multiton]] restricts object creation for a class to only one instance per given key. ==Structural patterns== These concern class and object composition. They use inheritance to compose interfaces and define ways to compose objects to obtain new functionality. * [[Adapter pattern|Adapter]] allows classes with incompatible interfaces to work together by wrapping 