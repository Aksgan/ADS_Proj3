the agile corral, Leipzig, Germany 2008, Pages 23–32. * [[Craig Larman]] & V. Basili (2003). "Iterative and Incremental Development: A Brief History", Computer (IEEE Computer Society) 36 (6): 47-56. * [[Matt Stephens]] and Doug Rosenberg (2003). ''Extreme Programming Refactored: The Case Against XP'', Apress. * Waldner, JB. (2008). "Nanocomputers and Swarm Intelligence". In: ISTE, 225-256. == External links == {{Commonscat|Extreme Programming}} * [[WikiWikiWeb:ExtremeProgramming|Extreme Programming]] * [http://www.extremeprogramming.org A gentle introduction] * [http://www.IndustrialXP.org/ Industrial eXtreme Programming] * [http://www.xprogramming.com XP magazine] * [http://c2.com/cgi/wiki?ExtremeProgrammingImplementationIssues Problems and Solutions to XP implementation] * [http://www.martinfowler.com/articles/agileOffshore.html Using an Agile Software Process with Offshore Development] - [[ThoughtWorks]]' experiences with implementing XP in large distributed projects {{Software Engineering}} [[Category:Extreme Programming| ]] [[Category:Software development philosophies]] [[Category:Agile software development]] {{Link GA|de}} [[be-x-old:Экстрэмальнае праграмаваньне]] [[bg:Екстремно програмиране]] [[ca:Programació Extrema]] [[cs:Extrémní programování]] [[da:Extreme Programming]] [[de:Extreme Programming]] [[es:Programación extrema]] [[fa:برنامه‌سازی مفرط]] [[fr:Extreme programming]] [[gl:Programación Extrema]] [[ko:익스트림 프로그래밍]] [[hi:एक्सट्रीम प्रोग्रामिंग]] [[it:Extreme Programming]] [[he:Extreme Programming]] [[lt:Ribinis programavimas]] [[nl:Extreme Programming]] [[ja:エクストリーム・プログラミング]] [[no:Extreme Programming]] [[pl:Programowanie ekstremalne]] [[pt:Programação extrema]] [[ru:Экстремальное программирование]] [[sr:Ekstremno programiranje]] [[sh:Ekstremno programiranje]] [[fi:Extreme Programming]] [[sv:Extrem programmering]] [[te:ఎక్స్‌ట్రీమ్ ప్రోగ్రామింగ్]] [[th:Extreme programming]] [[uk:Екстремальне програмування]] [[vi:Lập trình cực hạn]] [[zh:极限编程]]</text> </page> <page> <id>12982</id> <title>Extreme Transaction Processing</title> <text>{{Mergeto|transaction processing|discuss=Talk:transaction processing#Merge Extreme Transaction Processing|date=January 2010}} '''Extreme Transaction Processing''' ('''XTP''') is an exceptionally demanding form of [[transaction processing]]. Transactions of 10,000 concurrent accesses (500 transaction per second) or more would require this form of processing.{{Citation needed|date=January 2010}} == Description == XTP applications are designed, developed, deployed, managed, and maintained on [[computer clusters]] and/or distributed [[grid computing]] networks. As a result, XTP applications feature vast improvements in: * performance * scalability * availability * security * manageability * dependability These applications generate orders of magnitude more transactions than those created by traditional [[transaction processing system]]s because of their wider (often multi-enterprise, national and global) reach. == Methodology == {{Empty section|date=July 2010}} == See also == * [[Computer cluster]] * [[Complex Event Processing]] * [[Distributed Computing]] * [[Distributed transaction processing]] * [[Grid Computing]] * [[Java EE]] * [[.NET Framework]] * [[Transaction processing]] * [[Transaction Processing Performance Council]] == External links == * [http://www.voltdb.com VoltDB] (extreme OLTP database) * [http://www.hiperware.com Hiperware] * [http://www.gigaspaces.com GigaSpaces eXtreme Application Platform] * [http://www.oracle.com/products/middleware/coherence/index.html Oracle's Coherence Middleware] * [http://solutions.mysql.com/solutions/item.php?id=644 WareLite's WL-BOSS on MySQL] * [http://www.warelite.net/content/solutions_home.html XTP applications based on WL-BOSS] * [http://www.atomikos.com/Main/ProductsOverview Atomikos XTP Software] * [http://www.ibm.com/software/webservers/appserv/extremescale/ WebSphere eXtreme Scale] [[Category:Transaction processing]] [[ru:Экстремальная обработка транзакций]]</text> </page> <page> <id>13003</id> <title>F00f</title> <text>{{refimprove|date=May 2010}} {{lowercase|title=f00f}} <code>'''f00f'''</code> ({{pronEng|ˈfuːf}}), an [[abbreviation]] of <code>f0 0f c7 c8</code>, is the [[hexadecimal]] encoding of an [[instruction (computer science)|instruction]] that exhibits a [[design flaw]] in the majority of [[Intel]] [[Pentium (brand)|Pentium]], [[Pentium MMX]], and [[Pentium OverDrive]] [[processors]] (all in the [[P5 (microarchitecture)|P5 microarchitecture]]). Intel calls this issue the "invalid operand with locked CMPXCHG8B instruction."<ref name="pentium-update-cmpxchg8b"> {{cite book | title = Pentium Processor Specification Update | publisher = [[Intel Corporation]] | date = 1999-01 | pages = 51&ndash;52 | url = http://www.biblio.deis.unibo.it/Testi_Liberi/Pentium/24248041.PDF | format = [[PDF]] | accessdate = 2006-11-02 | id = order number 242480-041 }}</ref> <!-- Intel's official web site has a broken link: http://www.intel.com/design/pentium/specupdt/ --> ==Description== The instruction represents: <code>lock cmpxchg8b eax</code> The [[Operand#Computer_science|operand]] could be a register other than eax. The ''cmpxchg8b'' instruction is used to compare the value in the ''edx'' and ''eax'' [[processor register|registers]] with an 8-[[byte]] value at some memory location. In this example a 4-byte register is used as the destination operand, which is not big enough to store the 8-byte result. Under normal circumstances, this instruction would simply result in an [[exception handling|exception]]; however, when used with the ''lock'' prefix (normally used to prevent two processors from interfering with the same memory location), the exception handler is never called, the processor stops servicing [[interrupt]]s and the CPU must be reset to recover. The instruction does not require any [[Ring 0|special privileges]] and, due to the proliferation of Intel microprocessors, was considered a serious issue at the time. [[Operating system]] vendors responded by implementing [[workaround]]s that detected the condition and prevented the crash. Although technically not an example of either, the f00f instruction is often considered an [[Halt and Catch Fire|HCF]] instruction or a [[killer poke]]. Since the f00f bug has become common knowledge, the term is sometimes used to describe similar hardware design flaws such as the [[Cyrix coma bug]]. No permanent hardware damage would result from executing the f00f instruction on a vulnerable system. Depending on the [[file system]], [[operating system]], and other circumstances, it is possible for [[data loss]] to occur if the [[page cache|disk buffers]] have not been flushed, if drives were interrupted during a write operation, or if some other non-[[atomic operation]] was interrupted. No Intel processors since the introduction of the [[Pentium Pro]] have been affected by the bug. The myB2 [[Stepping_level|stepping]] fixed this issue.<ref name="pentium-update-cmpxchg8b" /> Information about this bug first appeared on the Internet on or about 7 November 1997.<ref> {{cite web | url = http://groups.google.com/group/nl.comp.hardware/msg/8e8aa53186685ed5 | title = Nieuwe Intel Pentium BUG | accessdate = 2008-07-07 }} </ref> ==See also== *[[Halt and Catch Fire]] *[[Hacker jargon]] *[[Pentium FDIV bug]] *[[Hexspeak]] ==External links== *[http://support.intel.com/support/processors/pentium/ppiie/index.htm Intel Pentium erratum] *[http://support.microsoft.com/kb/q163852/ Microsoft Knowledge Base article] *[http://news.com.com/2100-1033-205157.html?legacy=cnet CNET Article] *[http://www.ddj.com/architect/184410555 The Pentium F00F Bug: Workarounds for a nasty problem] provides a detailed description of the bug and possible workarounds. ==References== {{reflist}} [[Category:x86 architecture]] [[Category:Hardware bugs]] [[Category:Computer folklore]] [[de:Pentium-F00F-Bug]] [[ja:Pentium F00F バグ]] [[ru:F0 0F C7 C8]] [[sv:0xF00FC7C8]]</text> </page> <page> <id>13004</id> <title>F2c</title> <text>{{lowercase|f2c}} '''f2c''' is the name of a program to [[Transcompiler|convert]] [[Fortran 77]] to [[C programming language|C]] code, developed at [[Bell Laboratories]]. The standalone f2c program was based on the core of the first complete Fortran 77 [[compiler]] to be implemented, the "f77" program by Feldman and Weinberger. Because the f77 compiler was itself written in C and relied on a C compiler back end to complete its final compilation step, it and its derivatives like f2c were much more portable than compilers generating [[machine code]] directly. The f2c program was released as [[free software]] ([[open-source software]]) and subsequently became one of the most common means to compile Fortran code on many systems where native Fortran compilers were unavailable or expensive. 