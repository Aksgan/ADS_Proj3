is possible to protect certain methods and data structures belonging to "trusted" code from access or corruption by "untrusted" code executing within the same JVM. Furthermore, common programmer errors that often lead to data corruption or unpredictable behavior such as accessing off the end of an array or using an uninitialized pointer are not allowed to occur. Several features of Java combine to provide this safety, including the class model, the garbage-collected [[JVM#Heap|heap]], and the verifier. The JVM ''verifies'' all bytecode before it is executed. This verification consists primarily of three types of checks: * Branches are always to valid locations * Data is always initialized and references are always type-safe * Access to "private" or "package private" data and methods is rigidly controlled. The first two of these checks take place primarily during the "verification" step that occurs when a class is loaded and made eligible for use. The third is primarily performed dynamically, when data items or methods of a class are first accessed by another class. The verifier permits only some bytecode sequences in valid programs, e.g. a [[branch (computer science)|jump (branch) instruction]] can only target an instruction within the same [[Method (computer programming)|method]]. Furthermore, the verifier ensures that any given instruction operates on a fixed stack location,<ref>{{cite web | title=The Verification process | url=http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#9766 | work=The Java Virtual Machine Specification | publisher=Sun Microsystems | year=1999 | accessdate=2009-05-31}}</ref> allowing the JIT compiler to transform stack accesses into fixed register accesses. Because of this, that the JVM is a stack architecture does not imply a speed penalty for emulation on [[register machine|register-based architectures]] when using a JIT compiler. In the face of the code-verified JVM architecture, it makes no difference to a JIT compiler whether it gets named imaginary registers or imaginary stack positions that must be allocated to the target architecture's registers. In fact, code verification makes the JVM different from a classic stack architecture whose efficient emulation with a JIT compiler is more complicated and typically carried out by a slower interpreter. Code verification also ensures that arbitrary bit patterns cannot get used as an address. [[Memory protection]] is achieved without the need for a [[memory management unit]] (MMU). Thus, JVM is an efficient way of getting memory protection on simple architectures that lack an MMU. This is analogous to [[managed code]] in Microsoft's .NET [[Common Language Runtime]], and conceptually similar to [[capability architecture]]s such as the [[Plessey 250]], and IBM [[System/38]]. == Bytecode instructions == {{Main|Java bytecode}} The JVM has [[instruction (computer science)|instructions]] for the following groups of tasks: * Load and store * [[Arithmetic]] * [[Type conversion]] * [[dynamic memory allocation|Object creation and manipulation]] * [[stack (data structure)|Operand stack management (push / pop)]] * [[branch (computer science)|Control transfer (branching)]] * [[subroutine|Method invocation and return]] * [[exception handling|Throwing exceptions]] * [[monitor (synchronization)|Monitor-based concurrency]] The aim is binary compatibility. Each particular host [[operating system]] needs its own implementation of the JVM and runtime. These JVMs interpret the bytecode semantically the same way, but the actual implementation may be different. More complex than just emulating bytecode is compatibly and efficiently implementing the [[Java Class Library|Java core API]] that must be mapped to each host operating system. == Secure execution of remote code == A virtual machine architecture allows very fine-grained control over the actions that code within the machine is permitted to take. This is designed to allow safe execution of untrusted code from remote sources, a model used by [[Java applet]]s. Applets run within a VM incorporated into a user's browser, executing code downloaded from a remote [[HTTP]] server. The remote code runs in a restricted "[[sandbox (security)|sandbox]]", which is designed to protect the user from misbehaving or malicious code. Publishers can purchase a certificate with which to [[digital signature|digitally sign]] applets as "safe", giving them permission to ask the user to break out of the sandbox and access the local file system, [[clipboard (software)|clipboard]] or network. == C to bytecode compilers == From the point of view of a [[compiler]], the Java Virtual Machine is just another processor with an instruction set, [[Java bytecode]], for which code can be generated. The JVM was originally designed to execute programs written in the Java language. However, the JVM provides an execution environment in the form of a bytecode instruction set and a runtime system that is general enough that it can be used as the target for [[compiler]]s of other [[programming language|languages]]. Because of its close association with the Java language, the JVM performs the strict runtime checks mandated by the Java specification. That requires [[C (programming language)|C]] to bytecode compilers to provide their own "lax machine abstraction", for instance producing compiled code that uses a Java array to represent main memory (so pointers can be compiled to integers), and linking the C library to a centralized Java class that emulates system calls. Most or all of the compilers listed below use a similar approach. Several C to bytecode compilers exist: * [http://nestedvm.ibex.org/ NestedVM] translates C to MIPS machine language first before converting to Java bytecode. * [http://cibyl.googlecode.com Cybil] works similarly to NestedVM but targets J2ME devices. * [http://da.vidr.cc/projects/lljvm/ LLJVM] compiles C to [[LLVM]] IR, which is then translated to JVM bytecode. * [http://www.novosoft-us.com/solutions/product_c2j.shtml C2J] is also GCC-based, but it produces intermediary Java source code before generating bytecode.<ref>http://tech.novosoft-us.com/product_c2j_faq.jsp</ref> Supports the full ANSI C runtime. * [http://objectmix.com/compilers/37664-ampc-version-1-6-2-released-c-java-class-files-compiler.html Axiomatic Multi-Platform C] supports full ANSI C 1989, SWT, and J2ME CDC 1.1 for mobile devices. * [http://www.itee.uq.edu.au/~cristina/uqbt.html#gcc-jvm Java Backend for GCC], possibly the oldest project of its kind, was developed at The University of Queensland in 1999. * [http://sourceforge.net/projects/javum/ Javum] is an attempt to port the full GNU environment to the JVM, and includes one of the above compilers packaged with additional utilities. * [http://sourceforge.net/projects/egcs-jvm/ egcs-jvm] appears to be an inactive project. Compilers targeting Java bytecode have been written for other programming languages, including [[Ada (programming language)|Ada]] and [[COBOL]]. == Licensing == Starting with [[Java Platform, Standard Edition|J2SE]] 5.0, changes to the JVM specification have been developed under the [[Java 