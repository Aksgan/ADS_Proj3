software archaeology."</ref> Software archaeology, named by analogy with [[archaeology]],<ref>Bryon Moyer, "[http://adm.omg.org/docs/Software_Archeology_4-Mar-2009.pdf Software Archeology: Modernizing Old Systems]," Embedded Technology Journal, March 4, 2009.</ref> includes the [[reverse engineering]] of software modules, and the application of a variety of tools and processes for extracting and understanding program structure and recovering design information.<ref name="RGBH"/><ref>Richard Hopkins and Kevin Jenkins, ''[http://books.google.com/books?id=GYvP0u2k2uMC&pg=PA93 Eating the IT Elephant: Moving from greenfield development to brownfield]'', Addison-Wesley, 2008, ISBN 0137130120, p. 93.</ref> Software archaeology may reveal dysfunctional team processes which have produced poorly designed or even unused software modules.<ref>Diomidis Spinellis and Georgios Gousios, ''[http://books.google.com/books?id=h34pwy005nYC&pg=PA29 Beautiful Architecture]'', O'Reilly, 2009, ISBN 059651798X, p. 29.</ref> The term has been in use for several decades,<ref>An early discussion is Judith E. Grass, "[http://www.usenix.org/publications/compsystems/1992/win_grass.pdf Object-Oriented Design Archaeology with CIA++]," ''Computing Systems'', Vol. 5, No. 1, Winter 1992.</ref> and reflects a fairly natural metaphor: a programmer reading legacy code may feel that he or she is in the same situation as an archaeologist exploring the rubble of an ancient civilization.<ref name="AndyDave"/> ==Techniques== [[File:NDependPic1.png|thumb|A [[software visualization]] tool]] A workshop on Software Archaeology at the 2001 [[OOPSLA]] (Object-Oriented Programming, Systems, Languages & Applications) conference identified the following software archaeology techniques, some of which are specific to [[object-oriented programming]]:<ref name="AndyDave">[[Andy Hunt (author)|Andy Hunt]] and [[Dave Thomas (programmer)|Dave Thomas]], "[http://media.pragprog.com/articles/mar_02_archeology.pdf Software Archaeology]", ''IEEE Software'', vol. 19, no. 2, pp. 20-22, Mar./Apr. 2002, doi:10.1109/52.991327.</ref> * [[Scripting language]]s to build static reports and for filtering diagnostic output * Ongoing documentation in HTML pages or Wikis * Synoptic signature analysis, statistical analysis, and [[software visualization]] tools * Reverse-engineering tools * Operating-system-level tracing via [[truss (Unix)|truss]] or [[strace]] * Web search engines and tools to search for keywords in source files * [[Integrated development environment|IDE]] file browsing * Test harnesses such as [[JUnit]] and [[CppUnit]] * API documentation generation using tools such as [[Javadoc]] and [[doxygen]] * [[Debugger]]s More generally, [[Andy Hunt (author)|Andy Hunt]] and [[Dave Thomas (programmer)|Dave Thomas]] note the importance of [[revision control|version control]], dependency management, text indexing tools such as [[GLIMPSE]] and [[SWISH-E]], and "[drawing] a map as you begin exploring."<ref name="AndyDave"/> Like true archaeology, software archaeology involves investigative work to understand the thought processes of one's predecessors.<ref name="AndyDave"/> At the OOPSLA workshop, [[Ward Cunningham]] suggested a synoptic signature analysis technique which gave an overall "feel" for a program by showing only punctuation, such as semicolons and [[Block (programming)|curly braces]].<ref>[[Ward Cunningham]], "[http://c2.com/doc/SignatureSurvey/ Signature Survey: A Method for Browsing Unfamiliar Code]," Workshop Position Statement, Software Archeology: Understanding Large Systems, OOPSLA 2001.</ref> In the same vein, Cunningham has suggested viewing programs in 2 point font in order to understand the overall structure.<ref>"[http://www.johndcook.com/blog/2009/11/10/oftware-archeology/ Software Archeology]" on John D. Cook's blog ''The Endeavour'', November 10, 2009.</ref> Another technique identified at the workshop was the use of [[aspect-oriented programming]] tools such as [[AspectJ]] to systematically introduce [[Tracing (software)|tracing]] code without directly editing the legacy program.<ref name="AndyDave"/> Network and temporal analysis techniques can reveal the patterns of collaborative activity by the developers of legacy software, which in turn may shed light on the strengths and weaknesses of the software artifacts produced.<ref>Cleidson de Souza, Jon Froehlich, and Paul Dourish, "[http://www.dourish.com/publications/2005/DeSouzaFroehlichDourish-SeekingSource-GROUP.pdf Seeking the Source: Software Source Code as a Social and Technical Artifact]," Proceedings of the 2005 International ACM SIGGROUP Conference on Supporting Group Work, pp. 197-206.</ref> Michael Rozlog of [[Embarcadero Technologies]] has described software archaeology as a six-step process which enables programmers to answer questions such as "What have I just inherited?" and "Where are the scary sections of the code?"<ref name="Rozlog">Michael Rozlog, "[http://java.sys-con.com/node/487614 Software Archeology: What Is It and Why Should Java Developers Care?]," article on java.sys-con.com, January 28, 2008.</ref> These steps, similar to those identified by the OOPSLA workshop, include using visualization to obtain a visual representation of the program's design, using [[software metric]]s to look for design and style violations, using [[unit testing]] and [[Profiling (computer programming)|profiling]] to look for bugs and performance bottlenecks, and assembling design information recovered by the process.<ref name="Rozlog"/> Software archaeology can also be a service provided to programmers by external consultants.<ref>Simon Sharwood, [http://www.zdnetasia.com/raiders-of-the-lost-code-39199788.htm Raiders of the Lost Code], [[ZDNet]], November 3, 2004.</ref> Software archaeology has continued to be a topic of discussion at more recent software engineering conferences.<ref>For example, the [http://portal.acm.org/toc.cfm?id=1806799 32nd ACM/IEEE International Conference on Software Engineering] in Cape Town, South Africa in May 2010.</ref> ==See also== {{Portal|Software Testing}} * [[Code refactoring]] * [[Software brittleness]] * [[Software rot]] ==References== <references/> ==External links== * [http://www.visibleworkings.com/archeology/position-papers.html Position papers], OOPSLA 2001 Workshop on Software Archeology: Understanding Large Systems * [http://blogs.computerworld.com/14787/writing_code_reading_code_and_software_archeology Writing code, reading code and software archeology], ''Once More into the Code'' blog at [[Computerworld]], September 23, 2009 * [http://www.eclipsecon.org/2008/sub/attachments/How_to_apply_Software_Archeology_to_your_development_process.pdf How To Apply Software Archeology To Your Development Process], presentation by Michael Rozlog, March 13, 2008 * [http://www.oopsla.org/oopsla2008/content_include/podcast/oopsla200808.mp3 OOPSLA 2008 Podcast] with [[Grady Booch]] on software archaeology and related topics {{Software Engineering}} [[Category:Computer jargon]] [[Category:Software maintenance]]</text> </page> <page> <id>34963</id> <title>Software assurance</title> <text> '''Software Assurance''' (SwA) is defined as “the level of confidence that software is free from vulnerabilities, either intentionally designed into the software or accidentally inserted at anytime during its lifecycle, and that the software functions in the intended manner.”<ref>"National Information Assurance Glossary"; CNSS Instruction No. 4009 [[National Information Assurance Glossary]]</ref> ==Alternate definitions== ===Department of Homeland Security (DHS)=== According to the [[Department of Homeland Security|DHS]], software assurance addresses: * Trustworthiness - No exploitable vulnerabilities exist, either maliciously or unintentionally inserted; * Predictable Execution - Justifiable confidence that software, when executed, functions as intended; * Conformance - Planned and systematic set of multi-disciplinary activities that ensure software processes and products conform to requirements, standards/ procedures. Contributing SwA disciplines, articulated in Bodies of Knowledge and Core Competencies: Software Engineering, Systems Engineering, Information Systems Security Engineering, Information Assurance, Test and Evaluation, Safety, Security, Project Management, and Software Acquisition.<ref>[https://buildsecurityin.us-cert.gov/portal DHS Build Security In web portal]</ref> Software Assurance is a strategic initiative of the U.S. Department of Homeland Security (DHS) to promote integrity, security, and reliability in software. The SwA Program is based upon the National Strategy to Secure Cyberspace - Action/Recommendation 2-14: “DHS will facilitate a national public-private effort to promulgate best practices and methodologies that promote 