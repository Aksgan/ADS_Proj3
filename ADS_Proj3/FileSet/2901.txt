39 | issue = 9 | pages = 70&ndash;77 | pmid = | doi = 10.1145/234215.234473 | id = | url = | language = | format = | accessdate = | laysummary = | laysource = | laydate = | quote = }}</ref> They also have much in common with [[hypervisor]]s,<ref name="Heiser_UL_06">{{cite journal | title=Are Virtual-Machine Monitors Microkernels Done Right? | author=[[Gernot Heiser|Heiser, Gernot]]; Uhlig, Volkmar and LeVasseur, Joshua | journal=ACM SIGOPS Operating Systems Review | volume=40 | issue=1 | pages=95â€“99 | month=January | year=2006 | url=http://l4ka.org/publications/2006/p95-heiser.pdf | publisher=ACM | doi = 10.1145/1113361.1113363 | format=PDF}}</ref> but the latter make no claim to minimality and are specialized to supporting [[virtual machine]]s; indeed, the [[L4 microkernel]] frequently finds use in a hypervisor capacity. The historical term [[nanokernel]] has been used to distinguish modern, high-performance microkernels from earlier implementations which still contained many system services. However, nanokernels have all but replaced their microkernel progenitors, and the term has fallen into disuse. ==Introduction== Early operating system kernels were rather small, partly because computer memory was limited. As the capability of computers grew, the number of devices the kernel had to control also grew. Through the early history of [[Unix]], kernels were generally small, even though those kernels contained device drivers and file system managers. When address spaces increased from 16 to 32 bits, kernel design was no longer cramped by the hardware architecture, and kernels began to grow. Berkeley [[UNIX]] ([[BSD]]) began the era of big kernels. In addition to operating a basic system consisting of the CPU, disks and printers, BSD started adding additional [[file system]]s, a complete [[protocol stack|TCP/IP networking system]], and a number of "virtual" devices that allowed the existing programs to work invisibly over the network. This growth continued for many years, resulting in kernels with millions of lines of [[source code]]. As a result of this growth, kernels were more prone to bugs and became increasingly difficult to maintain. The microkernel was designed to address the increasing growth of kernels and the difficulties that came with them. In theory, the microkernel design allows for easier management of code due to its division into [[user space]] services. This also allows for increased security and stability resulting from the reduced amount of code running in [[kernel mode]]. For example, if a networking service crashed due to [[buffer overflow]], only the networking service's memory would be corrupted, leaving the rest of the system still functional. ==Inter-process communication== [[Inter-process communication]] (IPC) is any mechanism which allows separate processes to communicate with each other, usually by sending [[Message passing|messages]]. [[Shared memory]] is strictly speaking also an inter-process communication mechanism, but the abbreviation IPC usually only refers to message passing, and it is the latter that is particularly relevant to microkernels. IPC allows the operating system to be built from a number of small programs called servers, which are used by other programs on the system, invoked via IPC. Most or all support for peripheral hardware is handled in this fashion, with servers for device drivers, network protocol stacks, file systems, graphics, etc. IPC can be synchronous or asynchronous. Asynchronous IPC is analogous to network communication: the sender dispatches a message and continues executing. The receiver checks (polls) for the availability of the message by attempting a receive, or is alerted to it via some notification mechanism. Asynchronous IPC requires that the kernel maintains buffers and queues for messages, and deals with buffer overflows; it also requires double copying of messages (sender to kernel and kernel to receiver). In synchronous IPC, the first party (sender or receiver) blocks until the other party is ready to perform the IPC. It does not require buffering or multiple copies, but the implicit rendezvous can make programming tricky. Most programmers prefer asynchronous send and synchronous receive. First-generation microkernels typically supported synchronous as well as asynchronous IPC, and suffered from poor IPC performance. [[Jochen Liedtke]] identified the design and implementation of the IPC mechanisms as the underlying reason for this poor performance. In his [[L4 microkernel family|L4 microkernel]] he pioneered techniques that led to an [[order of magnitude|order-of-magnitude]] reduction of IPC costs.<ref name="Liedtke_93">{{cite conference | first = Jochen | last = Liedtke | authorlink = Jochen Liedtke | coauthors = | title = Improving IPC by kernel design | booktitle = 14th ACM Symposium on Operating System Principles | pages = 175&ndash;88 | publisher = | month = December | year = 1993 | location = Asheville, NC, USA | url = http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.40.1293&rep=rep1&type=pdf | accessdate = | id = }}</ref> These include an IPC system call that supports a send as well as a receive operation, making all IPC synchronous, and passing as much data as possible in registers. Furthermore, Liedtke introduced the concept of the ''direct process switch'', where during an IPC execution an (incomplete) [[context switch]] is performed from the sender directly to the receiver. If, as in L4, part or all of the message is passed in registers, this transfers the in-register part of the message without any copying at all. Furthermore, the overhead of invoking the scheduler is avoided; this is especially beneficial in the common case where IPC is used in an [[remote procedure call|RPC]]-type fashion by a client invoking a server. Another optimization, called ''lazy scheduling'', avoids traversing scheduling queues during IPC by leaving threads that block during IPC in the ready queue. Once the scheduler is invoked, it moves such threads to the appropriate waiting queue. As in many cases a thread gets unblocked before the next scheduler invocation, this approach saves significant work. Similar approaches have since been adopted by [[QNX]] and [[MINIX 3]].{{Citation needed|date=August 2010}} In a client-server system, most communication is essentially synchronous, even if using asynchronous primitives, as the typical operation is a client invoking a server and then waiting for a reply. As it also lends itself to more efficient implementation, modern microkernels generally follow L4's lead and only provide a synchronous IPC primitive. Asynchronous IPC can be implemented on top by using helper threads. However, versions 