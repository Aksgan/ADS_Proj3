is a sequence of [[quantum gate]]s, which are reversible transformations on a [[quantum mechanics|quantum mechanical]] [[Quantum register|analog]] of an ''n''-[[bit]] [[Processor register|register]]. This analogous structure is referred to as an ''n''-[[qubit]] register. == Reversible logic gates == Ordinarily, in <!-- Grammer correction --> a classical computer, the [[logic gate]]s other than the [[NOT gate]] are not [[reversible]]. Thus, for instance, for an [[AND gate]] one cannot recover the two input bits from the output bit; for example, if the output bit is 0, we cannot tell from this whether the input bits are 0,1 or 1,0 or 0,0. However, it is instructive to observe that reversible gates in classical computers are theoretically possible for input strings of any length; moreover, these are actually of practical interest, since they do not increase [[entropy]]. A reversible gate is a reversible function on ''n''-bit data that returns ''n''-bit data, where an ''n''-bit datum is a [[string (computer science)|string]] of bits ''x''<sub>1</sub>,''x''<sub>2</sub>, ...,''x''<sub>''n''</sub> of length ''n''. The set of ''n''-bit data is the space {0,1}<sup>''n''</sup>, which consists of 2<sup>''n''</sup> strings of 0's and 1's. More precisely, * An ''n''-bit reversible gate is a [[bijective]] mapping ''f'' from the set {0,1}<sup>''n''</sup> of ''n''-bit data onto itself. An example of such a reversible gate ''f'' is a mapping that changes the first digit of each string. We are only interested in maps ''f'' which are different from the identity, and for reasons of practical engineering we are only interested in gates for small values of ''n'', e.g. ''n''=1, ''n''=2 or ''n''=3. These gates can be easily described by tables. Examples of these logic gates which have been studied are the controlled NOT gate (also called [[Controlled NOT gate|CNOT]] gate), the [[Toffoli gate]] and the [[Fredkin gate]]. To consider quantum gates, we first need to specify the quantum replacement of an ''n''-bit datum. <blockquote> The ''quantized version'' of classical ''n''-bit space {0,1}<sup>''n''</sup> is :<math>H_{\operatorname{QB}(n)}= \ell^2(\{0,1\}^n).</math> This is by definition the space of complex-valued functions on {0,1}<sup>''n''</sup> and is naturally an [[inner product space]]. This space can also be regarded as consisting of linear superpositions of classical bit strings. Note that ''H''<sub>QB(''n'')</sub> is a vector space over the complex numbers of [[dimension]] 2<sup>''n''</sup>. The elements of this space are called ''n''-qubits. </blockquote> Using Dirac [[bra-ket|ket]] notation, if ''x''<sub>1</sub>,''x''<sub>2</sub>, ...,''x''<sub>''n''</sub> is a classical bit string, then :<math> | x_1, x_2, \cdots,x_n \rangle \quad </math> is a special ''n''-qubit corresponding to the function which maps this classical bit string to 1 and maps all other bit strings to 0; these 2<sup>''n''</sup> special ''n''-qubits are called ''computational basis states''. All ''n''-qubits are complex linear combinations of these computational basis states. For a quantum computer gate, we require a very special kind of reversible function, namely a [[unitarity (physics)|unitary]] mapping, that is, a mapping on ''H''<sub>QB(''n'')</sub> that preserves the inner product. * An ''n''-qubit (reversible) quantum gate is a unitary mapping ''U'' from the space ''H''<sub>QB(''n'')</sub> of ''n''-qubits onto itself. Again we are only interested in [[unitary operators]] ''U'' which are different from the identity and we are only interested in gates for small values of ''n''. In fact, reversible classical ''n''-bit logic gates give rise to reversible ''n''-bit quantum gates as follows: to each reversible ''n''-bit logic gate ''f'' corresponds a quantum gate ''W''<sub>''f''</sub> defined as follows: :<math> W_f( | x_1, x_2, \cdots,x_n \rangle) = |f(x_1, x_2, \cdots, x_n) \rangle. </math> Note that ''W''<sub>''f''</sub> permutes the computational basis states. Of particular importance is the quantized 2 qubit CNOT gate ''W''<sub>CNOT</sub>. Of course there are many other properly quantum gates. For example, a relative phase shift is a 1 qubit gate given by multiplication by the unitary matrix: :<math> U_\theta =\begin{bmatrix} e^{i \theta} & 0 \\ 0 & 1 \end{bmatrix}, </math> so :<math> U_\theta | 0 \rangle = e^{i \theta} | 0 \rangle \quad U_\theta | 1 \rangle = | 1 \rangle. </math> == Reversible circuits == {{main|reversible computing}} Again we consider first ''reversible'' classical computation. Conceptually there is no difference between a reversible ''n'' bit circuit and a reversible ''n'' bit logical gate: it is just an invertible function on the space of ''n'' bit data. However, as we mentioned in the previous section, for engineering reasons we would like to have a small number of reversible gates, that can be put together to assemble any reversible circuit. To explain this assembly process, suppose we have a reversible ''n'' bit gate ''f'' and a reversible ''m'' bit gate ''g''. Putting them together means producing a new circuit by connecting some set ''k'' < ''n'' of the outputs of ''f'' to some set of ''k'' inputs of ''g'' as in the figure below. In that figure ''n''=5, ''k'' =3 and ''m'' = 7. The resulting circuit is also reversible and operates on ''n''+''m''-''k'' bits. <center> [[Image:Reversible circuit composition.svg|175px]] </center> We will refer to this scheme as a ''classical assemblage''; (Remark: this concept corresponds to a technical definition in Kitaev's pioneering paper cited below.) In composing these reversible machines, it is important to ensure that the intermediate machines are also reversible. This condition assures that ''intermediate'' garbage is not created (the net physical effect would be to increase entropy, which is one of the motivations for going through this exercise). Now it is possible to show that the [[Toffoli gate]] is a [[quantum gate|universal gate]]. This means that given any reversible classical ''n'' bit circuit ''h'', we can construct a classical assemblage of Toffoli gates in the above manner to produce an ''n''+''m'' bit circuit ''f'' such that :<math> f(x_1, \ldots, x_n, \underbrace{0, \dots, 0}) = (y_1, \ldots, y_n, \underbrace{0, \ldots , 0})</math> where there are ''m'' underbraced zeroed inputs and :<math>(y_1, \ldots, y_n) = h(x_1, \ldots, x_n)</math>. Notice that the end result always has a string of ''m'' zeros as the ancilla bits! No rubbish is ever produced, and so this computation is indeed one that, in a physical sense, generates no entropy. This issue is carefully discussed in Kitaev's article. It follows immediately from this result that any function ''f'' (bijective 